<!--
============================================================================================================================================
/home/runner/work/aspnetcore/aspnetcore/src/Components/CustomElements/src/Microsoft.AspNetCore.Components.CustomElements.csproj
============================================================================================================================================
-->
<Project DefaultTargets="Build">
  <!--
============================================================================================================================================
  <Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk.Razor">
  This import was added implicitly because the Project element's Sdk attribute specified "Microsoft.NET.Sdk.Razor".

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Determines if the Razor Sdk is responsible for importing Microsoft.NET.Sdk. Microsoft.NET.Sdk.Web may have previously imported this. -->
    <_RazorSdkImportsMicrosoftNetSdk Condition="'$(UsingMicrosoftNETSdk)' != 'true'">true</_RazorSdkImportsMicrosoftNetSdk>
    <_RazorSdkImportsMicrosoftNetSdkStaticWebAssets Condition="'$(UsingMicrosoftNETSdkStaticWebAssets)' != 'true'">true</_RazorSdkImportsMicrosoftNetSdkStaticWebAssets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk" Condition="'$(_RazorSdkImportsMicrosoftNetSdk)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(_AfterSdkPublishDependsOn)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_AfterSdkPublishDependsOn Condition="'$(UsingMicrosoftNETSdkWeb)' == 'true'">AfterPublish</_AfterSdkPublishDependsOn>
    <_AfterSdkPublishDependsOn Condition="'$(UsingMicrosoftNETSdkWeb)' != 'true'">Publish</_AfterSdkPublishDependsOn>
  </PropertyGroup>
  <Target Name="AfterSdkPublish" AfterTargets="$(_AfterSdkPublishDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Indicate to other targets that Microsoft.NET.Sdk is being used.

      This must be set here (as early as possible, before Microsoft.Common.props)
      so that everything that follows can depend on it.

      In particular, Directory.Build.props and nuget package props need to be able
      to use this flag and they are imported by Microsoft.Common.props.
    -->
    <UsingMicrosoftNETSdk>true</UsingMicrosoftNETSdk>
    <!--
      Indicate whether the set of SDK defaults that makes SDK style project concise are being used.
      For example: globbing, importing msbuild common targets.

      Similar to the property above, it must be set here.
    -->
    <UsingNETSdkDefaults>true</UsingNETSdkDefaults>
    <CustomAfterDirectoryBuildProps>$(CustomAfterDirectoryBuildProps);$(MSBuildThisFileDirectory)UseArtifactsOutputPath.props</CustomAfterDirectoryBuildProps>
  </PropertyGroup>
  <PropertyGroup Condition="'$(MSBuildProjectFullPath)' == '$(ProjectToOverrideProjectExtensionsPath)'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MSBuildProjectExtensionsPath>$(ProjectExtensionsPathForSpecifiedProject)</MSBuildProjectExtensionsPath>
  </PropertyGroup>
  <!--<Import Project="$(AlternateCommonProps)" Condition="'$(AlternateCommonProps)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="'$(AlternateCommonProps)' == ''">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ImportByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportByWildcardBeforeMicrosoftCommonProps>
    <ImportByWildcardAfterMicrosoftCommonProps Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportByWildcardAfterMicrosoftCommonProps>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonProps>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonProps Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonProps>
    <ImportDirectoryBuildProps Condition="'$(ImportDirectoryBuildProps)' == ''">true</ImportDirectoryBuildProps>
  </PropertyGroup>
  <!--
      Determine the path to the directory build props file if the user did not disable $(ImportDirectoryBuildProps) and
      they did not already specify an absolute path to use via $(DirectoryBuildPropsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryBuildProps)' == 'true' and '$(DirectoryBuildPropsPath)' == ''">
    <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">Directory.Build.props</_DirectoryBuildPropsFile>
    <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildPropsFile)'))</_DirectoryBuildPropsBasePath>
    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeDirectoryBuildProps)" Condition="'$(CustomBeforeDirectoryBuildProps)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')">

/home/runner/work/aspnetcore/aspnetcore/src/Components/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory)..\, Directory.Build.props))\Directory.Build.props">

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <AccelerateBuildsInVisualStudio>true</AccelerateBuildsInVisualStudio>
  </PropertyGroup>
  <PropertyGroup>
    <!-- $(RepoRoot) is normally set globally and Arcade overrides it to ensure a trailing slash. -->
    <RepoRoot Condition=" '$(RepoRoot)' == '' OR !HasTrailingSlash('$(RepoRoot)') ">$(MSBuildThisFileDirectory)</RepoRoot>
    <DefaultRepositoryUrl>https://github.com/dotnet/aspnetcore</DefaultRepositoryUrl>
    <RepositoryUrl>$(DefaultRepositoryUrl)</RepositoryUrl>
    <PackageProjectUrl>$(DefaultRepositoryUrl)</PackageProjectUrl>
    <RepositoryType>git</RepositoryType>
  </PropertyGroup>
  <PropertyGroup>
    <EnableNETAnalyzers>true</EnableNETAnalyzers>
    <AnalysisLevel>latest</AnalysisLevel>
    <AnalysisMode>Default</AnalysisMode>
  </PropertyGroup>
  <!-- Defines project type conventions. -->
  <PropertyGroup>
    <RepoRelativeProjectDir>$([MSBuild]::MakeRelative($(RepoRoot), $(MSBuildProjectDirectory)))</RepoRelativeProjectDir>
    <IsBenchmarkProject Condition=" $(MSBuildProjectName.EndsWith('.Performance')) OR&#xA;        $(RepoRelativeProjectDir.Contains('perf')) OR&#xA;        $(RepoRelativeProjectDir.Contains('benchmarkapps')) ">true</IsBenchmarkProject>
    <IsMicrobenchmarksProject Condition=" $(MSBuildProjectName.EndsWith('.Microbenchmarks')) ">true</IsMicrobenchmarksProject>
    <IsSpecificationTestProject Condition="$(MSBuildProjectName.EndsWith('.Specification.Tests'))">true</IsSpecificationTestProject>
    <IsUnitTestProject Condition=" '$(IsUnitTestProject)' == '' AND&#xA;        '$(IsSpecificationTestProject)' != 'true' AND&#xA;        ( $(MSBuildProjectName.EndsWith('Tests')) OR&#xA;          $(MSBuildProjectName.EndsWith('.Test')) OR&#xA;          $(MSBuildProjectName.EndsWith('.FunctionalTest')) ) ">true</IsUnitTestProject>
    <IsUnitTestProject Condition=" '$(IsUnitTestProject)' == '' ">false</IsUnitTestProject>
    <IsTrimmingTestProject Condition="$(MSBuildProjectName.EndsWith('.TrimmingTests'))">true</IsTrimmingTestProject>
    <IsNativeAotTestProject Condition="$(MSBuildProjectName.EndsWith('.NativeAotTests'))">true</IsNativeAotTestProject>
    <IsPublishedAppTestProject Condition="'$(IsTrimmingTestProject)' == 'true' or '$(IsNativeAotTestProject)' == 'true'">true</IsPublishedAppTestProject>
    <IsTestAssetProject Condition=" $(RepoRelativeProjectDir.Contains('testassets')) OR $(MSBuildProjectName.Contains('TestCommon'))">true</IsTestAssetProject>
    <IsProjectTemplateProject Condition=" ($(RepoRelativeProjectDir.Contains('ProjectTemplates')) OR $(MSBuildProjectName.Contains('ProjectTemplates')) ) AND&#xA;        '$(IsUnitTestProject)' != 'true' AND&#xA;        '$(IsTestAssetProject)' != 'true' ">true</IsProjectTemplateProject>
    <IsSampleProject Condition=" $(RepoRelativeProjectDir.ToUpperInvariant().Contains('SAMPLE')) ">true</IsSampleProject>
    <IsAnalyzersProject Condition="$(MSBuildProjectName.EndsWith('.Analyzers'))">true</IsAnalyzersProject>
    <IsShipping Condition=" '$(IsSampleProject)' == 'true' OR&#xA;        '$(IsTestAssetProject)' == 'true' OR&#xA;        '$(IsBenchmarkProject)' == 'true' OR&#xA;        '$(IsPublishedAppTestProject)' == 'true' OR&#xA;        $(IsUnitTestProject) ">false</IsShipping>
  </PropertyGroup>
  <!-- Disable logging of some task parameters or metadata to reduce binlog size.
       Reenable logging of any particular item by changing the value of the property below to 'false'
       The format is as follows:
       DisableLogTaskParameter_[task name]_[parameter name] - Disable logging of a particular parameter
       DisableLogTaskParameterItemMetadata_[task name]_[parameter name] - Disable logging of item metadata of the parameter
  -->
  <PropertyGroup>
    <TrimTaskParameters Condition=" '$(TrimTaskParameters)' == '' ">true</TrimTaskParameters>
    <!-- ItemsToHash is used for incremental building and hashes input properties to a file
         This is not generally useful for day-to-day build debugging. -->
    <DisableLogTaskParameter_Hash_ItemsToHash>$(TrimTaskParameters)</DisableLogTaskParameter_Hash_ItemsToHash>
    <!-- JoinItems takes input ItemGroups. The output ItemGroup is logged. -->
    <DisableLogTaskParameter_JoinItems_Right>$(TrimTaskParameters)</DisableLogTaskParameter_JoinItems_Right>
    <DisableLogTaskParameter_JoinItems_Left>$(TrimTaskParameters)</DisableLogTaskParameter_JoinItems_Left>
    <!-- ConvertToAbsolutePaths - The output parameter (AbsolutePaths) is interesting
         while the input Path is not generally useful. The output itemgroup's metadata
         is not altered by the task. -->
    <DisableLogTaskParameter_ConvertToAbsolutePath_Paths>$(TrimTaskParameters)</DisableLogTaskParameter_ConvertToAbsolutePath_Paths>
    <DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_Paths>$(TrimTaskParameters)</DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_Paths>
    <!-- The standard msbuild Copy task does not use Metadata and thus the input/outputs
         item metadata is not relevant -->
    <DisableLogTaskParameterItemMetadata_Copy_SourceFiles>$(TrimTaskParameters)</DisableLogTaskParameterItemMetadata_Copy_SourceFiles>
    <DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>$(TrimTaskParameters)</DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>
    <!-- Reference metadata for GenerateDepsFile, Csc, RAR, etc. are sometimes useful, but extraordinarily large
          when building against a shared framework where the number of input assemblies is very large.
          Avoid logging these by default. -->
    <DisableLogTaskParameterItemMetadata_GenerateDepsFile_ReferenceAssemblies>$(TrimTaskParameters)</DisableLogTaskParameterItemMetadata_GenerateDepsFile_ReferenceAssemblies>
    <DisableLogTaskParameterItemMetadata_GenerateDepsFile_ReferencePaths>$(TrimTaskParameters)</DisableLogTaskParameterItemMetadata_GenerateDepsFile_ReferencePaths>
    <DisableLogTaskParameterItemMetadata_ResolveAssemblyReference_Assemblies>$(TrimTaskParameters)</DisableLogTaskParameterItemMetadata_ResolveAssemblyReference_Assemblies>
    <DisableLogTaskParameterItemMetadata_Csc_References>$(TrimTaskParameters)</DisableLogTaskParameterItemMetadata_Csc_References>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="eng\QuarantinedTests.BeforeArcade.props">

/home/runner/work/aspnetcore/aspnetcore/eng/QuarantinedTests.BeforeArcade.props
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(UseVSTestRunner)' != 'true'">
    <_QuarantinedTestRunAdditionalArgs>-trait "Quarantined=true"</_QuarantinedTestRunAdditionalArgs>
    <_NonQuarantinedTestRunAdditionalArgs>-notrait "Quarantined=true"</_NonQuarantinedTestRunAdditionalArgs>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseVSTestRunner)' == 'true'">
    <_QuarantinedTestRunAdditionalArgs>--filter Quarantined=true</_QuarantinedTestRunAdditionalArgs>
    <_NonQuarantinedTestRunAdditionalArgs>--filter Quarantined!=true</_NonQuarantinedTestRunAdditionalArgs>
  </PropertyGroup>
  <PropertyGroup>
    <TestRunnerAdditionalArguments Condition="'$(RunQuarantinedTests)' == ''">$(_NonQuarantinedTestRunAdditionalArgs) $(TestRunnerAdditionalArguments)</TestRunnerAdditionalArguments>
    <TestRunnerAdditionalArguments Condition="'$(RunQuarantinedTests)' == 'true'">$(_QuarantinedTestRunAdditionalArgs) $(TestRunnerAdditionalArguments)</TestRunnerAdditionalArguments>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Sdk.props" Sdk="Microsoft.DotNet.Arcade.Sdk">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/sdk/Sdk.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <!-- 
      When the bootstrapper script initializes a repo it restores an empty project that imports the toolset SDK.
      It invokes WriteToolsetLocation target with __ToolsetLocationOutputFile set to the path where the location of 
      SDK Build.proj entry point is to be stored. Suppress all other imports for that project.      
    -->
    <_SuppressSdkImports>false</_SuppressSdkImports>
    <_SuppressSdkImports Condition="'$(__ToolsetLocationOutputFile)' != ''">true</_SuppressSdkImports>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="..\tools\Settings.props" Condition="!$(_SuppressSdkImports)">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <_ArcadeOverriddenCustomBeforeMicrosoftCommonTargets>$(CustomBeforeMicrosoftCommonTargets)</_ArcadeOverriddenCustomBeforeMicrosoftCommonTargets>
    <_ArcadeOverriddenCustomBeforeMicrosoftCommonCrossTargetingTargets>$(CustomBeforeMicrosoftCommonCrossTargetingTargets)</_ArcadeOverriddenCustomBeforeMicrosoftCommonCrossTargetingTargets>
    <CustomBeforeMicrosoftCommonTargets>$(MSBuildThisFileDirectory)BeforeCommonTargets.targets</CustomBeforeMicrosoftCommonTargets>
    <CustomBeforeMicrosoftCommonCrossTargetingTargets>$(MSBuildThisFileDirectory)BeforeCommonTargets.CrossTargeting.targets</CustomBeforeMicrosoftCommonCrossTargetingTargets>
    <BeforeMicrosoftNETSdkTargets>$(BeforeMicrosoftNETSdkTargets);$(MSBuildThisFileDirectory)BeforeNETSdkTargets.targets</BeforeMicrosoftNETSdkTargets>
    <!-- MSBuild has "global" variables (ie command-line or MSBuild task properties) override local declarations.  That's generally not the behavior that we want in Arcade.
         We want to be able to have Arcade MSBuild a project / target with the property set as a default, but let the project override that value.  To work around MSBuild,
         we pass in `_blah` and set it to a local property (`blah`) which is not global. -->
    <NETCORE_ENGINEERING_TELEMETRY Condition="'$(NETCORE_ENGINEERING_TELEMETRY)' == ''">$(_NETCORE_ENGINEERING_TELEMETRY)</NETCORE_ENGINEERING_TELEMETRY>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="BuildTasks.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/BuildTasks.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <ArcadeSdkBuildTasksAssembly Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)netframework\Microsoft.DotNet.Arcade.Sdk.dll</ArcadeSdkBuildTasksAssembly>
    <ArcadeSdkBuildTasksAssembly Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)net\Microsoft.DotNet.Arcade.Sdk.dll</ArcadeSdkBuildTasksAssembly>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="ProjectLayout.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/ProjectLayout.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
     Properties describing the layout of the repo specific to the current project.
  -->
  <!--
============================================================================================================================================
  <Import Project="RepoDefaults.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/RepoDefaults.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    Properties describing some default properties of the repo.
  -->
  <PropertyGroup>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">AnyCPU</Platform>
    <PlatformName Condition="'$(PlatformName)' == ''">$(Platform)</PlatformName>
  </PropertyGroup>
  <PropertyGroup>
    <!-- TrackPrebuiltUsage is enabled by default when building source-only. -->
    <TrackPrebuiltUsage Condition="'$(TrackPrebuiltUsage)' == '' and '$(DotNetBuildSourceOnly)' == 'true' and '$(DotNetBuild)' == 'true'">true</TrackPrebuiltUsage>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/ProjectLayout.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="RepoLayout.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/RepoLayout.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
     Properties describing the layout of the repo.
  -->
  <PropertyGroup>
    <RepoRoot Condition="'$(RepoRoot)' == ''">$([MSBuild]::NormalizeDirectory('$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), 'global.json'))'))</RepoRoot>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DotNetTool)' == ''">
    <!-- Respect environment variable for the .NET install directory if set; otherwise, use the repo default location -->
    <DotNetRoot Condition="'$(DOTNET_INSTALL_DIR)' != ''">$(DOTNET_INSTALL_DIR)</DotNetRoot>
    <DotNetRoot Condition="'$(DotNetRoot)' != ''">$([MSBuild]::NormalizeDirectory('$(DotNetRoot)'))</DotNetRoot>
    <DotNetRoot Condition="'$(DotNetRoot)' == ''">$([MSBuild]::NormalizeDirectory('$(RepoRoot)', '.dotnet'))</DotNetRoot>
    <!-- Let the exec task find dotnet on PATH -->
    <DotNetRoot Condition="!Exists($(DotNetRoot))" />
    <DotNetTool Condition="'$(OS)' == 'Windows_NT'">$(DotNetRoot)dotnet.exe</DotNetTool>
    <DotNetTool Condition="'$(OS)' != 'Windows_NT'">$(DotNetRoot)dotnet</DotNetTool>
  </PropertyGroup>
  <PropertyGroup Condition="'$(MonoTool)' == ''">
    <MonoTool>mono</MonoTool>
  </PropertyGroup>
  <PropertyGroup>
    <RepositoryEngineeringDir>$([MSBuild]::NormalizeDirectory('$(RepoRoot)', 'eng'))</RepositoryEngineeringDir>
    <RepositoryToolsDir>$([MSBuild]::NormalizeDirectory('$(RepoRoot)', '.tools'))</RepositoryToolsDir>
    <VersionsPropsPath>$(RepositoryEngineeringDir)Versions.props</VersionsPropsPath>
    <ArtifactsDir Condition="'$(ArtifactsDir)' == ''">$([MSBuild]::NormalizeDirectory('$(RepoRoot)', 'artifacts'))</ArtifactsDir>
    <ArtifactsToolsetDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'toolset'))</ArtifactsToolsetDir>
    <ArtifactsObjDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'obj'))</ArtifactsObjDir>
    <ArtifactsBinDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'bin'))</ArtifactsBinDir>
    <ArtifactsLogDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'log', '$(Configuration)'))</ArtifactsLogDir>
    <ArtifactsLogNgenDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsLogDir)', 'ngen'))</ArtifactsLogNgenDir>
    <ArtifactsTmpDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'tmp', '$(Configuration)'))</ArtifactsTmpDir>
    <ArtifactsTestResultsDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'TestResults', '$(Configuration)'))</ArtifactsTestResultsDir>
    <ArtifactsSymStoreDirectory>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'SymStore', '$(Configuration)'))</ArtifactsSymStoreDirectory>
    <ArtifactsPackagesDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'packages', '$(Configuration)'))</ArtifactsPackagesDir>
    <ArtifactsShippingPackagesDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsPackagesDir)', 'Shipping'))</ArtifactsShippingPackagesDir>
    <ArtifactsNonShippingPackagesDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsPackagesDir)', 'NonShipping'))</ArtifactsNonShippingPackagesDir>
    <VisualStudioSetupOutputPath>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'VSSetup', '$(Configuration)'))</VisualStudioSetupOutputPath>
    <VisualStudioSetupInsertionPath>$([MSBuild]::NormalizeDirectory('$(VisualStudioSetupOutputPath)', 'Insertion'))</VisualStudioSetupInsertionPath>
    <VisualStudioSetupIntermediateOutputPath>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'VSSetup.obj', '$(Configuration)'))</VisualStudioSetupIntermediateOutputPath>
    <VisualStudioBuildPackagesDir>$([MSBuild]::NormalizeDirectory('$(VisualStudioSetupOutputPath)', 'DevDivPackages'))</VisualStudioBuildPackagesDir>
  </PropertyGroup>
  <!-- Keep in sync with eng/common/tools NUGET_PACKAGES env var defines. -->
  <PropertyGroup>
    <!-- Respect environment variable for the NuGet Packages Root if set. -->
    <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' != ''">$([MSBuild]::NormalizeDirectory('$(NuGetPackageRoot)'))</NuGetPackageRoot>
    <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' == '' and '$(NUGET_PACKAGES)' != ''">$([MSBuild]::NormalizeDirectory('$(NUGET_PACKAGES)'))</NuGetPackageRoot>
    <!-- When building source-only or with the ci flag, don't fallback to default cache locations. -->
    <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' == '' and&#xD;&#xA;                                 ('$(ContinuousIntegrationBuild)' == 'true' or '$(DotNetBuildSourceOnly)' == 'true')">$([MSBuild]::NormalizeDirectory('$(RepoRoot)', '.packages'))</NuGetPackageRoot>
    <!-- Otherwise, use the current default location -->
    <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' == '' and '$(OS)' == 'Windows_NT'">$([MSBuild]::NormalizeDirectory('$(UserProfile)', '.nuget', 'packages'))</NuGetPackageRoot>
    <NuGetPackageRoot Condition="'$(NuGetPackageRoot)' == '' and '$(OS)' != 'Windows_NT'">$([MSBuild]::NormalizeDirectory('$(HOME)', '.nuget', 'packages'))</NuGetPackageRoot>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/ProjectLayout.props
============================================================================================================================================
-->
  <PropertyGroup>
    <OutDirName Condition="'$(OutDirName)' == ''">$(MSBuildProjectName)</OutDirName>
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">$([System.IO.Path]::GetFullPath('$(ArtifactsBinDir)$(OutDirName)\'))</BaseOutputPath>
    <OutputPath Condition="'$(PlatformName)' == 'AnyCPU'">$(BaseOutputPath)$(Configuration)\</OutputPath>
    <OutputPath Condition="'$(PlatformName)' != 'AnyCPU'">$(BaseOutputPath)$(PlatformName)\$(Configuration)\</OutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">$([System.IO.Path]::GetFullPath('$(ArtifactsObjDir)$(OutDirName)\'))</BaseIntermediateOutputPath>
    <IntermediateOutputPath Condition="'$(PlatformName)' == 'AnyCPU'">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="'$(PlatformName)' != 'AnyCPU'">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="DefaultVersions.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/DefaultVersions.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    Sets versions of packages used by the toolset unless they were already specified by the repo.
    Version.props shall be imported prior this file.
  -->
  <PropertyGroup>
    <OfficialBuild>false</OfficialBuild>
    <OfficialBuild Condition="'$(OfficialBuildId)' != ''">true</OfficialBuild>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="DefaultVersions.Generated.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/DefaultVersions.Generated.props
============================================================================================================================================
-->
  <!-- Generated by Microsoft.DotNet.Arcade.Sdk.csproj -->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
  <PropertyGroup>
    <ArcadeSdkVersion>10.0.0-beta.25377.103</ArcadeSdkVersion>
    <MicrosoftNetCompilersToolsetVersion>4.8.0</MicrosoftNetCompilersToolsetVersion>
    <MicrosoftDiaSymReaderPdb2PdbVersion>1.1.0-beta2-19575-01</MicrosoftDiaSymReaderPdb2PdbVersion>
    <MicrosoftDotNetXliffTasksVersion>10.0.0-beta.25377.103</MicrosoftDotNetXliffTasksVersion>
    <MicrosoftSymbolUploaderBuildTaskVersion>2.0.0-preview.1.23470.14</MicrosoftSymbolUploaderBuildTaskVersion>
    <MicrosoftTemplateEngineAuthoringTasksVersion>10.0.100-preview.4.25220.1</MicrosoftTemplateEngineAuthoringTasksVersion>
    <MicrosoftDotNetXUnitAssertVersion>10.0.0-beta.25377.103</MicrosoftDotNetXUnitAssertVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/DefaultVersions.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(VersionsPropsPath)" Condition="Exists('$(VersionsPropsPath)')">

/home/runner/work/aspnetcore/aspnetcore/eng/Versions.props
============================================================================================================================================
-->
  <!--

  This file defines the versions of external dependencies used by ASP.NET Core.
  This file might be updated by automation.

-->
  <!--
============================================================================================================================================
  <Import Project="Version.Details.props" Condition="Exists('Version.Details.props')">

/home/runner/work/aspnetcore/aspnetcore/eng/Version.Details.props
============================================================================================================================================
-->
  <!--
This file is auto-generated by the Maestro dependency flow system.
Do not edit it manually, as it will get overwritten by automation.
This file should be imported by eng/Versions.props
-->
  <PropertyGroup>
    <!-- dotnet/dotnet dependencies -->
    <dotnetefPackageVersion>10.0.0-rc.1.25377.103</dotnetefPackageVersion>
    <MicrosoftBclAsyncInterfacesPackageVersion>10.0.0-preview.7.25377.103</MicrosoftBclAsyncInterfacesPackageVersion>
    <MicrosoftBclTimeProviderPackageVersion>10.0.0-preview.7.25377.103</MicrosoftBclTimeProviderPackageVersion>
    <MicrosoftDotNetArcadeSdkPackageVersion>10.0.0-beta.25377.103</MicrosoftDotNetArcadeSdkPackageVersion>
    <MicrosoftDotNetBuildTasksArchivesPackageVersion>10.0.0-beta.25377.103</MicrosoftDotNetBuildTasksArchivesPackageVersion>
    <MicrosoftDotNetBuildTasksInstallersPackageVersion>10.0.0-beta.25377.103</MicrosoftDotNetBuildTasksInstallersPackageVersion>
    <MicrosoftDotNetBuildTasksTemplatingPackageVersion>10.0.0-beta.25377.103</MicrosoftDotNetBuildTasksTemplatingPackageVersion>
    <MicrosoftDotNetHelixSdkPackageVersion>10.0.0-beta.25377.103</MicrosoftDotNetHelixSdkPackageVersion>
    <MicrosoftDotNetRemoteExecutorPackageVersion>10.0.0-beta.25377.103</MicrosoftDotNetRemoteExecutorPackageVersion>
    <MicrosoftDotNetSharedFrameworkSdkPackageVersion>10.0.0-beta.25377.103</MicrosoftDotNetSharedFrameworkSdkPackageVersion>
    <MicrosoftEntityFrameworkCorePackageVersion>10.0.0-rc.1.25377.103</MicrosoftEntityFrameworkCorePackageVersion>
    <MicrosoftEntityFrameworkCoreDesignPackageVersion>10.0.0-rc.1.25377.103</MicrosoftEntityFrameworkCoreDesignPackageVersion>
    <MicrosoftEntityFrameworkCoreInMemoryPackageVersion>10.0.0-rc.1.25377.103</MicrosoftEntityFrameworkCoreInMemoryPackageVersion>
    <MicrosoftEntityFrameworkCoreRelationalPackageVersion>10.0.0-rc.1.25377.103</MicrosoftEntityFrameworkCoreRelationalPackageVersion>
    <MicrosoftEntityFrameworkCoreSqlitePackageVersion>10.0.0-rc.1.25377.103</MicrosoftEntityFrameworkCoreSqlitePackageVersion>
    <MicrosoftEntityFrameworkCoreSqlServerPackageVersion>10.0.0-rc.1.25377.103</MicrosoftEntityFrameworkCoreSqlServerPackageVersion>
    <MicrosoftEntityFrameworkCoreToolsPackageVersion>10.0.0-rc.1.25377.103</MicrosoftEntityFrameworkCoreToolsPackageVersion>
    <MicrosoftExtensionsCachingAbstractionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsCachingAbstractionsPackageVersion>
    <MicrosoftExtensionsCachingMemoryPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsCachingMemoryPackageVersion>
    <MicrosoftExtensionsConfigurationPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationPackageVersion>
    <MicrosoftExtensionsConfigurationAbstractionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationAbstractionsPackageVersion>
    <MicrosoftExtensionsConfigurationBinderPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationBinderPackageVersion>
    <MicrosoftExtensionsConfigurationCommandLinePackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationCommandLinePackageVersion>
    <MicrosoftExtensionsConfigurationEnvironmentVariablesPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationEnvironmentVariablesPackageVersion>
    <MicrosoftExtensionsConfigurationFileExtensionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationFileExtensionsPackageVersion>
    <MicrosoftExtensionsConfigurationIniPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationIniPackageVersion>
    <MicrosoftExtensionsConfigurationJsonPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationJsonPackageVersion>
    <MicrosoftExtensionsConfigurationUserSecretsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationUserSecretsPackageVersion>
    <MicrosoftExtensionsConfigurationXmlPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsConfigurationXmlPackageVersion>
    <MicrosoftExtensionsDependencyInjectionPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsDependencyInjectionPackageVersion>
    <MicrosoftExtensionsDependencyInjectionAbstractionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsDependencyInjectionAbstractionsPackageVersion>
    <MicrosoftExtensionsDependencyModelPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsDependencyModelPackageVersion>
    <MicrosoftExtensionsDiagnosticsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsDiagnosticsPackageVersion>
    <MicrosoftExtensionsDiagnosticsAbstractionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsDiagnosticsAbstractionsPackageVersion>
    <MicrosoftExtensionsFileProvidersAbstractionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsFileProvidersAbstractionsPackageVersion>
    <MicrosoftExtensionsFileProvidersCompositePackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsFileProvidersCompositePackageVersion>
    <MicrosoftExtensionsFileProvidersPhysicalPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsFileProvidersPhysicalPackageVersion>
    <MicrosoftExtensionsFileSystemGlobbingPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsFileSystemGlobbingPackageVersion>
    <MicrosoftExtensionsHostFactoryResolverSourcesPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsHostFactoryResolverSourcesPackageVersion>
    <MicrosoftExtensionsHostingPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsHostingPackageVersion>
    <MicrosoftExtensionsHostingAbstractionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsHostingAbstractionsPackageVersion>
    <MicrosoftExtensionsHttpPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsHttpPackageVersion>
    <MicrosoftExtensionsLoggingPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsLoggingPackageVersion>
    <MicrosoftExtensionsLoggingAbstractionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsLoggingAbstractionsPackageVersion>
    <MicrosoftExtensionsLoggingConfigurationPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsLoggingConfigurationPackageVersion>
    <MicrosoftExtensionsLoggingConsolePackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsLoggingConsolePackageVersion>
    <MicrosoftExtensionsLoggingDebugPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsLoggingDebugPackageVersion>
    <MicrosoftExtensionsLoggingEventLogPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsLoggingEventLogPackageVersion>
    <MicrosoftExtensionsLoggingEventSourcePackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsLoggingEventSourcePackageVersion>
    <MicrosoftExtensionsLoggingTraceSourcePackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsLoggingTraceSourcePackageVersion>
    <MicrosoftExtensionsOptionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsOptionsPackageVersion>
    <MicrosoftExtensionsOptionsConfigurationExtensionsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsOptionsConfigurationExtensionsPackageVersion>
    <MicrosoftExtensionsOptionsDataAnnotationsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsOptionsDataAnnotationsPackageVersion>
    <MicrosoftExtensionsPrimitivesPackageVersion>10.0.0-preview.7.25377.103</MicrosoftExtensionsPrimitivesPackageVersion>
    <MicrosoftInternalRuntimeAspNetCoreTransportPackageVersion>10.0.0-preview.7.25377.103</MicrosoftInternalRuntimeAspNetCoreTransportPackageVersion>
    <MicrosoftNETRuntimeMonoAOTCompilerTaskPackageVersion>10.0.0-preview.7.25377.103</MicrosoftNETRuntimeMonoAOTCompilerTaskPackageVersion>
    <MicrosoftNETRuntimeWebAssemblySdkPackageVersion>10.0.0-preview.7.25377.103</MicrosoftNETRuntimeWebAssemblySdkPackageVersion>
    <MicrosoftNETCoreAppRefPackageVersion>10.0.0-preview.7.25377.103</MicrosoftNETCoreAppRefPackageVersion>
    <MicrosoftNETCoreBrowserDebugHostTransportPackageVersion>10.0.0-preview.7.25377.103</MicrosoftNETCoreBrowserDebugHostTransportPackageVersion>
    <MicrosoftNETCorePlatformsPackageVersion>10.0.0-preview.7.25377.103</MicrosoftNETCorePlatformsPackageVersion>
    <MicrosoftWebXdtPackageVersion>3.2.0-preview.25377.103</MicrosoftWebXdtPackageVersion>
    <SystemCollectionsImmutablePackageVersion>10.0.0-preview.7.25377.103</SystemCollectionsImmutablePackageVersion>
    <SystemCompositionPackageVersion>10.0.0-preview.7.25377.103</SystemCompositionPackageVersion>
    <SystemConfigurationConfigurationManagerPackageVersion>10.0.0-preview.7.25377.103</SystemConfigurationConfigurationManagerPackageVersion>
    <SystemDiagnosticsDiagnosticSourcePackageVersion>10.0.0-preview.7.25377.103</SystemDiagnosticsDiagnosticSourcePackageVersion>
    <SystemDiagnosticsEventLogPackageVersion>10.0.0-preview.7.25377.103</SystemDiagnosticsEventLogPackageVersion>
    <SystemDiagnosticsPerformanceCounterPackageVersion>10.0.0-preview.7.25377.103</SystemDiagnosticsPerformanceCounterPackageVersion>
    <SystemDirectoryServicesProtocolsPackageVersion>10.0.0-preview.7.25377.103</SystemDirectoryServicesProtocolsPackageVersion>
    <SystemFormatsAsn1PackageVersion>10.0.0-preview.7.25377.103</SystemFormatsAsn1PackageVersion>
    <SystemFormatsCborPackageVersion>10.0.0-preview.7.25377.103</SystemFormatsCborPackageVersion>
    <SystemIOHashingPackageVersion>10.0.0-preview.7.25377.103</SystemIOHashingPackageVersion>
    <SystemIOPipelinesPackageVersion>10.0.0-preview.7.25377.103</SystemIOPipelinesPackageVersion>
    <SystemMemoryDataPackageVersion>10.0.0-preview.7.25377.103</SystemMemoryDataPackageVersion>
    <SystemNetHttpJsonPackageVersion>10.0.0-preview.7.25377.103</SystemNetHttpJsonPackageVersion>
    <SystemNetHttpWinHttpHandlerPackageVersion>10.0.0-preview.7.25377.103</SystemNetHttpWinHttpHandlerPackageVersion>
    <SystemNetServerSentEventsPackageVersion>10.0.0-preview.7.25377.103</SystemNetServerSentEventsPackageVersion>
    <SystemNumericsTensorsPackageVersion>10.0.0-preview.7.25377.103</SystemNumericsTensorsPackageVersion>
    <SystemReflectionMetadataPackageVersion>10.0.0-preview.7.25377.103</SystemReflectionMetadataPackageVersion>
    <SystemResourcesExtensionsPackageVersion>10.0.0-preview.7.25377.103</SystemResourcesExtensionsPackageVersion>
    <SystemRuntimeCachingPackageVersion>10.0.0-preview.7.25377.103</SystemRuntimeCachingPackageVersion>
    <SystemSecurityCryptographyPkcsPackageVersion>10.0.0-preview.7.25377.103</SystemSecurityCryptographyPkcsPackageVersion>
    <SystemSecurityCryptographyXmlPackageVersion>10.0.0-preview.7.25377.103</SystemSecurityCryptographyXmlPackageVersion>
    <SystemSecurityPermissionsPackageVersion>10.0.0-preview.7.25377.103</SystemSecurityPermissionsPackageVersion>
    <SystemServiceProcessServiceControllerPackageVersion>10.0.0-preview.7.25377.103</SystemServiceProcessServiceControllerPackageVersion>
    <SystemTextEncodingsWebPackageVersion>10.0.0-preview.7.25377.103</SystemTextEncodingsWebPackageVersion>
    <SystemTextJsonPackageVersion>10.0.0-preview.7.25377.103</SystemTextJsonPackageVersion>
    <SystemThreadingAccessControlPackageVersion>10.0.0-preview.7.25377.103</SystemThreadingAccessControlPackageVersion>
    <SystemThreadingChannelsPackageVersion>10.0.0-preview.7.25377.103</SystemThreadingChannelsPackageVersion>
    <SystemThreadingRateLimitingPackageVersion>10.0.0-preview.7.25377.103</SystemThreadingRateLimitingPackageVersion>
    <!-- dotnet/roslyn dependencies -->
    <MicrosoftCodeAnalysisCommonPackageVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCommonPackageVersion>
    <MicrosoftCodeAnalysisCSharpPackageVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCSharpPackageVersion>
    <MicrosoftCodeAnalysisCSharpWorkspacesPackageVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCSharpWorkspacesPackageVersion>
    <MicrosoftCodeAnalysisExternalAccessAspNetCorePackageVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisExternalAccessAspNetCorePackageVersion>
    <!-- dotnet/extensions dependencies -->
    <MicrosoftExtensionsCachingHybridPackageVersion>9.8.0-preview.1.25401.1</MicrosoftExtensionsCachingHybridPackageVersion>
    <MicrosoftExtensionsDiagnosticsTestingPackageVersion>9.8.0-preview.1.25401.1</MicrosoftExtensionsDiagnosticsTestingPackageVersion>
    <MicrosoftExtensionsTimeProviderTestingPackageVersion>9.8.0-preview.1.25401.1</MicrosoftExtensionsTimeProviderTestingPackageVersion>
    <!-- _git/dotnet-optimization dependencies -->
    <optimizationlinuxarm64MIBCRuntimePackageVersion>1.0.0-prerelease.25374.3</optimizationlinuxarm64MIBCRuntimePackageVersion>
    <optimizationlinuxx64MIBCRuntimePackageVersion>1.0.0-prerelease.25374.3</optimizationlinuxx64MIBCRuntimePackageVersion>
    <optimizationwindows_ntarm64MIBCRuntimePackageVersion>1.0.0-prerelease.25374.3</optimizationwindows_ntarm64MIBCRuntimePackageVersion>
    <optimizationwindows_ntx64MIBCRuntimePackageVersion>1.0.0-prerelease.25374.3</optimizationwindows_ntx64MIBCRuntimePackageVersion>
    <optimizationwindows_ntx86MIBCRuntimePackageVersion>1.0.0-prerelease.25374.3</optimizationwindows_ntx86MIBCRuntimePackageVersion>
    <!-- dotnet/msbuild dependencies -->
    <MicrosoftBuildPackageVersion>17.12.36</MicrosoftBuildPackageVersion>
    <MicrosoftBuildFrameworkPackageVersion>17.12.36</MicrosoftBuildFrameworkPackageVersion>
    <MicrosoftBuildTasksCorePackageVersion>17.12.36</MicrosoftBuildTasksCorePackageVersion>
    <MicrosoftBuildUtilitiesCorePackageVersion>17.12.36</MicrosoftBuildUtilitiesCorePackageVersion>
    <!-- nuget/nuget.client dependencies -->
    <NuGetFrameworksPackageVersion>6.2.4</NuGetFrameworksPackageVersion>
    <NuGetPackagingPackageVersion>6.2.4</NuGetPackagingPackageVersion>
    <NuGetVersioningPackageVersion>6.2.4</NuGetVersioningPackageVersion>
  </PropertyGroup>
  <!--Property group for alternate package version names-->
  <PropertyGroup>
    <!-- dotnet/dotnet dependencies -->
    <dotnetefVersion>$(dotnetefPackageVersion)</dotnetefVersion>
    <MicrosoftBclAsyncInterfacesVersion>$(MicrosoftBclAsyncInterfacesPackageVersion)</MicrosoftBclAsyncInterfacesVersion>
    <MicrosoftBclTimeProviderVersion>$(MicrosoftBclTimeProviderPackageVersion)</MicrosoftBclTimeProviderVersion>
    <MicrosoftDotNetArcadeSdkVersion>$(MicrosoftDotNetArcadeSdkPackageVersion)</MicrosoftDotNetArcadeSdkVersion>
    <MicrosoftDotNetBuildTasksArchivesVersion>$(MicrosoftDotNetBuildTasksArchivesPackageVersion)</MicrosoftDotNetBuildTasksArchivesVersion>
    <MicrosoftDotNetBuildTasksInstallersVersion>$(MicrosoftDotNetBuildTasksInstallersPackageVersion)</MicrosoftDotNetBuildTasksInstallersVersion>
    <MicrosoftDotNetBuildTasksTemplatingVersion>$(MicrosoftDotNetBuildTasksTemplatingPackageVersion)</MicrosoftDotNetBuildTasksTemplatingVersion>
    <MicrosoftDotNetHelixSdkVersion>$(MicrosoftDotNetHelixSdkPackageVersion)</MicrosoftDotNetHelixSdkVersion>
    <MicrosoftDotNetRemoteExecutorVersion>$(MicrosoftDotNetRemoteExecutorPackageVersion)</MicrosoftDotNetRemoteExecutorVersion>
    <MicrosoftDotNetSharedFrameworkSdkVersion>$(MicrosoftDotNetSharedFrameworkSdkPackageVersion)</MicrosoftDotNetSharedFrameworkSdkVersion>
    <MicrosoftEntityFrameworkCoreVersion>$(MicrosoftEntityFrameworkCorePackageVersion)</MicrosoftEntityFrameworkCoreVersion>
    <MicrosoftEntityFrameworkCoreDesignVersion>$(MicrosoftEntityFrameworkCoreDesignPackageVersion)</MicrosoftEntityFrameworkCoreDesignVersion>
    <MicrosoftEntityFrameworkCoreInMemoryVersion>$(MicrosoftEntityFrameworkCoreInMemoryPackageVersion)</MicrosoftEntityFrameworkCoreInMemoryVersion>
    <MicrosoftEntityFrameworkCoreRelationalVersion>$(MicrosoftEntityFrameworkCoreRelationalPackageVersion)</MicrosoftEntityFrameworkCoreRelationalVersion>
    <MicrosoftEntityFrameworkCoreSqliteVersion>$(MicrosoftEntityFrameworkCoreSqlitePackageVersion)</MicrosoftEntityFrameworkCoreSqliteVersion>
    <MicrosoftEntityFrameworkCoreSqlServerVersion>$(MicrosoftEntityFrameworkCoreSqlServerPackageVersion)</MicrosoftEntityFrameworkCoreSqlServerVersion>
    <MicrosoftEntityFrameworkCoreToolsVersion>$(MicrosoftEntityFrameworkCoreToolsPackageVersion)</MicrosoftEntityFrameworkCoreToolsVersion>
    <MicrosoftExtensionsCachingAbstractionsVersion>$(MicrosoftExtensionsCachingAbstractionsPackageVersion)</MicrosoftExtensionsCachingAbstractionsVersion>
    <MicrosoftExtensionsCachingMemoryVersion>$(MicrosoftExtensionsCachingMemoryPackageVersion)</MicrosoftExtensionsCachingMemoryVersion>
    <MicrosoftExtensionsConfigurationVersion>$(MicrosoftExtensionsConfigurationPackageVersion)</MicrosoftExtensionsConfigurationVersion>
    <MicrosoftExtensionsConfigurationAbstractionsVersion>$(MicrosoftExtensionsConfigurationAbstractionsPackageVersion)</MicrosoftExtensionsConfigurationAbstractionsVersion>
    <MicrosoftExtensionsConfigurationBinderVersion>$(MicrosoftExtensionsConfigurationBinderPackageVersion)</MicrosoftExtensionsConfigurationBinderVersion>
    <MicrosoftExtensionsConfigurationCommandLineVersion>$(MicrosoftExtensionsConfigurationCommandLinePackageVersion)</MicrosoftExtensionsConfigurationCommandLineVersion>
    <MicrosoftExtensionsConfigurationEnvironmentVariablesVersion>$(MicrosoftExtensionsConfigurationEnvironmentVariablesPackageVersion)</MicrosoftExtensionsConfigurationEnvironmentVariablesVersion>
    <MicrosoftExtensionsConfigurationFileExtensionsVersion>$(MicrosoftExtensionsConfigurationFileExtensionsPackageVersion)</MicrosoftExtensionsConfigurationFileExtensionsVersion>
    <MicrosoftExtensionsConfigurationIniVersion>$(MicrosoftExtensionsConfigurationIniPackageVersion)</MicrosoftExtensionsConfigurationIniVersion>
    <MicrosoftExtensionsConfigurationJsonVersion>$(MicrosoftExtensionsConfigurationJsonPackageVersion)</MicrosoftExtensionsConfigurationJsonVersion>
    <MicrosoftExtensionsConfigurationUserSecretsVersion>$(MicrosoftExtensionsConfigurationUserSecretsPackageVersion)</MicrosoftExtensionsConfigurationUserSecretsVersion>
    <MicrosoftExtensionsConfigurationXmlVersion>$(MicrosoftExtensionsConfigurationXmlPackageVersion)</MicrosoftExtensionsConfigurationXmlVersion>
    <MicrosoftExtensionsDependencyInjectionVersion>$(MicrosoftExtensionsDependencyInjectionPackageVersion)</MicrosoftExtensionsDependencyInjectionVersion>
    <MicrosoftExtensionsDependencyInjectionAbstractionsVersion>$(MicrosoftExtensionsDependencyInjectionAbstractionsPackageVersion)</MicrosoftExtensionsDependencyInjectionAbstractionsVersion>
    <MicrosoftExtensionsDependencyModelVersion>$(MicrosoftExtensionsDependencyModelPackageVersion)</MicrosoftExtensionsDependencyModelVersion>
    <MicrosoftExtensionsDiagnosticsVersion>$(MicrosoftExtensionsDiagnosticsPackageVersion)</MicrosoftExtensionsDiagnosticsVersion>
    <MicrosoftExtensionsDiagnosticsAbstractionsVersion>$(MicrosoftExtensionsDiagnosticsAbstractionsPackageVersion)</MicrosoftExtensionsDiagnosticsAbstractionsVersion>
    <MicrosoftExtensionsFileProvidersAbstractionsVersion>$(MicrosoftExtensionsFileProvidersAbstractionsPackageVersion)</MicrosoftExtensionsFileProvidersAbstractionsVersion>
    <MicrosoftExtensionsFileProvidersCompositeVersion>$(MicrosoftExtensionsFileProvidersCompositePackageVersion)</MicrosoftExtensionsFileProvidersCompositeVersion>
    <MicrosoftExtensionsFileProvidersPhysicalVersion>$(MicrosoftExtensionsFileProvidersPhysicalPackageVersion)</MicrosoftExtensionsFileProvidersPhysicalVersion>
    <MicrosoftExtensionsFileSystemGlobbingVersion>$(MicrosoftExtensionsFileSystemGlobbingPackageVersion)</MicrosoftExtensionsFileSystemGlobbingVersion>
    <MicrosoftExtensionsHostFactoryResolverSourcesVersion>$(MicrosoftExtensionsHostFactoryResolverSourcesPackageVersion)</MicrosoftExtensionsHostFactoryResolverSourcesVersion>
    <MicrosoftExtensionsHostingVersion>$(MicrosoftExtensionsHostingPackageVersion)</MicrosoftExtensionsHostingVersion>
    <MicrosoftExtensionsHostingAbstractionsVersion>$(MicrosoftExtensionsHostingAbstractionsPackageVersion)</MicrosoftExtensionsHostingAbstractionsVersion>
    <MicrosoftExtensionsHttpVersion>$(MicrosoftExtensionsHttpPackageVersion)</MicrosoftExtensionsHttpVersion>
    <MicrosoftExtensionsLoggingVersion>$(MicrosoftExtensionsLoggingPackageVersion)</MicrosoftExtensionsLoggingVersion>
    <MicrosoftExtensionsLoggingAbstractionsVersion>$(MicrosoftExtensionsLoggingAbstractionsPackageVersion)</MicrosoftExtensionsLoggingAbstractionsVersion>
    <MicrosoftExtensionsLoggingConfigurationVersion>$(MicrosoftExtensionsLoggingConfigurationPackageVersion)</MicrosoftExtensionsLoggingConfigurationVersion>
    <MicrosoftExtensionsLoggingConsoleVersion>$(MicrosoftExtensionsLoggingConsolePackageVersion)</MicrosoftExtensionsLoggingConsoleVersion>
    <MicrosoftExtensionsLoggingDebugVersion>$(MicrosoftExtensionsLoggingDebugPackageVersion)</MicrosoftExtensionsLoggingDebugVersion>
    <MicrosoftExtensionsLoggingEventLogVersion>$(MicrosoftExtensionsLoggingEventLogPackageVersion)</MicrosoftExtensionsLoggingEventLogVersion>
    <MicrosoftExtensionsLoggingEventSourceVersion>$(MicrosoftExtensionsLoggingEventSourcePackageVersion)</MicrosoftExtensionsLoggingEventSourceVersion>
    <MicrosoftExtensionsLoggingTraceSourceVersion>$(MicrosoftExtensionsLoggingTraceSourcePackageVersion)</MicrosoftExtensionsLoggingTraceSourceVersion>
    <MicrosoftExtensionsOptionsVersion>$(MicrosoftExtensionsOptionsPackageVersion)</MicrosoftExtensionsOptionsVersion>
    <MicrosoftExtensionsOptionsConfigurationExtensionsVersion>$(MicrosoftExtensionsOptionsConfigurationExtensionsPackageVersion)</MicrosoftExtensionsOptionsConfigurationExtensionsVersion>
    <MicrosoftExtensionsOptionsDataAnnotationsVersion>$(MicrosoftExtensionsOptionsDataAnnotationsPackageVersion)</MicrosoftExtensionsOptionsDataAnnotationsVersion>
    <MicrosoftExtensionsPrimitivesVersion>$(MicrosoftExtensionsPrimitivesPackageVersion)</MicrosoftExtensionsPrimitivesVersion>
    <MicrosoftInternalRuntimeAspNetCoreTransportVersion>$(MicrosoftInternalRuntimeAspNetCoreTransportPackageVersion)</MicrosoftInternalRuntimeAspNetCoreTransportVersion>
    <MicrosoftNETRuntimeMonoAOTCompilerTaskVersion>$(MicrosoftNETRuntimeMonoAOTCompilerTaskPackageVersion)</MicrosoftNETRuntimeMonoAOTCompilerTaskVersion>
    <MicrosoftNETRuntimeWebAssemblySdkVersion>$(MicrosoftNETRuntimeWebAssemblySdkPackageVersion)</MicrosoftNETRuntimeWebAssemblySdkVersion>
    <MicrosoftNETCoreAppRefVersion>$(MicrosoftNETCoreAppRefPackageVersion)</MicrosoftNETCoreAppRefVersion>
    <MicrosoftNETCoreBrowserDebugHostTransportVersion>$(MicrosoftNETCoreBrowserDebugHostTransportPackageVersion)</MicrosoftNETCoreBrowserDebugHostTransportVersion>
    <MicrosoftNETCorePlatformsVersion>$(MicrosoftNETCorePlatformsPackageVersion)</MicrosoftNETCorePlatformsVersion>
    <MicrosoftWebXdtVersion>$(MicrosoftWebXdtPackageVersion)</MicrosoftWebXdtVersion>
    <SystemCollectionsImmutableVersion>$(SystemCollectionsImmutablePackageVersion)</SystemCollectionsImmutableVersion>
    <SystemCompositionVersion>$(SystemCompositionPackageVersion)</SystemCompositionVersion>
    <SystemConfigurationConfigurationManagerVersion>$(SystemConfigurationConfigurationManagerPackageVersion)</SystemConfigurationConfigurationManagerVersion>
    <SystemDiagnosticsDiagnosticSourceVersion>$(SystemDiagnosticsDiagnosticSourcePackageVersion)</SystemDiagnosticsDiagnosticSourceVersion>
    <SystemDiagnosticsEventLogVersion>$(SystemDiagnosticsEventLogPackageVersion)</SystemDiagnosticsEventLogVersion>
    <SystemDiagnosticsPerformanceCounterVersion>$(SystemDiagnosticsPerformanceCounterPackageVersion)</SystemDiagnosticsPerformanceCounterVersion>
    <SystemDirectoryServicesProtocolsVersion>$(SystemDirectoryServicesProtocolsPackageVersion)</SystemDirectoryServicesProtocolsVersion>
    <SystemFormatsAsn1Version>$(SystemFormatsAsn1PackageVersion)</SystemFormatsAsn1Version>
    <SystemFormatsCborVersion>$(SystemFormatsCborPackageVersion)</SystemFormatsCborVersion>
    <SystemIOHashingVersion>$(SystemIOHashingPackageVersion)</SystemIOHashingVersion>
    <SystemIOPipelinesVersion>$(SystemIOPipelinesPackageVersion)</SystemIOPipelinesVersion>
    <SystemMemoryDataVersion>$(SystemMemoryDataPackageVersion)</SystemMemoryDataVersion>
    <SystemNetHttpJsonVersion>$(SystemNetHttpJsonPackageVersion)</SystemNetHttpJsonVersion>
    <SystemNetHttpWinHttpHandlerVersion>$(SystemNetHttpWinHttpHandlerPackageVersion)</SystemNetHttpWinHttpHandlerVersion>
    <SystemNetServerSentEventsVersion>$(SystemNetServerSentEventsPackageVersion)</SystemNetServerSentEventsVersion>
    <SystemNumericsTensorsVersion>$(SystemNumericsTensorsPackageVersion)</SystemNumericsTensorsVersion>
    <SystemReflectionMetadataVersion>$(SystemReflectionMetadataPackageVersion)</SystemReflectionMetadataVersion>
    <SystemResourcesExtensionsVersion>$(SystemResourcesExtensionsPackageVersion)</SystemResourcesExtensionsVersion>
    <SystemRuntimeCachingVersion>$(SystemRuntimeCachingPackageVersion)</SystemRuntimeCachingVersion>
    <SystemSecurityCryptographyPkcsVersion>$(SystemSecurityCryptographyPkcsPackageVersion)</SystemSecurityCryptographyPkcsVersion>
    <SystemSecurityCryptographyXmlVersion>$(SystemSecurityCryptographyXmlPackageVersion)</SystemSecurityCryptographyXmlVersion>
    <SystemSecurityPermissionsVersion>$(SystemSecurityPermissionsPackageVersion)</SystemSecurityPermissionsVersion>
    <SystemServiceProcessServiceControllerVersion>$(SystemServiceProcessServiceControllerPackageVersion)</SystemServiceProcessServiceControllerVersion>
    <SystemTextEncodingsWebVersion>$(SystemTextEncodingsWebPackageVersion)</SystemTextEncodingsWebVersion>
    <SystemTextJsonVersion>$(SystemTextJsonPackageVersion)</SystemTextJsonVersion>
    <SystemThreadingAccessControlVersion>$(SystemThreadingAccessControlPackageVersion)</SystemThreadingAccessControlVersion>
    <SystemThreadingChannelsVersion>$(SystemThreadingChannelsPackageVersion)</SystemThreadingChannelsVersion>
    <SystemThreadingRateLimitingVersion>$(SystemThreadingRateLimitingPackageVersion)</SystemThreadingRateLimitingVersion>
    <!-- dotnet/roslyn dependencies -->
    <MicrosoftCodeAnalysisCommonVersion>$(MicrosoftCodeAnalysisCommonPackageVersion)</MicrosoftCodeAnalysisCommonVersion>
    <MicrosoftCodeAnalysisCSharpVersion>$(MicrosoftCodeAnalysisCSharpPackageVersion)</MicrosoftCodeAnalysisCSharpVersion>
    <MicrosoftCodeAnalysisCSharpWorkspacesVersion>$(MicrosoftCodeAnalysisCSharpWorkspacesPackageVersion)</MicrosoftCodeAnalysisCSharpWorkspacesVersion>
    <MicrosoftCodeAnalysisExternalAccessAspNetCoreVersion>$(MicrosoftCodeAnalysisExternalAccessAspNetCorePackageVersion)</MicrosoftCodeAnalysisExternalAccessAspNetCoreVersion>
    <!-- dotnet/extensions dependencies -->
    <MicrosoftExtensionsCachingHybridVersion>$(MicrosoftExtensionsCachingHybridPackageVersion)</MicrosoftExtensionsCachingHybridVersion>
    <MicrosoftExtensionsDiagnosticsTestingVersion>$(MicrosoftExtensionsDiagnosticsTestingPackageVersion)</MicrosoftExtensionsDiagnosticsTestingVersion>
    <MicrosoftExtensionsTimeProviderTestingVersion>$(MicrosoftExtensionsTimeProviderTestingPackageVersion)</MicrosoftExtensionsTimeProviderTestingVersion>
    <!-- _git/dotnet-optimization dependencies -->
    <optimizationlinuxarm64MIBCRuntimeVersion>$(optimizationlinuxarm64MIBCRuntimePackageVersion)</optimizationlinuxarm64MIBCRuntimeVersion>
    <optimizationlinuxx64MIBCRuntimeVersion>$(optimizationlinuxx64MIBCRuntimePackageVersion)</optimizationlinuxx64MIBCRuntimeVersion>
    <optimizationwindows_ntarm64MIBCRuntimeVersion>$(optimizationwindows_ntarm64MIBCRuntimePackageVersion)</optimizationwindows_ntarm64MIBCRuntimeVersion>
    <optimizationwindows_ntx64MIBCRuntimeVersion>$(optimizationwindows_ntx64MIBCRuntimePackageVersion)</optimizationwindows_ntx64MIBCRuntimeVersion>
    <optimizationwindows_ntx86MIBCRuntimeVersion>$(optimizationwindows_ntx86MIBCRuntimePackageVersion)</optimizationwindows_ntx86MIBCRuntimeVersion>
    <!-- dotnet/msbuild dependencies -->
    <MicrosoftBuildVersion>$(MicrosoftBuildPackageVersion)</MicrosoftBuildVersion>
    <MicrosoftBuildFrameworkVersion>$(MicrosoftBuildFrameworkPackageVersion)</MicrosoftBuildFrameworkVersion>
    <MicrosoftBuildTasksCoreVersion>$(MicrosoftBuildTasksCorePackageVersion)</MicrosoftBuildTasksCoreVersion>
    <MicrosoftBuildUtilitiesCoreVersion>$(MicrosoftBuildUtilitiesCorePackageVersion)</MicrosoftBuildUtilitiesCoreVersion>
    <!-- nuget/nuget.client dependencies -->
    <NuGetFrameworksVersion>$(NuGetFrameworksPackageVersion)</NuGetFrameworksVersion>
    <NuGetPackagingVersion>$(NuGetPackagingPackageVersion)</NuGetPackagingVersion>
    <NuGetVersioningVersion>$(NuGetVersioningPackageVersion)</NuGetVersioningVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/eng/Versions.props
============================================================================================================================================
-->
  <PropertyGroup Label="Version settings">
    <AspNetCoreMajorVersion>10</AspNetCoreMajorVersion>
    <AspNetCoreMinorVersion>0</AspNetCoreMinorVersion>
    <AspNetCorePatchVersion>0</AspNetCorePatchVersion>
    <PreReleaseVersionIteration>1</PreReleaseVersionIteration>
    <ValidateBaseline>true</ValidateBaseline>
    <IdentityModelVersion Condition="'$(IsIdentityModelTestJob)' != 'true'">8.0.1</IdentityModelVersion>
    <IdentityModelVersion Condition="'$(IsIdentityModelTestJob)' == 'true'">*-*</IdentityModelVersion>
    <!--
        When StabilizePackageVersion is set to 'true', this branch will produce stable outputs for 'Shipping' packages
    -->
    <StabilizePackageVersion Condition="'$(StabilizePackageVersion)' == ''">false</StabilizePackageVersion>
    <DotNetFinalVersionKind Condition="'$(StabilizePackageVersion)' == 'true'">release</DotNetFinalVersionKind>
    <PreReleaseVersionLabel>rc</PreReleaseVersionLabel>
    <PreReleaseBrandingLabel>RC $(PreReleaseVersionIteration)</PreReleaseBrandingLabel>
    <IncludePreReleaseLabelInPackageVersion>true</IncludePreReleaseLabelInPackageVersion>
    <IncludePreReleaseLabelInPackageVersion Condition=" '$(DotNetFinalVersionKind)' == 'release' ">false</IncludePreReleaseLabelInPackageVersion>
    <AspNetCoreMajorMinorVersion>$(AspNetCoreMajorVersion).$(AspNetCoreMinorVersion)</AspNetCoreMajorMinorVersion>
    <!-- Servicing builds have different characteristics for the way dependencies, baselines, and versions are handled. -->
    <IsServicingBuild Condition=" '$(PreReleaseVersionLabel)' == 'servicing' ">true</IsServicingBuild>
    <VersionPrefix>$(AspNetCoreMajorMinorVersion).$(AspNetCorePatchVersion)</VersionPrefix>
    <!--
      TargetingPackVersionPrefix is used by projects, like .deb and .rpm, which use slightly different version formats.
      It's also used in root Directory.Build.targets to determine the version of the last-built targeting pack.
    -->
    <TargetingPackVersionPrefix>$(VersionPrefix)</TargetingPackVersionPrefix>
    <ExperimentalVersionPrefix>0.$(AspNetCoreMajorVersion).$(AspNetCorePatchVersion)</ExperimentalVersionPrefix>
    <!-- ANCM versioning is intentionally 10 + AspNetCoreMajorVersion because earlier versions of ANCM shipped as 8.x. -->
    <AspNetCoreModuleVersionMajor>$([MSBuild]::Add(10, $(AspNetCoreMajorVersion)))</AspNetCoreModuleVersionMajor>
    <AspNetCoreModuleVersionMinor>$(AspNetCoreMinorVersion)</AspNetCoreModuleVersionMinor>
    <AspNetCoreModuleVersionRevision>$(AspNetCorePatchVersion)</AspNetCoreModuleVersionRevision>
    <!-- This is used for error checking to ensure generated code and baselines are up to date when we increment the patch. -->
    <PreviousAspNetCoreReleaseVersion Condition=" '$(AspNetCorePatchVersion)' != '0' ">$(AspNetCoreMajorMinorVersion).$([MSBuild]::Subtract($(AspNetCorePatchVersion), 1))</PreviousAspNetCoreReleaseVersion>
    <!--
      Update the packages referenced in Microsoft.AspNetCore.AzureAppServices.SiteExtension.csproj,
      src\Components\WebAssembly\Sdk\testassets\Directory.Build.props, and
      src\Razor\test\testassets\Directory.Build.props when this changes.
    -->
    <DefaultNetCoreTargetFramework>net10.0</DefaultNetCoreTargetFramework>
    <!-- this should usually match for LTS builds, and be off-by-one otherwise;
      example use-case here is OOB packages where Aspire wants to be able to consume
      new features specific to OOB -->
    <CurrentLtsTargetFramework>net10.0</CurrentLtsTargetFramework>
  </PropertyGroup>
  <PropertyGroup Label="Arcade settings">
    <!-- Opt-in to Arcade tools for building VSIX projects. -->
    <UsingToolVSSDK>true</UsingToolVSSDK>
    <!-- Disable XLIFF tasks -->
    <UsingToolXliff>false</UsingToolXliff>
  </PropertyGroup>
  <!--
    Versions below this comment are not managed by automation and can be changed as needed.
  -->
  <PropertyGroup Label="Manual">
    <!-- Dependencies from maintenance-packages -->
    <MicrosoftBCLHashCodeVersion>6.0.0</MicrosoftBCLHashCodeVersion>
    <MicrosoftIoRedistVersion>6.1.3</MicrosoftIoRedistVersion>
    <SystemBuffersVersion>4.6.1</SystemBuffersVersion>
    <SystemMemoryVersion>4.6.3</SystemMemoryVersion>
    <SystemThreadingTasksExtensionsVersion>4.6.3</SystemThreadingTasksExtensionsVersion>
    <SystemValueTupleVersion>4.6.1</SystemValueTupleVersion>
    <!-- DiagnosticAdapter package pinned temporarily (??) until migrated/deprecated -->
    <!-- This is the latest version found in dotnet-public. -->
    <MicrosoftExtensionsDiagnosticAdapterVersion>5.0.0-preview.3.20215.2</MicrosoftExtensionsDiagnosticAdapterVersion>
    <!-- Build tool dependencies -->
    <MicrosoftVSSDKBuildToolsVersion>15.9.3032</MicrosoftVSSDKBuildToolsVersion>
    <!-- Stable dotnet/corefx packages no longer updated for .NET Core 3 -->
    <MicrosoftCSharpVersion>4.7.0</MicrosoftCSharpVersion>
    <MicrosoftWin32RegistryVersion>5.0.0</MicrosoftWin32RegistryVersion>
    <NETStandardLibraryVersion>2.0.3</NETStandardLibraryVersion>
    <SystemCodeDomVersion>4.4.0</SystemCodeDomVersion>
    <SystemCommandlineExperimentalVersion>0.3.0-alpha.19317.1</SystemCommandlineExperimentalVersion>
    <SystemComponentModelVersion>4.3.0</SystemComponentModelVersion>
    <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
    <SystemNetSocketsVersion>4.3.0</SystemNetSocketsVersion>
    <SystemSecurityCryptographyX509CertificatesVersion>4.3.2</SystemSecurityCryptographyX509CertificatesVersion>
    <SystemRuntimeInteropServicesRuntimeInformationVersion>4.3.0</SystemRuntimeInteropServicesRuntimeInformationVersion>
    <!-- Packages developed by @aspnet, but manually updated as necessary. -->
    <MicrosoftAspNetWebApiClientVersion>5.2.6</MicrosoftAspNetWebApiClientVersion>
    <MicrosoftAspNetCoreRazorLanguageVersion>6.0.0</MicrosoftAspNetCoreRazorLanguageVersion>
    <MicrosoftAspNetCoreMvcRazorExtensionsVersion>6.0.0</MicrosoftAspNetCoreMvcRazorExtensionsVersion>
    <MicrosoftCodeAnalysisRazorVersion>6.0.0</MicrosoftCodeAnalysisRazorVersion>
    <!-- Partner teams -->
    <MicrosoftAzureSignalRVersion>1.2.0</MicrosoftAzureSignalRVersion>
    <MicrosoftBuildLocatorVersion>1.2.6</MicrosoftBuildLocatorVersion>
    <!-- Packages from dotnet/msbuild -->
    <MicrosoftBuildVersion>17.12.36</MicrosoftBuildVersion>
    <MicrosoftBuildFrameworkVersion>17.12.36</MicrosoftBuildFrameworkVersion>
    <MicrosoftBuildTasksCoreVersion>17.12.36</MicrosoftBuildTasksCoreVersion>
    <MicrosoftBuildUtilitiesCoreVersion>17.12.36</MicrosoftBuildUtilitiesCoreVersion>
    <!--
      Temporarily override the Microsoft.NET.Test.Sdk version Arcade defaults to. That's incompatible w/ test
      framework in current .NET SDKs.
    -->
    <MicrosoftNETTestSdkVersion>17.1.0-preview-20211109-03</MicrosoftNETTestSdkVersion>
    <!--
      Also use a newer, publicly-released version of the templating engine than the Arcade default.
      https://github.com/dotnet/templating/blob/main/docs/Localization.md recommends updating the version when
      preview or stable versions are released to NuGet.org.
    -->
    <MicrosoftTemplateEngineAuthoringTasksVersion>8.0.100-alpha.1.22607.1</MicrosoftTemplateEngineAuthoringTasksVersion>
    <!-- Packages from dotnet/roslyn -->
    <MicrosoftCodeAnalysisCommonVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCommonVersion>
    <MicrosoftCodeAnalysisExternalAccessAspNetCoreVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisExternalAccessAspNetCoreVersion>
    <MicrosoftCodeAnalysisCSharpVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCSharpVersion>
    <MicrosoftCodeAnalysisCSharpWorkspacesVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCSharpWorkspacesVersion>
    <!--
      Versions of Microsoft.CodeAnalysis packages referenced by analyzers shipped in the SDK.
      This need to be pinned since they're used in 3.1 apps and need to be loadable in VS 2019.
      If you update these versions, make sure to also update https://github.com/dotnet/aspnetcore/blob/main/eng/SourceBuildPrebuiltBaseline.xml
    -->
    <Analyzer_MicrosoftCodeAnalysisCSharpVersion>3.3.1</Analyzer_MicrosoftCodeAnalysisCSharpVersion>
    <Analyzer_MicrosoftCodeAnalysisCSharpWorkspacesVersion>3.3.1</Analyzer_MicrosoftCodeAnalysisCSharpWorkspacesVersion>
    <!-- Pin the version of the M.CA dependencies that we utilize with a custom version property $(MicrosoftCodeAnalysisVersion_LatestVS) to avoid automatically
    consuming the newest version of the packages when using the $(MicrosoftCodeAnalysisCSharpVersion) properties in source-build. -->
    <MicrosoftCodeAnalysisVersion_LatestVS>4.13.0-3.24613.7</MicrosoftCodeAnalysisVersion_LatestVS>
    <MicrosoftCodeAnalysisExternalAccessAspNetCoreVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisExternalAccessAspNetCoreVersion>
    <MicrosoftCodeAnalysisCommonVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCommonVersion>
    <MicrosoftCodeAnalysisCSharpVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCSharpVersion>
    <MicrosoftCodeAnalysisCSharpWorkspacesVersion>4.13.0-3.24613.7</MicrosoftCodeAnalysisCSharpWorkspacesVersion>
    <MicrosoftCodeAnalysisPublicApiAnalyzersVersion>3.3.3</MicrosoftCodeAnalysisPublicApiAnalyzersVersion>
    <MicrosoftCodeAnalysisCSharpAnalyzerTestingVersion>1.1.2</MicrosoftCodeAnalysisCSharpAnalyzerTestingVersion>
    <MicrosoftCodeAnalysisCSharpCodeFixTestingVersion>1.1.2</MicrosoftCodeAnalysisCSharpCodeFixTestingVersion>
    <MicrosoftCodeAnalysisCSharpSourceGeneratorsTestingVersion>1.1.2</MicrosoftCodeAnalysisCSharpSourceGeneratorsTestingVersion>
    <MicrosoftCssParserVersion>1.0.0-20230414.1</MicrosoftCssParserVersion>
    <MicrosoftIdentityModelLoggingVersion>$(IdentityModelVersion)</MicrosoftIdentityModelLoggingVersion>
    <MicrosoftIdentityModelProtocolsOpenIdConnectVersion>$(IdentityModelVersion)</MicrosoftIdentityModelProtocolsOpenIdConnectVersion>
    <MicrosoftIdentityModelProtocolsWsFederationVersion>$(IdentityModelVersion)</MicrosoftIdentityModelProtocolsWsFederationVersion>
    <MicrosoftInternalAspNetCoreH2SpecAllVersion>2.2.1</MicrosoftInternalAspNetCoreH2SpecAllVersion>
    <MicrosoftNETCoreWindowsApiSetsVersion>1.0.1</MicrosoftNETCoreWindowsApiSetsVersion>
    <MicrosoftOwinSecurityCookiesVersion>3.0.1</MicrosoftOwinSecurityCookiesVersion>
    <MicrosoftOwinTestingVersion>3.0.1</MicrosoftOwinTestingVersion>
    <MicrosoftWebAdministrationVersion>11.1.0</MicrosoftWebAdministrationVersion>
    <SystemIdentityModelTokensJwtVersion>$(IdentityModelVersion)</SystemIdentityModelTokensJwtVersion>
    <SystemComponentModelAnnotationsVersion>5.0.0</SystemComponentModelAnnotationsVersion>
    <SystemNetExperimentalMsQuicVersion>5.0.0-alpha.20560.6</SystemNetExperimentalMsQuicVersion>
    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
    <!-- Packages from downlevel branches used for site extension build. -->
    <MicrosoftAspNetCoreAzureAppServicesSiteExtension80Version>8.0.0-rtm-23531-12</MicrosoftAspNetCoreAzureAppServicesSiteExtension80Version>
    <MicrosoftAspNetCoreAzureAppServicesSiteExtension80x64Version>$(MicrosoftAspNetCoreAzureAppServicesSiteExtension80Version)</MicrosoftAspNetCoreAzureAppServicesSiteExtension80x64Version>
    <MicrosoftAspNetCoreAzureAppServicesSiteExtension80x86Version>$(MicrosoftAspNetCoreAzureAppServicesSiteExtension80Version)</MicrosoftAspNetCoreAzureAppServicesSiteExtension80x86Version>
    <MicrosoftAspNetCoreAzureAppServicesSiteExtension90Version>9.0.0-rtm-24529-3</MicrosoftAspNetCoreAzureAppServicesSiteExtension90Version>
    <MicrosoftAspNetCoreAzureAppServicesSiteExtension90x64Version>$(MicrosoftAspNetCoreAzureAppServicesSiteExtension90Version)</MicrosoftAspNetCoreAzureAppServicesSiteExtension90x64Version>
    <MicrosoftAspNetCoreAzureAppServicesSiteExtension90x86Version>$(MicrosoftAspNetCoreAzureAppServicesSiteExtension90Version)</MicrosoftAspNetCoreAzureAppServicesSiteExtension90x86Version>
    <!-- 3rd party dependencies -->
    <AzureIdentityVersion>1.11.4</AzureIdentityVersion>
    <AngleSharpVersion>0.9.9</AngleSharpVersion>
    <BenchmarkDotNetVersion>0.13.0</BenchmarkDotNetVersion>
    <CastleCoreVersion>4.2.1</CastleCoreVersion>
    <CommandLineParserVersion>2.3.0</CommandLineParserVersion>
    <FSharpCoreVersion>6.0.0</FSharpCoreVersion>
    <GoogleApiCommonProtosVersion>2.15.0</GoogleApiCommonProtosVersion>
    <GoogleProtobufVersion>3.27.0</GoogleProtobufVersion>
    <GrpcAspNetCoreVersion>2.64.0</GrpcAspNetCoreVersion>
    <GrpcAspNetCoreServerVersion>2.64.0</GrpcAspNetCoreServerVersion>
    <GrpcAuthVersion>2.64.0</GrpcAuthVersion>
    <GrpcNetClientVersion>2.64.0</GrpcNetClientVersion>
    <GrpcToolsVersion>2.64.0</GrpcToolsVersion>
    <MessagePackVersion>2.5.187</MessagePackVersion>
    <MicrosoftIdentityWebVersion>3.0.0</MicrosoftIdentityWebVersion>
    <MicrosoftIdentityWebGraphServiceClientVersion>3.0.0</MicrosoftIdentityWebGraphServiceClientVersion>
    <MicrosoftIdentityWebUIVersion>3.0.0</MicrosoftIdentityWebUIVersion>
    <MicrosoftIdentityWebDownstreamApiVersion>3.0.0</MicrosoftIdentityWebDownstreamApiVersion>
    <MicrosoftWindowsCsWin32Version>0.3.46-beta</MicrosoftWindowsCsWin32Version>
    <MessagePackAnalyzerVersion>$(MessagePackVersion)</MessagePackAnalyzerVersion>
    <MoqVersion>4.10.0</MoqVersion>
    <MonoCecilVersion>0.11.2</MonoCecilVersion>
    <MonoTextTemplatingVersion>2.2.1</MonoTextTemplatingVersion>
    <NewtonsoftJsonBsonVersion>1.0.2</NewtonsoftJsonBsonVersion>
    <NewtonsoftJsonVersion>13.0.3</NewtonsoftJsonVersion>
    <NSwagApiDescriptionClientVersion>13.0.4</NSwagApiDescriptionClientVersion>
    <PhotinoNETVersion>2.5.2</PhotinoNETVersion>
    <MicrosoftPlaywrightVersion>1.54.0</MicrosoftPlaywrightVersion>
    <PollyExtensionsHttpVersion>3.0.0</PollyExtensionsHttpVersion>
    <PollyVersion>7.2.4</PollyVersion>
    <SeleniumSupportVersion>4.34.0</SeleniumSupportVersion>
    <SeleniumWebDriverVersion>4.34.0</SeleniumWebDriverVersion>
    <SerilogExtensionsLoggingVersion>1.4.0</SerilogExtensionsLoggingVersion>
    <SerilogSinksFileVersion>4.0.0</SerilogSinksFileVersion>
    <StackExchangeRedisVersion>2.7.27</StackExchangeRedisVersion>
    <SystemReactiveLinqVersion>5.0.0</SystemReactiveLinqVersion>
    <SwashbuckleAspNetCoreVersion>6.6.2</SwashbuckleAspNetCoreVersion>
    <VerifySourceGeneratorsVersion>2.2.0</VerifySourceGeneratorsVersion>
    <VerifyXunitVersion>19.14.0</VerifyXunitVersion>
    <XunitAbstractionsVersion>2.0.3</XunitAbstractionsVersion>
    <XunitAnalyzersVersion>1.15.0</XunitAnalyzersVersion>
    <XunitVersion>2.9.2</XunitVersion>
    <XunitAssertVersion>$(XunitVersion)</XunitAssertVersion>
    <XunitExtensibilityCoreVersion>$(XunitVersion)</XunitExtensibilityCoreVersion>
    <XunitExtensibilityExecutionVersion>$(XunitVersion)</XunitExtensibilityExecutionVersion>
    <XUnitRunnerVisualStudioVersion>3.1.3</XUnitRunnerVisualStudioVersion>
    <MicrosoftDataSqlClientVersion>5.2.2</MicrosoftDataSqlClientVersion>
    <MicrosoftOpenApiVersion>2.0.0</MicrosoftOpenApiVersion>
    <MicrosoftOpenApiYamlReaderVersion>2.0.0</MicrosoftOpenApiYamlReaderVersion>
    <!-- dotnet tool versions (see also auto-updated DotnetEfVersion property). -->
    <DotnetDumpVersion>6.0.322601</DotnetDumpVersion>
    <DotnetServeVersion>1.10.93</DotnetServeVersion>
    <MicrosoftPlaywrightCLIVersion>1.2.3</MicrosoftPlaywrightCLIVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/DefaultVersions.props
============================================================================================================================================
-->
  <!-- TODO: remove once all repos remove RestoreSources from their Version.props files -->
  <PropertyGroup>
    <RestoreSources />
  </PropertyGroup>
  <!--
    Arcade SDK features.
  -->
  <PropertyGroup>
    <!-- Opt-out features -->
    <UsingToolXliff Condition="'$(UsingToolXliff)' == ''">true</UsingToolXliff>
    <UsingToolPdbConverter Condition="'$(UsingToolPdbConverter)' == ''">true</UsingToolPdbConverter>
    <!-- Opt-in features -->
    <UsingToolVSSDK Condition="'$(UsingToolVSSDK)' == ''">false</UsingToolVSSDK>
    <UsingToolIbcOptimization Condition="'$(UsingToolIbcOptimization)' == ''">false</UsingToolIbcOptimization>
    <UsingToolVisualStudioIbcTraining Condition="'$(UsingToolVisualStudioIbcTraining)' == ''">false</UsingToolVisualStudioIbcTraining>
    <UsingToolNuGetRepack Condition="'$(UsingToolNuGetRepack)' == ''">false</UsingToolNuGetRepack>
    <UsingToolSymbolUploader Condition="'$(UsingToolSymbolUploader)' == ''">false</UsingToolSymbolUploader>
    <!-- Deprecated features -->
    <!--
      The UsingToolXUnit property is deprecated,
      use the TestRunnerName property to choose which test runner to use.
    -->
    <UsingToolXUnit Condition="'$(UsingToolXUnit)' == ''">true</UsingToolXUnit>
    <!--
      Use compilers from the Microsoft.Net.Compilers.Toolset package.
      Repo can set this property to true if it needs to use a different version of the compiler than the one in the dotnet SDK.
    -->
    <UsingToolMicrosoftNetCompilers Condition="'$(UsingToolMicrosoftNetCompilers)' == ''">false</UsingToolMicrosoftNetCompilers>
  </PropertyGroup>
  <!--
    Disable features when building from source.
  -->
  <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' == 'true'">
    <UsingToolPdbConverter>false</UsingToolPdbConverter>
    <UsingToolVSSDK>false</UsingToolVSSDK>
    <UsingToolIbcOptimization>false</UsingToolIbcOptimization>
    <UsingToolVisualStudioIbcTraining>false</UsingToolVisualStudioIbcTraining>
    <UsingToolSymbolUploader>false</UsingToolSymbolUploader>
  </PropertyGroup>
  <!--
    Default versions
  -->
  <PropertyGroup>
    <DropAppVersion Condition="'$(DropAppVersion)' == ''">19.239.34923-buildid28260713</DropAppVersion>
    <MicroBuildPluginsSwixBuildVersion Condition="'$(MicroBuildPluginsSwixBuildVersion)' == ''">1.0.422</MicroBuildPluginsSwixBuildVersion>
    <MicrosoftDotNetIBCMergeVersion Condition="'$(MicrosoftDotNetIBCMergeVersion)' == ''">5.1.0-beta.21356.1</MicrosoftDotNetIBCMergeVersion>
    <MicrosoftNETTestSdkVersion Condition="'$(MicrosoftNETTestSdkVersion)' == ''">17.12.0</MicrosoftNETTestSdkVersion>
    <MicrosoftVSSDKBuildToolsVersion Condition="'$(MicrosoftVSSDKBuildToolsVersion)' == ''">16.9.1050</MicrosoftVSSDKBuildToolsVersion>
    <MicrosoftDotnetNuGetRepackTasksVersion Condition="'$(MicrosoftDotnetNuGetRepackTasksVersion)' == ''">$(ArcadeSdkVersion)</MicrosoftDotnetNuGetRepackTasksVersion>
    <MicrosoftDotNetSignToolVersion Condition="'$(MicrosoftDotNetSignToolVersion)' == ''">$(ArcadeSdkVersion)</MicrosoftDotNetSignToolVersion>
    <MicrosoftDotNetTarVersion Condition="'$(MicrosoftDotNetTarVersion)' == ''">$(ArcadeSdkVersion)</MicrosoftDotNetTarVersion>
    <MicrosoftDotNetMacOsPkgVersion Condition="'$(MicrosoftDotNetMacOsPkgVersion)' == ''">$(ArcadeSdkVersion)</MicrosoftDotNetMacOsPkgVersion>
    <MicrosoftTestPlatformVersion Condition="'$(MicrosoftTestPlatformVersion)' == ''">17.12.0</MicrosoftTestPlatformVersion>
    <!-- Follow the instructions on how to update any of the below xunit versions: https://github.com/dotnet/arcade/blob/main/Documentation/update-xunit.md. -->
    <XUnitVersion Condition="'$(XUnitVersion)' == ''">2.9.3</XUnitVersion>
    <XUnitAnalyzersVersion Condition="'$(XUnitAnalyzersVersion)' == ''">1.22.0</XUnitAnalyzersVersion>
    <XUnitRunnerConsoleVersion Condition="'$(XUnitRunnerConsoleVersion)' == ''">$(XUnitVersion)</XUnitRunnerConsoleVersion>
    <XUnitRunnerVisualStudioVersion Condition="'$(XUnitRunnerVisualStudioVersion)' == ''">3.1.3</XUnitRunnerVisualStudioVersion>
    <XUnitV3Version Condition="'$(XUnitV3Version)' == ''">3.0.0</XUnitV3Version>
    <MicrosoftTestingPlatformVersion Condition="'$(MicrosoftTestingPlatformVersion)' == ''">1.7.3</MicrosoftTestingPlatformVersion>
    <MSTestVersion Condition="'$(MSTestVersion)' == ''">3.9.3</MSTestVersion>
    <MSTestTestAdapterVersion Condition="'$(MSTestTestAdapterVersion)' == ''">$(MSTestVersion)</MSTestTestAdapterVersion>
    <MSTestTestFrameworkVersion Condition="'$(MSTestTestFrameworkVersion)' == ''">$(MSTestVersion)</MSTestTestFrameworkVersion>
    <MicrosoftDotNetBuildTasksFeedVersion Condition="'$(MicrosoftDotNetBuildTasksFeedVersion)' == ''">$(ArcadeSdkVersion)</MicrosoftDotNetBuildTasksFeedVersion>
    <MicrosoftDotNetBuildTasksInstallersVersion Condition="'$(MicrosoftDotNetBuildTasksInstallersVersion)' == ''">$(ArcadeSdkVersion)</MicrosoftDotNetBuildTasksInstallersVersion>
    <NUnitVersion Condition="'$(NUnitVersion)' == ''">3.12.0</NUnitVersion>
    <NUnit3TestAdapterVersion Condition="'$(NUnit3TestAdapterVersion)' == ''">3.15.1</NUnit3TestAdapterVersion>
    <VSWhereVersion Condition="'$(VSWhereVersion)' == ''">2.6.7</VSWhereVersion>
    <SNVersion Condition="'$(SNVersion)' == ''">1.0.0</SNVersion>
    <MicrosoftDotNetBuildTasksVisualStudioVersion Condition="'$(MicrosoftDotNetBuildTasksVisualStudioVersion)' == ''">$(ArcadeSdkVersion)</MicrosoftDotNetBuildTasksVisualStudioVersion>
    <MicrosoftDotNetSourceBuildTasksVersion Condition="'$(MicrosoftDotNetSourceBuildTasksVersion)' == ''">$(ArcadeSdkVersion)</MicrosoftDotNetSourceBuildTasksVersion>
    <MicrosoftVisualStudioEngMicroBuildCoreVersion Condition="'$(MicrosoftVisualStudioEngMicroBuildCoreVersion)' == ''">1.0.0</MicrosoftVisualStudioEngMicroBuildCoreVersion>
    <MicrosoftManifestToolCrossPlatformVersion Condition="'$(MicrosoftManifestToolCrossPlatformVersion)' == ''">2.1.3</MicrosoftManifestToolCrossPlatformVersion>
    <MicrosoftVisualStudioEngMicroBuildPluginsSwixBuildVersion Condition="'$(MicrosoftVisualStudioEngMicroBuildPluginsSwixBuildVersion)' == ''">1.1.286</MicrosoftVisualStudioEngMicroBuildPluginsSwixBuildVersion>
    <MicrosoftSignedWixVersion Condition="'$(MicrosoftSignedWixVersion)' == ''">3.14.1-9323.2545153</MicrosoftSignedWixVersion>
    <MicrosoftWixToolsetVersion Condition="'$(MicrosoftWixToolsetVersion)' == ''">5.0.2-dotnet.2737382</MicrosoftWixToolsetVersion>
  </PropertyGroup>
  <!-- RestoreSources overrides - defines DotNetRestoreSources variable if available -->
  <!--<Import Project="$(DotNetPackageVersionPropsPath)" Condition="'$(DotNetPackageVersionPropsPath)' != ''" />-->
  <!--
    Defaults for properties that need to be available to all CI build steps and are dependent on settings specified in eng/Versions.props.
  -->
  <PropertyGroup>
    <IbcOptimizationDataDir Condition="'$(UsingToolVisualStudioIbcTraining)' == 'true'">$(ArtifactsDir)ibc\</IbcOptimizationDataDir>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="StrongName.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/StrongName.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!-- Known public keys -->
  <PropertyGroup>
    <MicrosoftSharedPublicKey>0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9</MicrosoftSharedPublicKey>
    <MicrosoftPublicKey>002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293</MicrosoftPublicKey>
    <MicrosoftAspNetCorePublicKey>0024000004800000940000000602000000240000525341310004000001000100f33a29044fa9d740c9b3213a93e57c84b472c84e0b8a0e1ae48e67a9f8f6de9d5f7f3d52ac23e48ac51801f1dc950abe901da34d2a9e3baadb141a17c77ef3c565dd5ee5054b91cf63bb3c6ab83f72ab3aafe93d0fc3c2348b764fafb0b1c0733de51459aeab46580384bf9d74c4e28164b7cde247f891ba07891c9d872ad2bb</MicrosoftAspNetCorePublicKey>
    <ECMAPublicKey>00000000000000000400000000000000</ECMAPublicKey>
    <OpenPublicKey>00240000048000009400000006020000002400005253413100040000010001004b86c4cb78549b34bab61a3b1800e23bfeb5b3ec390074041536a7e3cbd97f5f04cf0f857155a8928eaa29ebfd11cfbbad3ba70efea7bda3226c6a8d370a4cd303f714486b6ebc225985a638471e6ef571cc92a4613c00b8fa65d61ccee0cbe5f36330c9a01f4183559f1bef24cc2917c6d913e3a541333a1d05d9bed22b38cb</OpenPublicKey>
    <SilverlightPlatformPublicKey>00240000048000009400000006020000002400005253413100040000010001008d56c76f9e8649383049f383c44be0ec204181822a6c31cf5eb7ef486944d032188ea1d3920763712ccb12d75fb77e9811149e6148e5d32fbaab37611c1878ddc19e20ef135d0cb2cff2bfec3d115810c3d9069638fe4be215dbf795861920e5ab6f7db2e2ceef136ac23d5dd2bf031700aec232f6c6b1c785b4305c123b37ab</SilverlightPlatformPublicKey>
  </PropertyGroup>
  <!--
      FullAssemblySigningSupported    "false" to use public signing even when full signing is possible. This is useful
                                      in environments where full signing is non-functional or not desired. For example,
                                      in some Linux distributions RSA+SHA1 (required for full signing) is not
                                      functional/available, and trying to use full signing results in the runtime
                                      throwing an exception. For more details and an example, see
                                      https://github.com/dotnet/runtime/issues/65874. We default to full assembly
                                      signing not being supported in source-only modes.
  -->
  <PropertyGroup>
    <FullAssemblySigningSupported Condition="'$(FullAssemblySigningSupported)' == '' and '$(DotNetBuildSourceOnly)' == 'true'">false</FullAssemblySigningSupported>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="ProjectDefaults.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/ProjectDefaults.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <SignAssembly>true</SignAssembly>
    <StrongNameKeyId>MicrosoftShared</StrongNameKeyId>
    <ChecksumAlgorithm>SHA256</ChecksumAlgorithm>
    <HighEntropyVA>true</HighEntropyVA>
    <NeutralLanguage>en-US</NeutralLanguage>
    <Company>Microsoft Corporation</Company>
    <CopyrightMicrosoft>© Microsoft Corporation. All rights reserved.</CopyrightMicrosoft>
    <CopyrightNetFoundation>© .NET Foundation and Contributors</CopyrightNetFoundation>
    <Authors>Microsoft</Authors>
    <Serviceable>true</Serviceable>
    <DevelopmentDependency>false</DevelopmentDependency>
    <PackageRequireLicenseAcceptance>true</PackageRequireLicenseAcceptance>
    <PublishRepositoryUrl>true</PublishRepositoryUrl>
    <EmbedUntrackedSources>true</EmbedUntrackedSources>
    <PackageIcon>Icon.png</PackageIcon>
    <PackageIconFullPath>$(MSBuildThisFileDirectory)Assets\DotNetPackageIcon.png</PackageIconFullPath>
    <!-- Disable the message indicating we are using a preview SDK. That is understood and by design -->
    <SuppressNETCoreSdkPreviewMessage>true</SuppressNETCoreSdkPreviewMessage>
    <!-- By default do not build NuGet package for a non pkgproj project. Project may override. -->
    <IsPackable Condition="'$(MSBuildProjectExtension)' != '.pkgproj'">false</IsPackable>
    <!--
      Official build:
       - Build standalone Portable PDBs to reduce the size of the binaries.
       - Convert Portable PDBs to Windows PDBs and publish the converted PDBs to Symbol Store to allow WinDBG, 
         Watson and other tools to find symbol format they understand.

      PR validation build:
       - Embed PDBs to make it easier to debug crash dumps captured on the CI machine.

      Developer build:
       - Embed PDBs to be consistent with PR validation build.    
    -->
    <DebugType>portable</DebugType>
    <DebugType Condition="'$(OfficialBuild)' != 'true'">embedded</DebugType>
    <!-- 
      This controls the places MSBuild will consult to resolve assembly references.  This is 
      kept as minimal as possible to make our build reliable from machine to machine.  Global
      locations such as GAC, AssemblyFoldersEx, etc ... are deliberately removed from this 
      list as they will not be the same from machine to machine.
    -->
    <AssemblySearchPaths>
      {HintPathFromItem};
      {TargetFrameworkDirectory};
      {RawFileName};
    </AssemblySearchPaths>
  </PropertyGroup>
  <PropertyGroup>
    <Language Condition="'$(MSBuildProjectExtension)' == '.csproj'">C#</Language>
    <Language Condition="'$(MSBuildProjectExtension)' == '.vbproj'">VB</Language>
    <Language Condition="'$(MSBuildProjectExtension)' == '.fsproj'">F#</Language>
    <Language Condition="'$(MSBuildProjectExtension)' == '.vcxproj'">C++</Language>
  </PropertyGroup>
  <!--
    When building WPF / VSIX projects MSBuild will create a temporary project with an extension of
    tmp_proj.  In that case the SDK is unable to determine the target language and cannot pick
    the correct import. Need to set it explicitly here.
    See https://github.com/dotnet/project-system/issues/1467
  -->
  <Choose>
    <When Condition="'$(MSBuildProjectExtension)' != '.csproj' and '$(MSBuildProjectExtension)' != '.vbproj' and '$(MSBuildProjectExtension)' != '.shproj'">
      <Choose>
        <When Condition="'$(Language)' == 'C#' or Exists('$(MSBuildProjectDirectory)\$(AssemblyName).csproj')">
          <PropertyGroup>
            <Language>C#</Language>
            <LanguageTargets>$(MSBuildToolsPath)\Microsoft.CSharp.targets</LanguageTargets>
          </PropertyGroup>
        </When>
        <When Condition="'$(Language)' == 'VB' or Exists('$(MSBuildProjectDirectory)\$(AssemblyName).vbproj')">
          <PropertyGroup>
            <Language>VB</Language>
            <LanguageTargets>$(MSBuildToolsPath)\Microsoft.VisualBasic.targets</LanguageTargets>
          </PropertyGroup>
        </When>
      </Choose>
    </When>
  </Choose>
  <Choose>
    <!-- C# specific settings -->
    <When Condition="'$(Language)' == 'C#'">
      <PropertyGroup>
        <NoWarn>$(NoWarn);1701;1702;1705</NoWarn>
        <NoWarn Condition="'$(SkipArcadeNoWarnCS1591)' != 'true'">$(NoWarn);1591</NoWarn>
      </PropertyGroup>
    </When>
    <!-- VB specific settings -->
    <When Condition="'$(Language)' == 'VB'">
      <PropertyGroup>
        <MyType>Empty</MyType>
        <OptionCompare>Binary</OptionCompare>
        <OptionStrict>On</OptionStrict>
        <RemoveIntegerChecks>true</RemoveIntegerChecks>
      </PropertyGroup>
    </When>
    <!-- F# specific settings -->
    <When Condition="'$(Language)' == 'F#'">
      <PropertyGroup>
        <!-- F# compiler doesn't support PathMap (see https://github.com/Microsoft/visualfsharp/issues/3812) -->
        <DeterministicSourcePaths>false</DeterministicSourcePaths>
      </PropertyGroup>
    </When>
    <!-- C++ specific settings -->
    <When Condition="'$(Language)' == 'C++'">
      <PropertyGroup>
        <OutDir>$(OutputPath)</OutDir>
        <!-- 
          Disable NuGet package resolution during build - PackageReferences are not fully supported 
          Props and target files are still going to be imported from referenced packages.
        -->
        <ResolveNuGetPackages>false</ResolveNuGetPackages>
      </PropertyGroup>
    </When>
  </Choose>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Tests.props" Condition="'$(DisableArcadeTestFramework)' != 'true'">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Tests.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup Condition="'$(IsPerformanceTestProject)' == ''">
    <IsPerformanceTestProject>false</IsPerformanceTestProject>
    <IsPerformanceTestProject Condition="$(MSBuildProjectName.EndsWith('.PerformanceTests'))">true</IsPerformanceTestProject>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsIntegrationTestProject)' == ''">
    <IsIntegrationTestProject>false</IsIntegrationTestProject>
    <IsIntegrationTestProject Condition="$(MSBuildProjectName.EndsWith('.IntegrationTests'))">true</IsIntegrationTestProject>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsUnitTestProject)' == ''">
    <IsUnitTestProject>false</IsUnitTestProject>
    <IsUnitTestProject Condition="$(MSBuildProjectName.EndsWith('.UnitTests')) or $(MSBuildProjectName.EndsWith('.Tests'))">true</IsUnitTestProject>
  </PropertyGroup>
  <PropertyGroup>
    <IsTestProject>false</IsTestProject>
    <IsTestProject Condition="'$(IsUnitTestProject)' == 'true' or '$(IsIntegrationTestProject)' == 'true' or '$(IsPerformanceTestProject)' == 'true'">true</IsTestProject>
    <!-- Disable building Integration Test projects in LUT. -->
    <BuildForLiveUnitTesting Condition="'$(BuildForLiveUnitTesting)' == '' and '$(IsIntegrationTestProject)' == 'true'">false</BuildForLiveUnitTesting>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsTestProject)' == 'true'">
    <!-- VS TestExplorer uses this to identify a test project -->
    <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
  </ItemGroup>
  <!-- Microsoft.NET.Test.Sdk is VSTest-specific package. -->
  <!-- If EnableMSTestRunner, EnableNUnitRunner, or UseMicrosoftTestingPlatformRunner is true, then the repo is using Microsoft.Testing.Platform -->
  <!-- In that case, we don't need Microsoft.NET.Test.Sdk -->
  <ItemGroup Condition="'$(IsTestProject)' == 'true' and '$(ExcludeMicrosoftNetTestSdk)' != 'true' and '$(EnableMSTestRunner)' != 'true' and '$(EnableNUnitRunner)' != 'true' and '$(UseMicrosoftTestingPlatformRunner)' != 'true'">
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="$(MicrosoftNETTestSdkVersion)" IsImplicitlyDefined="true" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Workarounds.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Workarounds.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    Determine whether the project is WPF temp project.
    Since .NET Framework 4.7.2 WPF temp project name ends with _wpftmp suffix and keeps the language specific extension (e.g. csproj). 
  -->
  <PropertyGroup Condition="'$(IsWpfTempProject)' == ''">
    <IsWpfTempProject>false</IsWpfTempProject>
    <IsWpfTempProject Condition="$(MSBuildProjectName.EndsWith('_wpftmp'))">true</IsWpfTempProject>
  </PropertyGroup>
  <!--
    WPF temp-projects do not import .props and .targets files from NuGet packages.
    (see https://github.com/dotnet/sourcelink/issues/91).
    
    Property _TargetAssemblyProjectName is set by GenerateTemporaryTargetAssembly task.

    Disable Source Link and Xliff in WPF temp projects to avoid generating non-deterministic file names to obj dir.
    The project name is non-deterministic and is included in the Source Link json file name and xlf directory names.
    It's also not necessary to generate these assets.
  -->
  <PropertyGroup Condition="'$(IsWpfTempProject)' == 'true'">
    <EnableSourceLink>false</EnableSourceLink>
    <EmbedUntrackedSources>false</EmbedUntrackedSources>
    <DeterministicSourcePaths>false</DeterministicSourcePaths>
    <EnableXlfLocalization>false</EnableXlfLocalization>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="TargetFrameworkDefaults.props">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/TargetFrameworkDefaults.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!-- Repositories using the arcade SDK can stay up to date with their target framework more easily using the properties in this file.

       Examples:
       <TargetFramework>$(NetCurrent)</TargetFramework>
       <TargetFrameworks>$(NetCurrent);$(NetFrameworkCurrent)</TargetFrameworks>
       <TargetFrameworks>$(NetCurrent);$(NetMinimum);netstandard2.0;$(NetFrameworkMinimum)</TargetFrameworks>
  -->
  <PropertyGroup>
    <!-- The TFM of the major release of .NET that the Arcade SDK aligns with. -->
    <NetCurrent>net10.0</NetCurrent>
    <!-- The previously released version of .NET.
         Undefined when NetMinimum and NetPrevious are identical. -->
    <NetPrevious>net9.0</NetPrevious>
    <!-- Lowest supported version of .NET at the time of the release of NetCurrent. -->
    <NetMinimum>net8.0</NetMinimum>
    <!-- The TFM of the latest version of .NET Framework. -->
    <NetFrameworkCurrent>net481</NetFrameworkCurrent>
    <!-- Lowest supported version of .NET Framework the time of the release of NetCurrent. -->
    <NetFrameworkMinimum>net462</NetFrameworkMinimum>
  </PropertyGroup>
  <PropertyGroup>
    <!-- The current version of .NET that tools (i.e. msbuild) target.
         MSBuild tasks and tools should use this version to target the latest TFM that is supported by tooling.
         Identical with NetCurrent when building from source. -->
    <NetToolCurrent Condition="'$(DotNetBuildSourceOnly)' != 'true'">net10.0</NetToolCurrent>
    <NetToolCurrent Condition="'$(DotNetBuildSourceOnly)' == 'true'">$(NetCurrent)</NetToolCurrent>
    <!-- Lowest version of .NET at the time of the release of NetCurrent that is supported by tooling.
         Identical with NetToolCurrent when building from source. -->
    <NetToolMinimum Condition="'$(DotNetBuildFromSource)' != 'true' and '$(DotNetBuildSourceOnly)' != 'true'">net8.0</NetToolMinimum>
    <NetToolMinimum Condition="'$(DotNetBuildFromSource)' == 'true' or '$(DotNetBuildSourceOnly)' == 'true'">$(NetToolCurrent)</NetToolMinimum>
    <!-- The version of .NET Framework that tools (i.e. msbuild tasks) should target. -->
    <NetFrameworkToolCurrent>net472</NetFrameworkToolCurrent>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Settings.props
============================================================================================================================================
-->
  <!--<Import Project="Compiler.props" Condition="'$(UsingToolMicrosoftNetCompilers)' == 'true'" />-->
  <!--<Import Project="VisualStudio.props" Condition="'$(UsingToolVSSDK)' == 'true' and '$(MSBuildRuntimeType)' != 'Core'" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/sdk/Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\QuarantinedTests.AfterArcade.props">

/home/runner/work/aspnetcore/aspnetcore/eng/QuarantinedTests.AfterArcade.props
============================================================================================================================================
-->
  <!-- Override where xUnit logs and results go if we're doing the Quarantined run -->
  <PropertyGroup Condition="'$(RunQuarantinedTests)' == 'true'">
    <ArtifactsLogDir>$(ArtifactsDir)log\$(Configuration)\Quarantined\</ArtifactsLogDir>
    <ArtifactsTestResultsDir>$(ArtifactsDir)TestResults\$(Configuration)\Quarantined\</ArtifactsTestResultsDir>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\Common.props">

/home/runner/work/aspnetcore/aspnetcore/eng/Common.props
============================================================================================================================================
-->
  <PropertyGroup>
    <TargetOsName Condition=" '$(TargetOsName)' == '' AND $([MSBuild]::IsOSPlatform('Windows'))">win</TargetOsName>
    <TargetOsName Condition=" '$(TargetOsName)' == '' AND $([MSBuild]::IsOSPlatform('OSX'))">osx</TargetOsName>
    <TargetOsName Condition=" '$(TargetOsName)' == '' AND $([MSBuild]::IsOSPlatform('Linux'))">linux</TargetOsName>
    <TargetOsName Condition=" '$(TargetOsName)' == '' AND $([MSBuild]::IsOSPlatform('FreeBSD'))">freebsd</TargetOsName>
    <TargetArchitecture Condition="'$(TargetArchitecture)' == ''">x64</TargetArchitecture>
    <NativePlatform>$(TargetArchitecture)</NativePlatform>
    <NativePlatform Condition=" '$(NativePlatform)' == 'x86' ">Win32</NativePlatform>
    <TargetRuntimeIdentifier Condition="'$(TargetRuntimeIdentifier)' == ''">$(TargetOsName)-$(TargetArchitecture)</TargetRuntimeIdentifier>
    <PortableBuild Condition="'$(PortableBuild)' == ''">true</PortableBuild>
    <DefaultAppHostRuntimeIdentifier Condition="'$(DotNetBuild)' == 'true'">$(TargetRuntimeIdentifier)</DefaultAppHostRuntimeIdentifier>
    <BuildNodeJS>$(BuildNodeJSUnlessSourcebuild)</BuildNodeJS>
    <BuildNodeJS Condition="'$(DotNetBuildSourceOnly)' == 'true'">false</BuildNodeJS>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(BuildAllProjects)' == 'true' ">
    <!-- Ignore $(BuildNative) when using MSBuild Core, on non-Windows platforms, or when C++ bits are missing. -->
    <BuildNative Condition=" '$(MSBuildRuntimeType)' == 'Core' ">false</BuildNative>
    <BuildNative Condition=" '$(TargetOsName)' != 'win' ">false</BuildNative>
    <BuildNative Condition=" '$(VCTargetsPath)' == '' ">false</BuildNative>
    <BuildNative Condition=" '$(BuildNative)' == '' ">true</BuildNative>
    <BuildNodeJS Condition="'$(BuildNodeJS)' == ''">true</BuildNodeJS>
    <BuildManaged Condition="'$(BuildManaged)' == ''">true</BuildManaged>
    <BuildJava Condition="'$(BuildJava)' == ''">true</BuildJava>
  </PropertyGroup>
  <PropertyGroup>
    <BuildNative Condition=" '$(BuildNative)' == '' ">false</BuildNative>
  </PropertyGroup>
  <!-- Don't restore w/ nuget.targets in VMR pass 2 -->
  <!-- This allows us to hook targets before Restore in the SiteExtensions build -->
  <PropertyGroup Condition=" '$(DotNetBuildPass)' == '2' ">
    <RestoreUsingNuGetTargets>false</RestoreUsingNuGetTargets>
  </PropertyGroup>
  <PropertyGroup>
    <!--
      Some assets are produced in all jobs, but only one job can publish them. We follow the following rules in that case:
      - If we're building outside of the VMR, publish these assets from the Windows job.
      - If we're building inside the VMR, publish these assets from whichever job is producing non-RID-specific artifacts.
    -->
    <PublishAllBuildsAssetsInThisJob Condition="('$(OS)' == 'Windows_NT' and '$(DotNetBuildFromVMR)' != 'true')&#xA;                                                or ('$(DotNetBuildFromVMR)' == 'true' and '$(EnableDefaultRidSpecificArtifacts)' != 'true'&#xA;                                                    and ('$(DotNetBuildPass)' == '' or '$(DotNetBuildPass)' == '1'))">true</PublishAllBuildsAssetsInThisJob>
    <PublishInstallerBaseVersion Condition="'$(PublishInstallerBaseVersion)' == ''">$(PublishAllBuildsAssetsInThisJob)</PublishInstallerBaseVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <Product>Microsoft ASP.NET Core</Product>
    <StrongNameKeyId>MicrosoftAspNetCore</StrongNameKeyId>
    <!-- The SPDX name for the source license. See https://spdx.org/licenses/. -->
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <!-- Contact email address for NuGet packages and Linux installers. -->
    <MaintainerEmail>nugetaspnet@microsoft.com</MaintainerEmail>
    <PackageProjectUrl>https://asp.net</PackageProjectUrl>
    <NuspecBasePath>$(MSBuildProjectDirectory)</NuspecBasePath>
    <IncludeSymbols>true</IncludeSymbols>
    <DefaultNetFxTargetFramework>net462</DefaultNetFxTargetFramework>
    <!-- Current xunit.runner.visualstudio supports net472+/net8.0+ only. So we can't use net462 -->
    <DefaultNetFxTargetFramework Condition="'$(IsTestProject)'=='true'">net472</DefaultNetFxTargetFramework>
    <CrossgenOutput Condition="'$(DotNetBuildUseMonoRuntime)' == 'true'">false</CrossgenOutput>
  </PropertyGroup>
  <!-- Warnings and errors -->
  <PropertyGroup>
    <!-- Ensure API docs are available. -->
    <NoWarn>$(NoWarn.Replace('1591', ''))</NoWarn>
    <NoWarn Condition=" '$(BuildingInsideVisualStudio)' == 'true' ">$(NoWarn);0105</NoWarn>
    <!-- Allow prerelease dependencies in stable packages when we're running the IdentityModel nightly tests -->
    <NoWarn Condition=" '$(IsIdentityModelTestJob)' == 'true' ">$(NoWarn);NU5104</NoWarn>
    <!-- For local builds, don't make missing XML docs a fatal build error, but still surface so we have visibility into undocumented APIs. -->
    <WarningsNotAsErrors Condition=" '$(ContinuousIntegrationBuild)' != 'true' ">$(WarningsNotAsErrors);CS1591</WarningsNotAsErrors>
    <!-- xUnit1004 = warns about skipped tests. Make this a non-fatal build warning. -->
    <WarningsNotAsErrors>$(WarningsNotAsErrors);xUnit1004</WarningsNotAsErrors>
    <!-- don't warn about calling ConfigureAwait in test methods. we already commonly get off the xunit threads because they cause issues. -->
    <NoWarn>$(NoWarn);xUnit1030</NoWarn>
    <!-- don't warn about unnecessary trim warning suppressions. can be removed with preview 6. -->
    <NoWarn>$(NoWarn);IL2121</NoWarn>
    <!-- // Temporary diagnostic code from https://github.com/dotnet/extensions/pull/4130 for metrics APIs used in test. -->
    <NoWarn>$(NoWarn);TBD</NoWarn>
  </PropertyGroup>
  <!-- Source code settings -->
  <PropertyGroup>
    <SharedSourceRoot>$(MSBuildThisFileDirectory)src\Shared\</SharedSourceRoot>
    <GoogleTestSubmoduleRoot>$(RepoRoot)src\submodules\googletest\</GoogleTestSubmoduleRoot>
    <!-- Embed source files that are not tracked by the source control manager in the PDB. -->
    <EmbedUntrackedSources>true</EmbedUntrackedSources>
  </PropertyGroup>
  <PropertyGroup>
    <SharedFxName>Microsoft.AspNetCore.App</SharedFxName>
    <SharedFxDescription>Shared Framework for hosting of Microsoft ASP.NET Core applications. It is open source, cross-platform and is supported by Microsoft. We hope you enjoy using it! If you do, please consider joining the active community of developers that are contributing to the project on GitHub ($(RepositoryUrl)). We happily accept issues and PRs.</SharedFxDescription>
    <NETCoreAppFrameworkIdentifier>.NETCoreApp</NETCoreAppFrameworkIdentifier>
    <NETCoreAppFramework>netcoreapp$(AspNetCoreMajorMinorVersion)</NETCoreAppFramework>
    <AspNetCoreAppFrameworkBrandName>ASP.NET Core $(AspNetCoreMajorMinorVersion)</AspNetCoreAppFrameworkBrandName>
    <TargetingPackName>Microsoft.AspNetCore.App.Ref</TargetingPackName>
    <RuntimeInstallerBaseName>aspnetcore-runtime</RuntimeInstallerBaseName>
    <TargetingPackInstallerBaseName>aspnetcore-targeting-pack</TargetingPackInstallerBaseName>
  </PropertyGroup>
  <!-- Compilation options which apply to all languages. Language-specific options should be set in eng/targets/$(lang).Common.props -->
  <PropertyGroup>
    <BuildArchitecture>$([System.Runtime.InteropServices.RuntimeInformation]::ProcessArchitecture.ToString().ToLowerInvariant())</BuildArchitecture>
    <!-- This defines the list of RIDs supported by the ASP.NET Core shared framework.
         The list is a semicolon separated list of RIDs. Whitespace may not be added to the property. -->
    <SupportedRuntimeIdentifiers>win-x64;win-x86;win-arm;win-arm64;osx-x64;osx-arm64;linux-musl-x64;linux-musl-arm;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;freebsd-x64</SupportedRuntimeIdentifiers>
    <SupportedRuntimeIdentifiers Condition=" '$(DotNetBuildSourceOnly)' == 'true' ">$(SupportedRuntimeIdentifiers);$(TargetRuntimeIdentifier)</SupportedRuntimeIdentifiers>
    <!-- Playwright provides binaries for Windows (x86 and x64), macOS (x64) and Linux (x64, non musl). We can't use it on other architectures. -->
    <IsPlaywrightAvailable Condition="'$(TargetOsName)' == 'linux-musl' OR ('$(TargetArchitecture)' != 'x86' AND '$(TargetArchitecture)' != 'x64')">false</IsPlaywrightAvailable>
    <IsPlaywrightAvailable Condition="'$(IsPlaywrightAvailable)' == ''">true</IsPlaywrightAvailable>
    <!-- Make error messages clickable in VS Code's console -->
    <GenerateFullPaths Condition="'$(VSCODE_CWD)' != '' OR '$(TERM_PROGRAM)' == 'vscode'">true</GenerateFullPaths>
    <!-- Fixes a common error in targets implementing a NoBuild mode. -->
    <BuildProjectReferences Condition=" '$(NoBuild)' == 'true' ">false</BuildProjectReferences>
  </PropertyGroup>
  <!-- Artifacts layout. Keep these values consistent with items defined in eng/Publishing.props. -->
  <PropertyGroup>
    <InstallersOutputPath>$(ArtifactsDir)installers\$(Configuration)\</InstallersOutputPath>
    <SymbolsOutputPath>$(ArtifactsDir)symbols\$(Configuration)\</SymbolsOutputPath>
  </PropertyGroup>
  <!-- Ensure these output paths exist. -->
  <ItemGroup>
    <CreateDirectory Include="$(InstallersOutputPath)" />
    <CreateDirectory Include="$(VisualStudioSetupOutputPath)" />
  </ItemGroup>
  <!-- The location of the local installation of the .NET Core shared framework. -->
  <PropertyGroup>
    <LocalDotNetRoot>$(RepoRoot).dotnet\</LocalDotNetRoot>
    <LocalDotNetRoot Condition="'$(DotNetBuild)' == 'true'">DontDareMutateThisSDK</LocalDotNetRoot>
    <!--
      Override the SDK default and point to local .dotnet folder. This is done to work around
      limitations in the way the .NET SDK finds shared frameworks and targeting packs. It allows
      tests to use the shared frameworks and targeting packs that were just built.

      However, the VMR needs this to not happen while building projects that rely on the
      AppHost framework pack. The VMR installs an SDK in a custom location outside this
      repository, and setting NetCoreTargetingPackRoot to a different location causes source-build
      to restore the AppHost pack as a prebuilt rather than using the one that's present in the SDK.
      The dotnet product build doesn't run tests, so the property is simply conditioned out.
    -->
    <NetCoreTargetingPackRoot Condition="'$(DotNetBuild)' != 'true'">$(LocalDotNetRoot)packs\</NetCoreTargetingPackRoot>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="eng\tools\RepoTasks\RepoTasks.tasks" Condition="'$(MSBuildProjectName)' != 'RepoTasks' AND '$(DesignTimeBuild)' != 'true'">

/home/runner/work/aspnetcore/aspnetcore/eng/tools/RepoTasks/RepoTasks.tasks
============================================================================================================================================
-->
  <PropertyGroup>
    <_RepoTaskAssemblyFolder Condition="'$(MSBuildRuntimeType)' == 'core'">$(DefaultNetCoreTargetFramework)</_RepoTaskAssemblyFolder>
    <_RepoTaskAssemblyFolder Condition="'$(MSBuildRuntimeType)' != 'core'">net472</_RepoTaskAssemblyFolder>
    <_RepoTaskAssembly>$(ArtifactsBinDir)RepoTasks\Release\$(_RepoTaskAssemblyFolder)\RepoTasks.dll</_RepoTaskAssembly>
  </PropertyGroup>
  <UsingTask TaskName="RepoTasks.GenerateGuid" AssemblyFile="$(_RepoTaskAssembly)" Condition="'$(MSBuildRuntimeType)' != 'core'" />
  <UsingTask TaskName="RepoTasks.GetMsiProperty" AssemblyFile="$(_RepoTaskAssembly)" Condition="'$(MSBuildRuntimeType)' != 'core'" />
  <UsingTask TaskName="RepoTasks.GenerateSharedFrameworkDepsFile" AssemblyFile="$(_RepoTaskAssembly)" />
  <UsingTask TaskName="RepoTasks.CreateFrameworkListFile" AssemblyFile="$(_RepoTaskAssembly)" />
  <UsingTask TaskName="RepoTasks.RemoveSharedFrameworkDependencies" AssemblyFile="$(_RepoTaskAssembly)" />
  <UsingTask TaskName="RepoTasks.GenerateTestDevCert" AssemblyFile="$(_RepoTaskAssembly)" />
  <UsingTask TaskName="DownloadFile" AssemblyFile="$(ArcadeSdkBuildTasksAssembly)" />
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <!--
      Disable deterministic source paths in test assets and samples.
      In order for the debugger to find source files when debugging a locally built binary the PDB must contain original, unmapped local paths
    -->
    <DeterministicSourcePaths Condition="'$(IsSampleProject)' == 'true' OR '$(IsTestAssetProject)' == 'true'">false</DeterministicSourcePaths>
    <!-- Projects which reference Microsoft.AspNetCore.Mvc.Testing should import this targets file to ensure dependency .deps.json files are copied into test output. -->
    <MvcTestingTargets>$(MSBuildThisFileDirectory)src\Mvc\Mvc.Testing\src\Microsoft.AspNetCore.Mvc.Testing.targets</MvcTestingTargets>
    <_MvcTestingTasksAssembly>$(ArtifactsBinDir)\Microsoft.AspNetCore.Mvc.Testing.Tasks\$(Configuration)\netstandard2.0\Microsoft.AspNetCore.Mvc.Testing.Tasks.dll</_MvcTestingTasksAssembly>
    <!-- IIS native projects can only be built on Windows for x86/x64/ARM64. -->
    <UseIisNativeAssets Condition=" '$(TargetOsName)' == 'win' AND ('$(TargetArchitecture)' == 'x86' OR '$(TargetArchitecture)' == 'x64' OR '$(TargetArchitecture)' == 'ARM64') ">true</UseIisNativeAssets>
    <!-- This property is shared by several projects to layout the AspNetCore.App targeting pack for installers -->
    <TargetingPackLayoutRoot>$(ArtifactsObjDir)TargetingPack.Layout\$(Configuration)\</TargetingPackLayoutRoot>
    <!-- This property is shared by several projects to layout the AspNetCore.App shared framework for installers -->
    <SharedFrameworkLayoutRoot>$(ArtifactsObjDir)SharedFx.Layout\$(Configuration)\$(TargetRuntimeIdentifier)\</SharedFrameworkLayoutRoot>
    <!-- This property points to a folder which includes both Microsoft.NETCore.App and AspNetCore.App. -->
    <RedistSharedFrameworkLayoutRoot>$(ArtifactsObjDir)RedistSharedFx.Layout\$(Configuration)\$(TargetRuntimeIdentifier)\</RedistSharedFrameworkLayoutRoot>
    <ArchiveExtension>.tar.gz</ArchiveExtension>
    <ArchiveExtension Condition="'$(TargetOsName)' == 'win'">.zip</ArchiveExtension>
  </PropertyGroup>
  <PropertyGroup>
    <OfficialBaseURL>https://builds.dotnet.microsoft.com/dotnet/</OfficialBaseURL>
    <!-- Allow overriding the public base URL for Unified Build scenarios to pull assets from a local build. -->
    <PublicBaseURL Condition="'$(PublicBaseURL)' == ''">https://ci.dot.net/public/</PublicBaseURL>
    <InternalBaseURL>https://ci.dot.net/internal/</InternalBaseURL>
    <!-- Allow overriding where installers are pulled in from previously completed jobs in Unified Build scenarios. -->
    <AddVersionToCrossArchitectureInstallerBasePath Condition="'$(CrossArchitectureInstallerBasePath)' != ''">true</AddVersionToCrossArchitectureInstallerBasePath>
    <CrossArchitectureInstallerBasePath Condition="'$(CrossArchitectureInstallerBasePath)' == ''">$(ArtifactsShippingPackagesDir)</CrossArchitectureInstallerBasePath>
  </PropertyGroup>
  <!-- Try various places to find the runtime. It's either released (use official version),
        public but un-released (use dotnetbuilds/public), or internal and unreleased (use dotnetbuilds/internal) -->
  <ItemGroup Condition="'$(DotNetBuild)' != 'true'">
    <RemoteAssetBaseURL Include="$(OfficialBaseURL)" />
    <RemoteAssetBaseURL Include="$(PublicBaseURL)" />
    <!-- Include the token here as we'll generate the URLs to download based on this item group. -->
    <RemoteAssetBaseURL Include="$(InternalBaseURL)" Condition=" '$(DotnetRuntimeSourceFeedKey)' != '' ">
      <token>$(DotnetRuntimeSourceFeedKey)</token>
    </RemoteAssetBaseURL>
  </ItemGroup>
  <!--
    Only try downloading from the "public" base URL when doing a vertical build.
    In a vertical build, the public URL will be overwritten to point to local build artifacts.
  -->
  <ItemGroup Condition="'$(DotNetBuild)' == 'true'">
    <!-- MSBuild removes the '//' slashes when passing PublicBaseURL from the outer to the inner build. -->
    <RemoteAssetBaseURL Condition="$(PublicBaseURL.StartsWith('file:')) and '$(OS)' != 'Windows_NT'" Include="$([System.Text.RegularExpressions.Regex]::Replace('$(PublicBaseURL)', '%28file:\/{1,}%29%28.+%29', 'file:///%242'))" />
    <RemoteAssetBaseURL Condition="!$(PublicBaseURL.StartsWith('file:')) or '$(OS)' == 'Windows_NT'" Include="$(PublicBaseURL)" />
  </ItemGroup>
  <PropertyGroup>
    <!-- PackageReadmeFile specifies the package readme file name in the package. PackageReadmeFilePath points to the package readme file on disk. -->
    <EnableDefaultPackageReadmeFile Condition="'$(EnableDefaultPackageReadmeFile)' == '' and '$(IsShipping)' != 'false'">true</EnableDefaultPackageReadmeFile>
    <PackageReadmeFilePath Condition="'$(PackageReadmeFilePath)' == '' and '$(EnableDefaultPackageReadmeFile)' == 'true'">PACKAGE.md</PackageReadmeFilePath>
    <PackageReadmeFile Condition="'$(PackageReadmeFile)' == '' and '$(EnableDefaultPackageReadmeFile)' == 'true' and Exists('$(PackageReadmeFilePath)' )">PACKAGE.md</PackageReadmeFile>
  </PropertyGroup>
  <!-- Add a package README file -->
  <ItemGroup Condition="'$(PackageReadmeFilePath)' != '' and Exists('$(PackageReadmeFilePath)' )">
    <None Include="$(PackageReadmeFilePath)" Pack="true" PackagePath="\" />
  </ItemGroup>
  <PropertyGroup>
    <!-- Set the before common targets so we compute ExcludeFromBuild before arcade uses it. -->
    <CustomBeforeMicrosoftCommonTargets>$(MSBuildThisFileDirectory)Directory.Build.BeforeCommonTargets.targets;$(CustomBeforeMicrosoftCommonTargets)</CustomBeforeMicrosoftCommonTargets>
    <CustomBeforeMicrosoftCommonCrossTargetingTargets>$(MSBuildThisFileDirectory)Directory.Build.BeforeCommonTargets.targets;$(CustomBeforeMicrosoftCommonCrossTargetingTargets)</CustomBeforeMicrosoftCommonCrossTargetingTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="eng\Workarounds.props">

/home/runner/work/aspnetcore/aspnetcore/eng/Workarounds.props
============================================================================================================================================
-->
  <!-- Use this file to workaround issues. List the issue tracking the item to fix so we can remove the workaround when the issue is resolved. -->
  <PropertyGroup>
    <!-- Reset this to the Microsoft.NET.Sdk default to workaround Arcade's defaults, which sets IsPackable=false by default. -->
    <IsPackable />
    <!-- Ensure symbols type is 'portable'. Arcade attempts to embed symbols in local and CI builds. -->
    <DebugType>portable</DebugType>
  </PropertyGroup>
  <!-- Prevent pdb2pdb.exe from running because it is currently causing build failures in Blazor. -->
  <PropertyGroup>
    <PublishWindowsPdb>false</PublishWindowsPdb>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseVSTestRunner)' != 'true'">
    <!-- Xunit output is piped into a file anyways, so color codes aren't useful. -->
    <TestRunnerAdditionalArguments>$(TestRunnerAdditionalArguments) -nocolor</TestRunnerAdditionalArguments>
  </PropertyGroup>
  <!-- Workaround https://github.com/dotnet/roslyn/issues/27975 -->
  <PropertyGroup>
    <!-- We use the compiler toolset that comes from NuGet Packages rather than the SDK built-in.
    This one sets UseSharedCompilation to false by default. -->
    <UseSharedCompilation>true</UseSharedCompilation>
  </PropertyGroup>
  <!-- Workaround continued use of netcoreapp2.1. -->
  <PropertyGroup>
    <NoWarn>$(NoWarn);NETSDK1138;CS8969</NoWarn>
  </PropertyGroup>
  <!-- Workaround obsolete X509Certificate ctor: https://github.com/dotnet/docs/issues/41662 -->
  <PropertyGroup>
    <NoWarn>$(NoWarn);SYSLIB0057</NoWarn>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Ignore warning about calling the Pack target on Web SDK projects. Our build scripts call /t:pack on everything in this repo. -->
    <WarnOnPackingNonPackableProject>false</WarnOnPackingNonPackableProject>
  </PropertyGroup>
  <!-- The SDK includes some conflict resolution targets that check for duplicate items in the publish targets. It's very greedy
       and ends up marking the same files in different projects as duplicates of each other. We disable this check here to work
       around this issue. -->
  <PropertyGroup>
    <ErrorOnDuplicatePublishOutputFiles>false</ErrorOnDuplicatePublishOutputFiles>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="artifacts\bin\GenerateFiles\Directory.Build.props" Condition=" '$(MSBuildProjectName)' != 'GenerateFiles' ">

/home/runner/work/aspnetcore/aspnetcore/artifacts/bin/GenerateFiles/Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <DefaultNetCoreTargetFramework>net10.0</DefaultNetCoreTargetFramework>
    <ArtifactsShippingPackagesDir>/home/runner/work/aspnetcore/aspnetcore/artifacts/packages/Debug/Shipping/</ArtifactsShippingPackagesDir>
    <TreatWarningsAsErrors Condition="'$(BuildingInsideVisualStudio)' != 'true'">true</TreatWarningsAsErrors>
    <LibNetHostAppPackVersion Condition=" '$(LibNetHostAppPackVersion)' == '' ">10.0.0-preview.7.25322.101</LibNetHostAppPackVersion>
    <!-- Temporarily hardcoded to true -->
    <SuppressGenerateILCompilerExplicitPackageReferenceWarning>true</SuppressGenerateILCompilerExplicitPackageReferenceWarning>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\Dependencies.props">

/home/runner/work/aspnetcore/aspnetcore/eng/Dependencies.props
============================================================================================================================================
-->
  <!--

This file contains a list of all the external dependencies used in ASP.NET Core. These dependencies
are expressed as `<LatestPackageReference>`. These are used as inputs reference resolution, and
may be turned into `<PackageReference>` items in projects.

`<BaselinePackageReference>` items should not be in this file. Those items appear in Baseline.Designer.props
and are generated based on the last package release.
-->
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>
  <ItemGroup Label=".NET team dependencies">
    <LatestPackageReference Include="Microsoft.AspNetCore.Razor.Language" />
    <LatestPackageReference Include="Microsoft.AspNetCore.Mvc.Razor.Extensions" />
    <LatestPackageReference Include="Microsoft.Azure.SignalR" />
    <LatestPackageReference Include="Microsoft.Bcl.HashCode" />
    <LatestPackageReference Include="Microsoft.Bcl.TimeProvider" />
    <LatestPackageReference Include="Microsoft.Css.Parser" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.Common" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.CSharp.Workspaces" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.CSharp" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.ExternalAccess.AspNetCore" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.Razor" />
    <LatestPackageReference Include="Microsoft.CSharp" />
    <LatestPackageReference Include="Microsoft.Extensions.Caching.Abstractions" />
    <LatestPackageReference Include="Microsoft.Extensions.Caching.Memory" />
    <LatestPackageReference Include="Microsoft.Extensions.Caching.Hybrid" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.Abstractions" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.Binder" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.CommandLine" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.FileExtensions" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.Ini" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.Json" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.UserSecrets" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration.Xml" />
    <LatestPackageReference Include="Microsoft.Extensions.Configuration" />
    <LatestPackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" />
    <LatestPackageReference Include="Microsoft.Extensions.DependencyInjection" />
    <LatestPackageReference Include="Microsoft.Extensions.DependencyModel" />
    <LatestPackageReference Include="Microsoft.Extensions.DiagnosticAdapter" />
    <LatestPackageReference Include="Microsoft.Extensions.Diagnostics.Abstractions" />
    <LatestPackageReference Include="Microsoft.Extensions.Diagnostics" />
    <LatestPackageReference Include="Microsoft.Extensions.FileProviders.Abstractions" />
    <LatestPackageReference Include="Microsoft.Extensions.FileProviders.Composite" />
    <LatestPackageReference Include="Microsoft.Extensions.FileProviders.Physical" />
    <LatestPackageReference Include="Microsoft.Extensions.FileSystemGlobbing" />
    <LatestPackageReference Include="Microsoft.Extensions.HostFactoryResolver.Sources" />
    <LatestPackageReference Include="Microsoft.Extensions.Hosting.Abstractions" />
    <LatestPackageReference Include="Microsoft.Extensions.Hosting" />
    <LatestPackageReference Include="Microsoft.Extensions.Http" />
    <LatestPackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
    <LatestPackageReference Include="Microsoft.Extensions.Logging.Configuration" />
    <LatestPackageReference Include="Microsoft.Extensions.Logging.Console" />
    <LatestPackageReference Include="Microsoft.Extensions.Logging.Debug" />
    <LatestPackageReference Include="Microsoft.Extensions.Logging.EventSource" />
    <LatestPackageReference Include="Microsoft.Extensions.Logging.EventLog" />
    <LatestPackageReference Include="Microsoft.Extensions.Logging.TraceSource" />
    <LatestPackageReference Include="Microsoft.Extensions.Logging" />
    <LatestPackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" />
    <LatestPackageReference Include="Microsoft.Extensions.Options.DataAnnotations" />
    <LatestPackageReference Include="Microsoft.Extensions.Options" />
    <LatestPackageReference Include="Microsoft.Extensions.Primitives" />
    <LatestPackageReference Include="Microsoft.Extensions.Diagnostics.Testing" />
    <LatestPackageReference Include="Microsoft.Extensions.TimeProvider.Testing" />
    <LatestPackageReference Include="Microsoft.Win32.Registry" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.CSharp.Analyzer.Testing" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.CSharp.CodeFix.Testing" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.CSharp.SourceGenerators.Testing" />
    <LatestPackageReference Include="Microsoft.OpenApi" />
    <LatestPackageReference Include="Microsoft.OpenApi.YamlReader" />
    <LatestPackageReference Include="System.Buffers" />
    <LatestPackageReference Include="System.CodeDom" />
    <LatestPackageReference Include="System.CommandLine.Experimental" />
    <LatestPackageReference Include="System.ComponentModel" />
    <LatestPackageReference Include="System.ComponentModel.Annotations" />
    <LatestPackageReference Include="System.Configuration.ConfigurationManager" />
    <LatestPackageReference Include="System.Diagnostics.DiagnosticSource" />
    <LatestPackageReference Include="System.Diagnostics.EventLog" />
    <LatestPackageReference Include="System.DirectoryServices.Protocols" />
    <LatestPackageReference Include="System.Formats.Cbor" />
    <LatestPackageReference Include="System.IdentityModel.Tokens.Jwt" />
    <LatestPackageReference Include="System.IO.Pipelines" />
    <LatestPackageReference Include="System.Memory" />
    <LatestPackageReference Include="System.Net.Http" />
    <LatestPackageReference Include="System.Net.Http.Json" />
    <LatestPackageReference Include="System.Net.Sockets" />
    <LatestPackageReference Include="System.Net.ServerSentEvents" />
    <LatestPackageReference Include="System.Reflection.Metadata" />
    <LatestPackageReference Include="System.Runtime.InteropServices.RuntimeInformation" />
    <LatestPackageReference Include="System.Runtime.Caching" />
    <LatestPackageReference Include="System.Security.Cryptography.Pkcs" />
    <LatestPackageReference Include="System.Security.Cryptography.X509Certificates" />
    <LatestPackageReference Include="System.Security.Cryptography.Xml" />
    <LatestPackageReference Include="System.Security.Permissions" />
    <LatestPackageReference Include="System.Security.Principal.Windows" />
    <LatestPackageReference Include="System.Text.Encodings.Web" />
    <LatestPackageReference Include="System.Text.Json" />
    <LatestPackageReference Include="System.Threading.AccessControl" />
    <LatestPackageReference Include="System.Threading.Channels" />
    <LatestPackageReference Include="System.Threading.RateLimiting" />
    <LatestPackageReference Include="System.ValueTuple" />
    <!-- Runtime packages required for crossgen -->
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.win-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.win-x86" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.win-arm" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.win-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.osx-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.osx-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.linux-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.linux-arm" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.linux-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.linux-musl-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.linux-musl-arm" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.linux-musl-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.freebsd-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.freebsd-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Runtime.$(TargetRuntimeIdentifier)" Condition=" '$(DotNetBuildSourceOnly)' == 'true'" />
    <!-- Crossgen2 compiler -->
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.win-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.win-x86" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.win-arm" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.win-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.osx-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.osx-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.linux-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.linux-arm" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.linux-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.linux-musl-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.linux-musl-arm" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.linux-musl-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.freebsd-x64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.freebsd-arm64" />
    <_LatestRuntimePackageReference Include="Microsoft.NETCore.App.Crossgen2.$(TargetRuntimeIdentifier)" Condition=" '$(DotNetBuildSourceOnly)' == 'true' " />
    <!-- Remove duplicates potentially introduced by the 'unknown' target runtime identifier in source-only modes. -->
    <LatestPackageReference Include="@(_LatestRuntimePackageReference-&gt;Distinct())" />
  </ItemGroup>
  <ItemGroup Label=".NET team dependencies (Non-source-build)" Condition="'$(DotNetBuildSourceOnly)' != 'true'">
    <LatestPackageReference Include="Microsoft.AspNet.WebApi.Client" />
    <LatestPackageReference Include="Microsoft.AspNetCore.AzureAppServices.SiteExtension.8.0.x64" />
    <LatestPackageReference Include="Microsoft.AspNetCore.AzureAppServices.SiteExtension.8.0.x86" />
    <LatestPackageReference Include="Microsoft.AspNetCore.AzureAppServices.SiteExtension.9.0.x64" />
    <LatestPackageReference Include="Microsoft.AspNetCore.AzureAppServices.SiteExtension.9.0.x86" />
    <LatestPackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Runtime" />
    <LatestPackageReference Include="Microsoft.Internal.Runtime.AspNetCore.Transport" />
    <LatestPackageReference Include="Microsoft.Bcl.AsyncInterfaces" />
    <LatestPackageReference Include="Microsoft.CodeAnalysis.PublicApiAnalyzers" />
    <LatestPackageReference Include="Microsoft.DotNet.RemoteExecutor" />
    <LatestPackageReference Include="Microsoft.EntityFrameworkCore.Design" />
    <LatestPackageReference Include="Microsoft.EntityFrameworkCore.InMemory" />
    <LatestPackageReference Include="Microsoft.EntityFrameworkCore.Relational" />
    <LatestPackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" />
    <LatestPackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" />
    <LatestPackageReference Include="Microsoft.EntityFrameworkCore.Tools" />
    <LatestPackageReference Include="Microsoft.EntityFrameworkCore" />
    <LatestPackageReference Include="Microsoft.Extensions.Caching.SqlServer" />
    <LatestPackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" />
    <LatestPackageReference Include="Microsoft.IdentityModel.Protocols.OpenIdConnect" />
    <LatestPackageReference Include="Microsoft.IdentityModel.Protocols.WsFederation" />
    <LatestPackageReference Include="Microsoft.Internal.AspNetCore.H2Spec.All" />
    <LatestPackageReference Include="Microsoft.NETCore.Windows.ApiSets" />
    <LatestPackageReference Include="Microsoft.NETCore.BrowserDebugHost.Transport" />
    <LatestPackageReference Include="Microsoft.Owin.Security.Cookies" />
    <LatestPackageReference Include="Microsoft.Owin.Testing" />
    <LatestPackageReference Include="Microsoft.Web.Administration" />
    <LatestPackageReference Include="Microsoft.Web.Xdt" />
    <LatestPackageReference Include="NETStandard.Library" />
    <LatestPackageReference Include="System.Net.Experimental.MsQuic" />
    <LatestPackageReference Include="System.Net.Http.WinHttpHandler" />
    <LatestPackageReference Include="System.ServiceProcess.ServiceController" />
    <LatestPackageReference Include="System.Threading.Tasks.Extensions" />
  </ItemGroup>
  <ItemGroup Label="MSBuild">
    <LatestPackageReference Include="Microsoft.Build" />
    <LatestPackageReference Include="Microsoft.Build.Framework" />
    <LatestPackageReference Include="Microsoft.Build.Locator" />
    <LatestPackageReference Include="Microsoft.Build.Utilities.Core" />
  </ItemGroup>
  <ItemGroup Label="External dependencies available in source build">
    <LatestPackageReference Include="Newtonsoft.Json" />
  </ItemGroup>
  <ItemGroup Label="External dependencies" Condition="'$(DotNetBuildSourceOnly)' != 'true'">
    <LatestPackageReference Include="AngleSharp" />
    <LatestPackageReference Include="Azure.Identity" />
    <LatestPackageReference Include="BenchmarkDotNet" />
    <LatestPackageReference Include="CommandLineParser" />
    <LatestPackageReference Include="FSharp.Core" />
    <LatestPackageReference Include="Google.Api.CommonProtos" />
    <LatestPackageReference Include="Google.Protobuf" />
    <LatestPackageReference Include="Grpc.AspNetCore" />
    <LatestPackageReference Include="Grpc.AspNetCore.Server" />
    <LatestPackageReference Include="Grpc.Auth" />
    <LatestPackageReference Include="Grpc.Net.Client" />
    <LatestPackageReference Include="Grpc.Tools" />
    <LatestPackageReference Include="MessagePack" />
    <LatestPackageReference Include="MessagePackAnalyzer" />
    <LatestPackageReference Include="Microsoft.Data.SqlClient" />
    <LatestPackageReference Include="Microsoft.Windows.CsWin32" />
    <LatestPackageReference Include="Mono.Cecil" />
    <LatestPackageReference Include="Mono.TextTemplating" />
    <LatestPackageReference Include="Moq" />
    <LatestPackageReference Include="Newtonsoft.Json.Bson" />
    <LatestPackageReference Include="NSwag.ApiDescription.Client" />
    <LatestPackageReference Include="NuGet.Frameworks" />
    <LatestPackageReference Include="NuGet.Versioning" />
    <LatestPackageReference Include="Photino.NET" />
    <LatestPackageReference Include="Microsoft.Playwright" />
    <LatestPackageReference Include="Polly" />
    <LatestPackageReference Include="Polly.Extensions.Http" />
    <LatestPackageReference Include="Selenium.Support" />
    <LatestPackageReference Include="Selenium.WebDriver" />
    <LatestPackageReference Include="Selenium.WebDriver.ChromeDriver" />
    <LatestPackageReference Include="Serilog.Extensions.Logging" />
    <LatestPackageReference Include="Serilog.Sinks.File" />
    <LatestPackageReference Include="StackExchange.Redis" />
    <LatestPackageReference Include="Swashbuckle.AspNetCore" />
    <LatestPackageReference Include="System.Reactive.Linq" />
    <LatestPackageReference Include="Verify.SourceGenerators" />
    <LatestPackageReference Include="Verify.Xunit" />
    <LatestPackageReference Include="xunit.abstractions" />
    <LatestPackageReference Include="xunit.analyzers" />
    <LatestPackageReference Include="xunit.assert" />
    <LatestPackageReference Include="xunit.extensibility.core" />
    <LatestPackageReference Include="xunit.extensibility.execution" />
  </ItemGroup>
  <ItemGroup Label="Dependencies with versions.">
    <!-- Get name prefixes for version properties. -->
    <LatestPackageReference Update="@(LatestPackageReference)">
      <VersionName>$([System.String]::new('%(Identity)').Replace('.',''))</VersionName>
    </LatestPackageReference>
    <!-- Get versions. -->
    <LatestPackageReference Update="@(LatestPackageReference)">
      <Version>$(%(VersionName)Version)</Version>
      <!-- Remove excess metadata. -->
      <VersionName />
    </LatestPackageReference>
    <!--
      Special case RID-specific Microsoft.NETCore.App.Runtime dependencies to ease new RID additions. Map from a
      single property to Version metadata for all RIDs.
    -->
    <LatestPackageReference Update="@(LatestPackageReference-&gt;WithMetadataValue('Version', ''))">
      <Version Condition=" $([System.String]::new('%(Identity)').StartsWith('Microsoft.NETCore.App.Runtime.')) or $([System.String]::new('%(Identity)').StartsWith('Microsoft.NETCore.App.Crossgen2.'))">$(MicrosoftNETCoreAppRefVersion)</Version>
    </LatestPackageReference>
  </ItemGroup>
  <!-- Replicates the same overriding of versions that occurs on Roslyn package versions for source only builds -->
  <ItemGroup Label="Source only build overrides" Condition="'$(DotNetBuildSourceOnly)' == 'true'">
    <LatestPackageReference Update="Microsoft.CodeAnalysis.Common">
      <Version>$(MicrosoftCodeAnalysisVersion_LatestVS)</Version>
    </LatestPackageReference>
    <LatestPackageReference Update="Microsoft.CodeAnalysis.CSharp">
      <Version>$(MicrosoftCodeAnalysisVersion_LatestVS)</Version>
    </LatestPackageReference>
    <LatestPackageReference Update="Microsoft.CodeAnalysis.CSharp.Workspaces">
      <Version>$(MicrosoftCodeAnalysisVersion_LatestVS)</Version>
    </LatestPackageReference>
    <LatestPackageReference Update="Microsoft.CodeAnalysis.ExternalAccess.AspNetCore">
      <Version>$(MicrosoftCodeAnalysisVersion_LatestVS)</Version>
    </LatestPackageReference>
    <LatestPackageReference Update="Microsoft.CodeAnalysis.Razor">
      <Version>$(MicrosoftCodeAnalysisVersion_LatestVS)</Version>
    </LatestPackageReference>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\ProjectReferences.props">

/home/runner/work/aspnetcore/aspnetcore/eng/ProjectReferences.props
============================================================================================================================================
-->
  <!--
  This file is automatically generated. Run `./eng/scripts/GenerateProjectList.ps1` to update.

  This file contains a map of assembly names to the projects that build them.
-->
  <ItemGroup>
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.App.Internal.Assets" ProjectPath="$(RepoRoot)src\Assets\Microsoft.AspNetCore.App.Internal.Assets.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Caching.SqlServer" ProjectPath="$(RepoRoot)src\Caching\SqlServer\src\Microsoft.Extensions.Caching.SqlServer.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Caching.StackExchangeRedis" ProjectPath="$(RepoRoot)src\Caching\StackExchangeRedis\src\Microsoft.Extensions.Caching.StackExchangeRedis.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore" ProjectPath="$(RepoRoot)src\DefaultBuilder\src\Microsoft.AspNetCore.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.JsonPatch.SystemTextJson" ProjectPath="$(RepoRoot)src\Features\JsonPatch.SystemTextJson\src\Microsoft.AspNetCore.JsonPatch.SystemTextJson.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.JsonPatch" ProjectPath="$(RepoRoot)src\Features\JsonPatch\src\Microsoft.AspNetCore.JsonPatch.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.DataProtection.Abstractions" ProjectPath="$(RepoRoot)src\DataProtection\Abstractions\src\Microsoft.AspNetCore.DataProtection.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Cryptography.Internal" ProjectPath="$(RepoRoot)src\DataProtection\Cryptography.Internal\src\Microsoft.AspNetCore.Cryptography.Internal.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Cryptography.KeyDerivation" ProjectPath="$(RepoRoot)src\DataProtection\Cryptography.KeyDerivation\src\Microsoft.AspNetCore.Cryptography.KeyDerivation.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.DataProtection" ProjectPath="$(RepoRoot)src\DataProtection\DataProtection\src\Microsoft.AspNetCore.DataProtection.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.DataProtection.EntityFrameworkCore" ProjectPath="$(RepoRoot)src\DataProtection\EntityFrameworkCore\src\Microsoft.AspNetCore.DataProtection.EntityFrameworkCore.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.DataProtection.Extensions" ProjectPath="$(RepoRoot)src\DataProtection\Extensions\src\Microsoft.AspNetCore.DataProtection.Extensions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.DataProtection.StackExchangeRedis" ProjectPath="$(RepoRoot)src\DataProtection\StackExchangeRedis\src\Microsoft.AspNetCore.DataProtection.StackExchangeRedis.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Antiforgery" ProjectPath="$(RepoRoot)src\Antiforgery\src\Microsoft.AspNetCore.Antiforgery.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Hosting.Abstractions" ProjectPath="$(RepoRoot)src\Hosting\Abstractions\src\Microsoft.AspNetCore.Hosting.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Hosting" ProjectPath="$(RepoRoot)src\Hosting\Hosting\src\Microsoft.AspNetCore.Hosting.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Hosting.Server.Abstractions" ProjectPath="$(RepoRoot)src\Hosting\Server.Abstractions\src\Microsoft.AspNetCore.Hosting.Server.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.TestHost" ProjectPath="$(RepoRoot)src\Hosting\TestHost\src\Microsoft.AspNetCore.TestHost.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Hosting.WindowsServices" ProjectPath="$(RepoRoot)src\Hosting\WindowsServices\src\Microsoft.AspNetCore.Hosting.WindowsServices.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.Abstractions" ProjectPath="$(RepoRoot)src\Http\Authentication.Abstractions\src\Microsoft.AspNetCore.Authentication.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.Core" ProjectPath="$(RepoRoot)src\Http\Authentication.Core\src\Microsoft.AspNetCore.Authentication.Core.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Net.Http.Headers" ProjectPath="$(RepoRoot)src\Http\Headers\src\Microsoft.Net.Http.Headers.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Http.Abstractions" ProjectPath="$(RepoRoot)src\Http\Http.Abstractions\src\Microsoft.AspNetCore.Http.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Http.Extensions" ProjectPath="$(RepoRoot)src\Http\Http.Extensions\src\Microsoft.AspNetCore.Http.Extensions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Http.Features" ProjectPath="$(RepoRoot)src\Http\Http.Features\src\Microsoft.AspNetCore.Http.Features.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Http.Results" ProjectPath="$(RepoRoot)src\Http\Http.Results\src\Microsoft.AspNetCore.Http.Results.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Http" ProjectPath="$(RepoRoot)src\Http\Http\src\Microsoft.AspNetCore.Http.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Metadata" ProjectPath="$(RepoRoot)src\Http\Metadata\src\Microsoft.AspNetCore.Metadata.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Owin" ProjectPath="$(RepoRoot)src\Http\Owin\src\Microsoft.AspNetCore.Owin.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Routing.Abstractions" ProjectPath="$(RepoRoot)src\Http\Routing.Abstractions\src\Microsoft.AspNetCore.Routing.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Routing" ProjectPath="$(RepoRoot)src\Http\Routing\src\Microsoft.AspNetCore.Routing.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.WebUtilities" ProjectPath="$(RepoRoot)src\Http\WebUtilities\src\Microsoft.AspNetCore.WebUtilities.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Http.Polly" ProjectPath="$(RepoRoot)src\HttpClientFactory\Polly\src\Microsoft.Extensions.Http.Polly.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Html.Abstractions" ProjectPath="$(RepoRoot)src\Html.Abstractions\src\Microsoft.AspNetCore.Html.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Identity" ProjectPath="$(RepoRoot)src\Identity\Core\src\Microsoft.AspNetCore.Identity.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Identity.EntityFrameworkCore" ProjectPath="$(RepoRoot)src\Identity\EntityFrameworkCore\src\Microsoft.AspNetCore.Identity.EntityFrameworkCore.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Identity.Core" ProjectPath="$(RepoRoot)src\Identity\Extensions.Core\src\Microsoft.Extensions.Identity.Core.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Identity.Stores" ProjectPath="$(RepoRoot)src\Identity\Extensions.Stores\src\Microsoft.Extensions.Identity.Stores.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Identity.Specification.Tests" ProjectPath="$(RepoRoot)src\Identity\Specification.Tests\src\Microsoft.AspNetCore.Identity.Specification.Tests.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Identity.UI" ProjectPath="$(RepoRoot)src\Identity\UI\src\Microsoft.AspNetCore.Identity.UI.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Connections.Abstractions" ProjectPath="$(RepoRoot)src\Servers\Connections.Abstractions\src\Microsoft.AspNetCore.Connections.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Server.HttpSys" ProjectPath="$(RepoRoot)src\Servers\HttpSys\src\Microsoft.AspNetCore.Server.HttpSys.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Server.IISIntegration" ProjectPath="$(RepoRoot)src\Servers\IIS\IISIntegration\src\Microsoft.AspNetCore.Server.IISIntegration.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Server.IIS" ProjectPath="$(RepoRoot)src\Servers\IIS\IIS\src\Microsoft.AspNetCore.Server.IIS.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Server.Kestrel.Core" ProjectPath="$(RepoRoot)src\Servers\Kestrel\Core\src\Microsoft.AspNetCore.Server.Kestrel.Core.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Server.Kestrel" ProjectPath="$(RepoRoot)src\Servers\Kestrel\Kestrel\src\Microsoft.AspNetCore.Server.Kestrel.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Server.Kestrel.Transport.NamedPipes" ProjectPath="$(RepoRoot)src\Servers\Kestrel\Transport.NamedPipes\src\Microsoft.AspNetCore.Server.Kestrel.Transport.NamedPipes.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Server.Kestrel.Transport.Quic" ProjectPath="$(RepoRoot)src\Servers\Kestrel\Transport.Quic\src\Microsoft.AspNetCore.Server.Kestrel.Transport.Quic.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets" ProjectPath="$(RepoRoot)src\Servers\Kestrel\Transport.Sockets\src\Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.BearerToken" ProjectPath="$(RepoRoot)src\Security\Authentication\BearerToken\src\Microsoft.AspNetCore.Authentication.BearerToken.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.Certificate" ProjectPath="$(RepoRoot)src\Security\Authentication\Certificate\src\Microsoft.AspNetCore.Authentication.Certificate.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.Cookies" ProjectPath="$(RepoRoot)src\Security\Authentication\Cookies\src\Microsoft.AspNetCore.Authentication.Cookies.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication" ProjectPath="$(RepoRoot)src\Security\Authentication\Core\src\Microsoft.AspNetCore.Authentication.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.Facebook" ProjectPath="$(RepoRoot)src\Security\Authentication\Facebook\src\Microsoft.AspNetCore.Authentication.Facebook.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.Google" ProjectPath="$(RepoRoot)src\Security\Authentication\Google\src\Microsoft.AspNetCore.Authentication.Google.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.JwtBearer" ProjectPath="$(RepoRoot)src\Security\Authentication\JwtBearer\src\Microsoft.AspNetCore.Authentication.JwtBearer.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.MicrosoftAccount" ProjectPath="$(RepoRoot)src\Security\Authentication\MicrosoftAccount\src\Microsoft.AspNetCore.Authentication.MicrosoftAccount.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.Negotiate" ProjectPath="$(RepoRoot)src\Security\Authentication\Negotiate\src\Microsoft.AspNetCore.Authentication.Negotiate.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.OAuth" ProjectPath="$(RepoRoot)src\Security\Authentication\OAuth\src\Microsoft.AspNetCore.Authentication.OAuth.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.OpenIdConnect" ProjectPath="$(RepoRoot)src\Security\Authentication\OpenIdConnect\src\Microsoft.AspNetCore.Authentication.OpenIdConnect.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.Twitter" ProjectPath="$(RepoRoot)src\Security\Authentication\Twitter\src\Microsoft.AspNetCore.Authentication.Twitter.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authentication.WsFederation" ProjectPath="$(RepoRoot)src\Security\Authentication\WsFederation\src\Microsoft.AspNetCore.Authentication.WsFederation.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authorization" ProjectPath="$(RepoRoot)src\Security\Authorization\Core\src\Microsoft.AspNetCore.Authorization.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Authorization.Policy" ProjectPath="$(RepoRoot)src\Security\Authorization\Policy\src\Microsoft.AspNetCore.Authorization.Policy.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.CookiePolicy" ProjectPath="$(RepoRoot)src\Security\CookiePolicy\src\Microsoft.AspNetCore.CookiePolicy.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Web.Xdt.Extensions" ProjectPath="$(RepoRoot)src\SiteExtensions\Microsoft.Web.Xdt.Extensions\src\Microsoft.Web.Xdt.Extensions.csproj" />
    <ProjectReferenceProvider Include="dotnet-getdocument" ProjectPath="$(RepoRoot)src\Tools\dotnet-getdocument\src\dotnet-getdocument.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.ApiDescription.Client" ProjectPath="$(RepoRoot)src\Tools\Extensions.ApiDescription.Client\src\Microsoft.Extensions.ApiDescription.Client.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.ApiDescription.Server" ProjectPath="$(RepoRoot)src\Tools\Extensions.ApiDescription.Server\src\Microsoft.Extensions.ApiDescription.Server.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.DeveloperCertificates.XPlat" ProjectPath="$(RepoRoot)src\Tools\FirstRunCertGenerator\src\Microsoft.AspNetCore.DeveloperCertificates.XPlat.csproj" />
    <ProjectReferenceProvider Include="GetDocument.Insider" ProjectPath="$(RepoRoot)src\Tools\GetDocumentInsider\src\GetDocument.Insider.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Logging.AzureAppServices" ProjectPath="$(RepoRoot)src\Logging.AzureAppServices\src\Microsoft.Extensions.Logging.AzureAppServices.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.ConcurrencyLimiter" ProjectPath="$(RepoRoot)src\Middleware\ConcurrencyLimiter\src\Microsoft.AspNetCore.ConcurrencyLimiter.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Cors" ProjectPath="$(RepoRoot)src\Middleware\CORS\src\Microsoft.AspNetCore.Cors.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Diagnostics.Abstractions" ProjectPath="$(RepoRoot)src\Middleware\Diagnostics.Abstractions\src\Microsoft.AspNetCore.Diagnostics.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore" ProjectPath="$(RepoRoot)src\Middleware\Diagnostics.EntityFrameworkCore\src\Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Diagnostics" ProjectPath="$(RepoRoot)src\Middleware\Diagnostics\src\Microsoft.AspNetCore.Diagnostics.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.HeaderPropagation" ProjectPath="$(RepoRoot)src\Middleware\HeaderPropagation\src\Microsoft.AspNetCore.HeaderPropagation.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" ProjectPath="$(RepoRoot)src\Middleware\HealthChecks.EntityFrameworkCore\src\Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Diagnostics.HealthChecks" ProjectPath="$(RepoRoot)src\Middleware\HealthChecks\src\Microsoft.AspNetCore.Diagnostics.HealthChecks.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.HostFiltering" ProjectPath="$(RepoRoot)src\Middleware\HostFiltering\src\Microsoft.AspNetCore.HostFiltering.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.HttpLogging" ProjectPath="$(RepoRoot)src\Middleware\HttpLogging\src\Microsoft.AspNetCore.HttpLogging.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.HttpOverrides" ProjectPath="$(RepoRoot)src\Middleware\HttpOverrides\src\Microsoft.AspNetCore.HttpOverrides.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.HttpsPolicy" ProjectPath="$(RepoRoot)src\Middleware\HttpsPolicy\src\Microsoft.AspNetCore.HttpsPolicy.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Localization.Routing" ProjectPath="$(RepoRoot)src\Middleware\Localization.Routing\src\Microsoft.AspNetCore.Localization.Routing.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Localization" ProjectPath="$(RepoRoot)src\Middleware\Localization\src\Microsoft.AspNetCore.Localization.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.OutputCaching.StackExchangeRedis" ProjectPath="$(RepoRoot)src\Middleware\Microsoft.AspNetCore.OutputCaching.StackExchangeRedis\src\Microsoft.AspNetCore.OutputCaching.StackExchangeRedis.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.MiddlewareAnalysis" ProjectPath="$(RepoRoot)src\Middleware\MiddlewareAnalysis\src\Microsoft.AspNetCore.MiddlewareAnalysis.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.OutputCaching" ProjectPath="$(RepoRoot)src\Middleware\OutputCaching\src\Microsoft.AspNetCore.OutputCaching.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.RateLimiting" ProjectPath="$(RepoRoot)src\Middleware\RateLimiting\src\Microsoft.AspNetCore.RateLimiting.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.RequestDecompression" ProjectPath="$(RepoRoot)src\Middleware\RequestDecompression\src\Microsoft.AspNetCore.RequestDecompression.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.ResponseCaching.Abstractions" ProjectPath="$(RepoRoot)src\Middleware\ResponseCaching.Abstractions\src\Microsoft.AspNetCore.ResponseCaching.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.ResponseCaching" ProjectPath="$(RepoRoot)src\Middleware\ResponseCaching\src\Microsoft.AspNetCore.ResponseCaching.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.ResponseCompression" ProjectPath="$(RepoRoot)src\Middleware\ResponseCompression\src\Microsoft.AspNetCore.ResponseCompression.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Rewrite" ProjectPath="$(RepoRoot)src\Middleware\Rewrite\src\Microsoft.AspNetCore.Rewrite.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Session" ProjectPath="$(RepoRoot)src\Middleware\Session\src\Microsoft.AspNetCore.Session.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SpaProxy" ProjectPath="$(RepoRoot)src\Middleware\Spa\SpaProxy\src\Microsoft.AspNetCore.SpaProxy.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SpaServices.Extensions" ProjectPath="$(RepoRoot)src\Middleware\Spa\SpaServices.Extensions\src\Microsoft.AspNetCore.SpaServices.Extensions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.StaticFiles" ProjectPath="$(RepoRoot)src\Middleware\StaticFiles\src\Microsoft.AspNetCore.StaticFiles.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.WebSockets" ProjectPath="$(RepoRoot)src\Middleware\WebSockets\src\Microsoft.AspNetCore.WebSockets.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Razor.Runtime" ProjectPath="$(RepoRoot)src\Razor\Razor.Runtime\src\Microsoft.AspNetCore.Razor.Runtime.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Razor" ProjectPath="$(RepoRoot)src\Razor\Razor\src\Microsoft.AspNetCore.Razor.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Abstractions" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Abstractions\src\Microsoft.AspNetCore.Mvc.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.ApiExplorer" ProjectPath="$(RepoRoot)src\Mvc\Mvc.ApiExplorer\src\Microsoft.AspNetCore.Mvc.ApiExplorer.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Core" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Core\src\Microsoft.AspNetCore.Mvc.Core.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Cors" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Cors\src\Microsoft.AspNetCore.Mvc.Cors.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.DataAnnotations" ProjectPath="$(RepoRoot)src\Mvc\Mvc.DataAnnotations\src\Microsoft.AspNetCore.Mvc.DataAnnotations.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Formatters.Json" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Formatters.Json\src\Microsoft.AspNetCore.Mvc.Formatters.Json.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Formatters.Xml" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Formatters.Xml\src\Microsoft.AspNetCore.Mvc.Formatters.Xml.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Localization" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Localization\src\Microsoft.AspNetCore.Mvc.Localization.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.NewtonsoftJson" ProjectPath="$(RepoRoot)src\Mvc\Mvc.NewtonsoftJson\src\Microsoft.AspNetCore.Mvc.NewtonsoftJson.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Razor.RuntimeCompilation\src\Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.RazorPages" ProjectPath="$(RepoRoot)src\Mvc\Mvc.RazorPages\src\Microsoft.AspNetCore.Mvc.RazorPages.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Razor" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Razor\src\Microsoft.AspNetCore.Mvc.Razor.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.TagHelpers" ProjectPath="$(RepoRoot)src\Mvc\Mvc.TagHelpers\src\Microsoft.AspNetCore.Mvc.TagHelpers.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Testing.Tasks" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Testing.Tasks\src\Microsoft.AspNetCore.Mvc.Testing.Tasks.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.Testing" ProjectPath="$(RepoRoot)src\Mvc\Mvc.Testing\src\Microsoft.AspNetCore.Mvc.Testing.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc.ViewFeatures" ProjectPath="$(RepoRoot)src\Mvc\Mvc.ViewFeatures\src\Microsoft.AspNetCore.Mvc.ViewFeatures.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Mvc" ProjectPath="$(RepoRoot)src\Mvc\Mvc\src\Microsoft.AspNetCore.Mvc.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.AzureAppServices.HostingStartup" ProjectPath="$(RepoRoot)src\Azure\AzureAppServices.HostingStartup\src\Microsoft.AspNetCore.AzureAppServices.HostingStartup.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.AzureAppServicesIntegration" ProjectPath="$(RepoRoot)src\Azure\AzureAppServicesIntegration\src\Microsoft.AspNetCore.AzureAppServicesIntegration.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Client.Core" ProjectPath="$(RepoRoot)src\SignalR\clients\csharp\Client.Core\src\Microsoft.AspNetCore.SignalR.Client.Core.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Client.SourceGenerator" ProjectPath="$(RepoRoot)src\SignalR\clients\csharp\Client.SourceGenerator\src\Microsoft.AspNetCore.SignalR.Client.SourceGenerator.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Client" ProjectPath="$(RepoRoot)src\SignalR\clients\csharp\Client\src\Microsoft.AspNetCore.SignalR.Client.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Http.Connections.Client" ProjectPath="$(RepoRoot)src\SignalR\clients\csharp\Http.Connections.Client\src\Microsoft.AspNetCore.Http.Connections.Client.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Http.Connections.Common" ProjectPath="$(RepoRoot)src\SignalR\common\Http.Connections.Common\src\Microsoft.AspNetCore.Http.Connections.Common.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Http.Connections" ProjectPath="$(RepoRoot)src\SignalR\common\Http.Connections\src\Microsoft.AspNetCore.Http.Connections.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Protocols.Json" ProjectPath="$(RepoRoot)src\SignalR\common\Protocols.Json\src\Microsoft.AspNetCore.SignalR.Protocols.Json.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Protocols.MessagePack" ProjectPath="$(RepoRoot)src\SignalR\common\Protocols.MessagePack\src\Microsoft.AspNetCore.SignalR.Protocols.MessagePack.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson" ProjectPath="$(RepoRoot)src\SignalR\common\Protocols.NewtonsoftJson\src\Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Common" ProjectPath="$(RepoRoot)src\SignalR\common\SignalR.Common\src\Microsoft.AspNetCore.SignalR.Common.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Core" ProjectPath="$(RepoRoot)src\SignalR\server\Core\src\Microsoft.AspNetCore.SignalR.Core.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR" ProjectPath="$(RepoRoot)src\SignalR\server\SignalR\src\Microsoft.AspNetCore.SignalR.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.Specification.Tests" ProjectPath="$(RepoRoot)src\SignalR\server\Specification.Tests\src\Microsoft.AspNetCore.SignalR.Specification.Tests.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.SignalR.StackExchangeRedis" ProjectPath="$(RepoRoot)src\SignalR\server\StackExchangeRedis\src\Microsoft.AspNetCore.SignalR.StackExchangeRedis.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.StaticAssets" ProjectPath="$(RepoRoot)src\StaticAssets\src\Microsoft.AspNetCore.StaticAssets.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.Authorization" ProjectPath="$(RepoRoot)src\Components\Authorization\src\Microsoft.AspNetCore.Components.Authorization.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components" ProjectPath="$(RepoRoot)src\Components\Components\src\Microsoft.AspNetCore.Components.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.CustomElements" ProjectPath="$(RepoRoot)src\Components\CustomElements\src\Microsoft.AspNetCore.Components.CustomElements.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.Endpoints" ProjectPath="$(RepoRoot)src\Components\Endpoints\src\Microsoft.AspNetCore.Components.Endpoints.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.Forms" ProjectPath="$(RepoRoot)src\Components\Forms\src\Microsoft.AspNetCore.Components.Forms.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter" ProjectPath="$(RepoRoot)src\Components\QuickGrid\Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter\src\Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.QuickGrid" ProjectPath="$(RepoRoot)src\Components\QuickGrid\Microsoft.AspNetCore.Components.QuickGrid\src\Microsoft.AspNetCore.Components.QuickGrid.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.Server" ProjectPath="$(RepoRoot)src\Components\Server\src\Microsoft.AspNetCore.Components.Server.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Authentication.WebAssembly.Msal" ProjectPath="$(RepoRoot)src\Components\WebAssembly\Authentication.Msal\src\Microsoft.Authentication.WebAssembly.Msal.csproj" />
    <ProjectReferenceProvider Include="Microsoft.JSInterop.WebAssembly" ProjectPath="$(RepoRoot)src\Components\WebAssembly\JSInterop\src\Microsoft.JSInterop.WebAssembly.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.WebAssembly.Server" ProjectPath="$(RepoRoot)src\Components\WebAssembly\Server\src\Microsoft.AspNetCore.Components.WebAssembly.Server.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.WebAssembly.Authentication" ProjectPath="$(RepoRoot)src\Components\WebAssembly\WebAssembly.Authentication\src\Microsoft.AspNetCore.Components.WebAssembly.Authentication.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.WebAssembly" ProjectPath="$(RepoRoot)src\Components\WebAssembly\WebAssembly\src\Microsoft.AspNetCore.Components.WebAssembly.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.WebView" ProjectPath="$(RepoRoot)src\Components\WebView\WebView\src\Microsoft.AspNetCore.Components.WebView.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Components.Web" ProjectPath="$(RepoRoot)src\Components\Web\src\Microsoft.AspNetCore.Components.Web.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.FileProviders.Embedded" ProjectPath="$(RepoRoot)src\FileProviders\Embedded\src\Microsoft.Extensions.FileProviders.Embedded.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Configuration.KeyPerFile" ProjectPath="$(RepoRoot)src\Configuration.KeyPerFile\src\Microsoft.Extensions.Configuration.KeyPerFile.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Localization.Abstractions" ProjectPath="$(RepoRoot)src\Localization\Abstractions\src\Microsoft.Extensions.Localization.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Localization" ProjectPath="$(RepoRoot)src\Localization\Localization\src\Microsoft.Extensions.Localization.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.ObjectPool" ProjectPath="$(RepoRoot)src\ObjectPool\src\Microsoft.Extensions.ObjectPool.csproj" />
    <ProjectReferenceProvider Include="Microsoft.JSInterop" ProjectPath="$(RepoRoot)src\JSInterop\Microsoft.JSInterop\src\Microsoft.JSInterop.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.WebEncoders" ProjectPath="$(RepoRoot)src\WebEncoders\src\Microsoft.Extensions.WebEncoders.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions" ProjectPath="$(RepoRoot)src\HealthChecks\Abstractions\src\Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Diagnostics.HealthChecks" ProjectPath="$(RepoRoot)src\HealthChecks\HealthChecks\src\Microsoft.Extensions.Diagnostics.HealthChecks.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.InternalTesting" ProjectPath="$(RepoRoot)src\Testing\src\Microsoft.AspNetCore.InternalTesting.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Features" ProjectPath="$(RepoRoot)src\Extensions\Features\src\Microsoft.Extensions.Features.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Grpc.JsonTranscoding" ProjectPath="$(RepoRoot)src\Grpc\JsonTranscoding\src\Microsoft.AspNetCore.Grpc.JsonTranscoding\Microsoft.AspNetCore.Grpc.JsonTranscoding.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.Grpc.Swagger" ProjectPath="$(RepoRoot)src\Grpc\JsonTranscoding\src\Microsoft.AspNetCore.Grpc.Swagger\Microsoft.AspNetCore.Grpc.Swagger.csproj" />
    <ProjectReferenceProvider Include="Microsoft.AspNetCore.OpenApi" ProjectPath="$(RepoRoot)src\OpenApi\src\Microsoft.AspNetCore.OpenApi.csproj" />
    <ProjectReferenceProvider Include="Microsoft.Extensions.Validation" ProjectPath="$(RepoRoot)src\Validation\src\Microsoft.Extensions.Validation.csproj" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\RequiresDelayedBuildProjects.props">

/home/runner/work/aspnetcore/aspnetcore/eng/RequiresDelayedBuildProjects.props
============================================================================================================================================
-->
  <!--
  This file is automatically generated. Run `./eng/scripts/GenerateProjectList.ps1` to update.

  This file contains a list of projects that must be restored etc. after App.Ref and App.Runtime are fully built.

  This file is generated using <RequiresDelayedBuild/> properties. Content may overlap ProjectReferences.csproj
  but that is not required (projects that are not project reference providers are also supported).
-->
  <ItemGroup>
    <RequiresDelayedBuild Include="$(RepoRoot)src\Framework\Microsoft.Internal.Aspnetcore.DotNetApiDocs.Transport\src\Microsoft.Internal.Aspnetcore.DotNetApiDocs.Transport.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\DataProtection\DataProtection\test\Microsoft.AspNetCore.DataProtection.TrimmingTests\Microsoft.AspNetCore.DataProtection.TrimmingTests.proj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\DefaultBuilder\test\Microsoft.AspNetCore.NativeAotTests\Microsoft.AspNetCore.NativeAotTests.proj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\DefaultBuilder\test\Microsoft.AspNetCore.TrimmingTests\Microsoft.AspNetCore.TrimmingTests.proj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Grpc\JsonTranscoding\perf\Microsoft.AspNetCore.Grpc.Microbenchmarks\Microsoft.AspNetCore.Grpc.Microbenchmarks.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Grpc\JsonTranscoding\src\Microsoft.AspNetCore.Grpc.JsonTranscoding\Microsoft.AspNetCore.Grpc.JsonTranscoding.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Grpc\JsonTranscoding\src\Microsoft.AspNetCore.Grpc.Swagger\Microsoft.AspNetCore.Grpc.Swagger.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Grpc\JsonTranscoding\test\Microsoft.AspNetCore.Grpc.JsonTranscoding.IntegrationTests\Microsoft.AspNetCore.Grpc.JsonTranscoding.IntegrationTests.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Grpc\JsonTranscoding\test\Microsoft.AspNetCore.Grpc.JsonTranscoding.Tests\Microsoft.AspNetCore.Grpc.JsonTranscoding.Tests.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Grpc\JsonTranscoding\test\Microsoft.AspNetCore.Grpc.Swagger.Tests\Microsoft.AspNetCore.Grpc.Swagger.Tests.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Grpc\JsonTranscoding\test\testassets\IntegrationTestsWebsite\IntegrationTestsWebsite.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Grpc\JsonTranscoding\test\testassets\Sandbox\Sandbox.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\OpenApi\test\Microsoft.AspNetCore.OpenApi.NativeAotTests\Microsoft.AspNetCore.OpenApi.NativeAotTests.proj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\ProjectTemplates\test\Templates.Blazor.Tests\Templates.Blazor.Tests.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\ProjectTemplates\test\Templates.Blazor.WebAssembly.Auth.Tests\Templates.Blazor.WebAssembly.Auth.Tests.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\ProjectTemplates\test\Templates.Blazor.WebAssembly.Tests\Templates.Blazor.WebAssembly.Tests.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\ProjectTemplates\test\Templates.Mvc.Tests\Templates.Mvc.Tests.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\ProjectTemplates\test\Templates.Tests\Templates.Tests.csproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\SignalR\server\SignalR\test\Microsoft.AspNetCore.SignalR.TrimmingTests\Microsoft.AspNetCore.SignalR.TrimmingTests.proj" />
    <RequiresDelayedBuild Include="$(RepoRoot)eng\Npm.Workspace.FunctionalTests.nodeproj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Validation\test\Microsoft.Extensions.Validation.NativeAotTests\Microsoft.Extensions.Validation.NativeAotTests.proj" />
    <RequiresDelayedBuild Include="$(RepoRoot)src\Validation\test\Microsoft.Extensions.Validation.TrimmingTests\Microsoft.Extensions.Validation.TrimmingTests.proj" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\SharedFramework.Local.props">

/home/runner/work/aspnetcore/aspnetcore/eng/SharedFramework.Local.props
============================================================================================================================================
-->
  <!--
  This file is automatically generated. Run `./eng/scripts/GenerateProjectList.ps1` to update.

  This file contains a complete list of the assemblies which are part of the shared framework.

  This file is generated using the <IsAspNetCoreApp/> and <IsPackable/> properties from each .csproj in this repository.
-->
  <ItemGroup>
    <!-- These assemblies are available as both a NuGet package and in the shared framework -->
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.DataProtection.Abstractions" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Cryptography.Internal" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Cryptography.KeyDerivation" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.DataProtection" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.DataProtection.Extensions" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Net.Http.Headers" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Metadata" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.WebUtilities" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Identity.Core" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Identity.Stores" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Connections.Abstractions" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Authorization" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Http.Connections.Common" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.SignalR.Protocols.Json" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.SignalR.Common" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Components.Authorization" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Components" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Components.Forms" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.AspNetCore.Components.Web" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.FileProviders.Embedded" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Configuration.KeyPerFile" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Localization.Abstractions" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Localization" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.ObjectPool" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.JSInterop" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.WebEncoders" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Diagnostics.HealthChecks" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Features" />
    <AspNetCoreAppReferenceAndPackage Include="Microsoft.Extensions.Validation" />
    <!-- These assemblies are only in the shared framework -->
    <AspNetCoreAppReference Include="Microsoft.AspNetCore" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Antiforgery" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Hosting.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Hosting" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Hosting.Server.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Authentication.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Authentication.Core" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Http.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Http.Extensions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Http.Features" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Http.Results" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Http" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Routing.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Routing" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Html.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Identity" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Server.HttpSys" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Server.IISIntegration" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Server.IIS" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Server.Kestrel.Core" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Server.Kestrel" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Server.Kestrel.Transport.NamedPipes" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Server.Kestrel.Transport.Quic" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Authentication.BearerToken" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Authentication.Cookies" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Authentication" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Authentication.OAuth" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Authorization.Policy" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.CookiePolicy" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Cors" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Diagnostics.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Diagnostics" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Diagnostics.HealthChecks" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.HostFiltering" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.HttpLogging" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.HttpOverrides" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.HttpsPolicy" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Localization.Routing" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Localization" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.OutputCaching" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.RateLimiting" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.RequestDecompression" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.ResponseCaching.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.ResponseCaching" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.ResponseCompression" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Rewrite" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Session" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.StaticFiles" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.WebSockets" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Razor.Runtime" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Razor" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.Abstractions" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.ApiExplorer" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.Core" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.Cors" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.DataAnnotations" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.Formatters.Json" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.Formatters.Xml" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.Localization" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.RazorPages" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.Razor" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.TagHelpers" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc.ViewFeatures" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Mvc" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Http.Connections" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.SignalR.Core" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.SignalR" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.StaticAssets" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Components.Endpoints" />
    <AspNetCoreAppReference Include="Microsoft.AspNetCore.Components.Server" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\SharedFramework.External.props">

/home/runner/work/aspnetcore/aspnetcore/eng/SharedFramework.External.props
============================================================================================================================================
-->
  <!--

  This lists all assemblies which are part of the Microsoft.AspNetCore.App shared framework
  and are built as packages in another repo.

-->
  <ItemGroup>
    <!-- Dependencies from dotnet/runtime -->
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Caching.Abstractions" Version="$(MicrosoftExtensionsCachingAbstractionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Caching.Memory" Version="$(MicrosoftExtensionsCachingMemoryVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="$(MicrosoftExtensionsConfigurationAbstractionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.Binder" Version="$(MicrosoftExtensionsConfigurationBinderVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.CommandLine" Version="$(MicrosoftExtensionsConfigurationCommandLineVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="$(MicrosoftExtensionsConfigurationEnvironmentVariablesVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.FileExtensions" Version="$(MicrosoftExtensionsConfigurationFileExtensionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.Ini" Version="$(MicrosoftExtensionsConfigurationIniVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.Json" Version="$(MicrosoftExtensionsConfigurationJsonVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.UserSecrets" Version="$(MicrosoftExtensionsConfigurationUserSecretsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration.Xml" Version="$(MicrosoftExtensionsConfigurationXmlVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Configuration" Version="$(MicrosoftExtensionsConfigurationVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="$(MicrosoftExtensionsDependencyInjectionAbstractionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.DependencyInjection" Version="$(MicrosoftExtensionsDependencyInjectionVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Diagnostics.Abstractions" Version="$(MicrosoftExtensionsDiagnosticsAbstractionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Diagnostics" Version="$(MicrosoftExtensionsDiagnosticsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.FileProviders.Abstractions" Version="$(MicrosoftExtensionsFileProvidersAbstractionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.FileProviders.Composite" Version="$(MicrosoftExtensionsFileProvidersCompositeVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.FileProviders.Physical" Version="$(MicrosoftExtensionsFileProvidersPhysicalVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.FileSystemGlobbing" Version="$(MicrosoftExtensionsFileSystemGlobbingVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="$(MicrosoftExtensionsHostingAbstractionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Hosting" Version="$(MicrosoftExtensionsHostingVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Http" Version="$(MicrosoftExtensionsHttpVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Logging.Abstractions" Version="$(MicrosoftExtensionsLoggingAbstractionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Logging.Configuration" Version="$(MicrosoftExtensionsLoggingConfigurationVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Logging.Console" Version="$(MicrosoftExtensionsLoggingConsoleVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Logging.Debug" Version="$(MicrosoftExtensionsLoggingDebugVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Logging.EventSource" Version="$(MicrosoftExtensionsLoggingEventSourceVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Logging.EventLog" Version="$(MicrosoftExtensionsLoggingEventLogVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Logging.TraceSource" Version="$(MicrosoftExtensionsLoggingTraceSourceVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Logging" Version="$(MicrosoftExtensionsLoggingVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="$(MicrosoftExtensionsOptionsConfigurationExtensionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Options.DataAnnotations" Version="$(MicrosoftExtensionsOptionsDataAnnotationsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Options" Version="$(MicrosoftExtensionsOptionsVersion)" />
    <ExternalAspNetCoreAppReference Include="Microsoft.Extensions.Primitives" Version="$(MicrosoftExtensionsPrimitivesVersion)" />
    <ExternalAspNetCoreAppReference Include="System.Formats.Cbor" Version="$(SystemFormatsCborVersion)" />
    <ExternalAspNetCoreAppReference Include="System.Security.Cryptography.Xml" Version="$(SystemSecurityCryptographyXmlVersion)" />
    <ExternalAspNetCoreAppReference Include="System.Threading.RateLimiting" Version="$(SystemThreadingRateLimitingVersion)" />
    <!--
      Transitive dependencies of other assemblies in the shared framework. These are listed separately and should not be included directly
      when setting `<Reference>`. These are listed for the purpose of tests and servicing builds only.

      If implementation details change and these assemblies are no longer showing up in the shared framework as a result of that,
      it is okay to remove these transitive dependencies.

      If these are needed as direct dependencies, it is okay to change them to ExternalAspNetCoreAppReference and move up into sections above.
    -->
    <_TransitiveExternalAspNetCoreAppReference Include="System.Security.Cryptography.Pkcs" Version="$(SystemSecurityCryptographyPkcsVersion)" />
    <!--
      Seems arbitrary that the following packages have their ref/ assemblies in our targeting pack but the above assemblies
      do not. This is likely about our public APIs i.e. external compilation requirements.
    -->
    <_TransitiveExternalAspNetCoreAppReference Include="System.Diagnostics.EventLog" Version="$(SystemDiagnosticsEventLogVersion)" />
  </ItemGroup>
  <ItemGroup Condition=" '$(IsServicingBuild)' == 'true' ">
    <!--
      Once we start to build a servicing release, hoist transitive dependencies to be direct dependencies.
      This will help us ensure servicing builds carry the latest versions of dependencies, even if we aren't rebuilding
      the original direct dependency that pulled in the transitive reference.
    -->
    <ExternalAspNetCoreAppReference Include="@(_TransitiveExternalAspNetCoreAppReference)" />
  </ItemGroup>
  <!--
    This compilation reference is necessary to compile netstandard2.0 assemblies that need IAsyncEnumerable and IAsyncDisposable and the assembly is also in the shared framework.
    This reference is part of Microsoft.NETCore.App, so is listed here as a reference to be used during compilation only.
  -->
  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <_CompilationOnlyReference Include="Microsoft.Bcl.AsyncInterfaces" />
  </ItemGroup>
  <!--
    These compilation references are necessary to compile netstandard2.0 assemblies which are in the shared framework.
    This references are part of Microsoft.NETCore.App, so are listed here as references to be used during compilation only.
  -->
  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0' or $(TargetFrameworks.Contains('netstandard2.0')) or '$(TargetFramework)' == 'netstandard2.1'">
    <_CompilationOnlyReference Include="Microsoft.Win32.Registry" />
    <_CompilationOnlyReference Include="System.Security.Principal.Windows" />
    <_CompilationOnlyReference Include="System.Buffers" />
    <_CompilationOnlyReference Include="System.ComponentModel.Annotations" />
    <_CompilationOnlyReference Include="System.Runtime.CompilerServices.Unsafe" />
    <_CompilationOnlyReference Include="System.Text.Json" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\ShippingAssemblies.props">

/home/runner/work/aspnetcore/aspnetcore/eng/ShippingAssemblies.props
============================================================================================================================================
-->
  <!--
  This file is automatically generated. Run `./eng/scripts/GenerateProjectList.ps1` to update.

  This file contains a list of all assemblies shipped from this repo, either via the Shared Framework or Nuget packages (or both).
-->
  <ItemGroup>
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.DataProtection.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Cryptography.Internal" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Cryptography.KeyDerivation" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.DataProtection" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.DataProtection.Extensions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Antiforgery" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Hosting.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Hosting" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Hosting.Server.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.Core" />
    <AspNetCoreShippingAssembly Include="Microsoft.Net.Http.Headers" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Http.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Http.Extensions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Http.Features" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Http.Results" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Http" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Metadata" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Routing.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Routing" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.WebUtilities" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Html.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Identity" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Identity.Core" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Identity.Stores" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Connections.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Server.HttpSys" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Server.IISIntegration" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Server.IIS" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Server.Kestrel.Core" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Server.Kestrel" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Server.Kestrel.Transport.NamedPipes" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Server.Kestrel.Transport.Quic" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.BearerToken" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.Cookies" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.OAuth" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authorization" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authorization.Policy" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.CookiePolicy" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Cors" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Diagnostics.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Diagnostics" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Diagnostics.HealthChecks" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.HostFiltering" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.HttpLogging" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.HttpOverrides" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.HttpsPolicy" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Localization.Routing" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Localization" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.OutputCaching" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.RateLimiting" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.RequestDecompression" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.ResponseCaching.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.ResponseCaching" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.ResponseCompression" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Rewrite" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Session" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.StaticFiles" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.WebSockets" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Razor.Runtime" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Razor" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.ApiExplorer" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Core" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Cors" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.DataAnnotations" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Formatters.Json" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Formatters.Xml" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Localization" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.RazorPages" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Razor" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.TagHelpers" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.ViewFeatures" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Http.Connections.Common" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Http.Connections" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.Protocols.Json" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.Common" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.Core" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.StaticAssets" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.Authorization" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.Endpoints" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.Forms" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.Server" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.Web" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.FileProviders.Embedded" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Configuration.KeyPerFile" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Localization.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Localization" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.ObjectPool" />
    <AspNetCoreShippingAssembly Include="Microsoft.JSInterop" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.WebEncoders" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Diagnostics.HealthChecks" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Features" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Validation" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.App.Internal.Assets" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Caching.SqlServer" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Caching.StackExchangeRedis" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.JsonPatch.SystemTextJson" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.JsonPatch" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.DataProtection.EntityFrameworkCore" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.DataProtection.StackExchangeRedis" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.TestHost" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Hosting.WindowsServices" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Owin" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Http.Polly" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Identity.EntityFrameworkCore" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Identity.Specification.Tests" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Identity.UI" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.Certificate" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.Facebook" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.Google" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.JwtBearer" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.MicrosoftAccount" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.Negotiate" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.OpenIdConnect" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.Twitter" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Authentication.WsFederation" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.ApiDescription.Client" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.ApiDescription.Server" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Logging.AzureAppServices" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.ConcurrencyLimiter" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.HeaderPropagation" />
    <AspNetCoreShippingAssembly Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.OutputCaching.StackExchangeRedis" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.MiddlewareAnalysis" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SpaProxy" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SpaServices.Extensions" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.NewtonsoftJson" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Mvc.Testing" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.AzureAppServices.HostingStartup" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.AzureAppServicesIntegration" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.Client.Core" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.Client" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Http.Connections.Client" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.Protocols.MessagePack" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.Specification.Tests" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.SignalR.StackExchangeRedis" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.CustomElements" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.QuickGrid" />
    <AspNetCoreShippingAssembly Include="Microsoft.Authentication.WebAssembly.Msal" />
    <AspNetCoreShippingAssembly Include="Microsoft.JSInterop.WebAssembly" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.WebAssembly.Server" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.WebAssembly.Authentication" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.WebAssembly" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Components.WebView" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Grpc.JsonTranscoding" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.Grpc.Swagger" />
    <AspNetCoreShippingAssembly Include="Microsoft.AspNetCore.OpenApi" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--<Import Project="eng\targets\Cpp.Common.props" Condition="'$(MSBuildProjectExtension)' == '.vcxproj'" />-->
  <!--
============================================================================================================================================
  <Import Project="eng\targets\CSharp.Common.props" Condition="'$(MSBuildProjectExtension)' == '.csproj'">

/home/runner/work/aspnetcore/aspnetcore/eng/targets/CSharp.Common.props
============================================================================================================================================
-->
  <PropertyGroup>
    <LangVersion>preview</LangVersion>
    <!-- Enables Strict mode for Roslyn compiler -->
    <Features>strict</Features>
  </PropertyGroup>
  <ItemGroup Condition=" $(IsTestProject) ">
    <Reference Include="Microsoft.AspNetCore.InternalTesting" />
    <Reference Include="Moq" />
    <Reference Include="NETStandard.Library" />
    <Compile Include="$(SharedSourceRoot)test\SuccessfulTests.cs" LinkBase="SharedTests" Visible="false" />
  </ItemGroup>
  <!--<Import Project="$(RepoRoot)src\Testing\src\build\Microsoft.AspNetCore.InternalTesting.props" Condition=" $(IsTestProject) " />-->
  <ItemDefinitionGroup Condition=" $(IsTestProject) ">
    <Content>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
      <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
    </Content>
  </ItemDefinitionGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.props
============================================================================================================================================
-->
  <!--<Import Project="eng\targets\Wix.Common.props" Condition="'$(MSBuildProjectExtension)' == '.wixproj'" />-->
  <!--<Import Project="eng\targets\Java.Common.props" Condition="'$(MSBuildProjectExtension)' == '.javaproj'" />-->
  <!--<Import Project="eng\testing\linker\trimmingTests.props" Condition="'$(IsPublishedAppTestProject)' == 'true'" />-->
  <!--<Import Project="eng\targets\Helix.props" Condition=" $(IsTestProject) " />-->
  <!--<Import Project="eng\targets\FunctionalTestWithAssets.props" Condition=" $(IsTestProject) " />-->
  <!-- Keys used by InternalsVisibleTo attributes. -->
  <PropertyGroup>
    <MoqPublicKey>0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7</MoqPublicKey>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/src/Components/Directory.Build.props
============================================================================================================================================
-->
  <PropertyGroup>
    <EnableTypeScriptNuGetTarget>true</EnableTypeScriptNuGetTarget>
  </PropertyGroup>
  <PropertyGroup>
    <PackageTags>aspnetcore;components</PackageTags>
    <ComponentsSharedSourceRoot>$(MSBuildThisFileDirectory)Shared\</ComponentsSharedSourceRoot>
    <PackageThirdPartyNoticesFile>$(MSBuildThisFileDirectory)THIRD-PARTY-NOTICES.txt</PackageThirdPartyNoticesFile>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Workaround microsoft/msbuild#3626 -->
    <AddSyntheticProjectReferencesForSolutionDependencies>false</AddSyntheticProjectReferencesForSolutionDependencies>
  </PropertyGroup>
  <!-- Workaround to add Blazor framework static assets without requiring a package reference -->
  <PropertyGroup>
    <UseBlazorFrameworkDebugAssets>true</UseBlazorFrameworkDebugAssets>
    <BlazorFrameworkStaticWebAssetRoot Condition="'$(Configuration)' == 'Debug'">$(RepoRoot)src\Components\Web.JS\dist\Debug</BlazorFrameworkStaticWebAssetRoot>
    <BlazorFrameworkStaticWebAssetRoot Condition="'$(Configuration)' == 'Release'">$(RepoRoot)src\Components\Web.JS\dist\Release</BlazorFrameworkStaticWebAssetRoot>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(RepoRoot)\src\Assets\build\Microsoft.AspNetCore.App.Internal.Assets.targets">

/home/runner/work/aspnetcore/aspnetcore/src/Assets/build/Microsoft.AspNetCore.App.Internal.Assets.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <ResolveStaticWebAssetsInputsDependsOn>
      $(ResolveStaticWebAssetsInputsDependsOn);
      _AddBlazorFrameworkStaticWebAssets;
    </ResolveStaticWebAssetsInputsDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <BlazorFrameworkStaticWebAssetRoot Condition="'$(BlazorFrameworkStaticWebAssetRoot)' == ''">$(MSBuildThisFileDirectory)..\_framework</BlazorFrameworkStaticWebAssetRoot>
  </PropertyGroup>
  <Target Name="_AddBlazorFrameworkStaticWebAssets" Condition="'$(OutputType)' == 'Exe'">
    <ItemGroup Condition="'$(UsingMicrosoftNETSdkWeb)' == 'true'">
      <_FrameworkStaticWebAssetCandidate Include="$(BlazorFrameworkStaticWebAssetRoot)\blazor.web.js">
        <RelativePath>_framework/blazor.web.js</RelativePath>
      </_FrameworkStaticWebAssetCandidate>
      <_FrameworkStaticWebAssetCandidate Include="$(BlazorFrameworkStaticWebAssetRoot)\blazor.server.js">
        <RelativePath>_framework/blazor.server.js</RelativePath>
      </_FrameworkStaticWebAssetCandidate>
    </ItemGroup>
    <ItemGroup Condition="'$(UsingMicrosoftNETSdkWeb)' == 'true' AND '$(UseBlazorFrameworkDebugAssets)' == 'true'">
      <_FrameworkStaticWebAssetCandidate Include="$(BlazorFrameworkStaticWebAssetRoot)\blazor.web.js.map">
        <RelativePath>_framework/blazor.web.js.map</RelativePath>
      </_FrameworkStaticWebAssetCandidate>
      <_FrameworkStaticWebAssetCandidate Include="$(BlazorFrameworkStaticWebAssetRoot)\blazor.server.js.map">
        <RelativePath>_framework/blazor.server.js.map</RelativePath>
      </_FrameworkStaticWebAssetCandidate>
    </ItemGroup>
    <ItemGroup>
      <_MissingFrameworkStaticWebAssetCandidate Include="@(_FrameworkStaticWebAssetCandidate)" Condition="!EXISTS('%(Identity)')" />
      <_FrameworkStaticWebAssetCandidate Remove="@(_MissingFrameworkStaticWebAssetCandidate)" />
    </ItemGroup>
    <Message Importance="High" Condition="'@(_MissingFrameworkStaticWebAssetCandidate-&gt;Count())' != '0'" Text="Framework asset '%(_MissingFrameworkStaticWebAssetCandidate.Identity)' could not be found and won't be included in the project." />
    <DefineStaticWebAssets Condition="'@(_FrameworkStaticWebAssetCandidate-&gt;Count())' != '0'" CandidateAssets="@(_FrameworkStaticWebAssetCandidate)" ContentRoot="$(BlazorFrameworkStaticWebAssetRoot)" SourceId="$(PackageId)" SourceType="Discovered" AssetKind="All" AssetMode="CurrentProject" AssetRole="Primary" FingerprintCandidates="true" BasePath="$(StaticWebAssetBasePath)">
      <Output TaskParameter="Assets" ItemName="_FrameworkStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints Condition="'@(_FrameworkStaticWebAsset)' != ''" CandidateAssets="@(_FrameworkStaticWebAsset)" ExistingEndpoints="" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_FrameworkStaticAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Include="@(_FrameworkStaticWebAsset)" />
      <StaticWebAssetEndpoint Include="@(_FrameworkStaticAssetEndpoint)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/src/Components/Directory.Build.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(CustomAfterDirectoryBuildProps)" Condition="'$(CustomAfterDirectoryBuildProps)' != ''">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/UseArtifactsOutputPath.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
UseArtifactsOutputPath.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- If ArtifactsPath or UseArtifactsOutput are set, then import .props to set ArtifactsPath here, so that BaseIntermediateOutputPath can be
       set in the ArtifactsPath.
       If the .props file is not imported here, it will be imported from Microsoft.NET.DefaultOutputPaths.targets, so that artifacts output
       properties can be set directly in the project file too (only in that case they won't affect the intermediate output). -->
  <!--<Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.DefaultArtifactsPath.props" Condition="'$(UseArtifactsOutput)' == 'true' Or '$(ArtifactsPath)' != ''" />-->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <UseArtifactsIntermediateOutput Condition="'$(UseArtifactsIntermediateOutput)' == ''">true</UseArtifactsIntermediateOutput>
    <ArtifactsProjectName Condition="'$(ArtifactsProjectName)' == ''">$(MSBuildProjectName)</ArtifactsProjectName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(BaseIntermediateOutputPath)' == '' And '$(UseArtifactsIntermediateOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <BaseIntermediateOutputPath Condition="'$(IncludeProjectNameInArtifactsPaths)' == 'true'">$(ArtifactsPath)\obj\$(ArtifactsProjectName)\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">$(ArtifactsPath)\obj\</BaseIntermediateOutputPath>
  </PropertyGroup>
  <!-- Record whether ArtifactsPath / UseArtifactsOutput was set at this point in evaluation.  We will generate an error if these properties are set
       after this point (ie in the project file). -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_ArtifactsPathSetEarly>true</_ArtifactsPathSetEarly>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <!--
      Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
        $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props

      Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
      management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
  -->
  <PropertyGroup>
    <!--
        The declaration of $(BaseIntermediateOutputPath) had to be moved up from Microsoft.Common.CurrentVersion.targets
        in order for the $(MSBuildProjectExtensionsPath) to use it as a default.
    -->
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <_InitialBaseIntermediateOutputPath>$(BaseIntermediateOutputPath)</_InitialBaseIntermediateOutputPath>
    <MSBuildProjectExtensionsPath Condition="'$(MSBuildProjectExtensionsPath)' == '' ">$(BaseIntermediateOutputPath)</MSBuildProjectExtensionsPath>
    <!--
        Import paths that are relative default to be relative to the importing file.  However, since MSBuildExtensionsPath
        defaults to BaseIntermediateOutputPath we expect it to be relative to the project directory.  So if the path is relative
        it needs to be made absolute based on the project directory.
    -->
    <MSBuildProjectExtensionsPath Condition="'$([System.IO.Path]::IsPathRooted($(MSBuildProjectExtensionsPath)))' == 'false'">$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
    <MSBuildProjectExtensionsPath Condition="!HasTrailingSlash('$(MSBuildProjectExtensionsPath)')">$(MSBuildProjectExtensionsPath)\</MSBuildProjectExtensionsPath>
    <!--
        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed
        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other
        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionProps
    -->
    <ImportProjectExtensionProps Condition="$([MSBuild]::AreFeaturesEnabled('17.10')) And '$(ImportProjectExtensionProps)' == '' And '$(MSBuildIsRestoring)' == 'true'">false</ImportProjectExtensionProps>
    <ImportProjectExtensionProps Condition="'$(ImportProjectExtensionProps)' == ''">true</ImportProjectExtensionProps>
    <_InitialMSBuildProjectExtensionsPath Condition=" '$(ImportProjectExtensionProps)' == 'true' ">$(MSBuildProjectExtensionsPath)</_InitialMSBuildProjectExtensionsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.props" Condition="'$(ImportProjectExtensionProps)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')">

/home/runner/work/aspnetcore/aspnetcore/artifacts/obj/Microsoft.AspNetCore.Components.CustomElements/Microsoft.AspNetCore.Components.CustomElements.csproj.nuget.g.props
============================================================================================================================================
-->
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">/home/runner/.nuget/packages/</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">/home/runner/.nuget/packages/</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.15.0</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SourceRoot Include="/home/runner/.nuget/packages/" />
  </ItemGroup>
  <!--<ImportGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.net.illink.tasks/10.0.0-preview.7.25322.101/build/Microsoft.NET.ILLink.Tasks.props" Condition="Exists('$(NuGetPackageRoot)microsoft.net.illink.tasks/10.0.0-preview.7.25322.101/build/Microsoft.NET.ILLink.Tasks.props')">

/home/runner/.nuget/packages/microsoft.net.illink.tasks/10.0.0-preview.7.25322.101/build/Microsoft.NET.ILLink.Tasks.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ILLink.Tasks.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- N.B. The ILLinkTargetsPath is used as a sentinel to indicate a version of this file has already been imported. It will also be the path
         used to import the targets later in the SDK. -->
    <ILLinkTargetsPath Condition="'$(ILLinkTargetsPath)' == ''">$(MSBuildThisFileDirectory)Microsoft.NET.ILLink.targets</ILLinkTargetsPath>
    <!-- Older SDKs used this property as a sentinel instead, to control the import of this file
         (but not the targets, which were included with the SDK). -->
    <UsingILLinkTasksSdk>true</UsingILLinkTasksSdk>
    <ILLinkTasksAssembly Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\ILLink.Tasks.dll</ILLinkTasksAssembly>
    <ILLinkTasksAssembly Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\ILLink.Tasks.dll</ILLinkTasksAssembly>
    <ILLinkAnalyzersPropsPath Condition="'$(ILLinkAnalyzersPropsPath)' == ''">$(MSBuildThisFileDirectory)Microsoft.NET.ILLink.Analyzers.props</ILLinkAnalyzersPropsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(ILLinkAnalyzersPropsPath)">

/home/runner/.nuget/packages/microsoft.net.illink.tasks/10.0.0-preview.7.25322.101/build/Microsoft.NET.ILLink.Analyzers.props
============================================================================================================================================
-->
  <ItemGroup>
    <CompilerVisibleProperty Include="EnableAotAnalyzer" />
    <CompilerVisibleProperty Include="EnableSingleFileAnalyzer" />
    <CompilerVisibleProperty Include="EnableTrimAnalyzer" />
    <CompilerVisibleProperty Include="IncludeAllContentForSelfExtract" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.net.illink.tasks/10.0.0-preview.7.25322.101/build/Microsoft.NET.ILLink.Tasks.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/artifacts/obj/Microsoft.AspNetCore.Components.CustomElements/Microsoft.AspNetCore.Components.CustomElements.csproj.nuget.g.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.codeanalysis.publicapianalyzers/3.3.3/build/Microsoft.CodeAnalysis.PublicApiAnalyzers.props" Condition="Exists('$(NuGetPackageRoot)microsoft.codeanalysis.publicapianalyzers/3.3.3/build/Microsoft.CodeAnalysis.PublicApiAnalyzers.props')">

/home/runner/.nuget/packages/microsoft.codeanalysis.publicapianalyzers/3.3.3/build/Microsoft.CodeAnalysis.PublicApiAnalyzers.props
============================================================================================================================================
-->
  <!-- 
    This property group prevents the rule ids implemented in this package to be bumped to errors when
    the 'CodeAnalysisTreatWarningsAsErrors' = 'false'.
  -->
  <PropertyGroup>
    <CodeAnalysisRuleIds>RS0016;RS0017;RS0022;RS0024;RS0025;RS0026;RS0027;RS0036;RS0037;RS0041;RS0048;RS0050</CodeAnalysisRuleIds>
    <WarningsNotAsErrors Condition="'$(CodeAnalysisTreatWarningsAsErrors)' == 'false'">$(WarningsNotAsErrors);$(CodeAnalysisRuleIds)</WarningsNotAsErrors>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/artifacts/obj/Microsoft.AspNetCore.Components.CustomElements/Microsoft.AspNetCore.Components.CustomElements.csproj.nuget.g.props
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PkgMicrosoft_NET_ILLink_Tasks Condition=" '$(PkgMicrosoft_NET_ILLink_Tasks)' == '' ">/home/runner/.nuget/packages/microsoft.net.illink.tasks/10.0.0-preview.7.25322.101</PkgMicrosoft_NET_ILLink_Tasks>
    <PkgMicrosoft_CodeAnalysis_PublicApiAnalyzers Condition=" '$(PkgMicrosoft_CodeAnalysis_PublicApiAnalyzers)' == '' ">/home/runner/.nuget/packages/microsoft.codeanalysis.publicapianalyzers/3.3.3</PkgMicrosoft_CodeAnalysis_PublicApiAnalyzers>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <!--
      Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ directory.
      This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
      the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory.

      Unfortunately, there is already a file named "Microsoft.Common.props" in this directory,
      so we have to have a slightly different directory name to hold extensions.
  -->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')" />-->
  <PropertyGroup>
    <CustomBeforeMicrosoftCommonProps Condition="'$(CustomBeforeMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.$(MSBuildThisFile)</CustomBeforeMicrosoftCommonProps>
    <CustomAfterMicrosoftCommonProps Condition="'$(CustomAfterMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.$(MSBuildThisFile)</CustomAfterMicrosoftCommonProps>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCommonProps)" Condition="'$(CustomBeforeMicrosoftCommonProps)' != '' and Exists('$(CustomBeforeMicrosoftCommonProps)')" />-->
  <!-- This is used to determine whether Microsoft.Common.targets needs to import
      Microsoft.Common.props itself, or whether it has been imported previously,
      e.g. by the project itself. -->
  <PropertyGroup>
    <MicrosoftCommonPropsHasBeenImported>true</MicrosoftCommonPropsHasBeenImported>
  </PropertyGroup>
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' and '$(DefaultProjectConfiguration)' != '' ">$(DefaultProjectConfiguration)</Configuration>
    <Platform Condition=" '$(Platform)' == '' and '$(DefaultProjectPlatform)' != '' ">$(DefaultProjectPlatform)</Platform>
  </PropertyGroup>
  <PropertyGroup>
    <WMSJSProject Condition="'$(WMSJSProject)' == ''">WJProject</WMSJSProject>
    <WMSJSProjectDirectory Condition="'$(WMSJSProjectDirectory)' == ''">JavaScript</WMSJSProjectDirectory>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" />-->
  <!--<Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')" />-->
  <!--
      Import NuGet.props file.
  -->
  <PropertyGroup>
    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
    <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
    <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPropsFile)" Condition="Exists('$(NuGetPropsFile)')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/NuGet.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
      Import 'Directory.Packages.props' which will contain centralized packages for all the projects and solutions under
      the directory in which the file is present. This is similar to 'Directory.Build.props/targets' logic which is present
      in the common props/targets which serve a similar purpose.
  -->
  <PropertyGroup>
    <ImportDirectoryPackagesProps Condition="'$(ImportDirectoryPackagesProps)' == ''">true</ImportDirectoryPackagesProps>
  </PropertyGroup>
  <!--
      Determine the path to the 'Directory.Packages.props' file, if the user did not disable $(ImportDirectoryPackagesProps) and
      they did not already specify an absolute path to use via $(DirectoryPackagesPropsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' == ''">
    <_DirectoryPackagesPropsFile Condition="'$(_DirectoryPackagesPropsFile)' == ''">Directory.Packages.props</_DirectoryPackagesPropsFile>
    <_DirectoryPackagesPropsBasePath Condition="'$(_DirectoryPackagesPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove('$(MSBuildProjectDirectory)', '$(_DirectoryPackagesPropsFile)'))</_DirectoryPackagesPropsBasePath>
    <DirectoryPackagesPropsPath Condition="'$(_DirectoryPackagesPropsBasePath)' != '' and '$(_DirectoryPackagesPropsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryPackagesPropsBasePath)', '$(_DirectoryPackagesPropsFile)'))</DirectoryPackagesPropsPath>
  </PropertyGroup>
  <!--<Import Project="$(DirectoryPackagesPropsPath)" Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' != '' and Exists('$(DirectoryPackagesPropsPath)')" />-->
  <PropertyGroup Condition="'$(ImportDirectoryPackagesProps)' == 'true' and '$(DirectoryPackagesPropsPath)' != '' and Exists('$(DirectoryPackagesPropsPath)')">
    <CentralPackageVersionsFileImported>true</CentralPackageVersionsFileImported>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.props
============================================================================================================================================
-->
  <PropertyGroup Condition=" '$(MSBuildLogVerboseTaskParameters)' != 'true' ">
    <DisableLogTaskParameter_ConvertToAbsolutePath_Path>true</DisableLogTaskParameter_ConvertToAbsolutePath_Path>
    <DisableLogTaskParameter_FindUnderPath_OutOfPath>true</DisableLogTaskParameter_FindUnderPath_OutOfPath>
    <DisableLogTaskParameter_RemoveDuplicates_Inputs>true</DisableLogTaskParameter_RemoveDuplicates_Inputs>
    <DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>true</DisableLogTaskParameterItemMetadata_ConvertToAbsolutePath_AbsolutePaths>
    <DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>true</DisableLogTaskParameterItemMetadata_Copy_CopiedFiles>
    <DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>true</DisableLogTaskParameterItemMetadata_Copy_DestinationFiles>
    <DisableLogTaskParameterItemMetadata_Copy_SourceFiles>true</DisableLogTaskParameterItemMetadata_Copy_SourceFiles>
    <DisableLogTaskParameterItemMetadata_FindUnderPath_Files>true</DisableLogTaskParameterItemMetadata_FindUnderPath_Files>
    <DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>true</DisableLogTaskParameterItemMetadata_FindUnderPath_InPath>
    <DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>true</DisableLogTaskParameterItemMetadata_GenerateResource_FilesWritten>
    <DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>true</DisableLogTaskParameterItemMetadata_Hash_ItemsToHash>
    <DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>true</DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>
    <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- This property disables the conflict resolution logic from the Microsoft.Packaging.Tools package, which is superceded by the logic here in the SDK -->
    <DisableHandlePackageFileConflicts>true</DisableHandlePackageFileConflicts>
  </PropertyGroup>
  <!-- Default configuration and platform to Debug|AnyCPU-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Configurations Condition=" '$(Configurations)' == '' ">Debug;Release</Configurations>
    <Platforms Condition=" '$(Platforms)' == '' ">AnyCPU</Platforms>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
  </PropertyGroup>
  <!-- Default the value of PackRelease for every project. Note that this is pre-evaluated by the CLI in an evaluation before evaluation (see ReleasePropertyProjectLocator.cs).
  Multitargeting pack splits a single 2 TFM project into 9 separate evaluations, with different target imports. Microsoft.NET.SDK.DefaultItems.Targets ...
  is where PublishRelease is defaulted because it depends on _TargetFrameworkVersionWithoutV. Some targets do not run in some instances of dotnet pack.
  So, we must set PackRelease here. Even though this occurs before project import, the project import can override PackRelease later, before the pre-evaluation, so this is fine.-->
  <PropertyGroup Condition="'$(PackRelease)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Do not depend on this value being correct until after project evaluation.-->
    <PackRelease>true</PackRelease>
  </PropertyGroup>
  <!-- User-facing configuration-agnostic defaults -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <OutputType Condition=" '$(OutputType)' == '' ">Library</OutputType>
    <FileAlignment Condition=" '$(FileAlignment)' == '' ">512</FileAlignment>
    <ErrorReport Condition=" '$(ErrorReport)' == '' ">prompt</ErrorReport>
    <AssemblyName Condition=" '$(AssemblyName)' == '' ">$(MSBuildProjectName)</AssemblyName>
    <RootNamespace Condition=" '$(RootNamespace)' == '' ">$(MSBuildProjectName.Replace(" ", "_"))</RootNamespace>
    <Deterministic Condition=" '$(Deterministic)' == '' ">true</Deterministic>
  </PropertyGroup>
  <!-- User-facing configuration-specific defaults -->
  <PropertyGroup Condition=" '$(Configuration)' == 'Debug' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DebugSymbols Condition=" '$(DebugSymbols)' == '' ">true</DebugSymbols>
    <Optimize Condition=" '$(Optimize)' == '' ">false</Optimize>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)' == 'Release' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Optimize Condition=" '$(Optimize)' == '' ">true</Optimize>
  </PropertyGroup>
  <!-- User-facing platform-specific defaults -->
  <!--
    NOTE:

     * We cannot compare against $(Platform) directly as that will give VS cause to instantiate extra
       configurations, for each combination, which leads to performance problems and clutter in the sln
       in the common AnyCPU-only case.

     * We cannot just set $(PlatformTarget) to $(Platform) here because $(Platform) can be set to anything
       at the solution level, but there are a fixed set valid $(PlatformTarget) values that can be passed
       to the compiler. It is up to the user to explicitly set PlatformTarget to non-AnyCPU (if desired)
       outside the 1:1 defaults below.
  -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_PlatformWithoutConfigurationInference>$(Platform)</_PlatformWithoutConfigurationInference>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(_PlatformWithoutConfigurationInference)' == 'x64' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PlatformTarget Condition=" '$(PlatformTarget)' == '' ">x64</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(_PlatformWithoutConfigurationInference)' == 'x86' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PlatformTarget Condition=" '$(PlatformTarget)' == '' ">x86</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(_PlatformWithoutConfigurationInference)' == 'ARM' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PlatformTarget Condition=" '$(PlatformTarget)' == '' ">ARM</PlatformTarget>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(_PlatformWithoutConfigurationInference)' == 'arm64' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PlatformTarget Condition=" '$(PlatformTarget)' == '' ">arm64</PlatformTarget>
  </PropertyGroup>
  <!-- Default settings for all projects built with this Sdk package -->
  <PropertyGroup Condition=" '$(AssemblySearchPaths)' == '' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- By default exclude GAC, registry, output directory from search paths. -->
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseCandidateAssemblyFiles)' != 'false'">{CandidateAssemblyFiles}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseHintPathFromItem)' != 'false'">$(AssemblySearchPaths);{HintPathFromItem}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseTargetFrameworkDirectory)' != 'false'">$(AssemblySearchPaths);{TargetFrameworkDirectory}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRawFileName)' != 'false'">$(AssemblySearchPaths);{RawFileName}</AssemblySearchPaths>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DebugType Condition="'$(DebugSymbols)' == 'false'">None</DebugType>
    <DebugType Condition=" '$(DebugType)' == '' ">portable</DebugType>
    <!-- This will turn off the base UWP-specific 'ResolveNuGetPackages' target -->
    <ResolveNuGetPackages>false</ResolveNuGetPackages>
    <!-- Skip import of Microsoft.NuGet.props and Microsoft.NuGet.targets -->
    <SkipImportNuGetProps>true</SkipImportNuGetProps>
    <SkipImportNuGetBuildTargets>true</SkipImportNuGetBuildTargets>
    <!-- NuGet should always restore .NET SDK projects with "PackageReference" style restore.  Setting this property will
         cause the right thing to happen even if there aren't any PackageReference items in the project, such as when
         a project targets .NET Framework and doesn't have any direct package dependencies. -->
    <RestoreProjectStyle>PackageReference</RestoreProjectStyle>
    <DesignTimeAssemblySearchPaths Condition=" '$(DesignTimeAssemblySearchPaths)' == '' ">$(AssemblySearchPaths)</DesignTimeAssemblySearchPaths>
    <AllowUnsafeBlocks Condition="'$(AllowUnsafeBlocks)'==''">false</AllowUnsafeBlocks>
    <TreatWarningsAsErrors Condition="'$(TreatWarningsAsErrors)'==''">false</TreatWarningsAsErrors>
    <Prefer32Bit Condition="'$(Prefer32Bit)'==''">false</Prefer32Bit>
    <PreferNativeArm64 Condition="'$(PreferNativeArm64)'==''">false</PreferNativeArm64>
    <SignAssembly Condition="'$(SignAssembly)'==''">false</SignAssembly>
    <DelaySign Condition="'$(DelaySign)'==''">false</DelaySign>
    <GeneratePackageOnBuild Condition="'$(GeneratePackageOnBuild)'==''">false</GeneratePackageOnBuild>
    <PackageRequireLicenseAcceptance Condition="'$(PackageRequireLicenseAcceptance)'==''">false</PackageRequireLicenseAcceptance>
    <DebugSymbols Condition="'$(DebugSymbols)'==''">false</DebugSymbols>
    <CheckForOverflowUnderflow Condition="'$(CheckForOverflowUnderflow)'==''">false</CheckForOverflowUnderflow>
    <AutomaticallyUseReferenceAssemblyPackages Condition="'$(AutomaticallyUseReferenceAssemblyPackages)'==''">true</AutomaticallyUseReferenceAssemblyPackages>
    <MicrosoftNETFrameworkReferenceAssembliesLatestPackageVersion>1.0.3</MicrosoftNETFrameworkReferenceAssembliesLatestPackageVersion>
    <CopyConflictingTransitiveContent>false</CopyConflictingTransitiveContent>
    <MSBuildCopyContentTransitively Condition="'$(MSBuildCopyContentTransitively)' == ''">true</MSBuildCopyContentTransitively>
    <ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts Condition="'$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)' == ''">true</ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts>
    <!-- Uncomment this once https://github.com/Microsoft/visualfsharp/issues/3207 gets fixed -->
    <!-- <WarningsAsErrors>$(WarningsAsErrors);NU1605</WarningsAsErrors> -->
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Path to project that the .NET CLI will build in order to generate deps.json files for .NET CLI tools -->
    <ToolDepsJsonGeneratorProject>$(MSBuildThisFileDirectory)GenerateDeps\GenerateDeps.proj</ToolDepsJsonGeneratorProject>
  </PropertyGroup>
  <!-- Default item includes (globs and implicit references) -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.DefaultItems.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.DefaultItems.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(NETCoreSdkBundledVersionsProps)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETCoreSdkBundledVersionsProps>$(MSBuildThisFileDirectory)..\..\..\Microsoft.NETCoreSdk.BundledVersions.props</NETCoreSdkBundledVersionsProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NETCoreSdkBundledVersionsProps)" Condition="Exists('$(NETCoreSdkBundledVersionsProps)')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.NETCoreSdk.BundledVersions.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NETCoreSdk.BundledVersions.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <NetCoreRoot Condition="'$(NetCoreRoot)' == ''">$([MSBuild]::NormalizePath('$(MSBuildThisFileDirectory)../../'))</NetCoreRoot>
    <NetCoreTargetingPackRoot Condition="'$(NetCoreTargetingPackRoot)' == ''">$([MSBuild]::EnsureTrailingSlash('$(NetCoreRoot)'))packs</NetCoreTargetingPackRoot>
    <PrunePackageDataRoot Condition="'$(PrunePackageDataRoot)' == ''">$([MSBuild]::EnsureTrailingSlash('$(MSBuildThisFileDirectory)'))PrunePackageData</PrunePackageDataRoot>
    <_NetFrameworkHostedCompilersVersion>5.0.0-1.25322.101</_NetFrameworkHostedCompilersVersion>
    <NETCoreAppMaximumVersion>10.0</NETCoreAppMaximumVersion>
    <BundledNETCoreAppTargetFrameworkVersion>10.0</BundledNETCoreAppTargetFrameworkVersion>
    <BundledNETCoreAppPackageVersion>10.0.0-preview.7.25322.101</BundledNETCoreAppPackageVersion>
    <BundledNETStandardTargetFrameworkVersion>2.1</BundledNETStandardTargetFrameworkVersion>
    <BundledNETStandardPackageVersion>2.1.0</BundledNETStandardPackageVersion>
    <BundledNETCorePlatformsPackageVersion>10.0.0-preview.7.25322.101</BundledNETCorePlatformsPackageVersion>
    <BundledRuntimeIdentifierGraphFile>$(MSBuildThisFileDirectory)RuntimeIdentifierGraph.json</BundledRuntimeIdentifierGraphFile>
    <NETCoreSdkVersion>10.0.100-preview.7.25322.101</NETCoreSdkVersion>
    <SdkAnalysisLevel>10.0.100</SdkAnalysisLevel>
    <NETCoreSdkRuntimeIdentifier>linux-x64</NETCoreSdkRuntimeIdentifier>
    <NETCoreSdkPortableRuntimeIdentifier>linux-x64</NETCoreSdkPortableRuntimeIdentifier>
    <_NETCoreSdkIsPreview>true</_NETCoreSdkIsPreview>
  </PropertyGroup>
  <ItemGroup>
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="1.0" DefaultVersion="1.0.5" LatestVersion="1.0.16" />
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="1.1" DefaultVersion="1.1.2" LatestVersion="1.1.13" />
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="2.0" DefaultVersion="2.0.0" LatestVersion="2.0.9" />
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="2.1" DefaultVersion="2.1.0" LatestVersion="2.1.30" />
    <ImplicitPackageReferenceVersion Include="Microsoft.NETCore.App" TargetFrameworkVersion="2.2" DefaultVersion="2.2.0" LatestVersion="2.2.8" />
    <ImplicitPackageReferenceVersion Include="Microsoft.AspNetCore.App" TargetFrameworkVersion="2.1" DefaultVersion="2.1.1" LatestVersion="2.1.30" />
    <ImplicitPackageReferenceVersion Include="Microsoft.AspNetCore.All" TargetFrameworkVersion="2.1" DefaultVersion="2.1.1" LatestVersion="2.1.30" />
    <ImplicitPackageReferenceVersion Include="Microsoft.AspNetCore.App" TargetFrameworkVersion="2.2" DefaultVersion="2.2.0" LatestVersion="2.2.8" />
    <ImplicitPackageReferenceVersion Include="Microsoft.AspNetCore.All" TargetFrameworkVersion="2.2" DefaultVersion="2.2.0" LatestVersion="2.2.8" />
    <!-- .NET 10.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="10.0.0-preview.7.25322.101" LatestRuntimeFrameworkVersion="10.0.0-preview.7.25322.101" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="10.0.0-preview.7.25322.101" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-musl-loongarch64;android-arm64;android-x64" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net10.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="10.0.0-preview.7.25322.101" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-musl-loongarch64" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net10.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="10.0.0-preview.7.25322.101" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm64;win-x86;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" />
    <KnownILCompilerPack Include="Microsoft.DotNet.ILCompiler" TargetFramework="net10.0" ILCompilerPackNamePattern="runtime.**RID**.Microsoft.DotNet.ILCompiler" ILCompilerPackVersion="10.0.0-preview.7.25322.101" ILCompilerRuntimeIdentifiers="linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;win-arm64;win-x64;osx-x64;osx-arm64;freebsd-x64;freebsd-arm64;linux-arm;linux-musl-arm;linux-loongarch64;linux-musl-loongarch64;win-x86;linux-riscv64;linux-musl-riscv64" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="10.0.0-preview.7.25322.101" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.NativeAOT.**RID**" RuntimePackRuntimeIdentifiers="ios-arm64;iossimulator-arm64;iossimulator-x64;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-arm64;maccatalyst-x64;linux-bionic-arm64;linux-bionic-x64;osx-arm64;osx-x64;freebsd-arm64;freebsd-x64;linux-x64;linux-arm;linux-arm64;linux-loongarch64;linux-bionic-arm;linux-musl-x64;linux-musl-arm;linux-musl-arm64;linux-musl-loongarch64;win-x64;win-x86;win-arm64;browser-wasm;wasi-wasm;linux-riscv64;linux-musl-riscv64" RuntimePackLabels="NativeAOT" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net10.0" ILLinkPackVersion="10.0.0-preview.7.25322.101" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net10.0" WebAssemblySdkPackVersion="10.0.0-preview.7.25322.101" />
    <KnownAspNetCorePack Include="Microsoft.AspNetCore.App.Internal.Assets" TargetFramework="net10.0" AspNetCorePackVersion="10.0.0-preview.7.25322.101" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="10.0.0-preview.7.25322.101" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86;freebsd-x64;freebsd-arm64;wasi-wasm;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="10.0.0-preview.6.25316.103" LatestRuntimeFrameworkVersion="10.0.0-preview.6.25316.103" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="10.0.0-preview.6.25316.103" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="10.0.0-preview.6.25316.103" LatestRuntimeFrameworkVersion="10.0.0-preview.6.25316.103" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="10.0.0-preview.6.25316.103" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="10.0.0-preview.6.25316.103" LatestRuntimeFrameworkVersion="10.0.0-preview.6.25316.103" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="10.0.0-preview.6.25316.103" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net10.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="10.0.0-preview.7.25322.101" LatestRuntimeFrameworkVersion="10.0.0-preview.7.25322.101" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="10.0.0-preview.7.25322.101" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" RuntimePackExcludedRuntimeIdentifiers="android;linux-bionic" />
    <!-- .NET 9.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.5" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="9.0.5" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-musl-loongarch64" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net9.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="9.0.5" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-musl-loongarch64" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net9.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="9.0.5" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm64;win-x86;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" />
    <KnownILCompilerPack Include="Microsoft.DotNet.ILCompiler" TargetFramework="net9.0" ILCompilerPackNamePattern="runtime.**RID**.Microsoft.DotNet.ILCompiler" ILCompilerPackVersion="9.0.5" ILCompilerRuntimeIdentifiers="linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;win-arm64;win-x64;osx-x64;osx-arm64;freebsd-x64;freebsd-arm64;linux-arm;linux-musl-arm;linux-loongarch64;linux-musl-loongarch64;win-x86" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="9.0.5" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.NativeAOT.**RID**" RuntimePackRuntimeIdentifiers="ios-arm64;iossimulator-arm64;iossimulator-x64;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-arm64;maccatalyst-x64;linux-bionic-arm64;linux-bionic-x64;osx-arm64;osx-x64;freebsd-arm64;freebsd-x64;linux-x64;linux-arm;linux-arm64;linux-loongarch64;linux-bionic-arm;linux-musl-x64;linux-musl-arm;linux-musl-arm64;linux-musl-loongarch64;win-x64;win-x86;win-arm64;browser-wasm;wasi-wasm" RuntimePackLabels="NativeAOT" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net9.0" ILLinkPackVersion="9.0.5" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net9.0" WebAssemblySdkPackVersion="10.0.0-preview.7.25322.101" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="9.0.5" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86;freebsd-x64;freebsd-arm64;wasi-wasm;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.5" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="9.0.5" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.5" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="9.0.5" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.5" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="9.0.5" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net9.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="9.0.0" LatestRuntimeFrameworkVersion="9.0.5" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="9.0.5" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64;linux-ppc64le;freebsd-x64;freebsd-arm64;linux-riscv64;linux-musl-riscv64;linux-loongarch64;linux-musl-loongarch64" RuntimePackExcludedRuntimeIdentifiers="android;linux-bionic" />
    <!-- .NET 8.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.16" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="8.0.16" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net8.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="8.0.16" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le;freebsd-x64;freebsd-arm64" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net8.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="8.0.16" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm64;win-x86;freebsd-x64;freebsd-arm64" />
    <KnownILCompilerPack Include="Microsoft.DotNet.ILCompiler" TargetFramework="net8.0" ILCompilerPackNamePattern="runtime.**RID**.Microsoft.DotNet.ILCompiler" ILCompilerPackVersion="8.0.16" ILCompilerRuntimeIdentifiers="linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;win-arm64;win-x64;osx-x64;osx-arm64;freebsd-x64;freebsd-arm64" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="8.0.16" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.NativeAOT.**RID**" RuntimePackRuntimeIdentifiers="ios-arm64;iossimulator-arm64;iossimulator-x64;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-arm64;maccatalyst-x64;linux-bionic-arm64;linux-bionic-x64;osx-arm64;osx-x64;freebsd-arm64;freebsd-x64" RuntimePackLabels="NativeAOT" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net8.0" ILLinkPackVersion="8.0.16" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net8.0" WebAssemblySdkPackVersion="10.0.0-preview.7.25322.101" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="8.0.16" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86;freebsd-x64;freebsd-arm64;wasi-wasm" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.16" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="8.0.16" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.16" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="8.0.16" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.16" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="8.0.16" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net8.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="8.0.0" LatestRuntimeFrameworkVersion="8.0.16" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="8.0.16" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64;linux-ppc64le;freebsd-x64;freebsd-arm64" RuntimePackExcludedRuntimeIdentifiers="android;linux-bionic" />
    <!-- .NET 7.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net7.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="7.0.20" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;linux-bionic-arm;linux-bionic-arm64;linux-bionic-x64;linux-bionic-x86;linux-ppc64le" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net7.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="7.0.20" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm;win-arm64;win-x86" />
    <KnownILCompilerPack Include="Microsoft.DotNet.ILCompiler" TargetFramework="net7.0" ILCompilerPackNamePattern="runtime.**RID**.Microsoft.DotNet.ILCompiler" ILCompilerPackVersion="7.0.20" ILCompilerRuntimeIdentifiers="linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;win-arm64;win-x64" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net7.0" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net7.0" WebAssemblySdkPackVersion="10.0.0-preview.7.25322.101" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="7.0.20" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net7.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="7.0.0" LatestRuntimeFrameworkVersion="7.0.20" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="7.0.20" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64;linux-ppc64le" RuntimePackExcludedRuntimeIdentifiers="android" />
    <!-- .NET 6.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net6.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="6.0.36" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64" ExcludedRuntimeIdentifiers="android" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net6.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="6.0.36" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64;linux-arm;linux-arm64;linux-musl-arm;linux-musl-arm64;osx-arm64;osx-x64;win-arm;win-arm64;win-x86" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net6.0" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownWebAssemblySdkPack Include="Microsoft.NET.Sdk.WebAssembly.Pack" TargetFramework="net6.0" WebAssemblySdkPackVersion="10.0.0-preview.7.25322.101" />
    <KnownRuntimePack Include="Microsoft.NETCore.App" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.NETCore.App" LatestRuntimeFrameworkVersion="6.0.36" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.Mono.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;osx-arm64;linux-s390x;linux-loongarch64;browser-wasm;ios-arm64;ios-arm;iossimulator-arm64;iossimulator-x64;iossimulator-x86;tvos-arm64;tvossimulator-arm64;tvossimulator-x64;maccatalyst-x64;maccatalyst-arm64;android-arm64;android-arm;android-x64;android-x86" RuntimePackLabels="Mono" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net6.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="6.0.0" LatestRuntimeFrameworkVersion="6.0.36" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="6.0.36" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64;osx-arm64;linux-s390x;linux-loongarch64" />
    <!-- .NET 5.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm;browser-wasm" IsTrimmable="true" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="net5.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="5.0.17" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86;linux-musl-arm" />
    <KnownCrossgen2Pack Include="Microsoft.NETCore.App.Crossgen2" TargetFramework="net5.0" Crossgen2PackNamePattern="Microsoft.NETCore.App.Crossgen2.**RID**" Crossgen2PackVersion="5.0.17" Crossgen2RuntimeIdentifiers="linux-musl-x64;linux-x64;win-x64" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="net5.0" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm64" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="net5.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="5.0.0" LatestRuntimeFrameworkVersion="5.0.17" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="5.0.0" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;linux-musl-arm;win-arm64" />
    <!-- .NET Core 3.1  -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="3.1.0" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86" IsTrimmable="true" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="netcoreapp3.1" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="3.1.32" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="netcoreapp3.1" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.1.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.1.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.1.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="netcoreapp3.1" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="3.1.0" LatestRuntimeFrameworkVersion="3.1.32" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="3.1.10" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64" />
    <!-- .NET Core 3.0 -->
    <KnownFrameworkReference Include="Microsoft.NETCore.App" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.NETCore.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.NETCore.App.Ref" TargetingPackVersion="3.0.0" RuntimePackNamePatterns="Microsoft.NETCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86" IsTrimmable="true" />
    <KnownAppHostPack Include="Microsoft.NETCore.App" TargetFramework="netcoreapp3.0" AppHostPackNamePattern="Microsoft.NETCore.App.Host.**RID**" AppHostPackVersion="3.0.3" AppHostRuntimeIdentifiers="linux-arm;linux-arm64;linux-musl-arm64;linux-musl-x64;linux-x64;osx-x64;tizen.4.0.0-armel;tizen.5.0.0-armel;win-arm;win-arm64;win-x64;win-x86" />
    <KnownILLinkPack Include="Microsoft.NET.ILLink.Tasks" TargetFramework="netcoreapp3.0" ILLinkPackVersion="7.0.100-1.23211.1" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" Profile="WPF" />
    <KnownFrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.WindowsDesktop.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.WindowsDesktop.App.Ref" TargetingPackVersion="3.0.0" RuntimePackNamePatterns="Microsoft.WindowsDesktop.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86" IsWindowsOnly="true" Profile="WindowsForms" />
    <KnownFrameworkReference Include="Microsoft.AspNetCore.App" TargetFramework="netcoreapp3.0" RuntimeFrameworkName="Microsoft.AspNetCore.App" DefaultRuntimeFrameworkVersion="3.0.0" LatestRuntimeFrameworkVersion="3.0.3" TargetingPackName="Microsoft.AspNetCore.App.Ref" TargetingPackVersion="3.0.1" RuntimePackNamePatterns="Microsoft.AspNetCore.App.Runtime.**RID**" RuntimePackRuntimeIdentifiers="win-x64;win-x86;win-arm;osx-x64;linux-musl-x64;linux-musl-arm64;linux-x64;linux-arm;linux-arm64" />
    <KnownFrameworkReference Include="NETStandard.Library" TargetFramework="netstandard2.1" TargetingPackName="NETStandard.Library.Ref" TargetingPackVersion="2.1.0" />
    <!-- Supported Windows versions -->
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.26100.0" WindowsSdkPackageVersion="10.0.26100.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22621.0" WindowsSdkPackageVersion="10.0.22621.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22000.0" WindowsSdkPackageVersion="10.0.22000.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.20348.0" WindowsSdkPackageVersion="10.0.20348.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.19041.0" WindowsSdkPackageVersion="10.0.19041.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.18362.0" WindowsSdkPackageVersion="10.0.18362.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.17763.0" WindowsSdkPackageVersion="10.0.17763.57" MinimumNETVersion="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.26100.0" WindowsSdkPackageVersion="10.0.26100.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22621.0" WindowsSdkPackageVersion="10.0.22621.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22000.0" WindowsSdkPackageVersion="10.0.22000.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.20348.0" WindowsSdkPackageVersion="10.0.20348.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.19041.0" WindowsSdkPackageVersion="10.0.19041.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.18362.0" WindowsSdkPackageVersion="10.0.18362.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.17763.0" WindowsSdkPackageVersion="10.0.17763.55" MinimumNETVersion="6.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.22000.0" WindowsSdkPackageVersion="10.0.22000.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.20348.0" WindowsSdkPackageVersion="10.0.20348.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.19041.0" WindowsSdkPackageVersion="10.0.19041.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.18362.0" WindowsSdkPackageVersion="10.0.18362.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.17763.0" WindowsSdkPackageVersion="10.0.17763.26" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="7.0" />
    <_KnownRuntimeIdentiferPlatforms Include="any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix;any;aot;freebsd;illumos;solaris;unix" />
    <_ExcludedKnownRuntimeIdentiferPlatforms Include="rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;rhel.6;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0;tizen.4.0.0;tizen.5.0.0" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.props
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(NETCoreSdkBundledMSBuildInformationProps)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETCoreSdkBundledMSBuildInformationProps>$(MSBuildThisFileDirectory)..\..\..\Microsoft.NETCoreSdk.BundledMSBuildInformation.props</NETCoreSdkBundledMSBuildInformationProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NETCoreSdkBundledMSBuildInformationProps)" Condition="Exists('$(NETCoreSdkBundledMSBuildInformationProps)')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.NETCoreSdk.BundledMSBuildInformation.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NETCoreSdk.BundledMSBuildInformation.props
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.
Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <MinimumMSBuildVersion>17.13.0</MinimumMSBuildVersion>
    <BundledMSBuildVersion>17.15.0</BundledMSBuildVersion>
    <_MSBuildVersionMajorMinor>$([System.Version]::Parse('$(MSBuildVersion)').ToString(2))</_MSBuildVersionMajorMinor>
    <_IsDisjointMSBuildVersion>$([MSBuild]::VersionLessThan('$(_MSBuildVersionMajorMinor)', '17.15'))</_IsDisjointMSBuildVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.props
============================================================================================================================================
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Disable web SDK implicit package versions for ASP.NET packages, since the .NET SDK now handles that -->
    <EnableWebSdkImplicitPackageVersions>false</EnableWebSdkImplicitPackageVersions>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <__WindowsAppSdkDefaultImageIncludes>**/*.png;**/*.bmp;**/*.jpg;**/*.dds;**/*.tif;**/*.tga;**/*.gif</__WindowsAppSdkDefaultImageIncludes>
  </PropertyGroup>
  <ItemGroup Condition=" '$(EnableDefaultItems)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Compile Include="**/*$(DefaultLanguageSourceExtension)" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" Condition=" '$(EnableDefaultCompileItems)' == 'true' " />
    <EmbeddedResource Include="**/*.resx" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" Condition=" '$(EnableDefaultEmbeddedResourceItems)' == 'true' " />
    <!-- Microsoft.WindowsAppSDK is a NuGet delivered SDK. EnableDefaultWindowsAppSdkContentItems and EnableDefaultWindowsAppSdkPRIResourceItems are overridable properties that the SDK will set to true by default. -->
    <Content Include="$(__WindowsAppSdkDefaultImageIncludes)" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" Condition=" '$(EnableDefaultContentItems)' != 'false' And '$(EnableDefaultWindowsAppSdkContentItems)' == 'true' " />
    <PRIResource Include="**/*.resw" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" Condition=" '$(EnableDefaultPRIResourceItems)' != 'false' And '$(EnableDefaultWindowsAppSdkPRIResourceItems)' == 'true' " />
  </ItemGroup>
  <ItemGroup Condition=" '$(EnableDefaultItems)' == 'true' And '$(EnableDefaultNoneItems)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <None Include="**/*" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />
    <None Remove="**/*$(DefaultLanguageSourceExtension)" />
    <None Remove="**/*.resx" />
    <!-- Microsoft.WindowsAppSDK is a NuGet delivered SDK. EnableDefaultWindowsAppSdkContentItems and EnableDefaultWindowsAppSdkPRIResourceItems are overridable properties that the SDK will set to true by default. -->
    <None Remove="$(__WindowsAppSdkDefaultImageIncludes)" Condition=" '$(EnableDefaultWindowsAppSdkContentItems)' == 'true' " />
    <None Remove="**/*.resw" Condition=" '$(EnableDefaultWindowsAppSdkPRIResourceItems)' == 'true' " />
  </ItemGroup>
  <!-- Automatically reference NETStandard.Library or Microsoft.NETCore.App package if targeting the corresponding target framework.
      We can refer here in the .props file to properties set in the .targets files because items and their conditions are
      evaluated in the second pass of evaluation, after all properties have been evaluated. -->
  <ItemGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(_TargetFrameworkVersionWithoutV)' &lt; '2.1'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageReference Include="NETStandard.Library" Version="$(NETStandardImplicitPackageVersion)" IsImplicitlyDefined="true" />
    <!-- If targeting .NET Standard 2.0 or higher, then don't include a dependency on NETStandard.Library in the package produced by pack -->
    <PackageReference Update="NETStandard.Library" Condition=" ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '2.0') " PrivateAssets="All" Publish="true" />
  </ItemGroup>
  <ItemGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(_TargetFrameworkVersionWithoutV)' &gt;= '2.1'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FrameworkReference Include="NETStandard.Library" IsImplicitlyDefined="true" Pack="false" PrivateAssets="All" />
  </ItemGroup>
  <ItemGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Use implicit PackageReference for Microsoft.NETCore.App on versions prior to 3.0.  For 3.0 or higher, use
         an implicit FrameworkReference -->
    <PackageReference Include="Microsoft.NETCore.App" IsImplicitlyDefined="true" Condition="('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &lt; '3.0')" />
    <!-- For targeting .NET Core 2.0 or higher, don't include a dependency on Microsoft.NETCore.App in the package produced by pack.
         Packing an DotnetCliTool should include the Microsoft.NETCore.App package dependency. -->
    <PackageReference Update="Microsoft.NETCore.App" Condition="('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '2.0') And ('$(PackageType)' != 'DotnetCliTool')" PrivateAssets="All" Publish="true" />
    <FrameworkReference Include="Microsoft.NETCore.App" IsImplicitlyDefined="true" Pack="false" PrivateAssets="All" Condition="('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0')" />
    <!-- Allow opt-in to Mono runtime pack for .NET 6.0 or higher -->
    <FrameworkReference Update="Microsoft.NETCore.App" RuntimePackLabels="Mono" Condition="'$(UseMonoRuntime)' == 'true' And ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '6.0')" />
    <!-- Allow opt-in to NativeAOT runtime pack for .NET 8.0 or higher -->
    <FrameworkReference Update="Microsoft.NETCore.App" RuntimePackLabels="NativeAOT" Condition="'$(_IsPublishing)' == 'true' and '$(PublishAotUsingRuntimePack)' == 'true' And ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '8.0')" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!-- Put workload resolution behind a feature flag.  It can be enabled either by setting the MSBuildEnableWorkloadResolver environment variable to true, or by
       putting an EnableWorkloadResolver.sentinel file beside the MSBuild SDK resolver DLL -->
  <PropertyGroup Condition="'$(MSBuildEnableWorkloadResolver)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <__DisableWorkloadResolverSentinelPath Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildBinPath)\DisableWorkloadResolver.sentinel</__DisableWorkloadResolverSentinelPath>
    <__DisableWorkloadResolverSentinelPath Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildToolsPath32)\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\DisableWorkloadResolver.sentinel</__DisableWorkloadResolverSentinelPath>
    <MSBuildEnableWorkloadResolver Condition="!Exists('$(__DisableWorkloadResolverSentinelPath)')">true</MSBuildEnableWorkloadResolver>
  </PropertyGroup>
  <!-- Import workload props -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.ImportWorkloads.props" Condition="'$(MSBuildEnableWorkloadResolver)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.ImportWorkloads.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.ImportWorkloads.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import workload props -->
  <!--<Import Project="AutoImport.props" Sdk="Microsoft.NET.SDK.WorkloadAutoImportPropsLocator" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!-- List of supported .NET Core and .NET Standard TFMs -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.SupportedTargetFrameworks.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.SupportedTargetFrameworks.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.SupportedTargetFrameworks.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This file contains a list of the TFMs that are supported by this SDK for .NET Core, .NET Standard, and .NET Framework.
     This is used by VS to show the list of frameworks to which projects can be retargeted. -->
  <!-- .NET Core App -->
  <ItemGroup>
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v1.0" DisplayName=".NET Core 1.0" Alias="netcoreapp1.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v1.1" DisplayName=".NET Core 1.1" Alias="netcoreapp1.1" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.0" DisplayName=".NET Core 2.0" Alias="netcoreapp2.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.1" DisplayName=".NET Core 2.1" Alias="netcoreapp2.1" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.2" DisplayName=".NET Core 2.2" Alias="netcoreapp2.2" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v3.0" DisplayName=".NET Core 3.0" Alias="netcoreapp3.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v3.1" DisplayName=".NET Core 3.1" Alias="netcoreapp3.1" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v5.0" DisplayName=".NET 5.0" Alias="net5.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v6.0" DisplayName=".NET 6.0" Alias="net6.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v7.0" DisplayName=".NET 7.0" Alias="net7.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v8.0" DisplayName=".NET 8.0" Alias="net8.0" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v9.0" DisplayName=".NET 9.0" Alias="net9.0" Condition="$([MSBuild]::VersionGreaterThanOrEquals($(MSBuildVersion), '17.12.0'))" />
    <SupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v10.0" DisplayName=".NET 10.0" Alias="net10.0" />
  </ItemGroup>
  <PropertyGroup>
    <!-- This is for a better error experience when using an older VS (with an older SDK) to target a newer TFM. The value should be the min VS version for N+1 version-->
    <UnsupportedTargetFrameworkVersion>$([MSBuild]::Add($(NETCoreAppMaximumVersion), 1)).0</UnsupportedTargetFrameworkVersion>
    <MinimumVisualStudioVersionForUnsupportedTargetFrameworkVersion>17.16</MinimumVisualStudioVersionForUnsupportedTargetFrameworkVersion>
  </PropertyGroup>
  <!-- .NET Standard -->
  <ItemGroup>
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.0" DisplayName=".NET Standard 1.0" Alias="netstandard1.0" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.1" DisplayName=".NET Standard 1.1" Alias="netstandard1.1" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.2" DisplayName=".NET Standard 1.2" Alias="netstandard1.2" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.3" DisplayName=".NET Standard 1.3" Alias="netstandard1.3" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.4" DisplayName=".NET Standard 1.4" Alias="netstandard1.4" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.5" DisplayName=".NET Standard 1.5" Alias="netstandard1.5" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v1.6" DisplayName=".NET Standard 1.6" Alias="netstandard1.6" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v2.0" DisplayName=".NET Standard 2.0" Alias="netstandard2.0" />
    <SupportedNETStandardTargetFramework Include=".NETStandard,Version=v2.1" DisplayName=".NET Standard 2.1" Alias="netstandard2.1" />
  </ItemGroup>
  <!-- .NET Framework -->
  <ItemGroup>
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v2.0" DisplayName=".NET Framework 2.0" Alias="net20" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v3.0" DisplayName=".NET Framework 3.0" Alias="net30" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v3.5" DisplayName=".NET Framework 3.5" Alias="net35" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.0" DisplayName=".NET Framework 4.0" Alias="net40" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.5" DisplayName=".NET Framework 4.5" Alias="net45" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.5.1" DisplayName=".NET Framework 4.5.1" Alias="net451" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.5.2" DisplayName=".NET Framework 4.5.2" Alias="net452" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.6" DisplayName=".NET Framework 4.6" Alias="net46" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.6.1" DisplayName=".NET Framework 4.6.1" Alias="net461" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.6.2" DisplayName=".NET Framework 4.6.2" Alias="net462" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.7" DisplayName=".NET Framework 4.7" Alias="net47" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.7.1" DisplayName=".NET Framework 4.7.1" Alias="net471" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.7.2" DisplayName=".NET Framework 4.7.2" Alias="net472" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.8" DisplayName=".NET Framework 4.8" Alias="net48" />
    <SupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v4.8.1" DisplayName=".NET Framework 4.8.1" Alias="net481" />
  </ItemGroup>
  <!-- All supported target frameworks -->
  <ItemGroup>
    <SupportedTargetFramework Include="@(SupportedNETCoreAppTargetFramework);@(SupportedNETStandardTargetFramework);@(SupportedNETFrameworkTargetFramework)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!-- List of supported target platforms -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.SupportedPlatforms.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.SupportedPlatforms.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.SupportedPlatforms.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup>
    <!-- Platforms supported by this SDK for analyzer warnings. Spec: https://github.com/dotnet/designs/blob/main/accepted/2020/platform-exclusion/platform-exclusion.md  -->
    <SupportedPlatform Include="Linux" />
    <SupportedPlatform Include="macOS" />
    <SupportedPlatform Include="Windows" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!-- List of supported .NET windows target platform versions -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.WindowsSdkSupportedTargetPlatforms.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.WindowsSdkSupportedTargetPlatforms.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.WindowsSdkSupportedTargetPlatforms.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This file contains a list of the windows target platform versions that are supported by this SDK for .NET. Supported versions are processed in _NormalizeTargetPlatformVersion -->
  <!-- These will be added to the BundledVersions.props that's generated in dotnet/installer.  So only add them here if we don't have that change yet -->
  <ItemGroup Condition="'@(WindowsSdkSupportedTargetPlatformVersion)' == ''">
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.19041.0" WindowsSdkPackageVersion="10.0.19041.16" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.18362.0" WindowsSdkPackageVersion="10.0.18362.16" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="10.0.17763.0" WindowsSdkPackageVersion="10.0.17763.16" MinimumNETVersion="5.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="8.0" />
    <WindowsSdkSupportedTargetPlatformVersion Include="7.0" />
  </ItemGroup>
  <ItemGroup>
    <SdkSupportedTargetPlatformVersion Condition="'$(TargetPlatformIdentifier)' == 'Windows'" Include="@(WindowsSdkSupportedTargetPlatformVersion)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.SourceLink.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.SourceLink.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Suppress implicit SourceLink inclusion if any Microsoft.SourceLink package is referenced. -->
    <SuppressImplicitGitSourceLink Condition="'$(PkgMicrosoft_SourceLink_Common)' != ''">true</SuppressImplicitGitSourceLink>
    <_SourceLinkPropsImported>true</_SourceLinkPropsImported>
  </PropertyGroup>
  <!--<ImportGroup Condition="'$(SuppressImplicitGitSourceLink)' != 'true'">-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.Build.Tasks.Git\build\Microsoft.Build.Tasks.Git.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.Build.Tasks.Git/build/Microsoft.Build.Tasks.Git.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <MicrosoftBuildTasksGitAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.Build.Tasks.Git.dll</MicrosoftBuildTasksGitAssemblyFile>
    <MicrosoftBuildTasksGitAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.Build.Tasks.Git.dll</MicrosoftBuildTasksGitAssemblyFile>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.Common\build\Microsoft.SourceLink.Common.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.Common/build/Microsoft.SourceLink.Common.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_MicrosoftSourceLinkCommonAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.Common.dll</_MicrosoftSourceLinkCommonAssemblyFile>
    <_MicrosoftSourceLinkCommonAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.Common.dll</_MicrosoftSourceLinkCommonAssemblyFile>
  </PropertyGroup>
  <PropertyGroup>
    <!--
      Used to suppress querying source control and features that use the information (e.g. git commit SHA).
    -->
    <EnableSourceControlManagerQueries Condition="'$(EnableSourceControlManagerQueries)' == ''">true</EnableSourceControlManagerQueries>
    <!--
      Do not generate SourceLink when building in the IDE or for Live Unit Testing.
    -->
    <EnableSourceLink Condition="'$(EnableSourceLink)' == '' and '$(DesignTimeBuild)' != 'true' and '$(BuildingForLiveUnitTesting)' != 'true'">true</EnableSourceLink>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.GitHub\build\Microsoft.SourceLink.GitHub.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.GitHub/build/Microsoft.SourceLink.GitHub.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <ItemGroup>
    <SourceLinkGitHubHost Include="github.com" ContentUrl="https://raw.githubusercontent.com" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.GitLab\build\Microsoft.SourceLink.GitLab.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.GitLab/build/Microsoft.SourceLink.GitLab.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <ItemGroup>
    <SourceLinkGitLabHost Include="gitlab.com" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.AzureRepos.Git\build\Microsoft.SourceLink.AzureRepos.Git.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.AzureRepos.Git/build/Microsoft.SourceLink.AzureRepos.Git.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <ItemGroup>
    <SourceLinkAzureReposGitHost Include="visualstudio.com" />
    <SourceLinkAzureReposGitHost Include="vsts.me" />
    <SourceLinkAzureReposGitHost Include="dev.azure.com" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.Bitbucket.Git\build\Microsoft.SourceLink.Bitbucket.Git.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.Bitbucket.Git/build/Microsoft.SourceLink.Bitbucket.Git.props
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <ItemGroup>
    <SourceLinkBitbucketGitHost Include="bitbucket.org" EnterpriseEdition="false" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.props
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.CSharp.props" Condition="'$(MSBuildProjectExtension)' == '.csproj'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.CSharp.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.CSharp.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NoWarn Condition=" '$(NoWarn)' == '' ">1701;1702</NoWarn>
    <!-- Remove the line below once https://github.com/Microsoft/visualfsharp/issues/3207 gets fixed -->
    <WarningsAsErrors>$(WarningsAsErrors);NU1605</WarningsAsErrors>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefineConstants Condition=" '$(DefineConstants)' != '' ">$(DefineConstants);</DefineConstants>
    <DefineConstants>$(DefineConstants)TRACE</DefineConstants>
  </PropertyGroup>
  <!-- Implicit imports -->
  <ItemGroup Condition="'$(ImplicitUsings)' == 'true' Or '$(ImplicitUsings)' == 'enable'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Using Include="System" />
    <Using Include="System.Collections.Generic" />
    <Using Include="System.IO" />
    <Using Include="System.Linq" />
    <Using Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
    <Using Include="System.Threading" />
    <Using Include="System.Threading.Tasks" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.VisualBasic.props" Condition="'$(MSBuildProjectExtension)' == '.vbproj'" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.FSharp.props" Condition="'$(MSBuildProjectExtension)' == '.fsproj'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackTool.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.PackTool.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.PackTool.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackProjectTool.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.PackProjectTool.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.PackProjectTool.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This UsingTask is in the PackTool.props because there is usage of it in other areas of the product
       and on public GitHub: https://github.com/search?q=path%3A*.props+OR+path%3A*.targets+AND+%28NOT+path%3A*%2FMicrosoft.NET.PackTool.targets%29+AND+%28NOT+path%3A*%2FMicrosoft.NET.Publish.targets%29+GetNuGetShortFolderName&amp;type=code -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.GetNuGetShortFolderName" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);_PackProjectToolValidation</TargetsForTfmSpecificContentInPackage>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)../../Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props" Condition="Exists('$(MSBuildThisFileDirectory)../../Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props
============================================================================================================================================
-->
  <ItemDefinitionGroup Condition=" '$(_EnableWindowsDesktopGlobbing)' == 'true' ">
    <ApplicationDefinition>
      <Generator>MSBuild:Compile</Generator>
      <XamlRuntime>$(DefaultXamlRuntime)</XamlRuntime>
      <SubType>Designer</SubType>
    </ApplicationDefinition>
    <Page>
      <Generator>MSBuild:Compile</Generator>
      <XamlRuntime>$(DefaultXamlRuntime)</XamlRuntime>
      <SubType>Designer</SubType>
    </Page>
  </ItemDefinitionGroup>
  <ItemGroup Condition=" '$(_EnableWindowsDesktopGlobbing)' == 'true' ">
    <ApplicationDefinition Include="App.xaml" Condition="'$(EnableDefaultApplicationDefinition)' != 'false' And Exists('$(MSBuildProjectDirectory)/App.xaml') And '$(MSBuildProjectExtension)' == '.csproj'" />
    <ApplicationDefinition Include="Application.xaml" Condition="'$(EnableDefaultApplicationDefinition)' != 'false' And Exists('$(MSBuildProjectDirectory)/Application.xaml') And '$(MSBuildProjectExtension)' == '.vbproj'" />
    <Page Include="**/*.xaml" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);@(ApplicationDefinition)" Condition="'$(EnableDefaultPageItems)' != 'false'" />
    <!--
      See https://github.com/dotnet/wpf/issues/685
      Visual Studio would prefer that we remove **/*.xaml instead of
      being more precise.

      <None Remove="@(Page)"
              Condition="'$(EnableDefaultPageItems)' != 'false'" />
      <None Remove="@(ApplicationDefinition)"
            Condition="'$(EnableDefaultApplicationDefinition)' != 'false'" />
    -->
    <None Remove="**/*.xaml" Condition="'$(EnableDefaultApplicationDefinition)' != 'false' And '$(EnableDefaultPageItems)' != 'false'" />
  </ItemGroup>
  <ItemGroup Condition=" '$(_EnableWindowsDesktopNetCoreFrameworkReferences)' == 'true' ">
    <FrameworkReference Include="Microsoft.WindowsDesktop.App" IsImplicitlyDefined="true" Condition="('$(UseWPF)' == 'true') And ('$(UseWindowsForms)' == 'true')" />
    <FrameworkReference Include="Microsoft.WindowsDesktop.App.WPF" IsImplicitlyDefined="true" Condition="('$(UseWPF)' == 'true') And ('$(UseWindowsForms)' != 'true')" />
    <FrameworkReference Include="Microsoft.WindowsDesktop.App.WindowsForms" IsImplicitlyDefined="true" Condition="('$(UseWPF)' != 'true') And ('$(UseWindowsForms)' == 'true')" />
  </ItemGroup>
  <!--
    Traditionally, Visual Studio has supplied these references for .NET Framework based
    WPF Projects:

    .NET 3.x:   PresentationCore, PresentationFramework, WindowsBase
    .NET 4.x:   PresentationCore, PresentationFramework, WindowsBase, System.Xaml


    Microsoft.NET.WindowsDesktop.SDK will supply the following references to .NET Framework based
    WPF Projects:

    .NET 3.x:   PresentationCore, PresentationFramework, WindowsBase

    .NET 4.0:   PresentationCore, PresentationFramework, WindowsBase, System.Xaml,
                UIAutomationClient, UIAutomationClientSideProviders, UIAutomationProvider, UIAutomationTypes

    .NET 4.5+:  PresentationCore, PresentationFramework, WindowsBase, System.Xaml,
                UIAutomationClient, UIAutomationClientSideProviders, UIAutomationProvider, UIAutomationTypes
                System.Windows.Controls.Ribbon
  -->
  <ItemGroup Condition=" '$(_EnableWindowsDesktopNETFrameworkImplicitReference)' == 'true' ">
    <!--
      The following 3 _WpfCommonNetFxReference items normally require Condition="'$(_TargetFrameworkVersionValue)' >= '3.0'", since
      they are supported on .NET Framework 3.0 and above.

      This condition is implicitly satisfied by '$(_TargetFrameworkVersionValue)' >= '$(_WindowsDesktopSdkTargetFrameworkVersionFloor)'
      in the outer ItemGroup
    -->
    <_WpfCommonNetFxReference Include="WindowsBase" />
    <_WpfCommonNetFxReference Include="PresentationCore" />
    <_WpfCommonNetFxReference Include="PresentationFramework" />
    <_WpfCommonNetFxReference Include="System.Xaml" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'">
      <RequiredTargetFramework>4.0</RequiredTargetFramework>
    </_WpfCommonNetFxReference>
    <_WpfCommonNetFxReference Include="UIAutomationClient" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'" />
    <_WpfCommonNetFxReference Include="UIAutomationClientSideProviders" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'" />
    <_WpfCommonNetFxReference Include="UIAutomationProvider" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'" />
    <_WpfCommonNetFxReference Include="UIAutomationTypes" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.0'" />
    <_WpfCommonNetFxReference Include="System.Windows.Controls.Ribbon" Condition="'$(_TargetFrameworkVersionValue)' != '' And '$(_TargetFrameworkVersionValue)' &gt;= '4.5'" />
  </ItemGroup>
  <ItemGroup Condition=" '$(_EnableWindowsDesktopNETFrameworkImplicitReference)' == 'true' ">
    <_SDKImplicitReference Include="@(_WpfCommonNetFxReference)" Condition="'$(UseWPF)' == 'true'" />
    <_SDKImplicitReference Include="System.Windows.Forms" Condition="('$(UseWindowsForms)' == 'true') " />
    <_SDKImplicitReference Include="WindowsFormsIntegration" Condition=" ('$(UseWindowsForms)' == 'true') And ('$(UseWPF)' == 'true') " />
  </ItemGroup>
  <!--
        Supported (and unsupported) TargetFrameworks

        Visual Studio Project System determines the list of valid TargetFrameworks to show
        in the Project properties by querying SupportedTargetFramework values.

        The Project System does not refer to this list at this time for .NET Framework TFM's.
  -->
  <!--
    When WindowsDesktop SDK is used without setting UseWPF or UseWindowsForms, it shows a (suppressible) warning and functions much
    like Microsoft.NET.Sdk

    Likewise, when WindowsDesktop SDK is used with a netcore TFM that is less than 3.0, it will simply act as if it were an
    Microsoft.NET.Sdk project (and show a suppressible build-time warning).

    Detect these situations and skip updates to @(SupportedTargetFramework) etc.
  -->
  <ItemGroup Condition=" '$(_RemoveUnsupportedTargetFrameworksForWindowsDesktop)' == 'true' ">
    <!--
        Windows Forms and WPF are supported only on .NET Core 3.0+
    -->
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v1.0" />
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v1.1" />
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.0" />
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.1" />
    <_UnsupportedNETCoreAppTargetFramework Include=".NETCoreApp,Version=v2.2" />
    <!--
        Windows Forms and WPF are not supported an any .NET Standard targets
    -->
    <_UnsupportedNETStandardTargetFramework Include="@(SupportedNETStandardTargetFramework)" />
    <!--
        Windows Forms was supported since .NET Framework 1.0, and is currently supported on
        .NET Framework 2.0+.

        WPF is supported on .NET Framework and WPF are supported on .NET Framework 3.0+

        In practice, the WindowsDesktop SDK is only supported on .NET Framework 3.0+ - this is controlled
        by $(_WindowsDesktopSdkTargetFrameworkVersionFloor), defined as 3.0, which applies to both .NETFramework
        and .NETCore.

        Here, we will encode .NET Framework 3.0 as the lowest supported version for both Windows Forms and WPF.

        The SDK does not define versions < 2.0 in @(SupportedNETFrameworkTargetFramework) list, so none of those
        need to be excluded here - removing 2.0 would suffice.
    -->
    <_UnsupportedNETFrameworkTargetFramework Include=".NETFramework,Version=v2.0" />
    <SupportedNETCoreAppTargetFramework Remove="@(_UnsupportedNETCoreAppTargetFramework)" />
    <SupportedNETStandardTargetFramework Remove="@(_UnsupportedNETStandardTargetFramework)" />
    <SupportedNETFrameworkTargetFramework Remove="@(_UnsupportedNETFrameworkTargetFramework)" />
    <SupportedTargetFramework Remove="@(_UnsupportedNETCoreAppTargetFramework);@(_UnsupportedNETStandardTargetFramework);@(_UnsupportedNETFrameworkTargetFramework)" />
  </ItemGroup>
  <!--
    Import Windows Forms props.
    These come via the Windows Forms transport package, that can be found under
    https://github.com/dotnet/winforms/tree/main/pkg/Microsoft.Private.Winforms/sdk
  -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.WindowsDesktop.WindowsForms.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.WindowsForms.props
============================================================================================================================================
-->
  <!--
    This props file comes from dotnet/winforms. It gets ingested by dotnet/wpf and processed by
    packaging/Microsoft.NET.Sdk.WindowsDesktop project.
    
    It is referenced via Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props.
   -->
  <!--
    ============================================================
                      GenerateImplicitNamespaceImports
    Generates implicit namespace imports source to intermediate directory for Windows Forms projects
    ============================================================
    -->
  <ItemGroup Condition="'$(UseWindowsForms)' == 'true' and ('$(ImplicitUsings)' == 'true' or '$(ImplicitUsings)' == 'enable')">
    <!--
      SDK defines the following global usings:
      * System
      * System.Collections.Generic
      * System.Linq
      * System.Threading.Tasks
    -->
    <Using Include="System.Drawing" />
    <Using Include="System.Windows.Forms" />
  </ItemGroup>
  <!-- Windows Forms source generator and analyzers -->
  <!--
============================================================================================================================================
  <Import Project="System.Windows.Forms.Analyzers.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/System.Windows.Forms.Analyzers.props
============================================================================================================================================
-->
  <!--
    This props file comes from dotnet/winforms. It gets ingested by dotnet/wpf and processed by
    packaging/Microsoft.NET.Sdk.WindowsDesktop project.

    It is referenced via Microsoft.NET.Sdk.WindowsDesktop.WindowsForms.props.
   -->
  <!-- Import for Windows Forms applications or when developing/testing locally -->
  <ItemGroup Condition="('$(UseWindowsForms)' == 'true') or ('$(ResolveWinFormsAnalyzersFromSdkRefPack)' == 'false')">
    <!-- Known Application properties -->
    <CompilerVisibleProperty Include="ApplicationManifest" />
    <CompilerVisibleProperty Include="StartupObject" />
    <!-- 
      Custom Application properties
      See for more details: https://github.com/dotnet/designs/blob/main/accepted/2021/winforms/streamline-application-bootstrap.md#msbuild-properties
      -->
    <CompilerVisibleProperty Include="ApplicationDefaultFont" />
    <CompilerVisibleProperty Include="ApplicationHighDpiMode" />
    <CompilerVisibleProperty Include="ApplicationUseCompatibleTextRendering" />
    <CompilerVisibleProperty Include="ApplicationVisualStyles" />
    <!-- If there is an app.manifest - let the generator explore it -->
    <AdditionalFiles Include="$(ApplicationManifest)" Condition="'$(ApplicationManifest)' != ''" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.WindowsForms.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.WindowsDesktop.WPF.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.WPF.props
============================================================================================================================================
-->
  <!--
    Generates implicit global namespace imports file <projectname>.ImplicitGlobalNamespaceImports.cs.
  -->
  <ItemGroup Condition="'$(UseWPF)' == 'true' and ('$(ImplicitUsings)' == 'true' or '$(ImplicitUsings)' == 'enable')">
    <Using Remove="System.IO" />
    <Using Remove="System.Net.Http" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Windows.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Windows.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Windows.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup Condition=" '$(IncludeWindowsSDKRefFrameworkReferences)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FrameworkReference Include="Microsoft.Windows.SDK.NET.Ref.Windows" IsImplicitlyDefined="true" Pack="false" PrivateAssets="All" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MicrosoftNETWindowsWorkloadInstalled>true</MicrosoftNETWindowsWorkloadInstalled>
    <!--https://github.com/dotnet/sdk/issues/12403-->
    <_TargetFrameworkVersionValue>0.0</_TargetFrameworkVersionValue>
    <_WindowsDesktopSdkTargetFrameworkVersionFloor>3.0</_WindowsDesktopSdkTargetFrameworkVersionFloor>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.props
============================================================================================================================================
-->
  <!--
      Extensibility point for users to import build logic after all of the .NET SDKs .props are imported but before the project's contents are evaluated.
      This can be useful for overriding default globs or properties that the SDK sets.
      -->
  <!--<Import Project="$(AfterMicrosoftNetSdkProps)" Condition="$(AfterMicrosoftNetSdkProps) != ''" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk.StaticWebAssets" Condition="'$(_RazorSdkImportsMicrosoftNetSdkStaticWebAssets)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Determines if the StaticWebAssets Sdk is responsible for importing Microsoft.NET.Sdk. Microsoft.NET.Sdk.Web may have previously imported this. -->
    <_StaticWebAssetsSdkImportsMicrosoftNetSdk Condition="'$(UsingMicrosoftNETSdk)' != 'true'">true</_StaticWebAssetsSdkImportsMicrosoftNetSdk>
  </PropertyGroup>
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk" Condition="'$(_StaticWebAssetsSdkImportsMicrosoftNetSdk)' == 'true'" />-->
  <PropertyGroup>
    <StaticWebAssetsSdkCurrentVersionProps Condition="'$(StaticWebAssetsSdkCurrentVersionProps)' == ''">$(MSBuildThisFileDirectory)..\targets\Sdk.StaticWebAssets.CurrentVersion.props</StaticWebAssetsSdkCurrentVersionProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(StaticWebAssetsSdkCurrentVersionProps)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Sdk.StaticWebAssets.CurrentVersion.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.StaticWebAssets.CurrentVersion.props
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.
Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Properties and tasks supporting StaticWebAssets MSBuild integration
  -->
  <!--
    Default properties for common StaticWebAssets SDK behavior.
  -->
  <PropertyGroup>
    <UsingMicrosoftNETSdkStaticWebAssets>true</UsingMicrosoftNETSdkStaticWebAssets>
    <!--
    Set to true to automatically include certain file types, such as .cshtml files, as content in the project.
    When referenced via Microsoft.NET.Sdk.Web, this additionally includes all files under wwwroot, and any config files.
    -->
    <EnableDefaultContentItems Condition="'$(EnableDefaultContentItems)'==''">true</EnableDefaultContentItems>
    <!--
      Set to true to automatically include Razor (.razor.cs) files in @(ScopedCssInput) from @(Content).
    -->
    <EnableDefaultScopedCssItems Condition="'$(EnableDefaultScopedCssItems)'==''">true</EnableDefaultScopedCssItems>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\Sdk\Sdk.StaticWebAssets.StaticAssets.ProjectSystem.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/Sdk/Sdk.StaticWebAssets.StaticAssets.ProjectSystem.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.StaticWebAssets.StaticAssets.ProjectSystem.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Properties for supporting static content -->
  <PropertyGroup>
    <!-- This is a contract we have with the Web SDK to allow them in the future to import this file
         instead of the whole SDK if needed.
     -->
    <_WebProjectSystemGlobsPropsDefined>true</_WebProjectSystemGlobsPropsDefined>
    <DefaultItemExcludes>$(DefaultItemExcludes);**\node_modules\**;node_modules\**</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**\jspm_packages\**;jspm_packages\**</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**\bower_components\**;bower_components\**</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**\packages.lock.json</DefaultItemExcludes>
    <DefaultWebContentItemExcludes>$(DefaultWebContentItemExcludes);wwwroot\**</DefaultWebContentItemExcludes>
  </PropertyGroup>
  <ItemGroup Condition="'$(EnableDefaultItems)' == 'true' And '$(EnableDefaultContentItems)' == 'true' ">
    <!-- Publish everything under wwwroot, all JSON files, all config files and all Razor files -->
    <Content Include="wwwroot\**" ExcludeFromSingleFile="true" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" />
    <!-- Specifically support the ~/.well-known directory as per IETF RFC5785 -->
    <Content Include="wwwroot\.well-known\**" ExcludeFromSingleFile="true" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes)" />
    <Content Include="**\*.config" ExcludeFromSingleFile="true" CopyToOutputDirectory="PreserveNewest" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);$(DefaultWebContentItemExcludes)" Condition="'$(ExcludeConfigFilesFromBuildOutput)'!='true'" />
    <Content Include="**\*.json" ExcludeFromSingleFile="true" CopyToOutputDirectory="PreserveNewest" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);$(DefaultWebContentItemExcludes)" Condition="'$(ExcludeConfigFilesFromBuildOutput)'!='true'" />
    <!-- When ExcludeConfigFilesFromBuildOutput is set, do not copy .,config, .json files to the build output directory. -->
    <Content Include="**\*.config" ExcludeFromSingleFile="true" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);$(DefaultWebContentItemExcludes)" Condition="'$(ExcludeConfigFilesFromBuildOutput)'=='true'" />
    <Content Include="**\*.json" ExcludeFromSingleFile="true" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);$(DefaultWebContentItemExcludes)" Condition="'$(ExcludeConfigFilesFromBuildOutput)'=='true'" />
    <!-- Set CopyToPublishDirectory to Never for items under AppDesignerFolder ("Properties", by default) to avoid publishing launchSettings.json -->
    <Content Update="$(AppDesignerFolder)\**" CopyToPublishDirectory="Never" Condition="'$(AppDesignerFolder)' != ''" />
    <!-- Remove Content items from other item types (in a way that CPS understands) -->
    <None Remove="wwwroot\**;**\*.json;**\*.config" />
    <Compile Remove="wwwroot\**" />
    <EmbeddedResource Remove="wwwroot\**" />
    <!-- Keep track of the default content items for later to distinguish them from newly generated content items -->
    <!-- It's important to keep this here so that it works well with the Web SDK -->
    <_ContentIncludedByDefault Include="@(Content)" />
  </ItemGroup>
  <ItemGroup Condition="'$([MSBuild]::GetTargetPlatformIdentifier($(TargetFramework)))' != 'browser'">
    <Content Remove="**\**\*.Browser.cs" />
    <!-- <None Include="**\**\*.Browser.cs" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" /> -->
    <Content Remove="**\Browser\**\*.cs" />
    <!-- <None Include="**\Browser\**\*.cs" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" /> -->
  </ItemGroup>
  <ItemGroup Condition="'$([MSBuild]::GetTargetPlatformIdentifier($(TargetFramework)))' != ''">
    <Content Remove="**\**\*.Server.cs" />
    <!-- <None Include="**\**\*.Server.cs" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" /> -->
    <Content Remove="**\Server\**\*.cs" />
    <!-- <None Include="**\Server\**\*.cs" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)" /> -->
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Sdk.StaticWebAssets.CurrentVersion.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.StaticWebAssets.ContentTypeMappings.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.ContentTypeMappings.props
============================================================================================================================================
-->
  <!-- Static web asset endpoint content-type mappings. Mappings come from
       https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/FileExtensionContentTypeProvider.cs

       We keep this list in a different order because our tasks iterate over the list in order to match files to content types
       and we want to avoid checking against uncommon content-types.

       The priority is used to determine the order in which the content types are matched. The higher the priority, the earlier
       we try to match the content. Normally, the priority is equivalent to the number of '.' in the pattern. For example,
       a pattern like '*.js' has a priority of 1, while a pattern like '*.module.js' has a priority of 2.

       However, for some well-known content-types we define a different priority to ensure that they are matched first, as the order
       significantly affects the performance of the mapping algorithm (since entries are tried on descending order of priority).

       Most common web content types are given a priority of 10, with the addition of `.gz` and `.br` compressed versions of the
       content types with a priority of 9 and 8 respectively. Other entries follow the regular rules described above and are only
       included to ensure a high degree of compatibility with IIS and the static files middleware.

       Using a priority that can be altered in the build is also a way to allow libraries to bring their own content type mappings
       and to make the maping of some content types more efficient by bypassing the rules for uncommon content types.
  -->
  <PropertyGroup>
    <StaticWebAssetEndpointDefaultMediaCacheControlHeader Condition="'$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)' == ''">max-age=3600, must-revalidate</StaticWebAssetEndpointDefaultMediaCacheControlHeader>
  </PropertyGroup>
  <ItemGroup>
    <StaticWebAssetContentTypeMapping Include="image/bmp" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.bmp" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/jpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.jpeg" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/jpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.jpg" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/gif" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.gif" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/svg+xml" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.svg" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/png" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.png" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/webp" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.webp" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="font/otf" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.otf" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="font/woff2" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.woff2" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mp4" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.m4v" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/quicktime" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mov" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-sgi-movie" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.movie" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mp2" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mp4" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mp4" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mp4" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mp4v" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mpa" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mpe" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mpeg" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mpg" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.mpv2" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-asf" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.nsc" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/ogg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.ogg" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/ogg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.ogv" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/webm" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.webm" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-jg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.art" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-cmx" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.cmx" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/cis-cod" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.cod" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/bmp" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.dib" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-icon" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.ico" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/ief" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.ief" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/pjpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.jfif" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/jpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.jpe" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-portable-bitmap" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.pbm" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-portable-graymap" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.pgm" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-portable-anymap" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.pnm" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/png" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.pnz" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-portable-pixmap" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.ppm" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-cmu-raster" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.ras" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/vnd.rn-realflash" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.rf" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-rgb" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.rgb" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/svg+xml" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.svgz" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/tiff" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.tif" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/tiff" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.tiff" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/vnd.wap.wbmp" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.wbmp" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-xbitmap" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.xbm" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-xpixmap" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.xpm" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="image/x-xwindowdump" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.xwd" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/3gpp2" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.3g2" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/3gpp2" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.3gp2" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/3gpp" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.3gp" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/3gpp" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.3gpp" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-asf" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.asf" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-asf" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.asr" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-asf" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.asx" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-msvideo" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.avi" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-dvr" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.dvr" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-flv" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.flv" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ivf" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.IVF" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-la-asf" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.lsf" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-la-asf" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.lsx" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/mpeg" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.m1v" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/vnd.dlna.mpeg-tts" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.m2ts" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/quicktime" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.qt" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/vnd.dlna.mpeg-tts" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.ts" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/vnd.dlna.mpeg-tts" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.tts" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-wm" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.wm" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-wmp" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.wmp" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-wmv" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.wmv" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-wmx" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.wmx" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-wtv" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.wtv" Priority="1" />
    <StaticWebAssetContentTypeMapping Include="video/x-ms-wvx" Cache="$(StaticWebAssetEndpointDefaultMediaCacheControlHeader)" Pattern="*.wvx" Priority="1" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Sdk.StaticWebAssets.CurrentVersion.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.StaticWebAssets.FingerprintingPatterns.props">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.FingerprintingPatterns.props
============================================================================================================================================
-->
  <!-- Fingerprinting patterns for content. By default (most common case), we check for a single extension, like .js or .css.
       In that situation we apply the fingerprint expression directly to the file name, like app.js -> app#[.{fingerprint}].js.
       If we detect more than one extension, for example, Rcl.lib.module.js or Rcl.Razor.js, we retrieve the last extension and
       check for a mapping in the list below. If we find a match, we apply the fingerprint expression to the file name, like
       Rcl.lib.module.js -> Rcl#[.{fingerprint}].lib.module.js. If we don't find a match, we add the extension to the name and
       continue matching against the next segment, like Rcl.Razor.js -> Rcl.Razor#[.{fingerprint}].js.
       If we don't find a match, we apply the fingerprint before the first extension, like Rcl.Razor.js -> Rcl.Razor#[.{fingerprint}].js.
  -->
  <ItemGroup>
    <StaticWebAssetFingerprintPattern Include="Initializer" Pattern="*.lib.module.js" Expression="#[.{fingerprint}]!" />
    <StaticWebAssetFingerprintPattern Include="MvcJsModule" Pattern="*.cshtml.js" />
    <StaticWebAssetFingerprintPattern Include="ComponentsJsModule" Pattern="*.razor.js" />
    <StaticWebAssetFingerprintPattern Include="MvcScopedCss" Pattern="*.cshtml.css" />
    <StaticWebAssetFingerprintPattern Include="ComponentsScopedCss" Pattern="*.razor.css" />
    <StaticWebAssetFingerprintPattern Include="JsModuleManifest" Pattern="*.modules.json" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Sdk.StaticWebAssets.CurrentVersion.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/Sdk/Sdk.props
============================================================================================================================================
-->
  <PropertyGroup>
    <RazorSdkCurrentVersionProps Condition="'$(RazorSdkCurrentVersionProps)' == ''">$(MSBuildThisFileDirectory)..\targets\Sdk.Razor.CurrentVersion.props</RazorSdkCurrentVersionProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(RazorSdkCurrentVersionProps)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Sdk.Razor.CurrentVersion.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.Razor.CurrentVersion.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Properties and tasks supporting Razor MSBuild integration
  -->
  <!--
    Default properties for common Razor SDK behavior.
  -->
  <PropertyGroup>
    <UsingMicrosoftNETSdkRazor>true</UsingMicrosoftNETSdkRazor>
    <!--
    Set to true to automatically include certain file types, such as .cshtml files, as content in the project.
    When referenced via Microsoft.NET.Sdk.Web, this additionally includes all files under wwwroot, and any config files.
    -->
    <EnableDefaultContentItems Condition="'$(EnableDefaultContentItems)'==''">true</EnableDefaultContentItems>
    <!--
      Set to true to automatically include Razor (.cshtml) files in @(RazorGenerate) from @(Content).
    -->
    <EnableDefaultRazorGenerateItems Condition="'$(EnableDefaultRazorGenerateItems)'==''">true</EnableDefaultRazorGenerateItems>
    <!--
      Set to true to automatically include Razor (.razor) files in @(RazorComponent) from @(Content).
    -->
    <EnableDefaultRazorComponentItems Condition="'$(EnableDefaultRazorComponentItems)'==''">true</EnableDefaultRazorComponentItems>
    <!--
      Set to true to copy RazorGenerate items (.cshtml) to the publish directory.

      Typically Razor files are not needed for a published application if they participate in compilation at build-time
      or publish-time. By default, the Razor SDK will suppress the copying of RazorGenerate items to the publish directory.
    -->
    <CopyRazorGenerateFilesToPublishDirectory Condition="'$(CopyRazorGenerateFilesToPublishDirectory)'==''">false</CopyRazorGenerateFilesToPublishDirectory>
    <!--
    Determines the toolset to use to compile Razor (.cshtml) files. Defaults to 'Implicit' to let the Razor Sdk determine the toolset to use.
    Valid values include 'Implicit', 'RazorSdk', and 'PrecompilationTool'.
    -->
    <RazorCompileToolset>Implicit</RazorCompileToolset>
    <!--
    Configures whether all Razor content items (.cshtml files) will be marked to be included in the produced NuGet package as content.

    All Content items are included in a NuGet package as content files. This setting can be used to control this behavior for Razor content items.
    -->
    <IncludeRazorContentInPack Condition="'$(IncludeRazorContentInPack)'==''">false</IncludeRazorContentInPack>
    <!--
    Configures the file extension used for generated C# files.
    -->
    <RazorGenerateOutputFileExtension>.g.cs</RazorGenerateOutputFileExtension>
    <!--
    List of file extensions that will cause VS to restart the application when RazorSDK is effective.
    This property affects C# projects targeting 3.0 or later.
    -->
    <RazorUpToDateReloadFileTypes>.cs;.razor;.resx;.cshtml</RazorUpToDateReloadFileTypes>
    <!--
    Target used by dotnet-watch to resolve additional items.
    -->
    <CustomCollectWatchItems>$(CustomCollectWatchItems);_RazorSdkCustomCollectWatchItems</CustomCollectWatchItems>
  </PropertyGroup>
  <ItemGroup Condition="'$(EnableDefaultItems)' == 'true' And '$(EnableDefaultContentItems)' == 'true'">
    <Content Include="**\*.cshtml" ExcludeFromSingleFile="true" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);$(DefaultWebContentItemExcludes)" />
    <Content Include="**\*.razor" ExcludeFromSingleFile="true" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);$(DefaultWebContentItemExcludes)" />
    <None Remove="**\*.cshtml" />
    <None Remove="**\*.razor" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/Sdk/Sdk.props
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/src/Components/CustomElements/src/Microsoft.AspNetCore.Components.CustomElements.csproj
============================================================================================================================================
-->
  <PropertyGroup>
    <TargetFramework>$(DefaultNetCoreTargetFramework)</TargetFramework>
    <Description>Provides a mechanism for using Blazor components as custom HTML elements.</Description>
    <IsTrimmable>true</IsTrimmable>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Microsoft.AspNetCore.Components.Web" />
  </ItemGroup>
  <PropertyGroup>
    <InteropWorkingDir>$(MSBuildThisFileDirectory)js\</InteropWorkingDir>
    <ResolveStaticWebAssetsInputsDependsOn>
      IncludeCompileJsOutput;
      $(ResolveStaticWebAssetsInputsDependsOn)
    </ResolveStaticWebAssetsInputsDependsOn>
  </PropertyGroup>
  <Target Name="IncludeCompileJsOutput" BeforeTargets="ResolveJSModuleStaticWebAssets;ResolveJsInitializerModuleStaticWebAssets">
    <ItemGroup>
      <_JsBuildOutput Include="$(InteropWorkingDir)dist\$(Configuration)\**" Exclude="$(InteropWorkingDir)dist\.gitignore" />
      <_JsBuildOutput>
        <RelativePath>%(_JsBuildOutput.RecursiveDir)%(Filename)%(Extension)</RelativePath>
      </_JsBuildOutput>
    </ItemGroup>
    <DefineStaticWebAssets Condition="'@(_JsBuildOutput)' != ''" SourceType="Discovered" SourceId="$(PackageId)" ContentRoot="$(InteropWorkingDir)dist\$(Configuration)\" BasePath="_content\$(PackageId)" CandidateAssets="@(_JsBuildOutput)" RelativePathFilter="**.js" RelativePathPattern="**">
      <Output TaskParameter="Assets" ItemName="_JSBuildStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints Condition="'@(_JsBuildOutput)' != ''" CandidateAssets="@(_JSBuildStaticWebAsset)" ExistingEndpoints="@()" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_JSBuildStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Include="@(_JSBuildStaticWebAsset)" />
      <StaticWebAssetEndpoint Include="@(_JSBuildStaticWebAssetEndpoint)" />
      <_JsBuildOutput Include="$(InteropWorkingDir)dist\$(Configuration)\**" Exclude="$(InteropWorkingDir)dist\.gitignore" />
      <FileWrites Include="$(_JsBuildOutput)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  <Import Project="Sdk.targets" Sdk="Microsoft.NET.Sdk.Razor">
  This import was added implicitly because the Project element's Sdk attribute specified "Microsoft.NET.Sdk.Razor".

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="Sdk.targets" Sdk="Microsoft.NET.Sdk" Condition="'$(_RazorSdkImportsMicrosoftNetSdk)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="$(BeforeMicrosoftNETSdkTargets)" Condition="'$(BeforeMicrosoftNETSdkTargets)' != ''">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/BeforeNETSdkTargets.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
============================================================================================================================================
  <Import Project="RuntimeIdentifierInference.BeforeNETSdkTargets.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/RuntimeIdentifierInference.BeforeNETSdkTargets.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <_EnableArcadeRuntimeIdentifierInference Condition="'$(_EnableArcadeRuntimeIdentifierInference)' == ''">$(EnableArcadeRuntimeIdentifierInference)</_EnableArcadeRuntimeIdentifierInference>
    <!-- If the user has specified a RID for their project, don't overwrite it. -->
    <_EnableArcadeRuntimeIdentifierInference Condition="'$(_EnableArcadeRuntimeIdentifierInference)' == '' and '$(RuntimeIdentifier)' != ''">false</_EnableArcadeRuntimeIdentifierInference>
    <!--
      If the SDK will infer this project as "RID agnostic", don't infer RIDs.
      This should generally match the logic for setting IsRidAgnostic in the SDK.
    -->
    <_RidAgnosticProject Condition="('$(OutputType)' == 'Library' or '$(IsTestProject)' == 'true') and '$(RuntimeIdentifiers)' == ''">true</_RidAgnosticProject>
    <!-- If this project is RID-agnostic, don't infer RIDs. -->
    <_EnableArcadeRuntimeIdentifierInference Condition="'$(_EnableArcadeRuntimeIdentifierInference)' == '' and ('$(IsRidAgnostic)' == 'true' or '$(_RidAgnosticProject)' == 'true')">false</_EnableArcadeRuntimeIdentifierInference>
    <!--
      We only need to infer if the project would use the RID
    -->
    <_BuildFlavorRequiredRid Condition="&#xD;&#xA;        '$(SelfContained)' == 'true' or&#xD;&#xA;        ('$(_IsPublishing)' == 'true' and&#xD;&#xA;          (&#xD;&#xA;            '$(PublishReadyToRun)' == 'true' or&#xD;&#xA;            '$(PublishSingleFile)' == 'true' or&#xD;&#xA;            '$(PublishAot)' == 'true'&#xD;&#xA;          )&#xD;&#xA;        )">true</_BuildFlavorRequiredRid>
    <_EnableArcadeRuntimeIdentifierInference Condition="'$(_EnableArcadeRuntimeIdentifierInference)' == '' and '$(_BuildFlavorRequiredRid)' != 'true'">false</_EnableArcadeRuntimeIdentifierInference>
    <!--
      When we're doing a build of a single vertical, we may not have a runtime or host available for any RID outside of our current target.
      For many of our projects, we don't actually need to build any RID-specific assets, but the SDK may still try to pull down assets for other RIDs,
      in particular for the RID matching the SDK's RID.
      To avoid this, we'll default to setting the RID to the vertical's target RID.
      To preserve expected behavior for projects that don't specify a RID in a non-vertical build, we won't append the RID to the output path if the user hasn't explicitly requested it.
    -->
    <_EnableArcadeRuntimeIdentifierInference Condition="'$(_EnableArcadeRuntimeIdentifierInference)' == '' and '$(DotNetBuildTargetRidOnly)' == 'true'">true</_EnableArcadeRuntimeIdentifierInference>
    <_EnableArcadeRuntimeIdentifierFilters Condition="'$(EnableArcadeRuntimeIdentifierFilters)' != ''">$(EnableArcadeRuntimeIdentifierFilters)</_EnableArcadeRuntimeIdentifierFilters>
    <!--
      If we infer a RID for the project, default to filtering down the list of RIDs the project specifies and automatically excluding projects that don't build for this RID.
    -->
    <_EnableArcadeRuntimeIdentifierFilters Condition="'$(_EnableArcadeRuntimeIdentifierFilters)' == '' and '$(_EnableArcadeRuntimeIdentifierInference)' == 'true'">$(_EnableArcadeRuntimeIdentifierFilters)</_EnableArcadeRuntimeIdentifierFilters>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_EnableArcadeRuntimeIdentifierInference)' == 'true'">
    <!-- If we're inferring a RID, regular builds wouldn't have appended the RID to the output path. Default to not appending to the output path to preserve expected output locations. -->
    <AppendRuntimeIdentifierToOutputPath Condition="'$(AppendRuntimeIdentifierToOutputPath)' == ''">false</AppendRuntimeIdentifierToOutputPath>
    <RuntimeIdentifier>$(TargetRid)</RuntimeIdentifier>
    <!-- If this project would have been inferred as "RID agnostic", preserve that as well. -->
    <IsRidAgnostic Condition="'$(_RidAgnosticProject)' == 'true'">true</IsRidAgnostic>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_EnableArcadeRuntimeIdentifierFilters)' == 'true' and '$(RuntimeIdentifiers)' != ''">
    <!-- Prepend and append with semicolons to make the Contains call below simpler. -->
    <_ExplicitlySpecifiedRuntimeIdentifiers>;$(RuntimeIdentifiers);</_ExplicitlySpecifiedRuntimeIdentifiers>
    <!--
      Sometimes we may need to filter the RuntimeIdentifiers list by a RID that is not TargetRid.
      Determine which RID to filter on here.

      We can't actually use the RID graph here as RID graph filtering is only possible in a task, and we need to do this during property evaluation.
    -->
    <_FilterRuntimeIdentifier>$(TargetRid)</_FilterRuntimeIdentifier>
    <!-- If we're building non-portable, filter instead on PortableTargetRid. -->
    <_FilterRuntimeIdentifier Condition="'$(PortableTargetRid)' != ''">$(PortableTargetRid)</_FilterRuntimeIdentifier>
    <!-- If a project builds for a set of RIDs specified in the project file and this vertical isn't in the list, suppress building this project. -->
    <_SuppressAllTargets Condition="'$(DisableArcadeExcludeFromBuildSupport)' != 'true' and $(_ExplicitlySpecifiedRuntimeIdentifiers).Contains(';$(_FilterRuntimeIdentifier);')) == 'false'">true</_SuppressAllTargets>
    <!-- The .NET SDK will try to restore for all specified RIDs. Change the list of RIDs to only our inferred RID to ensure that restore only restores assets that could be available. -->
    <RuntimeIdentifiers>$(RuntimeIdentifier)</RuntimeIdentifiers>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/BeforeNETSdkTargets.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!-- Using the same property as Microsoft.CSharp.targets and presumably Microsoft.VisualBasic.targets here -->
  <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.BeforeCommonCrossTargeting.targets" Condition="'$(IsCrossTargetingBuild)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.BeforeCommon.targets" Condition="'$(IsCrossTargetingBuild)' != 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.BeforeCommon.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- For projects that aren't using Microsoft.NET.Sdk, these props files won't have been imported yet.
       So import them here. -->
  <!--<ImportGroup Condition="'$(UsingNETSdkDefaults)' != 'true'">-->
  <!--<Import Project="Microsoft.NET.Sdk.DefaultItems.props" />-->
  <!--<Import Project="Microsoft.NET.SupportedTargetFrameworks.props" />-->
  <!--<Import Project="Microsoft.NET.SupportedPlatforms.props" />-->
  <!--<Import Project="Microsoft.NET.WindowsSdkSupportedTargetPlatforms.props" />-->
  <!--</ImportGroup>-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsExecutable Condition="'$(OutputType)' == 'Exe' or '$(OutputType)'=='WinExe'">true</_IsExecutable>
  </PropertyGroup>
  <PropertyGroup Condition="'$(HasRuntimeOutput)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <HasRuntimeOutput>$(_IsExecutable)</HasRuntimeOutput>
    <_UsingDefaultForHasRuntimeOutput>true</_UsingDefaultForHasRuntimeOutput>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DefaultAssemblyInfo.targets" Condition="'$(UsingNETSdkDefaults)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultAssemblyInfo.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultAssemblyInfo.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition=" '$(Version)' == '' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <VersionPrefix Condition=" '$(VersionPrefix)' == '' ">1.0.0</VersionPrefix>
    <Version Condition=" '$(VersionSuffix)' != '' ">$(VersionPrefix)-$(VersionSuffix)</Version>
    <Version Condition=" '$(Version)' == '' ">$(VersionPrefix)</Version>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Authors Condition=" '$(Authors)'=='' ">$(AssemblyName)</Authors>
    <Company Condition=" '$(Company)'=='' ">$(Authors)</Company>
    <AssemblyTitle Condition=" '$(AssemblyTitle)' == '' ">$(AssemblyName)</AssemblyTitle>
    <Product Condition=" '$(Product)' == ''">$(AssemblyName)</Product>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
    Apply these defaults from Microsoft.Common.CurrentVersion.targets now since we're running before them,
    but need to adjust them and/or make decisions in terms of them.
   -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Configuration Condition="'$(Configuration)'==''">Debug</Configuration>
    <Platform Condition="'$(Platform)'==''">AnyCPU</Platform>
    <PlatformName Condition="'$(PlatformName)' == ''">$(Platform)</PlatformName>
  </PropertyGroup>
  <!-- Before any additional SDK targets are imported, import the publish profile.
       This allows the publish profile to set properties like RuntimeIdentifier and them be
       respected by the SDK. -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.ImportPublishProfile.targets" Condition="'$(PublishProfileImported)' != 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.ImportPublishProfile.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.ImportPublishProfile.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Default to having imported the publish profile so the Web SDK doesn't also attempt to do so. -->
    <PublishProfileImported>true</PublishProfileImported>
    <_PublishProfileDesignerFolder Condition="'$(AppDesignerFolder)' != ''">$(AppDesignerFolder)</_PublishProfileDesignerFolder>
    <_PublishProfileDesignerFolder Condition="'$(_PublishProfileDesignerFolder)' == ''">Properties</_PublishProfileDesignerFolder>
    <_PublishProfileRootFolder Condition="'$(_PublishProfileRootFolder)' == ''">$(MSBuildProjectDirectory)\$(_PublishProfileDesignerFolder)\PublishProfiles\</_PublishProfileRootFolder>
    <PublishProfileName Condition="'$(PublishProfileName)' == '' and '$(PublishProfile)' != ''">$([System.IO.Path]::GetFileNameWithoutExtension($(PublishProfile)))</PublishProfileName>
    <PublishProfileFullPath Condition="'$(PublishProfileFullPath)' == '' and '$(PublishProfileName)' != ''">$(_PublishProfileRootFolder)$(PublishProfileName).pubxml</PublishProfileFullPath>
    <WebPublishProfileFile Condition="'$(WebPublishProfileFile)' == '' and Exists('$(PublishProfileFullPath)')">$(PublishProfileFullPath)</WebPublishProfileFile>
    <!-- If the publish profile doesn't exist, mark as not imported.
       This allows the Web SDK to import some default profiles that come with the Web SDK.
       Publishing in Visual Studio sets `WebPublishProfileFile` as a global property.
       Therefore, check that `ProjectToOverrideProjectExtensionsPath` is equal to `MSBuildProjectFullPath`
       to limit the import to the project being published. -->
    <PublishProfileImported Condition="('$(ProjectToOverrideProjectExtensionsPath)' != '' and&#xA;                                        '$(ProjectToOverrideProjectExtensionsPath)' != '$(MSBuildProjectFullPath)') or&#xA;                                       '$(WebPublishProfileFile)' == '' or&#xA;                                       !Exists('$(WebPublishProfileFile)')">false</PublishProfileImported>
  </PropertyGroup>
  <!--<Import Project="$(WebPublishProfileFile)" Condition="'$(PublishProfileImported)' == 'true'" />-->
  <!--<Import Project="$(WebPublishProfileFile).user" Condition="'$(PublishProfileImported)' == 'true' and Exists('$(WebPublishProfileFile).user')" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
    Expand TargetFramework to TargetFrameworkIdentifier and TargetFrameworkVersion,
    and adjust intermediate and output paths to include it.
  -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.TargetFrameworkInference.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.TargetFrameworkInference.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.TargetFrameworkInference.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Note that this file is only included when $(TargetFramework) is set and so we do not need to check that here.

    Common targets require that $(TargetFrameworkIdentifier) and $(TargetFrameworkVersion) are set by static evaluation
    before they are imported. In common cases (currently netstandard, netcoreapp, or net), we infer them from the short
    names given via TargetFramework to allow for terseness and lack of duplication in project files.

    For other cases, the user must supply them manually.

    For cases where inference is supported, the user need only specify the targets in TargetFrameworks, e.g:
      <PropertyGroup>
        <TargetFrameworks>net45;netstandard1.0</TargetFrameworks>
      </PropertyGroup>

    For cases where inference is not supported, identifier, version and profile can be specified explicitly as follows:
       <PropertyGroup>
         <TargetFrameworks>portable-net451+win81;xyz1.0</TargetFrameworks>
       <PropertyGroup>
       <PropertyGroup Condition="'$(TargetFramework)' == 'portable-net451+win81'">
         <TargetFrameworkIdentifier>.NETPortable</TargetFrameworkIdentifier>
         <TargetFrameworkVersion>v4.6</TargetFrameworkVersion>
         <TargetFrameworkProfile>Profile44</TargetFrameworkProfile>
       </PropertyGroup>
       <PropertyGroup Condition="'$(TargetFramework)' == 'xyz1.0'">
         <TargetFrameworkIdentifier>Xyz</TargetFrameworkVersion>
       <PropertyGroup>

    Note in the xyz1.0 case, which is meant to demonstrate a framework we don't yet recognize, we can still
    infer the version of 1.0. The user can also override it as always we honor a TargetFrameworkIdentifier
    or TargetFrameworkVersion that is already set.
   -->
  <!-- Hook for importing custom target framework parsing -->
  <!--<Import Project="$(BeforeTargetFrameworkInferenceTargets)" Condition="$(BeforeTargetFrameworkInferenceTargets) != ''" />-->
  <!--
    Parse TargetFramework properties.
  -->
  <PropertyGroup Condition="'$(TargetFramework)' != '' and ('$(TargetFrameworkIdentifier)' == '' or '$(TargetFrameworkVersion)' == '')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetFrameworkIdentifier>$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)'))</TargetFrameworkIdentifier>
    <TargetFrameworkVersion>v$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)', 2))</TargetFrameworkVersion>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_TargetFrameworkVersionWithoutV>$(TargetFrameworkVersion.TrimStart('vV'))</_TargetFrameworkVersionWithoutV>
  </PropertyGroup>
  <!--
    Parse TargetPlatform properties.
  -->
  <PropertyGroup Condition="'$(TargetFramework)' != '' and ('$(TargetPlatformIdentifier)' == '' or '$(TargetPlatformVersion)' == '')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == ''">$([MSBuild]::GetTargetPlatformIdentifier('$(TargetFramework)'))</TargetPlatformIdentifier>
    <TargetPlatformVersion Condition="'$(TargetPlatformIdentifier)' == 'Windows'">$([MSBuild]::GetTargetPlatformVersion('$(TargetFramework)', 4))</TargetPlatformVersion>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == '' or ('$(TargetPlatformIdentifier)' == 'Windows' and !$([MSBuild]::VersionGreaterThanOrEquals($(TargetPlatformVersion), 10.0)))">$([MSBuild]::GetTargetPlatformVersion('$(TargetFramework)', 2))</TargetPlatformVersion>
    <TargetPlatformVersion Condition="$([MSBuild]::VersionEquals($(TargetPlatformVersion), 0.0))" />
    <!-- Normalize casing of windows to Windows -->
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == 'Windows'">Windows</TargetPlatformIdentifier>
  </PropertyGroup>
  <!--
    Trigger an error if we're unable to infer the framework identifier and version.

    We have to evaluate this here and not in the target because by the time the target runs,
    Microsoft.Common.targets will have defaulted to .NETFramework,Version=v4.0
  -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '' or '$(TargetFrameworkIdentifier)' == 'Unsupported' or '$(TargetFrameworkVersion)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UnsupportedTargetFrameworkError>true</_UnsupportedTargetFrameworkError>
  </PropertyGroup>
  <!--
    NOTE: We must not validate the TFM before restore target runs as it prevents adding additional TFM
          support from being provided by a nuget package such as MSBuild.Sdk.Extras.

          We run before RunResolvePackageDependencies and GetReferenceAssemblyPaths so that design-time builds
          which do not currently invoke _CheckForInvalidConfigurationAndPlatform, will not trigger spurious
          errors that are only consequences of the root cause identified here.
  -->
  <Target Name="_CheckForUnsupportedTargetFramework" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;RunResolvePackageDependencies;GetFrameworkPaths;GetReferenceAssemblyPaths;Restore" Condition="'$(_UnsupportedTargetFrameworkError)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="!$(TargetFramework.Contains(';'))" ResourceName="CannotInferTargetFrameworkIdentifierAndVersion" FormatArguments="$([MSBuild]::Escape('$(TargetFramework)'))" />
    <NETSdkError Condition="$(TargetFramework.Contains(';'))" ResourceName="TargetFrameworkWithSemicolon" FormatArguments="$([MSBuild]::Escape('$(TargetFramework)'))" />
  </Target>
  <!-- Skip this target for design time builds when there are missing workload packs.
       This will prevent design time builds from failing and therefore allow
       Visual Studio to collect the workloads from the GetSuggestedWorkloads target -->
  <Target Name="_CheckForUnsupportedTargetPlatformIdentifier" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;RunResolvePackageDependencies;GetFrameworkPaths;GetReferenceAssemblyPaths;CollectPackageReferences" Condition="'$(TargetPlatformIdentifier)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) And ('$(DesignTimeBuild)' != 'true' Or '@(MissingWorkloadPack)' == '')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <TargetPlatformSupported Condition="'$(TargetPlatformIdentifier)' == 'Windows'">true</TargetPlatformSupported>
      <UseWorkloadsSpecificError Condition="($(TargetPlatformIdentifier) == 'ios' or $(TargetPlatformIdentifier) == 'tvos' or $(TargetPlatformIdentifier) == 'maccatalyst' or $(TargetPlatformIdentifier) == 'android' or $(TargetPlatformIdentifier.StartsWith('browser'))) and '$(MSBuildEnableWorkloadResolver)' != 'true'">true</UseWorkloadsSpecificError>
    </PropertyGroup>
    <NETSdkError Condition="'$(TargetPlatformSupported)' != 'true' and '$(UseWorkloadsSpecificError)' != 'true'" ResourceName="UnsupportedTargetPlatformIdentifier" FormatArguments="$(TargetPlatformIdentifier)" />
    <NETSdkError Condition="'$(TargetPlatformSupported)' != 'true' and '$(UseWorkloadsSpecificError)' == 'true'" ResourceName="UnsupportedTargetPlatformIdentifierWithWorkloadsDisabled" FormatArguments="$(TargetPlatformIdentifier)" />
  </Target>
  <UsingTask TaskName="AllowEmptyTelemetry" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_CollectTargetFrameworkForTelemetry" AfterTargets="_CheckForUnsupportedTargetFramework" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <TFTelemetry Include="TargetFrameworkVersion" Value="$([MSBuild]::Escape('$(TargetFrameworkMoniker)'))" />
      <TFTelemetry Include="RuntimeIdentifier" Value="$(RuntimeIdentifier)" />
      <TFTelemetry Include="SelfContained" Value="$(SelfContained)" />
      <TFTelemetry Include="UseApphost" Value="$(UseApphost)" />
      <TFTelemetry Include="OutputType" Value="$(OutputType)" />
      <TFTelemetry Include="UseArtifactsOutput" Value="$(UseArtifactsOutput)" />
      <TFTelemetry Include="ArtifactsPathLocationType" Value="$(_ArtifactsPathLocationType)" />
    </ItemGroup>
    <AllowEmptyTelemetry EventName="targetframeworkeval" EventData="@(TFTelemetry)" />
  </Target>
  <!--
    Don't leave TargetFrameworkVersion empty if it still hasn't been determined. We will trigger the error above,
    but we need this to be a valid version so that our error message does not get pre-empted by failure to interpret
    version comparison expressions, which is currently unrecoverable in VS.

    Also don't leave TargetFrameworkIdentifier unset as it will be defaulted to .NETFramework by common targets, which
    can cause restore (which we cannot block, see above) to silently succeed for empty TargetFramework.
  -->
  <PropertyGroup Condition="'$(TargetFrameworkVersion)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetFrameworkVersion>v0.0</TargetFrameworkVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetFrameworkIdentifier>_</TargetFrameworkIdentifier>
  </PropertyGroup>
  <!--
    Trigger an error if targeting a higher version of .NET Core than is supported by the current SDK.
  -->
  <Target Name="_CheckForUnsupportedNETCoreVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(NETCoreAppMaximumVersion)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <DisplayVSMessage Condition="$([MSBuild]::VersionLessThan($(MSBuildVersion), '$(MinimumVisualStudioVersionForUnsupportedTargetFrameworkVersion)')) and '$(BuildingInsideVisualStudio)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' == '$(UnsupportedTargetFrameworkVersion)' and '$([MSBuild]::IsOSPlatform(`Windows`))' == 'true'">true</DisplayVSMessage>
    </PropertyGroup>
    <NETSdkError Condition="'$(_TargetFrameworkVersionWithoutV)' &gt; '$(NETCoreAppMaximumVersion)' and '$(DisplayVSMessage)' != 'true'" ResourceName="UnsupportedTargetFrameworkVersion" FormatArguments=".NET;$(_TargetFrameworkVersionWithoutV);$(NETCoreAppMaximumVersion)" />
    <NETSdkError Condition="'$(DisplayVSMessage)' == 'true'" ResourceName="UnsupportedVisualStudioVersion" FormatArguments=".NET;$(_TargetFrameworkVersionWithoutV);$(NETCoreAppMaximumVersion);$(MinimumVisualStudioVersionForUnsupportedTargetFrameworkVersion)" />
  </Target>
  <!--
    Trigger a warning if targeting a lower version of .NET Standard than is recommended
  -->
  <Target Name="_CheckForNotRecommendedNETStandardVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' and $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '2.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <!-- Default the check to true, but allow developers to turn the warning off. -->
      <CheckNotRecommendedTargetFramework Condition="'$(CheckNotRecommendedTargetFramework)' == ''">true</CheckNotRecommendedTargetFramework>
    </PropertyGroup>
    <NETSdkWarning Condition="'$(CheckNotRecommendedTargetFramework)' == 'true'" ResourceName="TargetFrameworkIsNotRecommended" FormatArguments="https://aka.ms/dotnet/dotnet-standard-guidance" />
  </Target>
  <!--
    Trigger an error if C++ project targeting a lower version of .NET Core than 3.1.
  -->
  <Target Name="_CheckForUnsupportedCppNETCoreVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &lt; '3.1' and ('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')" ResourceName="CppRequiresTFMVersion31" />
  </Target>
  <!--C++/CLI has its own logic of determine TargetPlatformIdentifier and TargetPlatformVersion-->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) and ('$(Language)' != 'C++' or '$(_EnablePackageReferencesInVCProjects)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_EnableDefaultWindowsPlatform>false</_EnableDefaultWindowsPlatform>
    <UseOSWinMdReferences>false</UseOSWinMdReferences>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(NETStandardMaximumVersion)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETStandardMaximumVersion>2.1</NETStandardMaximumVersion>
  </PropertyGroup>
  <Target Name="_CheckForUnsupportedNETStandardVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(NETStandardMaximumVersion)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(_TargetFrameworkVersionWithoutV)' &gt; '$(NETStandardMaximumVersion)'" ResourceName="UnsupportedTargetFrameworkVersion" FormatArguments=".NET Standard;$(_TargetFrameworkVersionWithoutV);$(NETStandardMaximumVersion)" />
  </Target>
  <Target Name="_CheckForUnsupportedTargetFrameworkAndFeatureCombination" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;Restore;CollectPackageReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(UsingNETSdkDefaults)' != 'true'" ResourceName="NETFrameworkWithoutUsingNETSdkDefaults" />
  </Target>
  <Target Name="_CheckForSupportedOSPlatformVersionHigherThanTargetPlatformVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetPlatformVersion)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(SupportedOSPlatformVersion)' != '' and $(TargetPlatformVersion) != '' and $([MSBuild]::VersionGreaterThan($(SupportedOSPlatformVersion), $(TargetPlatformVersion)))" ResourceName="CannotHaveSupportedOSPlatformVersionHigherThanTargetPlatformVersion" FormatArguments="$(SupportedOSPlatformVersion);$(TargetPlatformVersion)" />
  </Target>
  <!--C++/CLI targets rely on the patch version of the Windows SDK version as TargetPlatformVersion. Skip the normalization.-->
  <Target Name="_NormalizeTargetPlatformVersion" BeforeTargets="ProcessFrameworkReferences" Condition="'$(TargetPlatformVersion)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) and ('$(Language)' != 'C++' or '$(_EnablePackageReferencesInVCProjects)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ApplicableTargetPlatformVersion Include="@(SdkSupportedTargetPlatformVersion)" Condition="'@(SdkSupportedTargetPlatformVersion)' != '' and '%(SdkSupportedTargetPlatformVersion.DefineConstantsOnly)' != 'true'" RemoveMetadata="DefineConstantsOnly" />
      <_ValidTargetPlatformVersion Include="@(_ApplicableTargetPlatformVersion)" Condition="'@(_ApplicableTargetPlatformVersion)' != '' and $([MSBuild]::VersionEquals(%(Identity), $(TargetPlatformVersion)))" />
    </ItemGroup>
    <PropertyGroup>
      <TargetPlatformVersion Condition="'@(_ValidTargetPlatformVersion)' != '' and '@(_ValidTargetPlatformVersion-&gt;Distinct()-&gt;Count())' == '1' and '@(_ValidTargetPlatformVersion)' != '$(TargetPlatformVersion)'">@(_ValidTargetPlatformVersion-&gt;Distinct())</TargetPlatformVersion>
    </PropertyGroup>
  </Target>
  <Target Name="_CheckForInvalidTargetPlatformVersion" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" DependsOnTargets="_NormalizeTargetPlatformVersion" Condition="'$(TargetPlatformVersion)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) and ('$(Language)' != 'C++' or '$(_EnablePackageReferencesInVCProjects)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <TargetPlatformVersionSupported Condition="'$(TargetPlatformVersionSupported)' == '' and '@(_ValidTargetPlatformVersion)' != ''">true</TargetPlatformVersionSupported>
      <_ValidTargetPlatformVersions Condition="'@(_ApplicableTargetPlatformVersion)' != ''">@(_ApplicableTargetPlatformVersion, '%0a')</_ValidTargetPlatformVersions>
      <_ValidTargetPlatformVersions Condition="'@(_ApplicableTargetPlatformVersion)' == ''">None</_ValidTargetPlatformVersions>
    </PropertyGroup>
    <NetSdkError Condition="'$(TargetPlatformVersionSupported)' != 'true'" ResourceName="InvalidTargetPlatformVersion" FormatArguments="$(TargetPlatformVersion);$(TargetPlatformIdentifier);$(_ValidTargetPlatformVersions)" />
  </Target>
  <!-- Hook for processing after target framework parsing (for example to customize output paths) -->
  <!--<Import Project="$(AfterTargetFrameworkInferenceTargets)" Condition="$(AfterTargetFrameworkInferenceTargets) != ''" />-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProduceReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) and ('$(ProduceOnlyReferenceAssembly)' != 'true') and '$(MSBuildProjectExtension)' != '.fsproj'">true</ProduceReferenceAssembly>
    <ProduceReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 7.0)) and ('$(ProduceOnlyReferenceAssembly)' != 'true') and '$(MSBuildProjectExtension)' == '.fsproj'">true</ProduceReferenceAssembly>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Set default intermediate and output paths -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DefaultOutputPaths.targets" Condition="'$(UsingNETSdkDefaults)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultOutputPaths.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultOutputPaths.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Note that common targets only set a default OutputPath if neither configuration nor
    platform were set by the user. This was used to validate that a valid configuration is passed,
    assuming the convention maintained by VS that every Configuration|Platform combination had
    an explicit OutputPath. Since we now want to support leaner project files with less
    duplication and more automatic defaults, we always set a default OutputPath.
   -->
  <!-- Projects which don't use Microsoft.NET.Sdk will typically define the OutputPath directly (usually in a
       Configuration-specific PropertyGroup), so in that case we won't append to it by default. -->
  <PropertyGroup Condition="'$(UsingNETSdkDefaults)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AppendTargetFrameworkToOutputPath Condition="'$(AppendTargetFrameworkToOutputPath)' == ''">true</AppendTargetFrameworkToOutputPath>
    <AppendPlatformToOutputPath Condition="'$(AppendPlatformToOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">false</AppendPlatformToOutputPath>
    <AppendPlatformToOutputPath Condition="'$(AppendPlatformToOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">true</AppendPlatformToOutputPath>
    <_PlatformToAppendToOutputPath Condition="'$(AppendPlatformToOutputPath)' == 'true'">$(PlatformName)\</_PlatformToAppendToOutputPath>
  </PropertyGroup>
  <!-- NOTE: If we want to default UseArtifactsOutput to true when targeting a given version of .NET or higher, this is where we would do it.

    It would look something like this:

  <PropertyGroup Condition="'$(UseArtifactsOutput)' == '' and
                            '$(TargetFrameworks)' == '' and
                            '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and
                            $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 8.0))">
    <UseArtifactsOutput>true</UseArtifactsOutput>
  </PropertyGroup>
  -->
  <!-- Import .props file to set ArtifactsPath if it wasn't already imported from Sdk.props (this is for the case when artifacts
       properties are set in the project file instead of Directory.Build.props -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DefaultArtifactsPath.props" Condition="'$(_DefaultArtifactsPathPropsImported)' != 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultArtifactsPath.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultArtifactsPath.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This .props file may be imported either from Sdk.props or from Microsoft.NET.DefaultOutputPaths.targets, depending
       on whether artifacts output properties were set in Directory.Build.props or not.

       Set a property to indicate it was imported, so we can avoid a duplicate import. -->
  <PropertyGroup>
    <_DefaultArtifactsPathPropsImported>true</_DefaultArtifactsPathPropsImported>
  </PropertyGroup>
  <!-- Setting ArtifactsPath automatically opts in to the artifacts output format -->
  <PropertyGroup Condition="'$(ArtifactsPath)' != '' And '$(UsingMicrosoftArtifactsSdk)' != 'true'">
    <UseArtifactsOutput Condition="'$(UseArtifactsOutput)' == ''">true</UseArtifactsOutput>
    <IncludeProjectNameInArtifactsPaths Condition="'$(IncludeProjectNameInArtifactsPaths)' == ''">true</IncludeProjectNameInArtifactsPaths>
    <_ArtifactsPathLocationType>ExplicitlySpecified</_ArtifactsPathLocationType>
  </PropertyGroup>
  <!-- Set up base output folders if UseArtifactsOutput is set -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(ArtifactsPath)' == '' And '$(_DirectoryBuildPropsBasePath)' != ''">
    <!-- Default ArtifactsPath to be in the directory where Directory.Build.props is found
         Note that we do not append a backslash to the ArtifactsPath as we do with most paths, because it may be a global property passed in on the command-line which we can't easily change -->
    <ArtifactsPath>$(_DirectoryBuildPropsBasePath)\artifacts</ArtifactsPath>
    <IncludeProjectNameInArtifactsPaths Condition="'$(IncludeProjectNameInArtifactsPaths)' == ''">true</IncludeProjectNameInArtifactsPaths>
    <_ArtifactsPathLocationType>DirectoryBuildPropsFolder</_ArtifactsPathLocationType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(ArtifactsPath)' == ''">
    <!-- If there was no Directory.Build.props file, then put the artifacts path in the project folder -->
    <ArtifactsPath>$(MSBuildProjectDirectory)\artifacts</ArtifactsPath>
    <_ArtifactsPathLocationType>ProjectFolder</_ArtifactsPathLocationType>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultOutputPaths.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ArtifactsProjectName Condition="'$(ArtifactsProjectName)' == ''">$(MSBuildProjectName)</ArtifactsProjectName>
    <ArtifactsBinOutputName Condition="'$(ArtifactsBinOutputName)' == ''">bin</ArtifactsBinOutputName>
    <ArtifactsPublishOutputName Condition="'$(ArtifactsPublishOutputName)' == ''">publish</ArtifactsPublishOutputName>
    <ArtifactsPackageOutputName Condition="'$(ArtifactsPackageOutputName)' == ''">package</ArtifactsPackageOutputName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(ArtifactsPivots)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ArtifactsPivots>$(Configuration.ToLowerInvariant())</ArtifactsPivots>
    <!-- Include the TargetFramework in the pivots if the project is multi-targeted (ie TargetFrameworks) is defined -->
    <ArtifactsPivots Condition="'$(TargetFrameworks)' != '' And '$(TargetFramework)' != ''">$(ArtifactsPivots)_$(TargetFramework.ToLowerInvariant())</ArtifactsPivots>
    <!-- This targets file is evaluated before RuntimeIdentifierInference.targets, so this will only include the
         RuntimeIdentifier in the path if it was explicitly specified, not if it was inferred.  This is the
         behavior we want.

         The BlazorWebAssembly .props file sets the RuntimeIdentifier to browser-wasm, so treat that as a special case.
         -->
    <ArtifactsPivots Condition="'$(RuntimeIdentifier)' != '' And !('$(RuntimeIdentifier)' == 'browser-wasm' And '$(AppendRuntimeIdentifierToOutputPath)' == 'false')">$(ArtifactsPivots)_$(RuntimeIdentifier.ToLowerInvariant())</ArtifactsPivots>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(IncludeProjectNameInArtifactsPaths)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set artifacts paths when project name should be included in the path -->
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">$(ArtifactsPath)\$(ArtifactsBinOutputName)\$(ArtifactsProjectName)\</BaseOutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == '' And '$(UseArtifactsIntermediateOutput)' == 'true'">$(ArtifactsPath)\obj\$(ArtifactsProjectName)\</BaseIntermediateOutputPath>
    <PublishDir Condition="'$(PublishDir)' == ''">$(ArtifactsPath)\$(ArtifactsPublishOutputName)\$(ArtifactsProjectName)\$(ArtifactsPivots)\</PublishDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true' And '$(IncludeProjectNameInArtifactsPaths)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set artifacts paths when project name should not be included in the path -->
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">$(ArtifactsPath)\$(ArtifactsBinOutputName)\</BaseOutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == '' And '$(UseArtifactsIntermediateOutput)' == 'true'">$(ArtifactsPath)\obj\</BaseIntermediateOutputPath>
    <PublishDir Condition="'$(PublishDir)' == ''">$(ArtifactsPath)\$(ArtifactsPublishOutputName)\$(ArtifactsPivots)\</PublishDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <OutputPath Condition="'$(OutputPath)' == ''">$(BaseOutputPath)$(ArtifactsPivots)\</OutputPath>
    <IntermediateOutputPath Condition=" $(IntermediateOutputPath) == '' And '$(UseArtifactsIntermediateOutput)' == 'true'">$(BaseIntermediateOutputPath)$(ArtifactsPivots)\</IntermediateOutputPath>
    <!-- The package output path does not include the project name, and only includes the Configuration as a pivot -->
    <PackageOutputPath Condition="'$(PackageOutputPath)' == ''">$(ArtifactsPath)\$(ArtifactsPackageOutputName)\$(Configuration.ToLowerInvariant())\</PackageOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">bin\</BaseOutputPath>
    <BaseOutputPath Condition="!HasTrailingSlash('$(BaseOutputPath)')">$(BaseOutputPath)\</BaseOutputPath>
    <OutputPath Condition="'$(OutputPath)' == ''">$(BaseOutputPath)$(_PlatformToAppendToOutputPath)$(Configuration)\</OutputPath>
    <OutputPath Condition="!HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
  </PropertyGroup>
  <!-- If "UseArtifactsOutput" wasn't set when the MSBuild project extensions .props files were imported, then use "obj" in the project folder for the intermediate output path
         instead a folder under ArtifactsPath.  To have the intermediate output path in the artifacts folder, "UseArtifactsOutput" should be set in Directory.Build.props-->
  <PropertyGroup Condition="'$(UseArtifactsIntermediateOutput)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <IntermediateOutputPath Condition=" $(IntermediateOutputPath) == '' ">$(BaseIntermediateOutputPath)$(_PlatformToAppendToOutputPath)$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
  </PropertyGroup>
  <!-- Set the package output path (for nuget pack target) now, before the TargetFramework is appended -->
  <PropertyGroup Condition="'$(PackageOutputPath)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageOutputPath Condition="'$(UseArtifactsOutput)' != 'true'">$(OutputPath)</PackageOutputPath>
  </PropertyGroup>
  <!-- Exclude files from OutputPath and IntermediateOutputPath from default item globs.  Use the value
       of these properties before the TargetFramework is appended, so that if these values are specified
       in the project file, the specified value will be used for the exclude. -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefaultItemExcludes>$(DefaultItemExcludes);$(OutputPath)/**</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);$(IntermediateOutputPath)/**</DefaultItemExcludes>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefaultItemExcludes>$(DefaultItemExcludes);$(ArtifactsPath)/**</DefaultItemExcludes>
    <!-- Exclude bin and obj folders to avoid issues with projects that switch to using artifacts output format -->
    <DefaultItemExcludes>$(DefaultItemExcludes);bin/**;obj/**</DefaultItemExcludes>
  </PropertyGroup>
  <!--
    Append $(TargetFramework) directory to output and intermediate paths to prevent bin clashes between
    targets.
   -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true' and&#xA;                            '$(AppendTargetFrameworkToOutputPath)' == 'true' and '$(TargetFramework)' != '' and '$(_UnsupportedTargetFrameworkError)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <OutputPath>$(OutputPath)$(TargetFramework.ToLowerInvariant())\</OutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true' and&#xA;                            '$(AppendTargetFrameworkToOutputPath)' == 'true' and '$(TargetFramework)' != '' and '$(_UnsupportedTargetFrameworkError)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IntermediateOutputPath>$(IntermediateOutputPath)$(TargetFramework.ToLowerInvariant())\</IntermediateOutputPath>
  </PropertyGroup>
  <Target Name="_CheckForUnsupportedArtifactsPath" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Generate an error if ArtifactsPath or UseArtifactsOutput are set in the project file.

         We generate an error because if they are set in the project file, it is too late to change the intermediate output path,
         and because it would be confusing to set the property in the project file and have the artifacts path depend on whether
         there happened to be a Directory.Build.props file defined.
    -->
    <NetSdkError Condition="'$(UseArtifactsOutput)' == 'true' and '$(_ArtifactsPathSetEarly)' != 'true'" ResourceName="ArtifactsPathCannotBeSetInProject" />
    <NetSdkError Condition="'$(_ArtifactsPathLocationType)' == 'ProjectFolder'" ResourceName="UseArtifactsOutputRequiresDirectoryBuildProps" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Related issue: https://github.com/dotnet/sdk/issues/12324-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Import winfx targets when we're targeting .NETFramework and not importing the newer WindowsDesktop targets via `UseWPF`. -->
    <ImportFrameworkWinFXTargets Condition="'$(ImportFrameworkWinFXTargets)' == '' and '$(UseWPF)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETFramework'">true</ImportFrameworkWinFXTargets>
    <!-- Otherwise, don't import. -->
    <ImportFrameworkWinFXTargets Condition="'$(ImportFrameworkWinFXTargets)' == ''">false</ImportFrameworkWinFXTargets>
  </PropertyGroup>
  <!--
    Import targets from RazorSDK if referenced
    Sdks\Microsoft.NET.Sdk\targets\Microsoft.NET.Sdk.BeforeCommon.targets
    Sdks\Microsoft.NET.Sdk.Razor\targets\Microsoft.NET.Sdk.Razor.BeforeCommon.targets
  -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.NET.Sdk.Razor\targets\Microsoft.NET.Sdk.Razor.BeforeCommon.targets" Condition="'$(UsingMicrosoftNETSdkRazor)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Microsoft.NET.Sdk.Razor.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Razor.BeforeCommon.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Configure PreserveCompilationContext and PreserveCompilationReferences defaults for .NET Framework apps and .NET Core apps targets 5.0 and earlier. -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' OR ('$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), 6.0)))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Determines if the deps file includes complication context -->
    <PreserveCompilationContext Condition="'$(PreserveCompilationContext)' == ''">true</PreserveCompilationContext>
    <!-- Determines if the refs folder is produced as part of build \ publish -->
    <PreserveCompilationReferences Condition="'$(PreserveCompilationReferences)' == ''">false</PreserveCompilationReferences>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Import workload targets -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.ImportWorkloads.targets" Condition="'$(MSBuildEnableWorkloadResolver)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.ImportWorkloads.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.ImportWorkloads.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Workload support -->
  <!-- Import workload manifests -->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100-preview.5/microsoft.net.sdk.android/36.0.0-preview.5.116/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'android' ">-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Android.Sdk.net10" Condition=" $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0')) " />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Android.Sdk.net9" Condition=" $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0')) " />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Android.Sdk.net8" Condition=" $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '8.0')) " />-->
  <!--<Import Project="Eol.targets" Sdk="Microsoft.Android.Sdk.net10" Condition=" $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), '7.0')) " />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetPlatformIdentifier)' == 'android' and $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0')) ">
    <KnownFrameworkReference Update="Microsoft.Android" LatestRuntimeFrameworkVersion="35.0.61" TargetingPackVersion="35.0.61" />
  </ItemGroup>
  <ItemGroup Condition=" '$(TargetPlatformIdentifier)' == 'android' and $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '8.0')) ">
    <KnownFrameworkReference Update="Microsoft.Android" LatestRuntimeFrameworkVersion="34.0.154" TargetingPackVersion="34.0.154" />
  </ItemGroup>
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="android" DisplayName="Android" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100-preview.5/microsoft.net.sdk.ios/18.4.10622-net10-p5/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'iOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Sdk.net10.0_18.4" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Windows.Sdk.Aliased.net10.0_18.4" Condition=" $([MSBuild]::IsOSPlatform('windows'))" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'iOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Sdk.net9.0_18.0" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Windows.Sdk.Aliased.net9.0_18.0" Condition=" $([MSBuild]::IsOSPlatform('windows'))" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'iOS' And '$(UsingAppleNETSdk)' != 'true'">-->
  <!--<Import Project="Sdk-eol.props" Sdk="Microsoft.iOS.Sdk.net10.0_18.4" Condition=" $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '9.0'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.iOS.Sdk.net10.0_18.4" Condition=" $([MSBuild]::VersionGreaterThan($(TargetFrameworkVersion), '10.0'))" />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="ios" DisplayName="iOS" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100-preview.5/microsoft.net.sdk.maccatalyst/18.4.10622-net10-p5/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'MacCatalyst' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.MacCatalyst.Sdk.net10.0_18.4" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'MacCatalyst' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.MacCatalyst.Sdk.net9.0_18.0" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'MacCatalyst' And '$(UsingAppleNETSdk)' != 'true'">-->
  <!--<Import Project="Sdk-eol.props" Sdk="Microsoft.MacCatalyst.Sdk.net10.0_18.4" Condition=" $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '9.0'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.MacCatalyst.Sdk.net10.0_18.4" Condition=" $([MSBuild]::VersionGreaterThan($(TargetFrameworkVersion), '10.0'))" />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="maccatalyst" DisplayName="MacCatalyst" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100-preview.5/microsoft.net.sdk.macos/15.4.10622-net10-p5/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'macOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.macOS.Sdk.net10.0_15.4" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'macOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.macOS.Sdk.net9.0_15.0" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'macOS' And '$(UsingAppleNETSdk)' != 'true'">-->
  <!--<Import Project="Sdk-eol.props" Sdk="Microsoft.macOS.Sdk.net10.0_15.4" Condition=" $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '9.0'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.macOS.Sdk.net10.0_15.4" Condition=" $([MSBuild]::VersionGreaterThan($(TargetFrameworkVersion), '10.0'))" />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="macos" DisplayName="macOS" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100-preview.5/microsoft.net.sdk.maui/10.0.0-preview.5.25306.5/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--
      .NET MAUI telemetry and failure tracking. These are used to detect when the user specified one of the
      various <UseMaui*> properties, but for some reason the workload was not installed correctly.
  -->
  <ItemGroup>
    <ProjectCapability Condition=" '$(UseMaui)' == 'true' " Include="UseMaui" />
    <ProjectCapability Condition=" '$(UseMauiCore)' == 'true' " Include="UseMauiCore" />
    <ProjectCapability Condition=" '$(UseMauiNuGets)' == 'true' " Include="UseMauiNuGets" />
    <ProjectCapability Condition=" '$(UseMauiEssentials)' == 'true' " Include="UseMauiEssentials" />
    <ProjectCapability Condition=" '$(UseMauiAssets)' == 'true' " Include="UseMauiAssets" />
  </ItemGroup>
  <!--
      Specifying any of the <UseMaui*> properties will enable the maui workload. BundledVersions.targets enables
      the specific parts of .NET MAUI SDK.
  -->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Maui.Sdk.net10" Condition=" ('$(UseMaui)' == 'true' or '$(UseMauiCore)' == 'true' or '$(UseMauiEssentials)' == 'true' or '$(UseMauiAssets)' == 'true') and ($([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))) and ('$(SkipMauiWorkloadManifest)' != 'true') " />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.Maui.Sdk.net9" Condition=" ('$(UseMaui)' == 'true' or '$(UseMauiCore)' == 'true' or '$(UseMauiEssentials)' == 'true' or '$(UseMauiAssets)' == 'true') and ($([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))) and ('$(SkipMauiWorkloadManifest)' != 'true') " />-->
  <!--
      Previous versions of the .NET MAUI SDK used **FromWorkload**, so replace with explicit versions.
      The BundledVersions.targets that is imported is from the previous SDK, so all the other values are correct.
  -->
  <ItemGroup Condition=" $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0')) and ('$(SkipMauiWorkloadManifest)' != 'true') ">
    <KnownFrameworkReference Update="Microsoft.Maui.Core" DefaultRuntimeFrameworkVersion="$(MauiVersion)" LatestRuntimeFrameworkVersion="$(MauiVersion)" TargetingPackVersion="$(MauiVersion)" />
    <KnownFrameworkReference Update="Microsoft.Maui.Controls" DefaultRuntimeFrameworkVersion="$(MauiVersion)" LatestRuntimeFrameworkVersion="$(MauiVersion)" TargetingPackVersion="$(MauiVersion)" />
    <KnownFrameworkReference Update="Microsoft.Maui.Essentials" DefaultRuntimeFrameworkVersion="$(MauiVersion)" LatestRuntimeFrameworkVersion="$(MauiVersion)" TargetingPackVersion="$(MauiVersion)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100-preview.5/microsoft.net.sdk.tvos/18.4.10622-net10-p5/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'tvOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '10.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.tvOS.Sdk.net10.0_18.4" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'tvOS' And '$(UsingAppleNETSdk)' != 'true' And $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '9.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.tvOS.Sdk.net9.0_18.0" />-->
  <!-- this SDK version will validate the TargetPlatformVersion and show an error (in .NET 9+) or a warning (.NET 8) if it's not valid -->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition=" '$(TargetPlatformIdentifier)' == 'tvOS' And '$(UsingAppleNETSdk)' != 'true'">-->
  <!--<Import Project="Sdk-eol.props" Sdk="Microsoft.tvOS.Sdk.net10.0_18.4" Condition=" $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '9.0'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.tvOS.Sdk.net10.0_18.4" Condition=" $([MSBuild]::VersionGreaterThan($(TargetFrameworkVersion), '10.0'))" />-->
  <!--</ImportGroup>-->
  <ItemGroup Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0')) ">
    <SdkSupportedTargetPlatformIdentifier Include="tvos" DisplayName="tvOS" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/8.0.100/microsoft.net.sdk.aspire/8.2.2/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<Import Project="WorkloadManifest.Aspire.targets" Condition=" '$(IsAspireHost)' == 'true' and '$(SkipAspireWorkloadManifest)' != 'true' " />-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.current/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <_RuntimePackInWorkloadVersionCurrent>10.0.0-preview.7.25322.101</_RuntimePackInWorkloadVersionCurrent>
    <_RuntimePackInWorkloadVersion9>9.0.6</_RuntimePackInWorkloadVersion9>
    <_RuntimePackInWorkloadVersion8>8.0.17</_RuntimePackInWorkloadVersion8>
    <_RuntimePackInWorkloadVersion7>7.0.20</_RuntimePackInWorkloadVersion7>
    <_RuntimePackInWorkloadVersion6>6.0.36</_RuntimePackInWorkloadVersion6>
    <TargetsCurrent Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '10.0'))">true</TargetsCurrent>
    <!-- Disabled until next release: force net10.0 to use the current targets until the SDK can target net11.0 -->
    <!--
    <TreatPreviousAsCurrent Condition="'$(TreatPreviousAsCurrent)' == ''">true</TreatPreviousAsCurrent>
    <TargetsCurrent Condition="'$(TreatPreviousAsCurrent)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '10.0'))">true</TargetsCurrent>
    -->
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetsCurrent)' != 'true'">
    <TargetsNet9 Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '9.0'))">true</TargetsNet9>
    <TargetsNet8 Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '8.0'))">true</TargetsNet8>
    <TargetsNet7 Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '7.0'))">true</TargetsNet7>
    <TargetsNet6 Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '6.0'))">true</TargetsNet6>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)WorkloadManifest.Wasi.targets" Condition="'$(RuntimeIdentifier)' == 'wasi-wasm'" />-->
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">
    <_BrowserWorkloadNotSupportedForTFM Condition="$([MSBuild]::VersionLessThan($(TargetFrameworkVersion), '6.0'))">true</_BrowserWorkloadNotSupportedForTFM>
    <_BrowserWorkloadDisabled>$(_BrowserWorkloadNotSupportedForTFM)</_BrowserWorkloadDisabled>
    <_UsingBlazorOrWasmSdk Condition="'$(UsingMicrosoftNETSdkBlazorWebAssembly)' == 'true' or '$(UsingMicrosoftNETSdkWebAssembly)' == 'true'">true</_UsingBlazorOrWasmSdk>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm'">
    <SelfContained>true</SelfContained>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsCurrent)' == 'true'">$(WasmNativeWorkload10)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsNet9)' == 'true'">$(WasmNativeWorkload9)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsNet8)' == 'true'">$(WasmNativeWorkload8)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsNet7)' == 'true'">$(WasmNativeWorkload7)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(TargetsNet6)' == 'true'">$(WasmNativeWorkload)</WasmNativeWorkloadAvailable>
    <WasmNativeWorkloadAvailable Condition="'$(WasmNativeWorkloadAvailable)' == '' or '$(WasmNativeWorkload)' == 'false'">false</WasmNativeWorkloadAvailable>
    <WasmNativeWorkload>$(WasmNativeWorkloadAvailable)</WasmNativeWorkload>
  </PropertyGroup>
  <!-- Runtime feature defaults to trim unnecessary code -->
  <!--<Import Project="$(MSBuildThisFileDirectory)WasmFeatures.props" Condition="'$(RuntimeIdentifier)' == 'browser-wasm' or '$(RuntimeIdentifier)' == 'wasi-wasm'" />-->
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">
    <!-- Keep in sync with WasmApp.Native.targets -->
    <_WasmPropertiesDifferFromRuntimePackThusNativeBuildNeeded Condition="&#xA;        '$(WasmEnableSIMD)' == 'false' or&#xA;        '$(WasmEnableExceptionHandling)' == 'false' or&#xA;        '$(InvariantTimezone)' == 'true' or&#xA;        ('$(_UsingBlazorOrWasmSdk)' != 'true' and '$(InvariantGlobalization)' == 'true') or&#xA;        '$(WasmNativeStrip)' == 'false'">true</_WasmPropertiesDifferFromRuntimePackThusNativeBuildNeeded>
    <!-- $(WasmBuildNative)==true is needed to enable workloads, when using native references, without AOT -->
    <!-- FIXME: is the blazor condition here correct? -->
    <_WasmNativeWorkloadNeeded Condition="&#xA;        '$(_WasmPropertiesDifferFromRuntimePackThusNativeBuildNeeded)' == 'true' or&#xA;        '$(RunAOTCompilation)' == 'true' or&#xA;        '$(WasmBuildNative)' == 'true' or&#xA;        '$(WasmGenerateAppBundle)' == 'true' or&#xA;        '$(_UsingBlazorOrWasmSdk)' != 'true' or&#xA;        '$(EmccMaximumHeapSize)' != '' ">true</_WasmNativeWorkloadNeeded>
    <UsingBrowserRuntimeWorkload Condition="'$(_BrowserWorkloadNotSupportedForTFM)' == 'true'">false</UsingBrowserRuntimeWorkload>
    <UsingBrowserRuntimeWorkload Condition="'$(UsingBrowserRuntimeWorkload)' == '' and '$(_WasmNativeWorkloadNeeded)' == 'true'">true</UsingBrowserRuntimeWorkload>
    <UsingBrowserRuntimeWorkload Condition="'$(UsingBrowserRuntimeWorkload)' == ''">$(WasmNativeWorkloadAvailable)</UsingBrowserRuntimeWorkload>
  </PropertyGroup>
  <!-- Mono AOT library mode support -->
  <PropertyGroup Condition="'$(PublishAot)' != 'true' and '$(NativeLib)' != ''">
    <_IsAndroidLibraryMode Condition="'$(RuntimeIdentifier)' == 'android-arm64' or '$(RuntimeIdentifier)' == 'android-arm' or '$(RuntimeIdentifier)' == 'android-x64' or '$(RuntimeIdentifier)' == 'android-x86'">true</_IsAndroidLibraryMode>
    <_IsAppleMobileLibraryMode Condition="'$(RuntimeIdentifier)' == 'ios-arm64' or '$(RuntimeIdentifier)' == 'iossimulator-arm64' or '$(RuntimeIdentifier)' == 'iossimulator-x64' or '$(RuntimeIdentifier)' == 'maccatalyst-arm64' or '$(RuntimeIdentifier)' == 'maccatalyst-x64' or '$(RuntimeIdentifier)' == 'tvos-arm64'">true</_IsAppleMobileLibraryMode>
    <_IsiOSLibraryMode Condition="'$(RuntimeIdentifier)' == 'ios-arm64' or '$(RuntimeIdentifier)' == 'iossimulator-arm64' or '$(RuntimeIdentifier)' == 'iossimulator-x64'">true</_IsiOSLibraryMode>
    <_IsMacCatalystLibraryMode Condition="'$(RuntimeIdentifier)' == 'maccatalyst-arm64' or '$(RuntimeIdentifier)' == 'maccatalyst-x64'">true</_IsMacCatalystLibraryMode>
    <_IstvOSLibraryMode Condition="'$(RuntimeIdentifier)' == 'tvos-arm64'">true</_IstvOSLibraryMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true' or '$(TargetPlatformIdentifier)' == 'macOS' or '$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(TargetPlatformIdentifier)' == 'ios' or '$(TargetPlatformIdentifier)' == 'tvos' or '$(_IsAppleMobileLibraryMode)' == 'true'">
    <UsingMobileWorkload>true</UsingMobileWorkload>
  </PropertyGroup>
  <PropertyGroup Condition="$([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0')) and ('$(UsingMobileWorkload)' == 'true' or '$(RuntimeIdentifier)' == 'browser-wasm' or '$(RuntimeIdentifier)' == 'wasi-wasm')">
    <_MonoWorkloadTargetsMobile>true</_MonoWorkloadTargetsMobile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_UsingBlazorOrWasmSdk)' == 'true' and '$(UsingBrowserRuntimeWorkload)' == 'true'">
    <WasmGenerateAppBundle>false</WasmGenerateAppBundle>
    <UsingBlazorAOTWorkloadManifest>true</UsingBlazorAOTWorkloadManifest>
  </PropertyGroup>
  <!-- Support for "browser" target platform identifier -->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'browser' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0'))">
    <TargetPlatformSupported>true</TargetPlatformSupported>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">1.0</TargetPlatformVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'browser' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0'))">
    <SdkSupportedTargetPlatformVersion Include="1.0" />
  </ItemGroup>
  <!-- Support for "wasi" target platform identifier -->
  <PropertyGroup Condition="'$(TargetPlatformIdentifier)' == 'wasi' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0'))">
    <TargetPlatformSupported>true</TargetPlatformSupported>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">1.0</TargetPlatformVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'wasi' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0'))">
    <SdkSupportedTargetPlatformVersion Include="1.0" />
  </ItemGroup>
  <!-- we can't condition sdk imports on the item @(NativeFileReference). Instead, explicitly check before the build
  and emit a warning -->
  <Target Name="_CheckBrowserWorkloadNeededButNotAvailable" Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(_BrowserWorkloadDisabled)' != 'true' and '$(WasmNativeWorkloadAvailable)' != 'true'" BeforeTargets="Build">
    <Warning Condition="@(NativeFileReference-&gt;Count()) &gt; 0" Text="%40(NativeFileReference) is not empty, but the native references won't be linked in, because neither %24(WasmBuildNative), nor %24(RunAOTCompilation) are 'true'. NativeFileReference=@(NativeFileReference)" />
  </Target>
  <Target Name="_ErrorWorkloadDisabledForTFMLessThan6" Condition="'$(_BrowserWorkloadNotSupportedForTFM)' == 'true'" BeforeTargets="Build">
    <Error Condition="'$(RunAOTCompilation)' == 'true'" Text="WebAssembly workloads, required for AOT, are only supported for projects targeting net6.0+ . Set %24(RunAOTCompilation)=false to disable it." />
    <Error Condition="@(NativeFileReference-&gt;Count()) &gt; 0" Text="WebAssembly workloads, required for linking native files (from %40(NativeFileReference)), are only supported for projects targeting net6.0+ ." />
    <Error Condition="'$(WasmBuildNative)' == 'true'" Text="WebAssembly workloads, required for native relinking, are only supported for projects targeting net6.0+ . Set %24(WasmBuildNative)=false to disable it." />
  </Target>
  <Target Name="_ErrorDualWasmThreadPropsOn7" Condition="'$(TargetsNet7)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and&#xA;    '$(BrowserWorkloadDisabled)' != 'true' and '$(WasmEnableThreads)' == 'true' and '$(WasmEnablePerfTrace)' == 'true'" BeforeTargets="Build">
    <Error Text="WebAssembly workloads can only support one active threading mode at a time. Either set WasmEnableThreads to true, but not both." />
  </Target>
  <Target Name="_SuggestWasmWorkloadForBlazor" BeforeTargets="Publish">
    <Message Condition="'$(_UsingBlazorOrWasmSdk)' == 'true' and '$(WasmNativeWorkloadAvailable)' != 'true'" Text="Publishing without optimizations. Although it's optional for Blazor, we strongly recommend using `wasm-tools` workload! You can install it by running `dotnet workload install wasm-tools` from the command line." Importance="High" />
  </Target>
  <!--<Import Project="$(MSBuildThisFileDirectory)WorkloadTelemetry.targets" Condition="'$(_MonoWorkloadTargetsMobile)' == 'true'" />-->
  <!-- end of common logic -->
  <!-- start of TFM specific logic, make sure every node has a TargetsCurrent/TargetsNet* condition -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net10" Condition="'$(TargetsCurrent)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true' or '$(UsingWasiRuntimeWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(_IsAndroidLibraryMode)' == 'true' or '$(_IsAppleMobileLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.LibraryBuilder.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.LibraryBuilder.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(TargetPlatformIdentifier)' == 'ios' or '$(_IsiOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'ios' or '$(_IsiOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.iossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(_IsMacCatalystLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(_IsMacCatalystLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and ('$(TargetPlatformIdentifier)' == 'tvos' or '$(_IstvOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'tvos' or '$(_IstvOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsCurrent)' == 'true' and '$(RuntimeIdentifier)' == 'wasi-wasm' and '$(UsingWasiRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net10.wasi-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net10" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsCurrent)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersionCurrent)</_MonoWorkloadRuntimePackPackageVersion>
    <_KnownWebAssemblySdkPackVersion>$(_RuntimePackInWorkloadVersionCurrent)</_KnownWebAssemblySdkPackVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsCurrent)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <!-- FIXMEWASI: workaround for now -->
      <RuntimePackRuntimeIdentifiers Condition="'%(KnownRuntimePack.TargetFramework)' == 'net10.0' and '$(RuntimeIdentifier)' == 'wasi-wasm'">%(RuntimePackRuntimeIdentifiers);wasi-wasm</RuntimePackRuntimeIdentifiers>
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net10.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
      <!-- Overrides for wasm threading support -->
      <RuntimePackNamePatterns Condition="'%(KnownRuntimePack.TargetFramework)' == 'net10.0' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(WasmEnableThreads)' == 'true'">Microsoft.NETCore.App.Runtime.Mono.multithread.**RID**</RuntimePackNamePatterns>
    </KnownRuntimePack>
    <KnownFrameworkReference Update="Microsoft.NETCore.App">
      <TargetingPackVersion Condition="'%(KnownFrameworkReference.TargetFramework)' == 'net10.0'">$(_MonoWorkloadRuntimePackPackageVersion)</TargetingPackVersion>
    </KnownFrameworkReference>
    <KnownWebAssemblySdkPack Update="@(KnownWebAssemblySdkPack)">
      <WebAssemblySdkPackVersion Condition="'%(KnownWebAssemblySdkPack.TargetFramework)' == 'net10.0'">$(_KnownWebAssemblySdkPackVersion)</WebAssemblySdkPackVersion>
    </KnownWebAssemblySdkPack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.current/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm'">
    <BrowserWorkloadDisabled Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and !$([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '6.0'))">true</BrowserWorkloadDisabled>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(BrowserWorkloadDisabled)' == 'true'">
    <_NativeBuildNeeded Condition="'$(RunAOTCompilation)' == 'true'">true</_NativeBuildNeeded>
    <WorkloadDisabledWithReason Condition="'$(_NativeBuildNeeded)' == 'true'">WebAssembly workloads (required for AOT) are only supported for projects targeting net6.0+</WorkloadDisabledWithReason>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(BrowserWorkloadDisabled)' != 'true'">
    <UsingBrowserRuntimeWorkload Condition="'$(RunAOTCompilation)' == 'true' or !('$(UsingMicrosoftNETSdkBlazorWebAssembly)' == 'true' or '$(UsingMicrosoftNETSdkWebAssembly)' == 'true')">true</UsingBrowserRuntimeWorkload>
    <UsingBrowserRuntimeWorkload Condition="'$(UsingBrowserRuntimeWorkload)' == ''">$(WasmNativeWorkload)</UsingBrowserRuntimeWorkload>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingEmscriptenWorkload)' == 'true'">
    <CurrentEmsdkTarget Condition="'$(TreatPreviousAsCurrent)' == 'true'">9.0</CurrentEmsdkTarget>
    <CurrentEmsdkTarget Condition="'$(TreatPreviousAsCurrent)' != 'true'">10.0</CurrentEmsdkTarget>
  </PropertyGroup>
  <PropertyGroup Condition="'$(BrowserWorkloadDisabled)' == 'true'">
    <UsingBrowserRuntimeWorkload>false</UsingBrowserRuntimeWorkload>
    <WasmNativeWorkload>false</WasmNativeWorkload>
  </PropertyGroup>
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingEmscriptenWorkload)' == 'true') and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '$(CurrentEmsdkTarget)'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net10" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net10" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net10" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net10" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.net6/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '6.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net6" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net6" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.net7/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '7.0'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net7" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net7" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net7" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net7" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.net8/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '8.0')) and $([MSBuild]::VersionLessThan('$(TargetFrameworkVersion)', '$(CurrentEmsdkTarget)'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net8" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net8" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net8" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net8" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.emscripten.net9/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals('$(TargetFrameworkVersion)', '9.0')) and $([MSBuild]::VersionLessThan('$(TargetFrameworkVersion)', '$(CurrentEmsdkTarget)'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Python.net9" Condition="!$([MSBuild]::IsOsPlatform('Linux'))" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Node.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.Emscripten.Cache.net9" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.net6/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net6" Condition="'$(TargetsNet6)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'android'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'android' and '$(RunAOTCompilation)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--
    <ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS' and $([MSBuild]::IsOSPlatform('osx'))">
    <Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.osx-arm64" />
    <Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.osx-x64" />
    </ImportGroup>
  -->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.ios-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.iossimulator-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.iossimulator-x86" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet6)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net6" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net6.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net6" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsNet6)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(TargetPlatformIdentifier)' == 'macOS' or '$(TargetPlatformIdentifier)' == 'ios' or '$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(TargetPlatformIdentifier)' == 'tvos' or '$(RuntimeIdentifier)' == 'browser-wasm')">
    <_MonoWorkloadTargetsMobile>true</_MonoWorkloadTargetsMobile>
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersion6)</_MonoWorkloadRuntimePackPackageVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsNet6)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net6.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
    </KnownRuntimePack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.net7/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net7" Condition="'$(TargetsNet7)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'android'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'android' and '$(RunAOTCompilation)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.ios-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.iossimulator-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.iossimulator-x86" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet7)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net7" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net7" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net7.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net7" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsNet7)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(TargetPlatformIdentifier)' == 'macOS' or '$(TargetPlatformIdentifier)' == 'ios' or '$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(TargetPlatformIdentifier)' == 'tvos' or '$(RuntimeIdentifier)' == 'browser-wasm')">
    <_MonoWorkloadTargetsMobile>true</_MonoWorkloadTargetsMobile>
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersion7)</_MonoWorkloadRuntimePackPackageVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsNet7)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net7.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
      <!-- Overrides for wasm threads support -->
      <RuntimePackNamePatterns Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(WasmEnablethreads)' == 'true'">Microsoft.NETCore.App.Runtime.Mono.multithread.**RID**</RuntimePackNamePatterns>
    </KnownRuntimePack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.net8/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net8" Condition="'$(TargetsNet8)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'android'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'android' and '$(RunAOTCompilation)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'ios' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.iossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'maccatalyst' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(TargetPlatformIdentifier)' == 'tvos' and $([MSBuild]::IsOSPlatform('osx'))">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet8)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net8" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net8" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net8.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net8" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsNet8)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(TargetPlatformIdentifier)' == 'macOS' or '$(TargetPlatformIdentifier)' == 'ios' or '$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(TargetPlatformIdentifier)' == 'tvos' or '$(RuntimeIdentifier)' == 'browser-wasm' or '$(RuntimeIdentifier)' == 'wasi-wasm')">
    <_MonoWorkloadTargetsMobile>true</_MonoWorkloadTargetsMobile>
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersion8)</_MonoWorkloadRuntimePackPackageVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsNet8)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <!-- FIXMEWASI: workaround for now -->
      <RuntimePackRuntimeIdentifiers Condition="'$(RuntimeIdentifier)' == 'wasi-wasm'">%(RuntimePackRuntimeIdentifiers);wasi-wasm</RuntimePackRuntimeIdentifiers>
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net8.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
      <!-- Overrides for wasm threads support -->
      <RuntimePackNamePatterns Condition="'$(RuntimeIdentifier)' == 'browser-wasm' and '$(WasmEnablethreads)' == 'true'">Microsoft.NETCore.App.Runtime.Mono.multithread.**RID**</RuntimePackNamePatterns>
    </KnownRuntimePack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="WorkloadManifest.targets" Sdk="Microsoft.NET.SDK.WorkloadManifestTargetsLocator">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk-manifests/10.0.100/microsoft.net.workload.mono.toolchain.net9/10.0.100-preview.7.25322.101/WorkloadManifest.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!-- TFM specific -->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoAOTCompiler.Task.net9" Condition="'$(TargetsNet9)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(UsingBrowserRuntimeWorkload)' == 'true' or '$(UsingMobileWorkload)' == 'true' or '$(UsingWasiRuntimeWorkload)' == 'true')" />-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(_IsAndroidLibraryMode)' == 'true' or '$(_IsAppleMobileLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.LibraryBuilder.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.LibraryBuilder.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and '$(RunAOTCompilation)' == 'true' and ('$(TargetPlatformIdentifier)' == 'android' or '$(_IsAndroidLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.android-x86" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.android-x64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.android-arm" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.android-arm64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and '$(TargetPlatformIdentifier)' == 'macOS'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(TargetPlatformIdentifier)' == 'ios' or '$(_IsiOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'ios' or '$(_IsiOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.ios-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.iossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.iossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(_IsMacCatalystLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'maccatalyst' or '$(_IsMacCatalystLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.maccatalyst-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.maccatalyst-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and ('$(TargetPlatformIdentifier)' == 'tvos' or '$(_IstvOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and $([MSBuild]::IsOSPlatform('osx')) and ('$(TargetPlatformIdentifier)' == 'tvos' or '$(_IstvOSLibraryMode)' == 'true')">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.tvos-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.tvossimulator-arm64" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.tvossimulator-x64" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(UsingBrowserRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.browser-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <!--<ImportGroup Condition="'$(TargetsNet9)' == 'true' and '$(RuntimeIdentifier)' == 'wasi-wasm' and '$(UsingWasiRuntimeWorkload)' == 'true'">-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.net9" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.net9" />-->
  <!--<Import Project="Sdk.props" Sdk="Microsoft.NETCore.App.Runtime.AOT.Cross.net9.wasi-wasm" />-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Runtime.MonoTargets.Sdk.net9" />-->
  <!--</ImportGroup>-->
  <PropertyGroup Condition="'$(TargetsNet9)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <_MonoWorkloadRuntimePackPackageVersion>$(_RuntimePackInWorkloadVersion9)</_MonoWorkloadRuntimePackPackageVersion>
    <_KnownWebAssemblySdkPackVersion>$(_RuntimePackInWorkloadVersion9)</_KnownWebAssemblySdkPackVersion>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetsNet9)' == 'true' and '$(_MonoWorkloadTargetsMobile)' == 'true'">
    <KnownRuntimePack Update="@(KnownRuntimePack)">
      <!-- FIXMEWASI: workaround for now -->
      <RuntimePackRuntimeIdentifiers Condition="'%(KnownRuntimePack.TargetFramework)' == 'net9.0' and '$(RuntimeIdentifier)' == 'wasi-wasm'">%(RuntimePackRuntimeIdentifiers);wasi-wasm</RuntimePackRuntimeIdentifiers>
      <LatestRuntimeFrameworkVersion Condition="'%(KnownRuntimePack.TargetFramework)' == 'net9.0' and '%(KnownRuntimePack.RuntimePackLabels)' == 'Mono'">$(_MonoWorkloadRuntimePackPackageVersion)</LatestRuntimeFrameworkVersion>
      <!-- Overrides for wasm threading support -->
      <RuntimePackNamePatterns Condition="'%(KnownRuntimePack.TargetFramework)' == 'net9.0' and '$(RuntimeIdentifier)' == 'browser-wasm' and '$(WasmEnableThreads)' == 'true'">Microsoft.NETCore.App.Runtime.Mono.multithread.**RID**</RuntimePackNamePatterns>
    </KnownRuntimePack>
    <KnownFrameworkReference Update="Microsoft.NETCore.App">
      <TargetingPackVersion Condition="'%(KnownFrameworkReference.TargetFramework)' == 'net9.0'">$(_MonoWorkloadRuntimePackPackageVersion)</TargetingPackVersion>
    </KnownFrameworkReference>
    <KnownWebAssemblySdkPack Update="@(KnownWebAssemblySdkPack)">
      <WebAssemblySdkPackVersion Condition="'%(KnownWebAssemblySdkPack.TargetFramework)' == 'net9.0'">$(_KnownWebAssemblySdkPackVersion)</WebAssemblySdkPackVersion>
    </KnownWebAssemblySdkPack>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.ImportWorkloads.targets
============================================================================================================================================
-->
  <UsingTask TaskName="ShowMissingWorkloads" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GetSuggestedWorkloads" Returns="@(SuggestedWorkload)" Condition="@(MissingWorkloadPack) != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ShowMissingWorkloads MissingWorkloadPacks="@(MissingWorkloadPack)" NetCoreRoot="$(NetCoreRoot)" NETCoreSdkVersion="$(NETCoreSdkVersion)" GenerateErrorsForMissingWorkloads="false">
      <Output TaskParameter="SuggestedWorkloads" ItemName="SuggestedWorkload" />
    </ShowMissingWorkloads>
  </Target>
  <!-- Skip this target for design time builds when there are missing workload packs.
       This will prevent design time builds from failing and therefore allow
       Visual Studio to collect the workloads from the GetSuggestedWorkloads target -->
  <Target Name="_CheckForMissingWorkload" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;_CheckForUnsupportedTargetPlatformIdentifier" Condition="'@(MissingWorkloadPack)' != '' And '$(DesignTimeBuild)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ShowMissingWorkloads MissingWorkloadPacks="@(MissingWorkloadPack)" NetCoreRoot="$(NetCoreRoot)" NETCoreSdkVersion="$(NETCoreSdkVersion)" GenerateErrorsForMissingWorkloads="true" />
  </Target>
  <!--  This target is not part of the build. Only used by dotnet workload restore command. Global property "SkipResolvePackageAssets"
        need to be set to "true" to avoid requiring restore (which would likely fail if the required workloads aren't already installed).
        In addition, since this is a target that is called on potentially-unsupported project types like esproj, we need to not fail
        if the Target is missing. -->
  <Target Name="_GetRequiredWorkloads" DependsOnTargets="GetSuggestedWorkloads;PrepareProjectReferences" Returns="@(_ResolvedSuggestedWorkload)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="_GetRequiredWorkloads" BuildInParallel="$(BuildInParallel)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences);TargetFramework;TargetFrameworks" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="SuggestedWorkloadFromReference" />
    </MSBuild>
    <ItemGroup>
      <_ResolvedSuggestedWorkload Include="@(SuggestedWorkload)" />
      <_ResolvedSuggestedWorkload Include="@(SuggestedWorkloadFromReference)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!--
    Use RuntimeIdentifier to determine PlatformTarget.
    Also, enforce that RuntimeIdentifier is always specified for .NETFramework executables.
  -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.RuntimeIdentifierInference.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.RuntimeIdentifierInference.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.RuntimeIdentifierInference.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    .NET Framework cannot load native package dependencies dynamically
    based on the current architecture.  We must have a RID to resolve
    and copy native dependencies to the output directory.

    When building a .NET Framework exe on Windows and not given a RID,
    we'll pick either win7-x64 or win7-x86 (based on PlatformTarget)
    if we're not given an explicit RID. However, if after resolving
    NuGet assets we find no copy-local native dependencies, we will
    emit the binary as AnyCPU.

    Note that we must set the RID here early (to be seen during NuGet
    restore) in order for the project.assets.json to include the
    native dependencies that will let us make the final call on
    AnyCPU or platform-specific.

    This allows these common cases to work without requiring mention
    of RuntimeIdentifier in the user project PlatformTarget:

      1. Building an AnyCPU .NET Framework application on any host OS
         with no native NuGet dependencies.

      2. Building an x86 or x64 .NET Framework application on and for
         Windows with native NuGet dependencies that do not require
         greater than win7.

     However, any other combination of host operating system, CPU
     architecture, and minimum Windows version will require some
     manual intervention in the project file to set up the right
     RID. (**)

     (*) Building NET4x from non-Windows is still not fully supported:
         https://github.com/dotnet/sdk/issues/335) The point above is
         that this code would not have to change to make the first
         scenario work on non-Windows hosts.

     (**) https://github.com/dotnet/sdk/issues/840 tracks improving
          the default RID selection here to make more non-AnyCPU scenarios
          work without user intervention. The current static evaluation
          requirement limits us.
   -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and&#xA;                            '$(HasRuntimeOutput)' == 'true' and&#xA;                            $([MSBuild]::IsOSPlatform(`Windows`)) and&#xA;                            '$(RuntimeIdentifier)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UsingDefaultRuntimeIdentifier>true</_UsingDefaultRuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(PlatformTarget)' == 'x64'">win7-x64</RuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(PlatformTarget)' == 'x86' or '$(PlatformTarget)' == ''">win7-x86</RuntimeIdentifier>
    <RuntimeIdentifier Condition="'$(PlatformTarget)' == 'x64' and '$(UseRidGraph)' != 'true'">win-x64</RuntimeIdentifier>
    <RuntimeIdentifier Condition="('$(PlatformTarget)' == 'x86' or '$(PlatformTarget)' == '') and '$(UseRidGraph)' != 'true'">win-x86</RuntimeIdentifier>
  </PropertyGroup>
  <!-- Breaking change in .NET 8: Some publish properties used to imply SelfContained or require it at the time of this PR to work. We decided to infer SelfContained still in these situations. -->
  <PropertyGroup Condition="'$(SelfContained)' == '' and&#xA;                             '$(PublishSelfContained)' == '' and&#xA;                             '$(_TargetFrameworkVersionWithoutV)' != '' and&#xA;                             '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                             $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '8.0')) and&#xA;                              (&#xA;                                  '$(PublishTrimmed)' == 'true' or&#xA;                                  '$(PublishSingleFile)' == 'true' or&#xA;                                  '$(PublishAot)' == 'true'&#xA;                              )" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishSelfContained>true</PublishSelfContained>
  </PropertyGroup>
  <!-- Packing a tool runs the publish targets, so in that case set _IsPublishing to true -->
  <PropertyGroup Condition="'$(PackAsTool)' == 'true' And '$(_IsPacking)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsPublishing>true</_IsPublishing>
  </PropertyGroup>
  <!-- Edit SelfContained to match the value of PublishSelfContained if we are publishing.
       This Won't affect t:/Publish (because of _IsPublishing), and also won't override a global SelfContained property.-->
  <PropertyGroup Condition="'$(_IsPublishing)' == 'true' and ('$(PublishSelfContained)' == 'true' or '$(PublishSelfContained)' == 'false')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SelfContained>$(PublishSelfContained)</SelfContained>
  </PropertyGroup>
  <!-- Automatically infer the RuntimeIdentifier for properties that require it.
  SelfContained without a RID is a no-op and semantically hints towards the fact that it can change the behavior of build, publish, and friends.
  ... So, we infer the RID for SelfContained regardless of the context.

  The other publish properties are specifically labelled Publish* and don't 'NEED' their RID unless we are doing a publish, so the RID inference
  ... for these properties is limited to publishing only scenarios.

  .NET Tools that build RID-specific packages will also need a primary package without a RuntimeIdentifier, so we disable RID inference for them
  in order to build the primary package

  Finally, library projects and non-executable projects have awkward interactions here so they are excluded.
  -->
  <PropertyGroup Condition="'$(UseCurrentRuntimeIdentifier)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <UseCurrentRuntimeIdentifier Condition="&#xA;                 '$(RuntimeIdentifier)' == '' and&#xA;                 '$(_IsExecutable)' == 'true' and '$(IsTestProject)' != 'true' and&#xA;                 '$(IsRidAgnostic)' != 'true' and&#xA;                 '$(PackAsTool)' != true and&#xA;                 (&#xA;                   '$(SelfContained)' == 'true' or&#xA;                   ('$(_IsPublishing)' == 'true' and&#xA;                      (&#xA;                        '$(PublishReadyToRun)' == 'true' or&#xA;                        '$(PublishSingleFile)' == 'true' or&#xA;                        '$(PublishAot)' == 'true'&#xA;                      )&#xA;                   )&#xA;                 )">true</UseCurrentRuntimeIdentifier>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseCurrentRuntimeIdentifier)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RuntimeIdentifier>$(NETCoreSdkPortableRuntimeIdentifier)</RuntimeIdentifier>
  </PropertyGroup>
  <PropertyGroup Condition="'$(_IsPublishing)' == 'true' and '$(PublishRuntimeIdentifier)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RuntimeIdentifier>$(PublishRuntimeIdentifier)</RuntimeIdentifier>
  </PropertyGroup>
  <PropertyGroup Condition="'$(PlatformTarget)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UsingDefaultPlatformTarget>true</_UsingDefaultPlatformTarget>
  </PropertyGroup>
  <!-- Determine PlatformTarget (if not already set) from runtime identifier. -->
  <Choose xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <When Condition="'$(PlatformTarget)' != '' or '$(RuntimeIdentifier)' == ''" />
    <When Condition="$(RuntimeIdentifier.EndsWith('-x86')) or $(RuntimeIdentifier.Contains('-x86-'))">
      <PropertyGroup>
        <PlatformTarget>x86</PlatformTarget>
      </PropertyGroup>
    </When>
    <When Condition="$(RuntimeIdentifier.EndsWith('-x64')) or $(RuntimeIdentifier.Contains('-x64-'))">
      <PropertyGroup>
        <PlatformTarget>x64</PlatformTarget>
      </PropertyGroup>
    </When>
    <When Condition="$(RuntimeIdentifier.EndsWith('-arm')) or $(RuntimeIdentifier.Contains('-arm-'))">
      <PropertyGroup>
        <PlatformTarget>arm</PlatformTarget>
      </PropertyGroup>
    </When>
    <When Condition="$(RuntimeIdentifier.EndsWith('-arm64')) or $(RuntimeIdentifier.Contains('-arm64-'))">
      <PropertyGroup>
        <PlatformTarget>arm64</PlatformTarget>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <PlatformTarget>AnyCPU</PlatformTarget>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <!--
    SelfContained was not an option in .NET Core SDK 1.0.
    Default SelfContained based on the RuntimeIdentifier, so projects don't have to explicitly set SelfContained.
    This avoids a breaking change from 1.0 behavior.
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Detecting property presence is not harmful and can be done in an unconditioned way -->
    <_SelfContainedWasSpecified Condition="'$(SelfContained)' != ''">true</_SelfContainedWasSpecified>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Breaking change in .NET 8: Projects with 8.0+ TFMS will no longer have RuntimeIdentifier imply SelfContained. Note that PublishReadyToRun will imply SelfContained in these versions. -->
    <SelfContained Condition="'$(SelfContained)' == '' and&#xA;                              '$(RuntimeIdentifier)' != '' and&#xA;                              '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                              '$(_TargetFrameworkVersionWithoutV)' != '' and&#xA;                              $([MSBuild]::VersionLessThan($(_TargetFrameworkVersionWithoutV), '8.0'))">true</SelfContained>
    <SelfContained Condition="'$(SelfContained)' == ''">false</SelfContained>
    <_RuntimeIdentifierUsesAppHost Condition="$(RuntimeIdentifier.StartsWith('ios')) or $(RuntimeIdentifier.StartsWith('tvos')) or $(RuntimeIdentifier.StartsWith('maccatalyst')) or $(RuntimeIdentifier.StartsWith('android')) or $(RuntimeIdentifier.StartsWith('browser')) or $(RuntimeIdentifier.StartsWith('wasi'))">false</_RuntimeIdentifierUsesAppHost>
    <_RuntimeIdentifierUsesAppHost Condition="'$(_IsPublishing)' == 'true' and '$(PublishAot)' == 'true'">false</_RuntimeIdentifierUsesAppHost>
    <_RuntimeIdentifierUsesAppHost Condition="'$(_RuntimeIdentifierUsesAppHost)' == ''">true</_RuntimeIdentifierUsesAppHost>
    <UseAppHost Condition="'$(UseAppHost)' == '' and&#xA;                           '$(_RuntimeIdentifierUsesAppHost)' == 'true' and&#xA;                           ('$(SelfContained)' == 'true' or&#xA;                            ('$(RuntimeIdentifier)' != '' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '2.1') or&#xA;                            '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0')">true</UseAppHost>
    <UseAppHost Condition="'$(UseAppHost)' == ''">false</UseAppHost>
  </PropertyGroup>
  <!-- Only use the default apphost if building without a RID and without a deps file path (used by GenerateDeps.proj for CLI tools). -->
  <PropertyGroup Condition="'$(DefaultAppHostRuntimeIdentifier)' == '' and&#xA;                            '$(RuntimeIdentifier)' == '' and&#xA;                            (('$(UseAppHost)' == 'true' and '$(ProjectDepsFilePath)' == '') or&#xA;                            ('$(EnableComHosting)' == 'true' and '$(_IsExecutable)' != 'true') or&#xA;                            '$(UseIJWHost)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefaultAppHostRuntimeIdentifier>$(NETCoreSdkRuntimeIdentifier)</DefaultAppHostRuntimeIdentifier>
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and '$(PlatformTarget)' == 'x64'">win-x64</DefaultAppHostRuntimeIdentifier>
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and '$(PlatformTarget)' == 'x86'">win-x86</DefaultAppHostRuntimeIdentifier>
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and '$(PlatformTarget)' == 'ARM'">win-arm</DefaultAppHostRuntimeIdentifier>
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and '$(PlatformTarget)' == 'ARM64'">win-arm64</DefaultAppHostRuntimeIdentifier>
    <!-- If we are running on an M1 with a native SDK and the TFM is < 6.0, we have to use a x64 apphost since there are no osx-arm64 apphosts previous to .NET 6.0. -->
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.EndsWith('arm64')) and&#xA;                                  $(DefaultAppHostRuntimeIdentifier.StartsWith('osx')) and&#xA;                                  $([MSBuild]::VersionLessThan('$(_TargetFrameworkVersionWithoutV)', '6.0'))">$(DefaultAppHostRuntimeIdentifier.Replace("arm64", "x64"))</DefaultAppHostRuntimeIdentifier>
    <!-- If we are running on win-arm64 and the TFM is < 5.0, we have to use a x64 apphost since there are no win-arm64 apphosts previous to .NET 5.0. -->
    <DefaultAppHostRuntimeIdentifier Condition="$(DefaultAppHostRuntimeIdentifier.EndsWith('arm64')) and&#xA;                                  $(DefaultAppHostRuntimeIdentifier.StartsWith('win')) and&#xA;                                  $([MSBuild]::VersionLessThan('$(_TargetFrameworkVersionWithoutV)', '5.0'))">$(DefaultAppHostRuntimeIdentifier.Replace("arm64", "x64"))</DefaultAppHostRuntimeIdentifier>
  </PropertyGroup>
  <Target Name="_CheckForUnsupportedAppHostUsage" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- The following RID errors are asserts, and we don't expect them to ever occur. The error message is added as a safeguard.-->
    <NETSdkError Condition="'$(SelfContained)' == 'true' and '$(RuntimeIdentifier)' == '' and '$(AllowSelfContainedWithoutRuntimeIdentifier)' != 'true'" ResourceName="ImplicitRuntimeIdentifierResolutionForPublishPropertyFailed" FormatArguments="SelfContained" />
    <NETSdkError Condition="'$(PublishReadyToRun)' == 'true' and '$(RuntimeIdentifier)' == '' and '$(_IsPublishing)' == 'true' and '$(AllowReadyToRunWithoutRuntimeIdentifier)' != 'true'" ResourceName="ImplicitRuntimeIdentifierResolutionForPublishPropertyFailed" FormatArguments="PublishReadyToRun" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' and '$(RuntimeIdentifier)' == '' and '$(_IsPublishing)' == 'true' and '$(AllowPublishSingleFileWithoutRuntimeIdentifier)' != 'true'" ResourceName="ImplicitRuntimeIdentifierResolutionForPublishPropertyFailed" FormatArguments="PublishSingleFile" />
    <NETSdkError Condition="'$(PublishAot)' == 'true' and '$(RuntimeIdentifier)' == '' and '$(_IsPublishing)' == 'true' and '$(AllowPublishAotWithoutRuntimeIdentifier)' != 'true'" ResourceName="ImplicitRuntimeIdentifierResolutionForPublishPropertyFailed" FormatArguments="PublishAot" />
    <!-- End of implicit RID resolver checks.-->
    <NETSdkError Condition="'$(PublishSelfContained)' != 'true' and '$(PublishSelfContained)' != 'false' and '$(PublishSelfContained)' != ''" ResourceName="PublishSelfContainedMustBeBool" FormatArguments="$(PublishSelfContained)" />
    <NETSdkError Condition="'$(SelfContained)' == 'true' and '$(UseAppHost)' != 'true' and '$(_RuntimeIdentifierUsesAppHost)' == 'true'" ResourceName="CannotUseSelfContainedWithoutAppHost" />
    <NETSdkError Condition="'$(SelfContained)' != 'true' and '$(UseAppHost)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &lt; '2.1'" ResourceName="FrameworkDependentAppHostRequiresVersion21" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'" ResourceName="PublishSingleFileRequiresVersion30" />
    <!-- The TFM version checks for PublishReadyToRun PublishTrimmed only generate warnings in .Net core 3.1
         because we do not want the behavior to be a breaking change compared to version 3.0 -->
    <NETSdkWarning Condition="'$(PublishReadyToRun)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'" ResourceName="PublishReadyToRunRequiresVersion30" />
    <!-- Previously, RuntimeIdentifier (RID) implied SelfContained (SC). A breaking change in 8.0 made it so RID did not activate SC by default.
         So we warn older TFM users before they upgrade to TFM 8.0 or above that they need to add <SelfContained>true</SelfContained> now to keep the same behavior.-->
    <NETSdkWarning Condition="'$(RuntimeIdentifier)' != '' and '$(_TargetFrameworkVersionWithoutV)' != '' and $([MSBuild]::VersionLessThan($(_TargetFrameworkVersionWithoutV), '8.0')) and '$(_SelfContainedWasSpecified)' != 'true'" ResourceName="RuntimeIdentifierWillNoLongerImplySelfContained" />
    <!-- Generate Trimming warnings for WinForms and Wpf applications-->
    <NetSdkError Condition="('$(UseWindowsForms)' == 'true') and ('$(PublishTrimmed)' == 'true') and ('$(_SuppressWinFormsTrimError)' != 'true')" ResourceName="TrimmingWindowsFormsIsNotSupported" />
    <NetSdkError Condition="('$(UseWpf)' == 'true') and ('$(PublishTrimmed)' == 'true') and ('$(_SuppressWpfTrimError)' != 'true')" ResourceName="TrimmingWpfIsNotSupported" />
  </Target>
  <Target Name="_CheckForUnsupportedHostingUsage" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning Condition="'$(SelfContained)' == 'true' and '$(EnableComHosting)' == 'true'" ResourceName="NoSupportComSelfContained" />
  </Target>
  <Target Name="_CheckAndUnsetUnsupportedPrefer32Bit" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '7.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning Condition="'$(Prefer32Bit)' == 'true'" ResourceName="Prefer32BitIgnoredForNetCoreApp" />
    <PropertyGroup>
      <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
  </Target>
  <Target Name="_CheckAndUnsetUnsupportedPreferNativeArm64" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(PreferNativeArm64)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning ResourceName="PreferNativeArm64IgnoredForNetCoreApp" />
    <PropertyGroup>
      <PreferNativeArm64>false</PreferNativeArm64>
    </PropertyGroup>
  </Target>
  <Target Name="_CheckForMismatchingPlatform" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(RuntimeIdentifier)' != '' and '$(PlatformTarget)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(PlatformTarget)' != 'AnyCPU' and !$(RuntimeIdentifier.ToUpperInvariant().Contains($(PlatformTarget.ToUpperInvariant())))" ResourceName="CannotHaveRuntimeIdentifierPlatformMismatchPlatformTarget" FormatArguments="$(RuntimeIdentifier);$(PlatformTarget)" />
  </Target>
  <Target Name="_CheckForLanguageAndFeatureCombinationSupport" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;ProcessFrameworkReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true') and $(OutputType) != 'library' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" ResourceName="NoSupportCppNonDynamicLibraryDotnetCore" />
    <NETSdkError Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true') and $(EnableComHosting) == 'true'" ResourceName="NoSupportCppEnableComHosting" />
    <NETSdkError Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true') and $(SelfContained) == 'true'" ResourceName="NoSupportCppSelfContained" />
  </Target>
  <Target Name="_CheckForNETCoreSdkIsPreview" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition=" '$(_NETCoreSdkIsPreview)' == 'true' AND '$(SuppressNETCoreSdkPreviewMessage)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ShowPreviewMessage />
  </Target>
  <!-- Projects which don't use Microsoft.NET.Sdk will typically define the OutputPath directly (usually in a
       Configuration-specific PropertyGroup), so in that case we won't append to it by default. -->
  <PropertyGroup Condition="'$(UsingNETSdkDefaults)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Projects can opt out of having the RID appended to the output path by setting this to false. -->
    <AppendRuntimeIdentifierToOutputPath Condition="'$(AppendRuntimeIdentifierToOutputPath)' == ''">true</AppendRuntimeIdentifierToOutputPath>
  </PropertyGroup>
  <!--
    Append $(RuntimeIdentifier) directory to output and intermediate paths to prevent bin clashes between
    targets.

    But do not append the implicit default runtime identifier for .NET Framework apps as that would
    append a RID the user never mentioned in the path and do so even in the AnyCPU case.
   -->
  <PropertyGroup Condition="'$(AppendRuntimeIdentifierToOutputPath)' == 'true' and '$(RuntimeIdentifier)' != '' and '$(_UsingDefaultRuntimeIdentifier)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IntermediateOutputPath Condition="'$(UseArtifactsIntermediateOutput)' != 'true'">$(IntermediateOutputPath)$(RuntimeIdentifier)\</IntermediateOutputPath>
    <OutputPath Condition="'$(UseArtifactsOutput)' != 'true'">$(OutputPath)$(RuntimeIdentifier)\</OutputPath>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.GetDefaultPlatformTargetForNetFramework" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    Switch our default .NETFramework CPU architecture choice back to AnyCPU before
    compiling the exe if no copy-local native dependencies were resolved from NuGet
  -->
  <Target Name="AdjustDefaultPlatformTargetForNetFrameworkExeWithNoNativeCopyLocalItems" AfterTargets="ResolvePackageAssets" BeforeTargets="CoreCompile" Condition="'$(_UsingDefaultPlatformTarget)' == 'true' and&#xA;                     '$(_UsingDefaultRuntimeIdentifier)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetDefaultPlatformTargetForNetFramework PackageDependencies="@(PackageDependencies)" NativeCopyLocalItems="@(NativeCopyLocalItems)">
      <Output TaskParameter="DefaultPlatformTarget" PropertyName="PlatformTarget" />
    </GetDefaultPlatformTargetForNetFramework>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Checks for EOL frameworks -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.EolTargetFrameworks.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.EolTargetFrameworks.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.EolTargetFrameworks.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Default the check to true, but allow developers to turn the warning off. -->
    <CheckEolTargetFramework Condition="'$(CheckEolTargetFramework)' == '' and '$(OutputType)' != 'Library'">true</CheckEolTargetFramework>
    <CheckEolWorkloads Condition="'$(CheckEolWorkloads)' == ''">true</CheckEolWorkloads>
  </PropertyGroup>
  <!--
    .NET Core framework versions that are currently considered to be end-of-life (EOL). These versions will not be targeted to
    receive servicing updates and security fixes.
  -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_EolNetCoreTargetFrameworkVersions Include="1.0;1.1;2.0;2.1;2.2;3.0;3.1;5.0;7.0" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_MinimumNonEolSupportedNetCoreTargetFramework>net6.0</_MinimumNonEolSupportedNetCoreTargetFramework>
  </PropertyGroup>
  <Target Name="_CheckForEolTargetFrameworks" AfterTargets="_CheckForUnsupportedNETCoreVersion" Condition="'@(_EolNetCoreTargetFrameworkVersions-&gt;AnyHaveMetadataValue('Identity', '$(_TargetFrameworkVersionWithoutV)'))' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(CheckEolTargetFramework)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning ResourceName="TargetFrameworkIsEol" FormatArguments="$(TargetFramework.ToLowerInvariant());https://aka.ms/dotnet-core-support" />
  </Target>
  <Target Name="_CheckForEolWorkloads" AfterTargets="_CheckForUnsupportedNETCoreVersion" Condition="'@(EolWorkload)' != '' and '$(CheckEolWorkloads)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning ResourceName="WorkloadIsEol" FormatArguments="%(EolWorkload.Identity);$([MSBuild]::ValueOrDefault('%(EolWorkload.Url)', 'https://aka.ms/dotnet-core-support'))" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <!-- Check if the Target Framework is coreclr based -->
  <PropertyGroup Condition="'$(_IsNETCoreOrNETStandard)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsNETCoreOrNETStandard Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</_IsNETCoreOrNETStandard>
    <_IsNETCoreOrNETStandard Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">true</_IsNETCoreOrNETStandard>
  </PropertyGroup>
  <!-- Unification / automatic binding redirect logic -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DesignTimeAutoUnify Condition="'$(DesignTimeAutoUnify)' == ''">true</DesignTimeAutoUnify>
    <AutoUnifyAssemblyReferences Condition="'$(AutoUnifyAssemblyReferences)' == '' and $(OutputType) == 'Library'">true</AutoUnifyAssemblyReferences>
    <AutoUnifyAssemblyReferences Condition="'$(AutoUnifyAssemblyReferences)' == '' and '$(_IsNETCoreOrNETStandard)' == 'true'">true</AutoUnifyAssemblyReferences>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AutoGenerateBindingRedirects Condition="'$(AutoGenerateBindingRedirects)' == ''">true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <!-- Default settings for .NET Core and .NET Standard build logic -->
  <PropertyGroup Condition="'$(_IsNETCoreOrNETStandard)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateDependencyFile Condition=" '$(GenerateDependencyFile)' == '' ">true</GenerateDependencyFile>
    <!-- Assembly and file versions of runtime assets should be written to the deps.json by default, to support
         runtime minor version roll-forward: https://github.com/dotnet/core-setup/issues/3546 -->
    <IncludeFileVersionsInDependencyFile Condition="'$(IncludeFileVersionsInDependencyFile)' == ''">true</IncludeFileVersionsInDependencyFile>
    <!-- Force .dll extension for .NETCoreApp and .NETStandard projects even if output type is exe. -->
    <TargetExt Condition="'$(TargetExt)' == ''">.dll</TargetExt>
    <!-- Disable the use of FrameworkPathOverride in Microsoft.Common.CurrentVersion.targets which can slow down evaluation.  FrameworkPathOverride
    is not needed for NETStandard or NETCore since references come from NuGet packages-->
    <EnableFrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' == ''">false</EnableFrameworkPathOverride>
  </PropertyGroup>
  <!-- Regardless of platform, enable dependency file generation if PreserveCompilationContext is set. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateDependencyFile Condition="'$(GenerateDependencyFile)' == ''">$(PreserveCompilationContext)</GenerateDependencyFile>
  </PropertyGroup>
  <!-- Set PublishDir here, before Microsoft.Common.targets, to avoid a competing default there.
       If using artifacts output path format, PublishDir is already set in Microsoft.NET.DefaultOutputPaths.targets -->
  <PropertyGroup Condition="'$(UseArtifactsOutput)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishDirName Condition="'$(PublishDirName)' == ''">publish</PublishDirName>
    <!-- ensure the PublishDir is RID specific-->
    <PublishDir Condition="'$(PublishDir)' == '' and&#xA;                           '$(AppendRuntimeIdentifierToOutputPath)' != 'true' and&#xA;                           '$(RuntimeIdentifier)' != '' and&#xA;                           '$(_UsingDefaultRuntimeIdentifier)' != 'true'">$(OutputPath)$(RuntimeIdentifier)\$(PublishDirName)\</PublishDir>
    <PublishDir Condition="'$(PublishDir)' == ''">$(OutputPath)$(PublishDirName)\</PublishDir>
  </PropertyGroup>
  <!--
    Sets RestoreAdditionalProjectSources or RestoreAdditionalProjectFallbackFolders to the SDK Offline Cache based
    on the TargetFramework.
  -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.NuGetOfflineCache.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.NuGetOfflineCache.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.NuGetOfflineCache.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_NugetFallbackFolder>$(MSBuildThisFileDirectory)..\..\..\..\NuGetFallbackFolder</_NugetFallbackFolder>
    <_IsNETCore1x Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &lt; '2.0' ">true</_IsNETCore1x>
    <_WorkloadLibraryPacksFolder Condition="'$(_WorkloadLibraryPacksFolder)' == ''">$([MSBuild]::EnsureTrailingSlash('$(NetCoreRoot)'))library-packs</_WorkloadLibraryPacksFolder>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(DisableImplicitNuGetFallbackFolder)' != 'true' and Exists($(_NugetFallbackFolder)) " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RestoreAdditionalProjectSources Condition=" '$(_IsNETCore1x)' == 'true' and '$(DisableImplicit1xNuGetFallbackFolder)' != 'true' ">$(RestoreAdditionalProjectSources);$(_NugetFallbackFolder)</RestoreAdditionalProjectSources>
    <RestoreAdditionalProjectFallbackFoldersExcludes Condition=" '$(_IsNETCore1x)' == 'true' ">$(RestoreAdditionalProjectFallbackFoldersExcludes);$(_NugetFallbackFolder)</RestoreAdditionalProjectFallbackFoldersExcludes>
    <RestoreAdditionalProjectFallbackFolders Condition=" '$(_IsNETCore1x)' != 'true' ">$(RestoreAdditionalProjectFallbackFolders);$(_NugetFallbackFolder)</RestoreAdditionalProjectFallbackFolders>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(DisableImplicitLibraryPacksFolder)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RestoreAdditionalProjectSources Condition="Exists('$(_WorkloadLibraryPacksFolder)')">$(RestoreAdditionalProjectSources);$(_WorkloadLibraryPacksFolder)</RestoreAdditionalProjectSources>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.BeforeCommon.targets
============================================================================================================================================
-->
  <ItemGroup Condition=" '$(DisableImplicitFrameworkReferences)' != 'true' and '$(TargetFrameworkIdentifier)' == '.NETFramework'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_SDKImplicitReference Include="System" />
    <_SDKImplicitReference Include="System.Data" />
    <_SDKImplicitReference Include="System.Drawing" />
    <_SDKImplicitReference Include="System.Xml" />
    <!-- When doing greater than/less than comparisons between strings, MSBuild will try to parse the strings as Version objects and compare them as
         such if the parse succeeds. -->
    <!-- Framework assemblies introduced in .NET 3.5 -->
    <_SDKImplicitReference Include="System.Core" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.5' " />
    <_SDKImplicitReference Include="System.Runtime.Serialization" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.5' " />
    <_SDKImplicitReference Include="System.Xml.Linq" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.5' " />
    <!-- Framework assemblies introduced in .NET 4.0 -->
    <_SDKImplicitReference Include="System.Numerics" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '4.0' " />
    <!-- Framework assemblies introduced in .NET 4.5 -->
    <_SDKImplicitReference Include="System.IO.Compression.FileSystem" Condition=" '$(_TargetFrameworkVersionWithoutV)' &gt;= '4.5' " />
    <_SDKImplicitReference Update="@(_SDKImplicitReference)" Pack="false" IsImplicitlyDefined="true" />
    <!-- Don't duplicate any references that are explicit in the project file.  This means that if you do want to include a framework assembly in your
         NuGet package, you can just add the Reference to your project file. -->
    <_SDKImplicitReference Remove="@(Reference)" />
    <!-- Add the implicit references to @(Reference) -->
    <Reference Include="@(_SDKImplicitReference)" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Prevent System.Core reference from being added separately (see Microsoft.NETFramework.CurrentVersion.props) -->
    <AddAdditionalExplicitAssemblyReferences>false</AddAdditionalExplicitAssemblyReferences>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DisableImplicitAssetTargetFallback)' != 'true' and '$(_IsNETCoreOrNETStandard)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '2.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AssetTargetFallback>$(AssetTargetFallback);net461;net462;net47;net471;net472;net48;net481</AssetTargetFallback>
  </PropertyGroup>
  <!-- Add conditional compilation symbols for the target framework (for example NET461, NETSTANDARD2_0, NETCOREAPP1_0) -->
  <PropertyGroup Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' and '$(TargetFrameworkIdentifier)' != '.NETPortable' and '$(TargetFrameworkIdentifier)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_FrameworkIdentifierForImplicitDefine>$(TargetFrameworkIdentifier.Replace('.', '').ToUpperInvariant())</_FrameworkIdentifierForImplicitDefine>
    <_FrameworkIdentifierForImplicitDefine Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) ">NET</_FrameworkIdentifierForImplicitDefine>
    <VersionlessImplicitFrameworkDefine>$(_FrameworkIdentifierForImplicitDefine)</VersionlessImplicitFrameworkDefine>
    <_FrameworkIdentifierForImplicitDefine Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework'">NET</_FrameworkIdentifierForImplicitDefine>
    <_FrameworkVersionForImplicitDefine>$(TargetFrameworkVersion.TrimStart('vV'))</_FrameworkVersionForImplicitDefine>
    <_FrameworkVersionForImplicitDefine>$(_FrameworkVersionForImplicitDefine.Replace('.', '_'))</_FrameworkVersionForImplicitDefine>
    <_FrameworkVersionForImplicitDefine Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework'">$(_FrameworkVersionForImplicitDefine.Replace('_', ''))</_FrameworkVersionForImplicitDefine>
    <ImplicitFrameworkDefine>$(_FrameworkIdentifierForImplicitDefine)$(_FrameworkVersionForImplicitDefine)</ImplicitFrameworkDefine>
    <BackwardsCompatFrameworkDefine Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0))">$(TargetFrameworkIdentifier.Replace('.', '').ToUpperInvariant())</BackwardsCompatFrameworkDefine>
  </PropertyGroup>
  <!-- Add conditional compilation symbols for the target platform (for example ANDROID, IOS, WINDOWS) -->
  <Target Name="GenerateTargetPlatformDefineConstants" Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' and '$(TargetPlatformIdentifier)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_PlatformIdentifierForImplicitDefine>$(TargetPlatformIdentifier.ToUpperInvariant())</_PlatformIdentifierForImplicitDefine>
      <_PlatformVersionForImplicitDefine>$(TargetPlatformVersion.Replace('.', '_'))</_PlatformVersionForImplicitDefine>
    </PropertyGroup>
    <ItemGroup>
      <_ImplicitDefineConstant Include="$(_PlatformIdentifierForImplicitDefine)" />
      <_ImplicitDefineConstant Include="$(_PlatformIdentifierForImplicitDefine)$(_PlatformVersionForImplicitDefine)" />
    </ItemGroup>
  </Target>
  <!-- Add OR_GREATER compilation symbols for target frameworks with .NET Framework, .NET Standard, .NET Core, and .NET -->
  <Target Name="GenerateNETCompatibleDefineConstants" Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' and ('$(TargetFrameworkIdentifier)' == '.NETCoreApp' or '$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == '.NETStandard')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_SupportedFrameworkVersions Include="@(SupportedNETCoreAppTargetFramework-&gt;'%(Identity)'-&gt;TrimStart('.NETCoreApp,Version=v'))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' " />
      <_SupportedFrameworkVersions Include="@(SupportedNETFrameworkTargetFramework-&gt;'%(Identity)'-&gt;TrimStart('.NETFramework,Version=v'))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework' " />
      <_SupportedFrameworkVersions Include="@(SupportedNETStandardTargetFramework-&gt;'%(Identity)'-&gt;TrimStart('.NETStandard,Version=v'))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETStandard' " />
      <_CompatibleFrameworkVersions Include="@(_SupportedFrameworkVersions)" Condition=" $([MSBuild]::VersionLessThanOrEquals(%(Identity), $(TargetFrameworkVersion))) " />
      <_FormattedCompatibleFrameworkVersions Include="@(_CompatibleFrameworkVersions)" Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' or '$(TargetFrameworkIdentifier)' == '.NETStandard' " />
      <_FormattedCompatibleFrameworkVersions Include="@(_CompatibleFrameworkVersions-&gt;'%(Identity)'-&gt;Replace('.', ''))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework' " />
      <_ImplicitDefineConstant Include="@(_FormattedCompatibleFrameworkVersions-&gt;'$(_FrameworkIdentifierForImplicitDefine)%(Identity)_OR_GREATER'-&gt;Replace('.', '_'))" Condition=" '$(TargetFrameworkIdentifier)' != '.NETCoreApp' or $([MSBuild]::VersionGreaterThanOrEquals(%(_FormattedCompatibleFrameworkVersions.Identity), 5.0)) " />
      <_ImplicitDefineConstant Include="@(_FormattedCompatibleFrameworkVersions-&gt;'NETCOREAPP%(Identity)_OR_GREATER'-&gt;Replace('.', '_'))" Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionLessThan(%(_FormattedCompatibleFrameworkVersions.Identity), 5.0)) " />
    </ItemGroup>
  </Target>
  <!-- Add OR_GREATER compilation symbols for target platforms. -->
  <Target Name="GeneratePlatformCompatibleDefineConstants" Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' and '$(TargetPlatformIdentifier)' != '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0)) " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_SupportedPlatformCompatibleVersions Include="@(SdkSupportedTargetPlatformVersion)" Condition=" %(Identity) != '' and $([MSBuild]::VersionLessThanOrEquals(%(Identity), $(TargetPlatformVersion))) " />
      <_ImplicitDefineConstant Include="@(_SupportedPlatformCompatibleVersions-&gt;Distinct()-&gt;'$(TargetPlatformIdentifier.ToUpper())%(Identity)_OR_GREATER'-&gt;Replace('.', '_'))" />
    </ItemGroup>
  </Target>
  <!-- Remove TRACE when DisableDiagnosticTracing is true -->
  <Target Name="_DisableDiagnosticTracing" Condition="'$(DisableDiagnosticTracing)' == 'true'" DependsOnTargets="GenerateTargetPlatformDefineConstants;GenerateNETCompatibleDefineConstants;GeneratePlatformCompatibleDefineConstants" BeforeTargets="CoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_DefineConstantsWithoutTrace Include="$(DefineConstants)" />
      <_DefineConstantsWithoutTrace Remove="TRACE" />
    </ItemGroup>
    <PropertyGroup>
      <DefineConstants>@(_DefineConstantsWithoutTrace)</DefineConstants>
    </PropertyGroup>
  </Target>
  <!--
    Add implicitly defined preprocessor symbols to DefineConstants. Note: this is intentionally using 'PrepareForBuild' as
    trigger to ensure that it runs before the XamlPreCompile targets. This targets creates the intermediate XAML project
    that is used by some XAML-based UI frameworks (eg. UWP XAML, WinUI 3). If it runs before AddImplicitDefineConstants,
    and the code has any '#ifdefs' on constants generated by this target (eg. 'NET9_0_OR_GREATER'), the intermediate XAML
    project will end up selecting the other code paths instead, which can cause all kinds of build failures or other
    problems. For additional context, see: https://github.com/dotnet/sdk/issues/43908.
  -->
  <Target Name="AddImplicitDefineConstants" Condition=" '$(DisableImplicitFrameworkDefines)' != 'true' " DependsOnTargets="GenerateTargetPlatformDefineConstants;GenerateNETCompatibleDefineConstants;GeneratePlatformCompatibleDefineConstants;_DisableDiagnosticTracing" AfterTargets="PrepareForBuild" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <DefineConstants Condition=" '@(_ImplicitDefineConstant)' != '' ">$(DefineConstants);@(_ImplicitDefineConstant)</DefineConstants>
      <FinalDefineConstants Condition=" '@(_ImplicitDefineConstant)' != '' and '$(Language)' == 'VB' ">$(FinalDefineConstants),@(_ImplicitDefineConstant->'%(Identity)=-1', ',')</FinalDefineConstants>
    </PropertyGroup>
  </Target>
  <!-- Handle XML documentation file settings -->
  <PropertyGroup Condition="'$(GenerateDocumentationFile)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateDocumentationFile Condition="'$(DocumentationFile)' == ''">false</GenerateDocumentationFile>
    <GenerateDocumentationFile Condition="'$(DocumentationFile)' != ''">true</GenerateDocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(GenerateDocumentationFile)' == 'true' and '$(DocumentationFile)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DocumentationFile Condition="'$(MSBuildProjectExtension)' == '.vbproj'">$(AssemblyName).xml</DocumentationFile>
    <DocumentationFile Condition="'$(MSBuildProjectExtension)' != '.vbproj'">$(IntermediateOutputPath)$(AssemblyName).xml</DocumentationFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(GenerateDocumentationFile)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DocumentationFile />
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishDocumentationFiles Condition="'$(PublishDocumentationFiles)' == ''">true</PublishDocumentationFiles>
    <PublishDocumentationFile Condition="'$(PublishDocumentationFile)' == '' and '$(PublishDocumentationFiles)' == 'true'">true</PublishDocumentationFile>
    <PublishReferencesDocumentationFiles Condition="'$(PublishReferencesDocumentationFiles)' == '' and '$(PublishDocumentationFiles)' == 'true'">true</PublishReferencesDocumentationFiles>
  </PropertyGroup>
  <!-- Add a project capability so that the project properties in the IDE can show the option to generate an XML documentation file without specifying the filename -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="GenerateDocumentationFile" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IsNetCoreAppTargetingLatestTFM Condition="'$(IsNetCoreAppTargetingLatestTFM)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' == '$(NETCoreAppMaximumVersion)'">true</IsNetCoreAppTargetingLatestTFM>
  </PropertyGroup>
  <!--
    Use Roslyn deployed with SDK for builds of SDK-style projects (regardless of whether the initiator is `dotnet` or `msbuild`).
    See https://github.com/dotnet/sdk/blob/main/documentation/general/decouple-vs-and-net-sdk.md.
  -->
  <Choose xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- RoslynCompilerType specified by user, do not overwrite it. -->
    <When Condition="'$(RoslynCompilerType)' != ''" />
    <!-- BuildWithNetFrameworkHostedCompiler specified by user to opt into downloading compiler framework toolset package. -->
    <When Condition="'$(BuildWithNetFrameworkHostedCompiler)' == 'true'">
      <PropertyGroup>
        <RoslynCompilerType>FrameworkPackage</RoslynCompilerType>
      </PropertyGroup>
    </When>
    <!-- On core MSBuild or if we have path to dotnet host, use Core compiler type. -->
    <When Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DOTNET_HOST_PATH)' != '' or '$(DOTNET_EXPERIMENTAL_HOST_PATH)' != ''">
      <PropertyGroup>
        <RoslynCompilerType>Core</RoslynCompilerType>
      </PropertyGroup>
    </When>
    <!-- Automatically opt users into using the toolset package if they are running an MSBuild other than what this SDK was built against.
          This is to reduce 'tearing'/dependency mismatch, but as always users can override this behavior by disabling the hosted compiler flag. -->
    <When Condition="'$(MSBuildRuntimeType)' == 'Full'&#xA;      and '$(BuildWithNetFrameworkHostedCompiler)' == ''&#xA;      and '$(_IsDisjointMSBuildVersion)' == 'true'&#xA;      and ('$(MSBuildProjectExtension)' == '.csproj'&#xA;      or '$(MSBuildProjectExtension)' == '.vbproj')">
      <PropertyGroup>
        <RoslynCompilerType>FrameworkPackage</RoslynCompilerType>
      </PropertyGroup>
    </When>
    <!-- Otherwise we must be on full MSBuild, so choose Framework compiler type. -->
    <Otherwise>
      <PropertyGroup>
        <RoslynCompilerType>Framework</RoslynCompilerType>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <PropertyGroup Condition="'$(RoslynCompilerType)' == 'Core'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RoslynTargetsPath Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\..\..\Roslyn</RoslynTargetsPath>
    <RoslynTasksAssembly Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\..\..\Roslyn\Microsoft.Build.Tasks.CodeAnalysis.dll</RoslynTasksAssembly>
    <RoslynTargetsPath Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\..\..\Roslyn\binfx</RoslynTargetsPath>
    <RoslynTasksAssembly Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\..\..\Roslyn\binfx\Microsoft.Build.Tasks.CodeAnalysis.Sdk.dll</RoslynTasksAssembly>
    <CSharpCoreTargetsPath>$(MSBuildThisFileDirectory)..\..\..\Roslyn\Microsoft.CSharp.Core.targets</CSharpCoreTargetsPath>
    <VisualBasicCoreTargetsPath>$(MSBuildThisFileDirectory)..\..\..\Roslyn\Microsoft.VisualBasic.Core.targets</VisualBasicCoreTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(LanguageTargets)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <LanguageTargets Condition="'$(MSBuildProjectExtension)' == '.csproj'">$(MSBuildToolsPath)\Microsoft.CSharp.targets</LanguageTargets>
    <LanguageTargets Condition="'$(MSBuildProjectExtension)' == '.vbproj'">$(MSBuildToolsPath)\Microsoft.VisualBasic.targets</LanguageTargets>
    <LanguageTargets Condition="'$(MSBuildProjectExtension)' == '.fsproj'">$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.FSharpTargetsShim.targets</LanguageTargets>
    <!-- If LanguageTargets isn't otherwise set, then just import the common targets.  This should allow the restore target to run,
         which could bring in NuGet packages that set the LanguageTargets to something else.  This means support for different
         languages could either be supplied via an SDK or via a NuGet package. -->
    <LanguageTargets Condition="'$(LanguageTargets)' == ''">$(MSBuildToolsPath)\Microsoft.Common.targets</LanguageTargets>
  </PropertyGroup>
  <!-- REMARK: Dont remove/rename, the LanguageTargets property is used by F# to hook inside the project's sdk
               using Sdk attribute (from .NET Core Sdk 1.0.0-preview4) -->
  <!--
============================================================================================================================================
  <Import Project="$(LanguageTargets)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.CSharp.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CSharp.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process specific for C# .NET projects.
For example, it contains the step that actually calls the C# compiler.  The remainder
of the build process is defined in Microsoft.Common.targets, which is imported by
this file.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <Choose>
    <When Condition="'$(IsCrossTargetingBuild)' == 'true'">
      <PropertyGroup>
        <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CrossTargeting.targets</CSharpTargetsPath>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <CSharpTargetsPath>$(MSBuildToolsPath)\Microsoft.CSharp.CurrentVersion.targets</CSharpTargetsPath>
      </PropertyGroup>
    </Otherwise>
  </Choose>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Managed.Before.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines common build logic for all managed languaged: C#, VisualBasic, F#
It is imported before the common targets have been imported.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
      We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
      and there is no current target framework being built individually. In that case, a multitargeting
      project file like Microsoft.<language>.CrossTargeting.targets gets imported.
  -->
  <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
    <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(CSharpTargetsPath)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.CSharp.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process specific for C# .NET projects.
For example, it contains the step that actually calls the C# compiler.  The remainder
of the build process is defined in Microsoft.Common.targets, which is imported by
this file.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ImportByWildcardBeforeMicrosoftCSharpTargets Condition="'$(ImportByWildcardBeforeMicrosoftCSharpTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCSharpTargets>
    <ImportByWildcardAfterMicrosoftCSharpTargets Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == ''">true</ImportByWildcardAfterMicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportBefore')" />-->
  <PropertyGroup>
    <CustomBeforeMicrosoftCSharpTargets Condition="'$(CustomBeforeMicrosoftCSharpTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.Microsoft.CSharp.targets</CustomBeforeMicrosoftCSharpTargets>
    <CustomAfterMicrosoftCSharpTargets Condition="'$(CustomAfterMicrosoftCSharpTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.Microsoft.CSharp.targets</CustomAfterMicrosoftCSharpTargets>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeMicrosoftCSharpTargets)" Condition="'$(CustomBeforeMicrosoftCSharpTargets)' != '' and Exists('$(CustomBeforeMicrosoftCSharpTargets)')" />-->
  <PropertyGroup>
    <DefaultLanguageSourceExtension>.cs</DefaultLanguageSourceExtension>
    <Language>C#</Language>
    <TargetRuntime>Managed</TargetRuntime>
    <AlwaysUseNumericalSuffixInItemNames>true</AlwaysUseNumericalSuffixInItemNames>
    <DefineCommonItemSchemas Condition=" '$(DefineCommonItemSchemas)' == '' ">true</DefineCommonItemSchemas>
    <DefineCommonReferenceSchemas Condition=" '$(DefineCommonReferenceSchemas)' == '' ">true</DefineCommonReferenceSchemas>
    <DefineCommonCapabilities Condition=" '$(DefineCommonCapabilities)' == '' ">true</DefineCommonCapabilities>
    <SynthesizeLinkMetadata Condition=" '$(SynthesizeLinkMetadata)' == '' and '$(HasSharedItems)' == 'true' ">true</SynthesizeLinkMetadata>
    <DefaultProjectTypeGuid Condition=" '$(DefaultProjectTypeGuid)' == '' ">{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</DefaultProjectTypeGuid>
    <AppDesignerFolder Condition="'$(AppDesignerFolder)' == ''">Properties</AppDesignerFolder>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCSharpItemSchemas)' != 'false' ">
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.ProjectItemsSchema.xaml;" />
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.xaml;">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)CSharp.BrowseObject.xaml;">
      <Context>BrowseObject</Context>
    </PropertyPageSchema>
    <ProjectCapability Include="CSharp;Managed" />
  </ItemGroup>
  <ItemGroup Condition=" '$(DefineCommonCapabilities)' == 'true' ">
    <ProjectCapability Include="ReferencesFolder;LanguageService" />
  </ItemGroup>
  <!--
    The CreateManifestResourceNames target create the manifest resource names from the .RESX
    files.

        [IN]
        @(EmbeddedResource) - The list of EmbeddedResource items that have been pre-processed to add metadata about resource type
                              Expected Metadata "Type" can either be "Resx" or "Non-Resx"

        [OUT]
        @(EmbeddedResource) - EmbeddedResource items with metadata

    For C# applications the transformation is like:

        Resources1.resx => RootNamespace.Resources1 => Build into main assembly
        SubFolder\Resources1.resx => RootNamespace.SubFolder.Resources1 => Build into main assembly
        Resources1.fr.resx => RootNamespace.Resources1.fr => Build into satellite assembly
        Resources1.notaculture.resx => RootNamespace.Resources1.notaculture => Build into main assembly

    For other project systems, this transformation may be different.
    -->
  <PropertyGroup>
    <CreateManifestResourceNamesDependsOn />
  </PropertyGroup>
  <Target Name="CreateManifestResourceNames" Condition="'@(EmbeddedResource)' != ''" DependsOnTargets="$(CreateManifestResourceNamesDependsOn)">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
    <CreateCSharpManifestResourceName ResourceFiles="@(EmbeddedResource)" RootNamespace="$(RootNamespace)" EnableCustomCulture="$(EnableCustomCulture)" UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)" Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
    </CreateCSharpManifestResourceName>
    <!-- Create manifest names for all culture non-resx resources -->
    <CreateCSharpManifestResourceName ResourceFiles="@(EmbeddedResource)" RootNamespace="$(RootNamespace)" PrependCultureAsDirectory="false" UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)" Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
      <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
    </CreateCSharpManifestResourceName>
    <ItemGroup>
      <EmbeddedResource Remove="@(EmbeddedResource)" Condition="'%(EmbeddedResource.ManifestResourceName)' == ''" />
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveCodeAnalysisRuleSet" Condition="'$(CodeAnalysisRuleSet)' != ''">
    <ResolveCodeAnalysisRuleSet CodeAnalysisRuleSet="$(CodeAnalysisRuleSet)" CodeAnalysisRuleSetDirectories="$(CodeAnalysisRuleSetDirectories)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
      <Output TaskParameter="ResolvedCodeAnalysisRuleSet" PropertyName="ResolvedCodeAnalysisRuleSet" />
    </ResolveCodeAnalysisRuleSet>
  </Target>
  <ItemGroup>
    <!-- Activate CPS projects to track folder names in namespace. -->
    <ProjectCapability Include="RelativePathDerivedDefaultNamespace" />
  </ItemGroup>
  <PropertyGroup>
    <!-- Provide a facility to override UseHostCompilerIfAvailable-->
    <UseHostCompilerIfAvailable Condition=" '$(UseHostCompilerIfAvailable)' == ''">true</UseHostCompilerIfAvailable>
  </PropertyGroup>
  <ItemGroup>
    <DocFileItem Include="$(DocumentationFile)" Condition="'$(DocumentationFile)'!=''" />
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(PdbFile)' != ''">
    <_DebugSymbolsIntermediatePathTemporary Include="$(PdbFile)" />
    <!-- Add any missing .pdb extension, as the compiler does -->
    <_DebugSymbolsIntermediatePath Include="@(_DebugSymbolsIntermediatePathTemporary->'%(RootDir)%(Directory)%(Filename).pdb')" />
  </ItemGroup>
  <PropertyGroup>
    <CoreCompileDependsOn>$(CoreCompileDependsOn);_ComputeNonExistentFileProperty;ResolveCodeAnalysisRuleSet</CoreCompileDependsOn>
    <ExportWinMDFile Condition="'$(ExportWinMDFile)' == '' and '$(OutputType)' == 'WinMDObj'">true</ExportWinMDFile>
  </PropertyGroup>
  <!--
      The XamlPreCompile target must remain identical to
      the CoreCompile target in Microsoft.CSharp.Core.targets.
      Any updates to one must be made to the other.
-->
  <Target Name="XamlPreCompile" Inputs="$(MSBuildAllProjects);&#xA;                @(Compile);&#xA;                @(_CoreCompileResourceInputs);&#xA;                $(ApplicationIcon);&#xA;                $(AssemblyOriginatorKeyFile);&#xA;                @(ReferencePath);&#xA;                @(CompiledLicenseFile);&#xA;                @(LinkResource);&#xA;                @(EmbeddedDocumentation);&#xA;                $(Win32Resource);&#xA;                $(Win32Manifest);&#xA;                @(CustomAdditionalCompileInputs);&#xA;                @(Page);&#xA;                @(ApplicationDefinition);&#xA;                $(ResolvedCodeAnalysisRuleSet)" Outputs="@(DocFileItem);&#xA;                 @(XamlIntermediateAssembly);&#xA;                 @(_DebugSymbolsIntermediatePath);&#xA;                 $(NonExistentFile);&#xA;                 @(CustomAdditionalCompileOutputs)" Condition="'@(Page)' != '' Or '@(ApplicationDefinition)' != ''" Returns="" DependsOnTargets="$(CoreCompileDependsOn);GenerateMSBuildEditorConfigFile">
    <!-- These two compiler warnings are raised when a reference is bound to a different version
             than specified in the assembly reference version number.  MSBuild raises the same warning in this case,
             so the compiler warning would be redundant. -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' != 'v1.0') and ('$(TargetFrameworkVersion)' != 'v1.1')">
      <NoWarn>$(NoWarn);1701;1702</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
      <!-- To match historical behavior, when inside VS11+ disable the warning from csc.exe indicating that no sources were passed in-->
      <NoWarn Condition=" '$(BuildingInsideVisualStudio)' == 'true' and '$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt; '10.0' ">$(NoWarn);2008</NoWarn>
    </PropertyGroup>
    <ItemGroup Condition="'$(TargetingClr2Framework)'=='true'">
      <ReferencePath>
        <EmbedInteropTypes />
      </ReferencePath>
    </ItemGroup>
    <PropertyGroup>
      <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
                 then we'll use AppConfig -->
      <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' and '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
      <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
      <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
    </PropertyGroup>
    <!-- Prefer32Bit was introduced in .NET 4.5. Set it to false if we are targeting 4.0 -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' == 'v4.0')">
      <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
    <ItemGroup Condition="('$(AdditionalFileItemNames)' != '')">
      <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
      <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
    </ItemGroup>
    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>
    <!-- Condition is to filter out the _CoreCompileResourceInputs so that it doesn't pass in culture resources to the compiler -->
    <!-- Don't run analyzers for Csc task on XamlPrecompile pass, we only want to run them on core compile. -->
    <Csc Condition="'%(_CoreCompileResourceInputs.WithCulture)' != 'true'" AdditionalLibPaths="$(AdditionalLibPaths)" AddModules="@(AddModules)" AdditionalFiles="@(AdditionalFiles)" AllowUnsafeBlocks="$(AllowUnsafeBlocks)" AnalyzerConfigFiles="@(EditorConfigFiles)" Analyzers="@(Analyzer)" ApplicationConfiguration="$(AppConfigForCompiler)" BaseAddress="$(BaseAddress)" CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)" ChecksumAlgorithm="$(ChecksumAlgorithm)" CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)" CodePage="$(CodePage)" CompilerType="$(RoslynCompilerType)" DebugType="none" DefineConstants="$(DefineConstants)" DelaySign="$(DelaySign)" DisabledWarnings="$(NoWarn)" DisableSdkPath="$(DisableSdkPath)" DocumentationFile="@(DocFileItem)" EmbedAllSources="false" EmbeddedFiles="@(EmbeddedFiles)" EmitDebugInformation="$(DebugSymbols)" EnvironmentVariables="$(CscEnvironment)" ErrorEndLocation="$(ErrorEndLocation)" ErrorLog="$(ErrorLog)" ErrorReport="$(ErrorReport)" Features="$(Features)" InterceptorsNamespaces="$(InterceptorsNamespaces)" InterceptorsPreviewNamespaces="$(InterceptorsPreviewNamespaces)" FileAlignment="$(FileAlignment)" GeneratedFilesOutputPath="$(CompilerGeneratedFilesOutputPath)" GenerateFullPaths="$(GenerateFullPaths)" HighEntropyVA="$(HighEntropyVA)" Instrument="$(Instrument)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LangVersion="$(LangVersion)" LinkResources="@(LinkResource)" MainEntryPoint="$(StartupObject)" ModuleAssemblyName="$(ModuleAssemblyName)" NoConfig="true" NoLogo="$(NoLogo)" NoStandardLib="$(NoCompilerStandardLib)" NoWin32Manifest="$(NoWin32Manifest)" Nullable="$(Nullable)" Optimize="$(Optimize)" Deterministic="$(Deterministic)" PublicSign="$(PublicSign)" OutputAssembly="@(XamlIntermediateAssembly)" OutputRefAssembly="" PdbFile="" Platform="$(PlatformTarget)" Prefer32Bit="$(Prefer32Bit)" PreferredUILang="$(PreferredUILang)" ProjectName="$(MSBuildProjectName)" ProvideCommandLineArgs="$(ProvideCommandLineArgs)" References="@(ReferencePath)" RefOnly="false" ReportAnalyzer="$(ReportAnalyzer)" ReportIVTs="$(ReportIVTs)" Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)" ResponseFiles="$(CompilerResponseFile)" RuntimeMetadataVersion="$(RuntimeMetadataVersion)" SharedCompilationId="$(SharedCompilationId)" SkipAnalyzers="true" SkipCompilerExecution="$(SkipCompilerExecution)" Sources="@(Compile)" SubsystemVersion="$(SubsystemVersion)" TargetType="$(OutputType)" TargetFramework="$(TargetFramework)" ToolExe="$(CscToolExe)" ToolPath="$(CscToolPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)" UseSharedCompilation="$(UseSharedCompilation)" Utf8Output="$(Utf8Output)" VsSessionGuid="$(VsSessionGuid)" WarningLevel="$(WarningLevel)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" Win32Icon="$(ApplicationIcon)" Win32Manifest="$(Win32Manifest)" Win32Resource="$(Win32Resource)" PathMap="$(PathMap)" SourceLink="$(SourceLink)" />
    <!-- Only Applicable to the regular CoreCompile:
              <ItemGroup>
                  <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />
              </ItemGroup>

              <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''"/>
-->
    <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />
  </Target>
  <PropertyGroup>
    <!-- Design-time builds require a newer version than 1.0 to succeed, so override back to inbox in that case -->
    <CSharpCoreTargetsPath Condition="'$(CSharpCoreTargetsPath)' == '' or ('$(DesignTimeBuild)' == 'true' and $(CSharpCoreTargetsPath.Contains('Microsoft.Net.Compilers.1.0.0')))">$(RoslynTargetsPath)\Microsoft.CSharp.Core.targets</CSharpCoreTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CSharpCoreTargetsPath)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Roslyn/Microsoft.CSharp.Core.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Managed.Core.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Roslyn/Microsoft.Managed.Core.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE file in the project root for more information. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_BuildTasksDirectory>$(MSBuildThisFileDirectory)</_BuildTasksDirectory>
    <_BuildTasksDirectory Condition="Exists('$(RoslynTargetsPath)')">$(RoslynTargetsPath)\</_BuildTasksDirectory>
    <_BuildTasksAssemblyName>Microsoft.Build.Tasks.CodeAnalysis</_BuildTasksAssemblyName>
    <_BuildTasksAssemblyName Condition="!Exists('$(_BuildTasksDirectory)$(_BuildTasksAssemblyName)') and Exists('$(_BuildTasksDirectory)Microsoft.Build.Tasks.CodeAnalysis.Sdk.dll')">Microsoft.Build.Tasks.CodeAnalysis.Sdk</_BuildTasksAssemblyName>
  </PropertyGroup>
  <!--
    Common targets for managed compilers.
  -->
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.MapSourceRoots" AssemblyFile="$(_BuildTasksDirectory)$(_BuildTasksAssemblyName).dll" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Managed.Core.CurrentVersions.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Roslyn/Microsoft.Managed.Core.CurrentVersions.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <CompilerApiVersion>roslyn5.0</CompilerApiVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Roslyn/Microsoft.Managed.Core.targets
============================================================================================================================================
-->
  <Target Name="ShimReferencePathsWhenCommonTargetsDoesNotUnderstandReferenceAssemblies" BeforeTargets="CoreCompile" Condition="'@(ReferencePathWithRefAssemblies)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- 
      FindReferenceAssembliesForReferences target in Common targets populate this item 
      since dev15.3. The compiler targets may be used (via NuGet package) on earlier MSBuilds. 
      If the ReferencePathWithRefAssemblies item is not populated, just use ReferencePaths 
      (implementation assemblies) as they are.
      
      Since XAML inner build runs CoreCompile directly (instead of Compile target),
      it also doesn't invoke FindReferenceAssembliesForReferences listed in CompileDependsOn.
      In that case we also populate ReferencePathWithRefAssemblies with implementation assemblies.
    -->
    <ItemGroup>
      <ReferencePathWithRefAssemblies Include="@(ReferencePath)" />
    </ItemGroup>
  </Target>
  <Target Name="_BeforeVBCSCoreCompile" DependsOnTargets="ShimReferencePathsWhenCommonTargetsDoesNotUnderstandReferenceAssemblies" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(TargetingClr2Framework)' == 'true'">
      <ReferencePathWithRefAssemblies>
        <EmbedInteropTypes />
      </ReferencePathWithRefAssemblies>
    </ItemGroup>
    <!-- Prefer32Bit was introduced in .NET 4.5. Set it to false if we are targeting 4.0 -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' == 'v4.0')">
      <Prefer32Bit>false</Prefer32Bit>
    </PropertyGroup>
    <!-- TODO: Remove this ItemGroup once it has been moved to "_GenerateCompileInputs" target in Microsoft.Common.CurrentVersion.targets.
         https://github.com/dotnet/roslyn/issues/12223 -->
    <ItemGroup Condition="('$(AdditionalFileItemNames)' != '')">
      <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
      <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
    </ItemGroup>
    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>
  </Target>
  <!--
    ========================
    SkipAnalyzers Support
    ========================
    
    -->
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.ShowMessageForImplicitlySkipAnalyzers" AssemblyFile="$(_BuildTasksDirectory)$(_BuildTasksAssemblyName).dll" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_ComputeSkipAnalyzers" BeforeTargets="CoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- First, force clear non-user facing properties '_SkipAnalyzers' and '_ImplicitlySkipAnalyzers'. -->
    <PropertyGroup>
      <_SkipAnalyzers />
      <_ImplicitlySkipAnalyzers />
    </PropertyGroup>
    <!--
        Then, determine if '_SkipAnalyzers' needs to be 'true' based on user facing property 'RunAnalyzers'.
        If 'RunAnalyzers' is not set, then fallback to user facing property 'RunAnalyzersDuringBuild'.
        Latter property allows users to disable analyzers only for non-design time builds.
        Design time builds are background builds inside Visual Studio,
        see details here: https://github.com/dotnet/project-system/blob/main/docs/design-time-builds.md.
        Setting 'RunAnalyzersDuringBuild' to false, without setting 'RunAnalyzers', allows users to
        continue running analyzers in the background in Visual Studio while typing (i.e. intellisense),
        while disabling analyzer execution on explicitly invoked non-design time builds.
      -->
    <PropertyGroup Condition="'$(RunAnalyzers)' == 'false' or&#xA;                              ('$(RunAnalyzers)' == '' and '$(RunAnalyzersDuringBuild)' == 'false')">
      <_SkipAnalyzers>true</_SkipAnalyzers>
    </PropertyGroup>
    <!-- PERF: For builds which are indirectly triggered inside Visual Studio from commands 
               such as from 'Run Tests' or 'Start Debugging', we implicitly skip analyzers and nullable analysis to speed up the build.
               We only do so by default when 'TreatWarningsAsErrors' is not 'true'. For the scenario where
			         'TreatWarningsAsErrors' is 'true', users can explicitly enable this functionality by setting
			         'OptimizeImplicitlyTriggeredBuild' to 'true'.
               NOTE: This feature is currently supported only for SDK-style projects, i.e. UsingMicrosoftNETSdk = true.
    -->
    <PropertyGroup Condition="'$(_SkipAnalyzers)' == '' and&#xA;                              '$(IsImplicitlyTriggeredBuild)' == 'true' and&#xA;                              '$(UsingMicrosoftNETSdk)' == 'true' and&#xA;                              '$(OptimizeImplicitlyTriggeredBuild)' != 'false' and&#xA;                              ('$(TreatWarningsAsErrors)' != 'true' or '$(OptimizeImplicitlyTriggeredBuild)' == 'true')">
      <_ImplicitlySkipAnalyzers>true</_ImplicitlySkipAnalyzers>
      <_SkipAnalyzers>true</_SkipAnalyzers>
      <Features>run-nullable-analysis=never;$(Features)</Features>
    </PropertyGroup>
    <!-- Display a message to inform the users about us implicitly skipping analyzers for speeding up indirect builds. -->
    <ShowMessageForImplicitlySkipAnalyzers Condition="'$(_ImplicitlySkipAnalyzers)' == 'true'" />
    <!-- Semaphore file to indicate the time stamp for last build with skipAnalyzers flag. -->
    <PropertyGroup>
      <_LastBuildWithSkipAnalyzers>$(IntermediateOutputPath)$(MSBuildProjectFile).BuildWithSkipAnalyzers</_LastBuildWithSkipAnalyzers>
    </PropertyGroup>
    <!-- '_LastBuildWithSkipAnalyzers' semaphore file, if exists, is passed as custom additional file input to builds without skipAnalyzers flag to ensure correct incremental builds. 
	       Additionally, we need to pass this file as an 'UpToDateCheckInput' item with 'Kind = ImplicitBuild' for project system's fast-upto-date check to work correctly.
		     See https://github.com/dotnet/project-system/issues/7290 for details.
	  -->
    <ItemGroup Condition="Exists('$(_LastBuildWithSkipAnalyzers)') and '$(_SkipAnalyzers)' != 'true'">
      <CustomAdditionalCompileInputs Include="$(_LastBuildWithSkipAnalyzers)" />
      <UpToDateCheckInput Include="$(_LastBuildWithSkipAnalyzers)" Kind="ImplicitBuild" />
    </ItemGroup>
  </Target>
  <!-- We touch and create a semaphore file after build to indicate the time stamp for last build with skipAnalyzers flag. -->
  <Target Name="_TouchLastBuildWithSkipAnalyzers" Condition="'$(_SkipAnalyzers)' == 'true'" AfterTargets="CoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Touch AlwaysCreate="true" Files="$(_LastBuildWithSkipAnalyzers)" />
  </Target>
  <!--
    ========================
    .editorconfig Support
    ========================
    
    -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_AllDirectoriesAbove Include="@(Compile-&gt;GetPathsOfAllDirectoriesAbove())" Condition="'$(DiscoverEditorConfigFiles)' != 'false' or '$(DiscoverGlobalAnalyzerConfigFiles)' != 'false'" />
    <!-- Work around a GetPathsOfAllDirectoriesAbove() bug where it can return multiple equivalent paths when the 
         compilation includes linked files with relative paths - https://github.com/microsoft/msbuild/issues/4392 -->
    <PotentialEditorConfigFiles Include="@(_AllDirectoriesAbove-&gt;'%(FullPath)'-&gt;Distinct()-&gt;Combine('.editorconfig'))" Condition="'$(DiscoverEditorConfigFiles)' != 'false'" />
    <EditorConfigFiles Include="@(PotentialEditorConfigFiles-&gt;Exists())" Condition="'$(DiscoverEditorConfigFiles)' != 'false'" />
    <GlobalAnalyzerConfigFiles Include="@(_AllDirectoriesAbove-&gt;'%(FullPath)'-&gt;Distinct()-&gt;Combine('.globalconfig'))" Condition="'$(DiscoverGlobalAnalyzerConfigFiles)' != 'false'" />
    <EditorConfigFiles Include="@(GlobalAnalyzerConfigFiles-&gt;Exists())" Condition="'$(DiscoverGlobalAnalyzerConfigFiles)' != 'false'" />
  </ItemGroup>
  <!--
    ========================
    Property/metadata global .editorconfig Support
    ========================
    
    Generates a global editor config that contains the evaluation of requested MSBuild properties and item metadata
    
    Requested properties/items are requested via item groups like:
   
      <CompilerVisibleProperty Include="PropertyNameToEval" />
      <CompilerVisibleItemMetadata Include="ItemType" MetadataName="MetadataToRetrieve" />
    -->
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig" AssemblyFile="$(_BuildTasksDirectory)$(_BuildTasksAssemblyName).dll" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GenerateMSBuildEditorConfigFile" BeforeTargets="BeforeCompile;CoreCompile" DependsOnTargets="PrepareForBuild;GenerateMSBuildEditorConfigFileShouldRun;GenerateMSBuildEditorConfigFileCore" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GenerateMSBuildEditorConfigFileShouldRun" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <GeneratedMSBuildEditorConfigFile Condition="'$(GeneratedMSBuildEditorConfigFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).GeneratedMSBuildEditorConfig.editorconfig</GeneratedMSBuildEditorConfigFile>
      <GenerateMSBuildEditorConfigFile Condition="'$(GenerateMSBuildEditorConfigFile)' == ''">true</GenerateMSBuildEditorConfigFile>
      <_GeneratedEditorConfigHasItems Condition="'@(CompilerVisibleItemMetadata-&gt;Count())' != '0'">true</_GeneratedEditorConfigHasItems>
      <_GeneratedEditorConfigShouldRun Condition="'$(GenerateMSBuildEditorConfigFile)' == 'true' and ('$(_GeneratedEditorConfigHasItems)' == 'true' or '@(CompilerVisibleProperty-&gt;Count())' != '0')">true</_GeneratedEditorConfigShouldRun>
    </PropertyGroup>
  </Target>
  <Target Name="GenerateMSBuildEditorConfigFileCore" Condition="'$(_GeneratedEditorConfigShouldRun)' == 'true'" Outputs="$(GeneratedMSBuildEditorConfigFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Collect requested properties, and eval their value -->
      <_GeneratedEditorConfigProperty Include="@(CompilerVisibleProperty)">
        <Value>$(%(CompilerVisibleProperty.Identity))</Value>
      </_GeneratedEditorConfigProperty>
      <!-- Collect the requested items and remember which metadata is wanted -->
      <_GeneratedEditorConfigMetadata Include="@(%(CompilerVisibleItemMetadata.Identity))" Condition="'$(_GeneratedEditorConfigHasItems)' == 'true'">
        <ItemType>%(Identity)</ItemType>
        <MetadataName>%(CompilerVisibleItemMetadata.MetadataName)</MetadataName>
      </_GeneratedEditorConfigMetadata>
      <!-- Record that we'll write a file, and add it to the analyzerconfig inputs -->
      <FileWrites Include="$(GeneratedMSBuildEditorConfigFile)" />
      <EditorConfigFiles Include="$(GeneratedMSBuildEditorConfigFile)" />
    </ItemGroup>
    <!-- Transform the collected properties and items into an editor config file -->
    <GenerateMSBuildEditorConfig PropertyItems="@(_GeneratedEditorConfigProperty)" MetadataItems="@(_GeneratedEditorConfigMetadata)" FileName="$(GeneratedMSBuildEditorConfigFile)" />
  </Target>
  <!--
    ========================
    DeterministicSourcePaths
    ========================
    
    Unless specified otherwise enable deterministic source root (PathMap) when building deterministically on CI server, but not for local builds.
    In order for the debugger to find source files when debugging a locally built binary the PDB must contain original, unmapped local paths.
  -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DeterministicSourcePaths Condition="'$(DeterministicSourcePaths)' == '' and '$(Deterministic)' == 'true' and '$(ContinuousIntegrationBuild)' == 'true'">true</DeterministicSourcePaths>
  </PropertyGroup>
  <!--
    ==========
    SourceRoot
    ==========

    All source files of the project are expected to be located under one of the directories specified by SourceRoot item group.
    This target collects all SourceRoots from various sources.

    This target calculates final local path for each SourceRoot and sets SourceRoot.MappedPath metadata accordingly.
    The final path is a path with deterministic prefix when DeterministicSourcePaths is true, and the original path otherwise.
    In addition, the target validates and deduplicates the SourceRoot items.

    InitializeSourceControlInformation is an msbuild target that ensures the SourceRoot items are populated from source control.
    The target is available only if SourceControlInformationFeatureSupported is true.

    A consumer of SourceRoot.MappedPath metadata, such as Source Link generator, shall depend on this target. 
  -->
  <Target Name="InitializeSourceRootMappedPaths" DependsOnTargets="_InitializeSourceRootMappedPathsFromSourceControl" Returns="@(SourceRoot)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'@(_MappedSourceRoot)' != ''">
      <_MappedSourceRoot Remove="@(_MappedSourceRoot)" />
    </ItemGroup>
    <Microsoft.CodeAnalysis.BuildTasks.MapSourceRoots SourceRoots="@(SourceRoot)" Deterministic="$(DeterministicSourcePaths)">
      <Output TaskParameter="MappedSourceRoots" ItemName="_MappedSourceRoot" />
    </Microsoft.CodeAnalysis.BuildTasks.MapSourceRoots>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_MappedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!-- 
    Declare that target InitializeSourceRootMappedPaths that populates MappedPaths metadata on SourceRoot items is available.
  -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SourceRootMappedPathsFeatureSupported>true</SourceRootMappedPathsFeatureSupported>
  </PropertyGroup>
  <!-- 
    If InitializeSourceControlInformation target isn't supported, we just continue without invoking that synchronization target. 
    We'll proceed with SourceRoot (and other source control properties) provided by the user (or blank).
  -->
  <Target Name="_InitializeSourceRootMappedPathsFromSourceControl" DependsOnTargets="InitializeSourceControlInformation" Condition="'$(SourceControlInformationFeatureSupported)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!-- 
    =======
    PathMap
    =======

    If DeterministicSourcePaths is true sets PathMap based on SourceRoot.MappedPaths.

    This target requires SourceRoot to be initialized in order to calculate the PathMap.
    If SourceRoot doesn't contain any top-level roots an error is reported.
  -->
  <Target Name="_SetPathMapFromSourceRoots" DependsOnTargets="InitializeSourceRootMappedPaths" BeforeTargets="CoreCompile" Condition="'$(DeterministicSourcePaths)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_TopLevelSourceRoot Include="@(SourceRoot)" Condition="'%(SourceRoot.NestedRoot)' == ''">
        <EscapedKey>$([MSBuild]::ValueOrDefault('%(Identity)', '').Replace(',', ',,').Replace('=', '=='))</EscapedKey>
        <EscapedValue>$([MSBuild]::ValueOrDefault('%(MappedPath)', '').Replace(',', ',,').Replace('=', '=='))</EscapedValue>
      </_TopLevelSourceRoot>
    </ItemGroup>
    <PropertyGroup Condition="'@(_TopLevelSourceRoot)' != ''">
      <!--
        Prepend the SourceRoot.MappedPath values to PathMap, if it already has a value.
        For each emitted source path the compiler applies the first mapping that matches the path.
        PathMap values set previously will thus only be applied if the mapping provided by 
        SourceRoot.MappedPath doesn't match. Since SourceRoot.MappedPath is also used by SourceLink 
        preferring it over manually set PathMap ensures that PathMap is consistent with SourceLink.
      -->
      <PathMap>@(_TopLevelSourceRoot->'%(EscapedKey)=%(EscapedValue)', ','),$(PathMap)</PathMap>
    </PropertyGroup>
  </Target>
  <!--
    =======
    CopyAdditionalFiles
    =======

    If a user requests that any @(AdditionalFiles) items are copied to the output directory
    we add them to the @(None) group to ensure they will be copied.
 -->
  <Target Name="CopyAdditionalFiles" BeforeTargets="AssignTargetPaths" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <None Include="@(AdditionalFiles)" Condition="'%(AdditionalFiles.CopyToOutputDirectory)' != ''" />
    </ItemGroup>
  </Target>
  <!--
    ========================
    CompilerGeneratedFilesOutputPath
    ========================
    
    Controls output of generated files.
    
    CompilerGeneratedFilesOutputPath controls the location the files will be output to.
    The compiler will not emit any generated files when the path is empty, and defaults to a /generated directory in $(IntermediateOutputPath) if $(IntermediateOutputPath) has a value.
    A relative path is considered relative to the project directory.

    EmitCompilerGeneratedFiles allows the user to control if anything is emitted by clearing the property when not true.
    When EmitCompilerGeneratedFiles is true, we ensure that CompilerGeneatedFilesOutputPath has a value and issue a warning if not.

    We will create CompilerGeneratedFilesOutputPath if it does not exist.
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EmitCompilerGeneratedFiles Condition="'$(EmitCompilerGeneratedFiles)' == ''">false</EmitCompilerGeneratedFiles>
    <CompilerGeneratedFilesOutputPath Condition="'$(EmitCompilerGeneratedFiles)' != 'true'" />
    <CompilerGeneratedFilesOutputPath Condition="'$(EmitCompilerGeneratedFiles)' == 'true' and '$(CompilerGeneratedFilesOutputPath)' == '' and '$(IntermediateOutputPath)' != ''">$(IntermediateOutputPath)/generated</CompilerGeneratedFilesOutputPath>
  </PropertyGroup>
  <Target Name="CreateCompilerGeneratedFilesOutputPath" BeforeTargets="CoreCompile" Condition="'$(EmitCompilerGeneratedFiles)' == 'true' and !('$(DesignTimeBuild)' == 'true' OR '$(BuildingProject)' != 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Warning Condition="'$(CompilerGeneratedFilesOutputPath)' == ''" Text="EmitCompilerGeneratedFiles was true, but no CompilerGeneratedFilesOutputPath was provided. CompilerGeneratedFilesOutputPath must be set in order to emit generated files." />
    <MakeDir Condition="'$(CompilerGeneratedFilesOutputPath)' != ''" Directories="$(CompilerGeneratedFilesOutputPath)" />
  </Target>
  <!--
    ========================
    Component Debugger Support
    ========================
    
    Add the specified VS capability if a user indicates this project supports component debugging
    -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="RoslynComponent" Condition="'$(IsRoslynComponent)' == 'true'" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Roslyn/Microsoft.CSharp.Core.targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- .NETCoreApp < 3.0, .NETStandard < 2.1, or any other target framework -->
    <_MaxSupportedLangVersion Condition="('$(TargetFrameworkIdentifier)' != '.NETCoreApp' OR '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0') AND&#xA;                                         ('$(TargetFrameworkIdentifier)' != '.NETStandard' OR '$(_TargetFrameworkVersionWithoutV)' &lt; '2.1')">7.3</_MaxSupportedLangVersion>
    <!-- .NETCoreApp < 5.0, .NETStandard == 2.1 -->
    <_MaxSupportedLangVersion Condition="(('$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND '$(_TargetFrameworkVersionWithoutV)' &lt; '5.0') OR&#xA;                                          ('$(TargetFrameworkIdentifier)' == '.NETStandard' AND '$(_TargetFrameworkVersionWithoutV)' == '2.1')) AND&#xA;                                          '$(_MaxSupportedLangVersion)' == ''">8.0</_MaxSupportedLangVersion>
    <!-- 
      Automatically calculate the maximum supported C# language version based on the .NET Target Framework.
      - Pattern: .NET 5.0 uses C# 9.0, .NET 6.0 uses C# 10.0, and so on.
      - Starting from C# 9.0 for .NET 5.0, we add the difference between the major .NET version and 5 
        to determine the correct language version.
      NOTE: `.Split('.')[0]` needed due to https://github.com/dotnet/msbuild/issues/9757.
    -->
    <_MaxSupportedLangVersion Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND&#xA;                                         '$(_MaxSupportedLangVersion)' == ''">$([MSBuild]::Add(9, $([MSBuild]::Subtract($(_TargetFrameworkVersionWithoutV.Split('.')[0]), 5)))).0</_MaxSupportedLangVersion>
    <!-- Cap _MaxSupportedLangVersion if it exceeds _MaxAvailableLangVersion -->
    <_MaxAvailableLangVersion>13.0</_MaxAvailableLangVersion>
    <_MaxSupportedLangVersion Condition="'$(_MaxSupportedLangVersion)' != '' AND&#xA;                                         '$(_MaxSupportedLangVersion)' &gt; '$(_MaxAvailableLangVersion)'">$(_MaxAvailableLangVersion)</_MaxSupportedLangVersion>
    <MaxSupportedLangVersion>$(_MaxSupportedLangVersion)</MaxSupportedLangVersion>
    <LangVersion Condition="'$(LangVersion)' == '' AND '$(_MaxSupportedLangVersion)' != ''">$(_MaxSupportedLangVersion)</LangVersion>
  </PropertyGroup>
  <Target Name="CoreCompile" Inputs="$(MSBuildAllProjects);&#xA;                  @(Compile);&#xA;                  @(_CoreCompileResourceInputs);&#xA;                  $(ApplicationIcon);&#xA;                  $(KeyOriginatorFile);&#xA;                  @(ReferencePathWithRefAssemblies);&#xA;                  @(CompiledLicenseFile);&#xA;                  @(LinkResource);&#xA;                  @(EmbeddedDocumentation);&#xA;                  $(Win32Resource);&#xA;                  $(Win32Manifest);&#xA;                  @(CustomAdditionalCompileInputs);&#xA;                  $(ResolvedCodeAnalysisRuleSet);&#xA;                  @(AdditionalFiles);&#xA;                  @(EmbeddedFiles);&#xA;                  @(Analyzer);&#xA;                  @(EditorConfigFiles);&#xA;                  $(SourceLink)" Outputs="@(DocFileItem);&#xA;                   @(IntermediateAssembly);&#xA;                   @(IntermediateRefAssembly);&#xA;                   @(_DebugSymbolsIntermediatePath);&#xA;                   $(NonExistentFile);&#xA;                   @(CustomAdditionalCompileOutputs)" Returns="@(CscCommandLineArgs)" DependsOnTargets="$(CoreCompileDependsOn);_BeforeVBCSCoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- These two compiler warnings are raised when a reference is bound to a different version
             than specified in the assembly reference version number.  MSBuild raises the same warning in this case,
             so the compiler warning would be redundant. -->
    <PropertyGroup Condition="('$(TargetFrameworkVersion)' != 'v1.0') and ('$(TargetFrameworkVersion)' != 'v1.1')">
      <NoWarn>$(NoWarn);1701;1702</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
      <!-- To match historical behavior, when inside VS11+ disable the warning from csc.exe indicating that no sources were passed in-->
      <NoWarn Condition="'$(BuildingInsideVisualStudio)' == 'true' AND '$(VisualStudioVersion)' != '' AND '$(VisualStudioVersion)' &gt; '10.0'">$(NoWarn);2008</NoWarn>
    </PropertyGroup>
    <PropertyGroup>
      <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
                 then we'll use AppConfig -->
      <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' AND '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
      <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
      <PdbFile Condition="'$(PdbFile)' == '' AND '$(OutputType)' == 'winmdobj' AND '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
    </PropertyGroup>
    <!-- Condition is to filter out the _CoreCompileResourceInputs so that it doesn't pass in culture resources to the compiler -->
    <Csc Condition="'%(_CoreCompileResourceInputs.WithCulture)' != 'true'" AdditionalLibPaths="$(AdditionalLibPaths)" AddModules="@(AddModules)" AdditionalFiles="@(AdditionalFiles)" AllowUnsafeBlocks="$(AllowUnsafeBlocks)" AnalyzerConfigFiles="@(EditorConfigFiles)" Analyzers="@(Analyzer)" ApplicationConfiguration="$(AppConfigForCompiler)" BaseAddress="$(BaseAddress)" CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)" ChecksumAlgorithm="$(ChecksumAlgorithm)" CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)" CodePage="$(CodePage)" DebugType="$(DebugType)" DefineConstants="$(DefineConstants)" DelaySign="$(DelaySign)" DisabledWarnings="$(NoWarn)" DisableSdkPath="$(DisableSdkPath)" DocumentationFile="@(DocFileItem)" EmbedAllSources="$(EmbedAllSources)" EmbeddedFiles="@(EmbeddedFiles)" EmitDebugInformation="$(DebugSymbols)" EnvironmentVariables="$(CscEnvironment)" ErrorEndLocation="$(ErrorEndLocation)" ErrorLog="$(ErrorLog)" ErrorReport="$(ErrorReport)" Features="$(Features)" InterceptorsNamespaces="$(InterceptorsNamespaces)" InterceptorsPreviewNamespaces="$(InterceptorsPreviewNamespaces)" FileAlignment="$(FileAlignment)" GeneratedFilesOutputPath="$(CompilerGeneratedFilesOutputPath)" GenerateFullPaths="$(GenerateFullPaths)" HighEntropyVA="$(HighEntropyVA)" Instrument="$(Instrument)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LangVersion="$(LangVersion)" LinkResources="@(LinkResource)" MainEntryPoint="$(StartupObject)" ModuleAssemblyName="$(ModuleAssemblyName)" NoConfig="true" NoLogo="$(NoLogo)" NoStandardLib="$(NoCompilerStandardLib)" NoWin32Manifest="$(NoWin32Manifest)" Nullable="$(Nullable)" Optimize="$(Optimize)" Deterministic="$(Deterministic)" PublicSign="$(PublicSign)" OutputAssembly="@(IntermediateAssembly)" OutputRefAssembly="@(IntermediateRefAssembly)" PdbFile="$(PdbFile)" Platform="$(PlatformTarget)" Prefer32Bit="$(Prefer32Bit)" PreferredUILang="$(PreferredUILang)" ProjectName="$(MSBuildProjectName)" ProvideCommandLineArgs="$(ProvideCommandLineArgs)" References="@(ReferencePathWithRefAssemblies)" RefOnly="$(ProduceOnlyReferenceAssembly)" ReportAnalyzer="$(ReportAnalyzer)" ReportIVTs="$(ReportIVTs)" Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)" ResponseFiles="$(CompilerResponseFile)" RuntimeMetadataVersion="$(RuntimeMetadataVersion)" SharedCompilationId="$(SharedCompilationId)" SkipAnalyzers="$(_SkipAnalyzers)" SkipCompilerExecution="$(SkipCompilerExecution)" Sources="@(Compile)" SubsystemVersion="$(SubsystemVersion)" TargetType="$(OutputType)" TargetFramework="$(TargetFramework)" ToolExe="$(CscToolExe)" ToolPath="$(CscToolPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)" UseSharedCompilation="$(UseSharedCompilation)" Utf8Output="$(Utf8Output)" VsSessionGuid="$(VsSessionGuid)" WarningLevel="$(WarningLevel)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" Win32Icon="$(ApplicationIcon)" Win32Manifest="$(Win32Manifest)" Win32Resource="$(Win32Resource)" PathMap="$(PathMap)" SourceLink="$(SourceLink)">
      <Output TaskParameter="CommandLineArgs" ItemName="CscCommandLineArgs" />
    </Csc>
    <ItemGroup>
      <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />
    </ItemGroup>
    <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''" />
  </Target>
  <!-- When we load a project in Visual Studio, the project system first does an evaluation pass of the
       project, and hands the resulting list of <Compile> items to the language service. It then does an
       execution pass executing CoreCompile passing SkipCompilerExecution=true and ProvideCommandLineArgs=true,
       that resulting command line string is where we get our compiler switches. The execution pass is much
       slower than the evaluation pass, so there's a window of time where we have a list of files, but not
       any options yet.

       Because there's a gap, that means there's a time where we are parsing source files with the default
       parse options. We'll then have to reparse them a second time which isn't great. It also means any
       cache lookups we do won't have the right options either, so the cache lookups might miss.

       To help this, we'll have properties for the evaluation pass which is an "approximation" of the
       options that would come out of CoreCompile, but only the ones that are required to be specified
       and we don't expect them to change after evaluation phase or those that matter for parsing.

       It's acceptable for the options that affect parsing to be imperfect: once the execution pass is complete we'll use those options instead,
       so any behaviors here that don't match the real command line generation will only be temporary, and
       probably won't be any worse than having no options at all. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CommandLineArgsForDesignTimeEvaluation>-langversion:$(LangVersion)</CommandLineArgsForDesignTimeEvaluation>
    <CommandLineArgsForDesignTimeEvaluation Condition="'$(ChecksumAlgorithm)' != ''">$(CommandLineArgsForDesignTimeEvaluation) -checksumalgorithm:$(ChecksumAlgorithm)</CommandLineArgsForDesignTimeEvaluation>
    <CommandLineArgsForDesignTimeEvaluation Condition="'$(DefineConstants)' != ''">$(CommandLineArgsForDesignTimeEvaluation) -define:$(DefineConstants)</CommandLineArgsForDesignTimeEvaluation>
    <CommandLineArgsForDesignTimeEvaluation Condition="'$(Features)' != ''">$(CommandLineArgsForDesignTimeEvaluation) -features:$(Features)</CommandLineArgsForDesignTimeEvaluation>
    <CommandLineArgsForDesignTimeEvaluation Condition="'$(DocumentationFile)' != ''">$(CommandLineArgsForDesignTimeEvaluation) -doc:"$(DocumentationFile)"</CommandLineArgsForDesignTimeEvaluation>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- Import design time targets for Roslyn Project System. These are only available if Visual Studio is installed. -->
  <!-- Import design time targets before the common targets, which import targets from Nuget. -->
  <PropertyGroup>
    <CSharpDesignTimeTargetsPath Condition="'$(CSharpDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.CSharp.DesignTime.targets</CSharpDesignTimeTargetsPath>
  </PropertyGroup>
  <!--<Import Project="$(CSharpDesignTimeTargetsPath)" Condition="'$(CSharpDesignTimeTargetsPath)' != '' and Exists('$(CSharpDesignTimeTargetsPath)')" />-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.Common.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, and Visual C#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <CommonTargetsPath>$(MSBuildToolsPath)\Microsoft.Common.CurrentVersion.targets</CommonTargetsPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CommonTargetsPath)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Common.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines the steps in the standard build process for .NET projects.  It
contains all the steps that are common among the different .NET languages, such as
Visual Basic, and Visual C#.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="'$(MicrosoftCommonPropsHasBeenImported)' != 'true' and Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />-->
  <PropertyGroup>
    <ImportByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCommonTargets>
    <ImportByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportByWildcardAfterMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets>
    <ImportUserLocationsByWildcardAfterMicrosoftCommonTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftCommonTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore')" />-->
  <!--<Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')" />-->
  <!-- VS10 without SP1 and without VS11 will not have VisualStudioVersion set, so do that here -->
  <PropertyGroup>
    <VisualStudioVersion Condition="'$(VisualStudioVersion)' == ''">10.0</VisualStudioVersion>
  </PropertyGroup>
  <PropertyGroup>
    <CustomBeforeMicrosoftCommonTargets Condition="'$(CustomBeforeMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.Before.Microsoft.Common.targets</CustomBeforeMicrosoftCommonTargets>
    <CustomAfterMicrosoftCommonTargets Condition="'$(CustomAfterMicrosoftCommonTargets)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.Microsoft.Common.targets</CustomAfterMicrosoftCommonTargets>
    <ReportingServicesTargets Condition="'$(ReportingServicesTargets)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\ReportingServices\Microsoft.ReportingServices.targets</ReportingServicesTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(CustomBeforeMicrosoftCommonTargets)" Condition="'$(CustomBeforeMicrosoftCommonTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonTargets)')">

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.BeforeCommonTargets.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- Only build Microsoft.AspNetCore.App, Microsoft.AspNetCore.App.Ref, ref/ assemblies, and ProjectTemplates in source build. -->
    <!-- Analyzer package are needed in source build for WebSDK -->
    <ExcludeFromSourceOnlyBuild Condition="'$(ExcludeFromSourceOnlyBuild)' == '' and&#xA;            '$(DotNetBuildSourceOnly)' == 'true' and&#xA;            '$(IsAspNetCoreApp)' != 'true' and&#xA;            '$(UsingMicrosoftDotNetSharedFrameworkSdk)' != 'true' and&#xA;            '$(IsAnalyzersProject)' != 'true' and&#xA;            '$(IsProjectTemplateProject)' != 'true'">true</ExcludeFromSourceOnlyBuild>
    <!-- If the user has specified that they want to skip building any test related projects with SkipTestBuild,
     suppress all targets for TestProjects using ExcludeFromBuild. -->
    <ExcludeFromBuild Condition="'$(IsPackable)' != 'true' and&#xA;        ('$(SkipTestBuild)' == 'true' or ('$(DotNetBuild)' == 'true' and '$(DotNetBuildTests)' != 'true')) and&#xA;        ($(IsTestProject) or&#xA;         '$(IsPublishedAppTestProject)' == 'true' or&#xA;         '$(IsTestAssetProject)' == 'true' or&#xA;         '$(IsBenchmarkProject)' == 'true' or&#xA;         '$(IsSampleProject)' == 'true' or&#xA;         '$(IsSpecificationTestProject)' == 'true' or&#xA;         '$(IsMicrobenchmarksProject)' == 'true')">true</ExcludeFromBuild>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(CustomBeforeMicrosoftCommonTargets)" Condition="'$(CustomBeforeMicrosoftCommonTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonTargets)')">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/BeforeCommonTargets.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--<Import Project="$(_ArcadeOverriddenCustomBeforeMicrosoftCommonTargets)" Condition="Exists('$(_ArcadeOverriddenCustomBeforeMicrosoftCommonTargets)')" />-->
  <PropertyGroup>
    <_ArcadeBeforeCommonTargetsImported>true</_ArcadeBeforeCommonTargetsImported>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Version.BeforeCommonTargets.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Version.BeforeCommonTargets.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    Compute the IsShipping* properties

    Unless specified otherwise project is assumed to produce artifacts (assembly, package, vsix, etc.) that ship.
      Test projects automatically set IsShipping to false.

      Some projects may produce packages that contain shipping assemblies but the packages themselves do not ship.
      Thes projects shall specify IsShippingPackage=false and leave IsShipping unset (will default to true).

      Targets that need to determine whether an artifact is shipping shall use the artifact specific IsShippingXxx property,
      if available for the kind of artifact they operate on.
  -->
  <PropertyGroup>
    <!-- Treat test assemblies as non-shipping (do not publish or sign them). -->
    <IsShipping Condition="'$(IsShipping)' == '' and ('$(IsTestProject)' == 'true' or '$(IsTestUtilityProject)' == 'true')">false</IsShipping>
    <IsShipping Condition="'$(IsShipping)' == ''">true</IsShipping>
    <IsShippingAssembly Condition="'$(IsShippingAssembly)' == ''">$(IsShipping)</IsShippingAssembly>
    <IsShippingPackage Condition="'$(IsVisualStudioBuildPackage)' == 'true'">false</IsShippingPackage>
    <IsShippingPackage Condition="'$(IsShippingPackage)' == ''">$(IsShipping)</IsShippingPackage>
    <IsShippingVsix Condition="'$(IsShippingVsix)' == ''">$(IsShipping)</IsShippingVsix>
  </PropertyGroup>
  <!--
    Specification: https://github.com/dotnet/arcade/blob/master/Documentation/CorePackages/Versioning.md

    Workaround for https://github.com/dotnet/sdk/issues/3173:
    The following must be evaluated after the project file is imported but before Microsoft.NET.DefaultAssemblyInfo.targets from .NET Core SDK is imported.
    The project may set VersionPrefix, MajorVersion, MinorVersion, or AutoGenerateAssemblyVersion properties, which are consumed below.
    Microsoft.NET.DefaultAssemblyInfo.targets consumes VersionPrefix property, which may be set below.
  -->
  <!--
    Version numbers calculated here are date-based. In official builds this is given by OfficialBuildId parameter,
    but other builds do not have such input and would therefore be non-deterministic.
  -->
  <PropertyGroup Condition="'$(OfficialBuild)' == 'true' or '$(DotNetUseShippingVersions)' == 'true'">
    <!--
      Building MSIs from dev build requires file versions to be increasing.
      Use the current date in non-official builds. Note that this reduces the deterministic properties of the build
      and should only be enabled when it's necessary to test-install the MSIs produced by the build.
    -->
    <_BuildNumber>$(OfficialBuildId)</_BuildNumber>
    <_BuildNumber Condition="'$(OfficialBuildId)' == ''">$([System.DateTime]::Now.ToString(yyyyMMdd)).1</_BuildNumber>
    <!--
      OfficialBuildId is assumed to have format "20yymmdd.r" (the assumption is checked later in a target).
    -->
    <_BuildNumberYY>$(_BuildNumber.Substring(2, 2))</_BuildNumberYY>
    <_BuildNumberMM>$(_BuildNumber.Substring(4, 2))</_BuildNumberMM>
    <_BuildNumberDD>$(_BuildNumber.Substring(6, 2))</_BuildNumberDD>
    <_BuildNumberR>$(_BuildNumber.Substring(9))</_BuildNumberR>
    <!-- SHORT_DATE := yy * 1000 + mm * 50 + dd -->
    <VersionSuffixDateStamp>$([MSBuild]::Add($([MSBuild]::Add($([MSBuild]::Multiply($(_BuildNumberYY), 1000)), $([MSBuild]::Multiply($(_BuildNumberMM), 50)))), $(_BuildNumberDD)))</VersionSuffixDateStamp>
    <!-- REVISION := r -->
    <VersionSuffixBuildOfTheDay>$(_BuildNumberR)</VersionSuffixBuildOfTheDay>
    <VersionSuffixBuildOfTheDayPadded>$(VersionSuffixBuildOfTheDay.PadLeft(2, $([System.Convert]::ToChar(`0`))))</VersionSuffixBuildOfTheDayPadded>
    <!-- PATCH_NUMBER := (SHORT_DATE - VersionBaseShortDate) * 100 + r -->
    <_PatchNumber>$([MSBuild]::Add($([MSBuild]::Multiply($([MSBuild]::Subtract($(VersionSuffixDateStamp), $([MSBuild]::ValueOrDefault($(VersionBaseShortDate), 19000)))), 100)), $(_BuildNumberR)))</_PatchNumber>
  </PropertyGroup>
  <!--
    Calculate VersionPrefix.
  -->
  <!--
    The project can specify version either directly using the .NET SDK recognized property VersionPrefix, or using MajorVersion and MinorVersion properties.
    Note that .NET Core SDK sets VersionPrefix to 1.0.0 if not set by the project. Override it here if the project sets MajorVersion, MinorVersion, and optionally a PatchVersion.
  -->
  <PropertyGroup>
    <VersionPrefix Condition="'$(MajorVersion)' != '' and '$(MinorVersion)' != ''">$(MajorVersion).$(MinorVersion).$([MSBuild]::ValueOrDefault('$(PatchVersion)', '0'))</VersionPrefix>
    <_OriginalVersionPrefix>$(VersionPrefix)</_OriginalVersionPrefix>
  </PropertyGroup>
  <!--
    If a package is designated to be a release-only package (PreReleaseVersionLabel is empty) its package version does
    not include any pre-release labels in official build. The 3rd component of the version prefix is overwritten either
    by PATCH_NUMBER or '0' in non-official builds.
  -->
  <PropertyGroup Condition="'$(PreReleaseVersionLabel)' == ''">
    <_VersionPrefixMajor>$(VersionPrefix.Split('.')[0])</_VersionPrefixMajor>
    <_VersionPrefixMinor>$(VersionPrefix.Split('.')[1])</_VersionPrefixMinor>
    <VersionPrefix>$(_VersionPrefixMajor).$(_VersionPrefixMinor).$([MSBuild]::ValueOrDefault($(_PatchNumber), '0'))</VersionPrefix>
    <VersionSuffix />
  </PropertyGroup>
  <!--
    Calculate VersionSuffix.
  -->
  <PropertyGroup Condition="'$(PreReleaseVersionLabel)' != '' or '$(VersionSuffixDateStamp)' == ''">
    <!--
      Traditionally, .NET Core has used prerelease labels like:
      - preview1
      - beta1,
      - preview9

      For previews, this presents a problem if we decide to release more than 9 previews, as preview10 sorts
      after preview9. This could be dealt with by using preview01, preview02, etc. but this is harder to read.
      Instead, repos should use preview.1, preview.2, etc. if using SemVer2. NuGet will properly preference preview.10
      over preview.9.

      If PreReleaseVersionIteration is set and SemanticVersioningV1 is not set to true, then the prerelease version
      number is appended with a '.' to PreReleaseVersionLabel to create the final prerelease label.
    -->
    <_PreReleaseLabel>$(PreReleaseVersionLabel)</_PreReleaseLabel>
    <_PreReleaseLabel Condition="'$(SemanticVersioningV1)' != 'true' and '$(PreReleaseVersionIteration)' != ''">$(PreReleaseVersionLabel).$(PreReleaseVersionIteration)</_PreReleaseLabel>
    <_PreReleaseLabel Condition="'$(SemanticVersioningV1)' == 'true'">$(PreReleaseVersionLabel)$(PreReleaseVersionIteration)</_PreReleaseLabel>
    <_PreReleaseLabel Condition="'$(ContinuousIntegrationBuild)' == 'true' and '$(OfficialBuild)' != 'true'">ci</_PreReleaseLabel>
    <!-- Allow a non CI build to have an official build version label when OfficialBuild is explicitly passed-in. -->
    <_PreReleaseLabel Condition="'$(ContinuousIntegrationBuild)' != 'true' and '$(OfficialBuild)' != 'true'">dev</_PreReleaseLabel>
    <_BuildNumberLabels Condition="'$(VersionSuffixDateStamp)' != '' and '$(SemanticVersioningV1)' != 'true'">.$(VersionSuffixDateStamp).$(VersionSuffixBuildOfTheDay)</_BuildNumberLabels>
    <_BuildNumberLabels Condition="'$(VersionSuffixDateStamp)' != '' and '$(SemanticVersioningV1)' == 'true'">-$(VersionSuffixDateStamp)-$(VersionSuffixBuildOfTheDayPadded)</_BuildNumberLabels>
    <!--
      If DotNetFinalVersionKind is specified, overrides the package version produced by the build like so:
        ""           1.2.3-beta.12345.67
        "prerelease" 1.2.3-beta
        "release"    1.2.3
    -->
    <VersionSuffix Condition="'$(DotNetFinalVersionKind)' == 'release'" />
    <VersionSuffix Condition="'$(DotNetFinalVersionKind)' == 'prerelease' and '$(SemanticVersioningV1)' != 'true'">$(_PreReleaseLabel).final</VersionSuffix>
    <VersionSuffix Condition="'$(DotNetFinalVersionKind)' == 'prerelease' and '$(SemanticVersioningV1)' == 'true'">$(_PreReleaseLabel)-final</VersionSuffix>
    <VersionSuffix Condition="'$(DotNetFinalVersionKind)' == ''">$(_PreReleaseLabel)$(_BuildNumberLabels)</VersionSuffix>
    <!--
      Some projects want to remain producing prerelease packages even if we are doing a final stable build because
      they don't ship or aren't ready to ship stable. Those projects can set SuppressFinalPackageVersion property to true.

      TODO: BlockStable is obsolete. Remove once repos update. https://github.com/dotnet/arcade/issues/1213
    -->
    <VersionSuffix Condition="'$(BlockStable)' == 'true' or '$(SuppressFinalPackageVersion)' == 'true'">$(_PreReleaseLabel)$(_BuildNumberLabels)</VersionSuffix>
    <!--
      If a project produces non-shipping packages, these packages should always include the build number label
    -->
    <VersionSuffix Condition="'$(IsShippingPackage)' != 'true'">$(_PreReleaseLabel)$(_BuildNumberLabels)</VersionSuffix>
    <!--
      Disable NuGet Pack warning that the version is SemVer 2.0.
      SemVer 2.0 is supported by NuGet since 3.0.0 (July 2015) in some capacity, and fully since 3.5.0 (October 2016).
    -->
    <NoWarn Condition="'$(SemanticVersioningV1)' != 'true'">$(NoWarn);NU5105</NoWarn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(VersionSuffixDateStamp)' == ''">
    <!--
      Don't include a commit SHA to AssemblyInformationalVersion.
      It would reduce the possibility of sharing otherwise unchanged build artifacts across deterministic builds.
    -->
    <IncludeSourceRevisionInInformationalVersion>false</IncludeSourceRevisionInInformationalVersion>
  </PropertyGroup>
  <!--
    Workaround for https://github.com/dotnet/sdk/issues/3173.
    Overwrite the value of Version set in Microsoft.NET.DefaultAssemblyInfo.targets.
  -->
  <PropertyGroup>
    <VersionPrefix Condition="'$(VersionPrefix)' == ''">1.0.0</VersionPrefix>
    <Version>$(VersionPrefix)</Version>
    <Version Condition="'$(VersionSuffix)' != ''">$(Version)-$(VersionSuffix)</Version>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/BeforeCommonTargets.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="TargetFrameworkFilters.BeforeCommonTargets.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/TargetFrameworkFilters.BeforeCommonTargets.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <!-- TFM filtering is enabled by default and can be disabled, at repo level, by setting NoTargetFrameworkFiltering propert
         to true, in repo's root Directory.Build.props file. -->
    <DotNetTargetFrameworkFilter Condition="'$(DotNetTargetFrameworkFilter)' == '' and '$(DotNetBuildSourceOnly)' == 'true'">netstandard2.0%3bnetstandard2.1%3bnetcoreapp2.1%3bnetcoreapp3.1%3bnet5.0%3bnet6.0%3bnet7.0%3bnet8.0%3bnet9.0%3bnet10.0</DotNetTargetFrameworkFilter>
    <_EnableTargetFrameworkFiltering>false</_EnableTargetFrameworkFiltering>
    <_EnableTargetFrameworkFiltering Condition="'$(NoTargetFrameworkFiltering)' != 'true' and '$(DotNetTargetFrameworkFilter)' != ''">true</_EnableTargetFrameworkFiltering>
  </PropertyGroup>
  <PropertyGroup Condition="$(_EnableTargetFrameworkFiltering)">
    <_OriginalTargetFrameworks Condition="'$(TargetFrameworks)' != ''">$(TargetFrameworks)</_OriginalTargetFrameworks>
    <_OriginalTargetFrameworks Condition="'$(TargetFramework)' != ''">$(TargetFramework)</_OriginalTargetFrameworks>
    <_FilteredTargetFrameworks>$([MSBuild]::Unescape($([MSBuild]::FilterTargetFrameworks('$(_OriginalTargetFrameworks)', '$(DotNetTargetFrameworkFilter)'))))</_FilteredTargetFrameworks>
    <!-- Maintain usage of the original property -->
    <TargetFrameworks Condition="'$(TargetFrameworks)' != ''">$(_FilteredTargetFrameworks)</TargetFrameworks>
    <TargetFramework Condition="'$(TargetFramework)' != ''">$(_FilteredTargetFrameworks)</TargetFramework>
    <!-- If nothing left to build, exclude it! -->
    <ExcludeFromBuild Condition="'$(_FilteredTargetFrameworks)' == ''">true</ExcludeFromBuild>
  </PropertyGroup>
  <!-- Opt-in target to verify that a project doesn't bring in the .NET Standard 1.x dependency graph
       (usually transitively) via old dependencies. -->
  <Target Name="FlagNetStandard1xDependencies" Condition="'$(FlagNetStandard1XDependencies)' == 'true'" AfterTargets="ResolvePackageAssets">
    <ItemGroup>
      <NetStandard1xPackage Include="&#xD;&#xA;        Microsoft.Win32.Primitives;&#xD;&#xA;        System.AppContext;&#xD;&#xA;        System.Collections;&#xD;&#xA;        System.Collections.Concurrent;&#xD;&#xA;        System.Console;&#xD;&#xA;        System.Diagnostics.Debug;&#xD;&#xA;        System.Diagnostics.Tools;&#xD;&#xA;        System.Diagnostics.Tracing;&#xD;&#xA;        System.Globalization;&#xD;&#xA;        System.Globalization.Calendars;&#xD;&#xA;        System.IO;&#xD;&#xA;        System.IO.Compression;&#xD;&#xA;        System.IO.Compression.ZipFile;&#xD;&#xA;        System.IO.FileSystem;&#xD;&#xA;        System.IO.FileSystem.Primitives;&#xD;&#xA;        System.Linq;&#xD;&#xA;        System.Linq.Expressions;&#xD;&#xA;        System.Net.Http;&#xD;&#xA;        System.Net.Primitives;&#xD;&#xA;        System.Net.Sockets;&#xD;&#xA;        System.ObjectModel;&#xD;&#xA;        System.Reflection;&#xD;&#xA;        System.Reflection.Extensions;&#xD;&#xA;        System.Reflection.Primitives;&#xD;&#xA;        System.Resources.ResourceManager;&#xD;&#xA;        System.Runtime;&#xD;&#xA;        System.Runtime.Extensions;&#xD;&#xA;        System.Runtime.Handles;&#xD;&#xA;        System.Runtime.InteropServices;&#xD;&#xA;        System.Runtime.InteropServices.RuntimeInformation;&#xD;&#xA;        System.Runtime.Numerics;&#xD;&#xA;        System.Security.Cryptography.Algorithms;&#xD;&#xA;        System.Security.Cryptography.Encoding;&#xD;&#xA;        System.Security.Cryptography.Primitives;&#xD;&#xA;        System.Security.Cryptography.X509Certificates;&#xD;&#xA;        System.Text.Encoding;&#xD;&#xA;        System.Text.Encoding.Extensions;&#xD;&#xA;        System.Text.RegularExpressions;&#xD;&#xA;        System.Threading;&#xD;&#xA;        System.Threading.Tasks;&#xD;&#xA;        System.Threading.Timer;&#xD;&#xA;        System.Xml.ReaderWriter;&#xD;&#xA;        System.Xml.XDocument" />
      <!-- That package doesn't bring any dependencies in on .NET Framework and is fine to use. -->
      <NetStandard1xPackage Remove="System.Runtime.InteropServices.RuntimeInformation" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
    </ItemGroup>
    <ItemGroup>
      <NonFoundNetStandard1xPackage Include="@(PackageDependencies)" Exclude="@(NetStandard1xPackage)" />
      <FoundNetStandard1xPackage Include="@(PackageDependencies)" Exclude="@(NonFoundNetStandard1xPackage)" />
    </ItemGroup>
    <Error Text="The following .NET Standard 1.x packages are referenced and must be removed: %0D%0A- @(FoundNetStandard1xPackage, '%0D%0A- ')%0D%0AConsult the project.assets.json files to find the parent dependencies." Condition="'@(FoundNetStandard1xPackage)' != ''" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/BeforeCommonTargets.targets
============================================================================================================================================
-->
  <!-- Import the logic to determine whether a project should not build.
       This is done at this point because we need to exclude the import of some standard Microsoft restore targets (NuGet)
       that are loaded before the import of Arcade's Sdk.targets. See info in ExcludeFromBuild.
       Repositories that don't require this infrastructure can set DisableArcadeExcludeFromBuildSupport to true to disable it. -->
  <!--
============================================================================================================================================
  <Import Project="ExcludeFromBuild.BeforeCommonTargets.targets" Condition="'$(DisableArcadeExcludeFromBuildSupport)' != 'true'">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/ExcludeFromBuild.BeforeCommonTargets.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--  This file sets properties that enable skipping of a project build if desired.
        Cases where we might skip include:
        - Source-build mode and "ExcludeFromSourceOnlyBuild" is set.
        - Non source-build mode and "ExcludeFromBuild" is set
        - Target filtering is used and the target filters set "ExcludeFromBuild".
        - .NET product build (DotNetBuild) and "ExcludeFromDotNetBuild" is set.
        - .NET product build in source-only mode and "ExcludeFromSourceOnlyBuild" is set.

        To exclude a project from building, Arcade must do two things:
        - Create/override the standard targets (Build, Restore, Sign, etc.) with empty ones.
        - Keep the .NET SDK from importing the standard NuGet restore targets - NuGet uses the
          '_IsProjectRestoreSupported target' to determine whether a project can be restored. If the project shouldn't be built,
          it shouldn't be restored either. This could be done two ways:
            - Override the _IsProjectRestoreSupported target to an empty target, or one that returns false.
            - Avoid import of the _IsProjectRestoreSupported target altogether.
          The first approach is more consistent with the rest of Arcade's approach to skipping a build.
          However is does **not** work with msbuild static graph. Static graph uses the *existence* of the
          target to determine whether a project should be restored, so overriding with an empty target will
          only avoid building a project, but it will still get restored. This could cause issues with target
          framework filtering, or introduce unexpected prebuilts.

          So to achieve the desired affect, Arcade must reset NuGetRestoreTargets to an empty file. Because
          this import is done early, the BeforeCommonTargets hook must be used. There is a case
          where the BeforeCommonTargets hook is not used (see https://github.com/dotnet/arcade/issues/2676).
          In that case, Sdk.targets imports it explicitly. -->
  <!-- Exclude test and test utility projects from source-only and .NET non-source only product builds by default. -->
  <PropertyGroup Condition="'$(IsTestProject)' == 'true' or '$(IsTestUtilityProject)' == 'true'">
    <ExcludeFromSourceOnlyBuild Condition="'$(ExcludeFromSourceOnlyBuild)' == '' and '$(DotNetBuildTests)' != 'true'">true</ExcludeFromSourceOnlyBuild>
    <!-- Avoid excluding packable projects. They often need to flow downstream to dependent repos. -->
    <ExcludeFromDotNetBuild Condition="'$(ExcludeFromDotNetBuild)' == '' and '$(DotNetBuildTests)' != 'true' and '$(IsPackable)' != 'true'">true</ExcludeFromDotNetBuild>
  </PropertyGroup>
  <!--
    Calculate the value of the target suppress flag. It should be true when:
    - Building from source only and the project is excluded from source-only builds (legacy switches and new switches)
    - Building a vertical and the project is excluded from vertical builds (to be removed)
    - The project is explicitly excluded.

    It's also possible to set ExcludeFromBuild prior to importing the Sdk.targets
    to skip building as desired in non-source build scenarios. This might be done to
    avoid building tests in certain product build scenarios.
  -->
  <PropertyGroup>
    <_SuppressAllTargets>false</_SuppressAllTargets>
    <!-- New .NET build switches -->
    <_SuppressAllTargets Condition="'$(DotNetBuildSourceOnly)' == 'true' and '$(ExcludeFromSourceOnlyBuild)' == 'true'">true</_SuppressAllTargets>
    <_SuppressAllTargets Condition="'$(DotNetBuild)' == 'true' and '$(ExcludeFromDotNetBuild)' == 'true'">true</_SuppressAllTargets>
    <!-- General exclusion -->
    <_SuppressAllTargets Condition="'$(ExcludeFromBuild)' == 'true'">true</_SuppressAllTargets>
    <!-- If excluding, then disable a restore warning, which will fire on newer SDKs, as well as set the NuGetRestoreTargets property to empty,
         which will avoid importing the restore targets inside the .NET SDK. If the restore targets exist, then static graph restore will attempt tpo
         execute. -->
    <DisableWarnForInvalidRestoreProjects Condition="'$(_SuppressAllTargets)' == 'true'">true</DisableWarnForInvalidRestoreProjects>
    <NuGetRestoreTargets Condition="'$(_SuppressAllTargets)' == 'true'">$(MSBuildThisFileDirectory)NoRestore.targets</NuGetRestoreTargets>
    <!-- When a project is using the .NET SDK, but with the "UseWpf" property, there will be an attempt to import the windows desktop SDK targets.
         These are not available in certain circumstances, like linux source build. -->
    <ImportWindowsDesktopTargets Condition="'$(_SuppressAllTargets)' == 'true'">false</ImportWindowsDesktopTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/BeforeCommonTargets.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!-- By default, we are creating a managed app because .NET 2.0 projects did not have this property. -->
  <PropertyGroup Condition="'$(TargetRuntime)' == ''">
    <TargetRuntime>Managed</TargetRuntime>
  </PropertyGroup>
  <!-- Because .NET 2.0 apps did not set TargetFrameworkIdentifier, we need to set it for them here by default.  If
       the runtime is set to Managed, we also need to set these.  Otherwise they should be blank (for instance Javascript or
       Native apps) because they do not target a .NET Framework. -->
  <PropertyGroup Condition="'$(TargetRuntime)' == 'Managed'">
    <TargetFrameworkIdentifier Condition="'$(TargetFrameworkIdentifier)' == ''">.NETFramework</TargetFrameworkIdentifier>
    <TargetFrameworkVersion Condition=" '$(TargetFrameworkVersion)' == '' ">v4.0</TargetFrameworkVersion>
  </PropertyGroup>
  <!-- AvailablePlatforms is the list of platform targets available. -->
  <PropertyGroup>
    <AvailablePlatforms Condition="'$(VisualStudioVersion)' == '10.0' or '$(VisualStudioVersion)' == ''">Any CPU,x86,x64,Itanium</AvailablePlatforms>
    <AvailablePlatforms Condition="'$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt; '10.0'">Any CPU,x86,x64</AvailablePlatforms>
  </PropertyGroup>
  <!-- Import depends on if it is .NETCore. Imports for .NETFramework is a superset of that for .NETCore-->
  <!--<Import Project="Microsoft.NETFramework.props" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight'" />-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.props" Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' or '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.NET.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file contains .NET-specific properties, and items. This file is imported for .NET Core, .NET Standard, and .NET Framework projects.
these two files are used to encapsulate the multi-targeting and framework specific build process.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!--
    ============================================================
                                        GetToolPaths
    Get the paths for the .NET Framework and .NET Core tools and sdk tools directories.
    This does not need to be a target since all of the values are availiable at project evaluation time.
    ============================================================
  -->
  <PropertyGroup>
    <TargetFrameworkSDKToolsDirectory Condition=" '$(TargetFrameworkSDKToolsDirectory)' == '' ">$(SDK40ToolsPath)</TargetFrameworkSDKToolsDirectory>
  </PropertyGroup>
  <!--
    ============================================================
                                        SetHighEntropyVA
    Set HighEntropyVA according to the TargetFramework
    ============================================================
  -->
  <PropertyGroup Condition="('$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0') or '$(TargetFrameworkIdentifier)' == '.NETCoreApp' or '$(TargetFrameworkIdentifier)' == '.NETStandard'">
    <HighEntropyVA Condition="'$(HighEntropyVA)' == ''">true</HighEntropyVA>
  </PropertyGroup>
  <PropertyGroup>
    <HighEntropyVA Condition="'$(HighEntropyVA)' == ''">false</HighEntropyVA>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- Generates full paths for the 'File' property in errors, warnings and messages in many targets -->
    <GenerateFullPaths Condition="'$(GenerateFullPaths)' == ''">true</GenerateFullPaths>
    <!-- Yield optimization properties -->
    <YieldDuringToolExecution Condition="'$(YieldDuringToolExecution)' == ''">true</YieldDuringToolExecution>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' != '' and '$(TargetFrameworkVersion)' != ''">
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == '' and '$([System.String]::IsNullOrWhitespace($(TargetFrameworkProfile)))' != 'true'">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion),Profile=$(TargetFrameworkProfile)</TargetFrameworkMoniker>
    <TargetFrameworkMoniker Condition="'$(TargetFrameworkMoniker)' == ''">$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
    <!-- When working off a packaged reference assemblies, do not go to machine-global locations. This property is target-framework-specific, so it cannot be overridden in msbuild.exe.config once and for all. -->
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And '$(FrameworkPathOverride)' == '' And Exists('$(TargetFrameworkRootPath)$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)')">$(TargetFrameworkRootPath)$(TargetFrameworkIdentifier)\$(TargetFrameworkVersion)</FrameworkPathOverride>
    <!-- The FrameworkPathOverride is required for the inproc visual basic compiler to initialize when targeting target frameworks less than 4.0. If .net 2.0 is not installed then the property value above will not provide the location
             of mscorlib. This is also true if the build author overrides this property to some other directory which does not contain mscorlib.dll. In the case we cannot find mscorlib.dll at the correct location
             we need to find a directory which does contain mscorlib to allow the inproc compiler to initialize and give us the chance to show certain dialogs in the IDE (which only happen after initialization).-->
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And '$(FrameworkPathOverride)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToStandardLibraries($(TargetFrameworkIdentifier), $(TargetFrameworkVersion), $(TargetFrameworkProfile), $(PlatformTarget), $(TargetFrameworkRootPath), $(TargetFrameworkFallbackSearchPaths)))</FrameworkPathOverride>
    <FrameworkPathOverride Condition="'$(EnableFrameworkPathOverride)' != 'false' And !Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
  </PropertyGroup>
  <PropertyGroup>
    <TargetPlatformIdentifier Condition="'$(TargetPlatformIdentifier)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">Windows</TargetPlatformIdentifier>
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == '' and '$(_EnableDefaultWindowsPlatform)' != 'false'">7.0</TargetPlatformVersion>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformSdkRootOverride)' != ''">$(TargetPlatformSdkRootOverride)\</TargetPlatformSdkPath>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and $([MSBuild]::IsOSPlatform('Windows')) and '$(MSBuildRuntimeType)' != 'Core'">$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\Software\Microsoft\Microsoft SDKs\Windows\v$(TargetPlatformVersion)', InstallationFolder, null, RegistryView.Registry32, RegistryView.Default))</TargetPlatformSdkPath>
    <TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKLocation($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformSdkPath>
    <TargetPlatformSdkMetadataLocation Condition="'$(TargetPlatformSdkMetadataLocation)' == '' and Exists('$(TargetPlatformSdkPath)')">$(TargetPlatformSdkPath)Windows Metadata</TargetPlatformSdkMetadataLocation>
    <TargetPlatformSdkMetadataLocation Condition="Exists('$(TargetPlatformSdkPath)') and ('$(TargetPlatformSdkMetadataLocation)' == '' or !Exists('$(TargetPlatformSdkMetadataLocation)'))">$(TargetPlatformSdkPath)References\CommonConfiguration\Neutral</TargetPlatformSdkMetadataLocation>
    <TargetPlatformWinMDLocation Condition="'$(TargetPlatformWinMDLocation)' == '' and Exists('$(TargetPlatformSdkMetadataLocation)')">$(TargetPlatformSdkMetadataLocation)</TargetPlatformWinMDLocation>
    <UseOSWinMdReferences Condition="'$(UseOSWinMdReferences)' == '' and ('$(TargetPlatformWinMDLocation)' == '' and '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &gt; '7.0')">true</UseOSWinMdReferences>
    <TargetPlatformWinMDLocation Condition="'$(UseOsWinMdReferences)' == 'true'">$(WinDir)\System32\WinMetadata</TargetPlatformWinMDLocation>
    <TargetPlatformMoniker Condition="'$(TargetPlatformMoniker)' == '' and '$(TargetPlatformIdentifier)' != '' and '$(TargetPlatformVersion)' != ''">$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
    <TargetPlatformDisplayName Condition="'$(TargetPlatformDisplayName)' == ''">$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformDisplayName>
  </PropertyGroup>
  <!--
    Several properties must be set in the main project file, before using this .TARGETS file.
    However, if the properties are not set, we pick some defaults.

    OutDir:
    Indicates the final output location for the project or solution. When building a solution,
    OutDir can be used to gather multiple project outputs in one location. In addition,
    OutDir is included in AssemblySearchPaths used for resolving references.

    BaseOutputPath:
    This is the top level folder where all configuration specific output folders will be created.
    Default value is bin\

    OutputPath:
    This is the full Output Path, and is derived from BaseOutputPath, if none specified
    (eg. bin\Debug). If this property is overridden, then setting BaseOutputPath has no effect.

    For Legacy projects using only Common targets, this property is usually specified in the project file
    and is used to initialize OutDir. Some SDKs including the .NET SDK derive this automatically.
    OutDir and OutputPath are distinguished for legacy reasons, and OutDir should be used if at all possible.

    BaseIntermediateOutputPath:
    This is the top level folder where all configuration specific intermediate output folders will be created.
    Default value is obj\

    IntermediateOutputPath:
    This is the full intermediate Output Path, and is derived from BaseIntermediateOutputPath, if none specified
    (eg. obj\Debug). If this property is overridden, then setting BaseIntermediateOutputPath has no effect.

    Ensure any and all path property has a trailing slash, so it can be concatenated.
    -->
  <PropertyGroup>
    <!-- Example, AnyCPU -->
    <_OriginalPlatform>$(Platform)</_OriginalPlatform>
    <!-- Example, Debug -->
    <_OriginalConfiguration>$(Configuration)</_OriginalConfiguration>
    <!-- Check whether OutputPath was specified for valid Configuration/Platform combination -->
    <_OutputPathWasMissing Condition="'$(_OriginalPlatform)' != '' and '$(_OriginalConfiguration)' != '' and '$(OutputPath)' == ''">true</_OutputPathWasMissing>
    <!-- Check whether BaseOutputPath was specified -->
    <BaseOutputPathWasSpecified Condition="'$(BaseOutputPath)' != ''">true</BaseOutputPathWasSpecified>
  </PropertyGroup>
  <PropertyGroup>
    <Platform Condition="'$(Platform)' == ''">AnyCPU</Platform>
    <PlatformName Condition="'$(PlatformName)' == ''">$(Platform)</PlatformName>
    <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
    <ConfigurationName Condition="'$(ConfigurationName)' == ''">$(Configuration)</ConfigurationName>
    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">bin\</BaseOutputPath>
    <BaseOutputPath Condition="!HasTrailingSlash('$(BaseOutputPath)')">$(BaseOutputPath)\</BaseOutputPath>
    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseOutputPath)$(Configuration)\</OutputPath>
    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseOutputPath)$(PlatformName)\$(Configuration)\</OutputPath>
    <OutputPath Condition="!HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">obj\</BaseIntermediateOutputPath>
    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
    <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Determine OutputType property from the legacy TargetType property -->
    <OutputType Condition=" '$(TargetType)' != ''">$(TargetType)</OutputType>
    <OutputType Condition=" '$(TargetType)' == 'Container' or '$(TargetType)' == 'DocumentContainer' ">library</OutputType>
    <OutputType Condition=" '$(OutputType)' == '' ">exe</OutputType>
    <DebugSymbols Condition=" '$(ConfigurationName)' == 'Debug' and '$(DebugSymbols)' == '' and '$(DebugType)'==''">true</DebugSymbols>
    <!-- Whether or not a .pdb file is produced. -->
    <_DebugSymbolsProduced>false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugSymbols)'=='true'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='none'">false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='pdbonly'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='full'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='portable'">true</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(DebugType)'=='embedded'">false</_DebugSymbolsProduced>
    <_DebugSymbolsProduced Condition="'$(ProduceOnlyReferenceAssembly)'=='true'">false</_DebugSymbolsProduced>
    <!-- Whether or not a .xml file is produced. -->
    <_DocumentationFileProduced>true</_DocumentationFileProduced>
    <_DocumentationFileProduced Condition="'$(DocumentationFile)'==''">false</_DocumentationFileProduced>
    <!-- Whether or not a reference assembly is produced. -->
    <ProduceReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == ''">false</ProduceReferenceAssembly>
  </PropertyGroup>
  <!--
    For Legacy projects that define properties per Configuration/Platform combination, the validity of an
    invalid combination is determined by the non-empty value of the 'OutputPath' property specified under
    the IDE generated Configuration/Platform specific 'PropertyGroup' section.

    If 'BaseOutputPath' is specified, we can skip the validation, since, we assume the 'OutputPath' property
    will be derived (e.g.: from the 'BaseOutputPath' property).
  -->
  <PropertyGroup Condition="'$(BaseOutputPathWasSpecified)' != 'true' and '$(_OutputPathWasMissing)' == 'true'">
    <!--
        When 'OutputPath' is missing or empty (along with non-existent 'BaseOutputPath') at this point means,
        we're in legacy mode and we shall assume the current Configuration/Platform combination as invalid.
        Whether this is considered an error or a warning depends on the value of $(SkipInvalidConfigurations).
    -->
    <_InvalidConfigurationMessageSeverity Condition=" '$(SkipInvalidConfigurations)' == 'true' ">Warning</_InvalidConfigurationMessageSeverity>
    <_InvalidConfigurationMessageSeverity Condition=" '$(SkipInvalidConfigurations)' != 'true' ">Error</_InvalidConfigurationMessageSeverity>
  </PropertyGroup>
  <!--
    IDE Macros available from both integrated builds and from command line builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps.
  -->
  <PropertyGroup>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='exe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='winexe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='appcontainerexe'">.exe</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='library'">.dll</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='module'">.netmodule</TargetExt>
    <TargetExt Condition="'$(TargetExt)' == '' and '$(OutputType)'=='winmdobj'">.winmdobj</TargetExt>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Required for enabling Team Build for packaging app package-generating projects -->
    <OutDirWasSpecified Condition=" '$(OutDir)'!='' and '$(OutDirWasSpecified)'=='' ">true</OutDirWasSpecified>
    <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>
    <!-- Example, bin\Debug\ -->
    <!-- Ensure OutDir has a trailing slash, so it can be concatenated -->
    <OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>
    <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>
    <!-- Example, MyProject -->
    <!-- For projects that generate app packages or ones that want a per-project output directory, update OutDir to include the project name -->
    <OutDir Condition="'$(OutDir)' != '' and '$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$(OutDir)$(ProjectName)\</OutDir>
    <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
    <TargetName Condition="'$(TargetName)' == '' and '$(OutputType)' == 'winmdobj' and '$(RootNamespace)' != ''">$(RootNamespace)</TargetName>
    <TargetName Condition=" '$(TargetName)' == '' ">$(AssemblyName)</TargetName>
    <!-- Example, MyAssembly -->
    <ProjectFileName Condition=" '$(ProjectFileName)' == '' ">$(MSBuildProjectFile)</ProjectFileName>
    <!-- Example, MyProject.csproj -->
    <ProjectExt Condition=" '$(ProjectExt)' == '' ">$(MSBuildProjectExtension)</ProjectExt>
    <!-- Example, .csproj -->
    <WinMDExpOutputWindowsMetadataFilename Condition="'$(WinMDExpOutputWindowsMetadataFilename)' == '' and '$(OutputType)' == 'winmdobj'">$(TargetName).winmd</WinMDExpOutputWindowsMetadataFilename>
    <TargetFileName Condition=" '$(TargetFileName)' == '' and '$(OutputType)' == 'winmdobj'">$(WinMDExpOutputWindowsMetadataFilename)</TargetFileName>
    <TargetFileName Condition=" '$(TargetFileName)' == '' ">$(TargetName)$(TargetExt)</TargetFileName>
    <!-- Example, MyAssembly.dll -->
  </PropertyGroup>
  <PropertyGroup>
    <!--
        The PublishableProject property is used when invoking the publish target on a solution that
        contains multiple projects. The property determines which projects should be published, and
        which projects should be skipped in the publish target. By default any "Windows Application"
        or "Console Application" project type is publishable. However, a project that would otherwise
        be published can be skipped by defining the PublishableProject property in the project itself.
        -->
    <_DeploymentPublishableProjectDefault Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe' or '$(OutputType)'=='appcontainerexe'">true</_DeploymentPublishableProjectDefault>
    <PublishableProject Condition="'$(PublishableProject)'==''">$(_DeploymentPublishableProjectDefault)</PublishableProject>
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='library'">Native.$(AssemblyName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, Native.MyAssembly.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='winexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='exe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <_DeploymentTargetApplicationManifestFileName Condition="'$(OutputType)'=='appcontainerexe'">$(TargetFileName).manifest</_DeploymentTargetApplicationManifestFileName>
    <!-- Example, MyAssembly.exe.manifest -->
    <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' != 'true'">$(AssemblyName).application</TargetDeployManifestFileName>
    <!-- Example, MyAssembly.application -->
    <TargetDeployManifestFileName Condition="'$(TargetDeployManifestFileName)' == '' and '$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</TargetDeployManifestFileName>
    <!-- Example, MyAssembly.xbap -->
    <GenerateClickOnceManifests Condition="'$(OutputType)'=='winexe' or '$(OutputType)'=='exe' or '$(OutputType)'=='appcontainerexe'">$(GenerateManifests)</GenerateClickOnceManifests>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='library'">Native.$(AssemblyName)</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='winexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='exe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentApplicationManifestIdentity Condition="'$(OutputType)'=='appcontainerexe'">$(AssemblyName).exe</_DeploymentApplicationManifestIdentity>
    <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' != 'true'">$(AssemblyName).application</_DeploymentDeployManifestIdentity>
    <_DeploymentDeployManifestIdentity Condition="'$(HostInBrowser)' == 'true'">$(AssemblyName).xbap</_DeploymentDeployManifestIdentity>
    <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'=='true'">.deploy</_DeploymentFileMappingExtension>
    <_DeploymentFileMappingExtension Condition="'$(MapFileExtensions)'!='true'" />
    <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'=='true'">$(UpdateInterval)</_DeploymentBuiltUpdateInterval>
    <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'=='true'">$(UpdateIntervalUnits)</_DeploymentBuiltUpdateIntervalUnits>
    <_DeploymentBuiltUpdateInterval Condition="'$(UpdatePeriodically)'!='true'">0</_DeploymentBuiltUpdateInterval>
    <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'!='true'">Days</_DeploymentBuiltUpdateIntervalUnits>
    <_DeploymentBuiltMinimumRequiredVersion Condition="'$(UpdateRequired)'=='true' and '$(Install)'=='true'">$(MinimumRequiredVersion)</_DeploymentBuiltMinimumRequiredVersion>
    <_DeploymentLauncherBased Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</_DeploymentLauncherBased>
    <MaxTargetPath Condition="'$(MaxTargetPath)'==''">100</MaxTargetPath>
  </PropertyGroup>
  <PropertyGroup>
    <!--
        By default, GenerateApplicationManifest puts all satellite assemblies to the manifest
        record by default by setting TargetCulture to *.
        -->
    <TargetCulture Condition="'$(TargetCulture)'==''">*</TargetCulture>
    <FallbackCulture Condition="'$(UICulture)'!='' and '$(FallbackCulture)'==''">$(UICulture)</FallbackCulture>
  </PropertyGroup>
  <ItemGroup>
    <!-- Not used any more-->
    <_OutputPathItem Include="$(OutDir)" />
    <_UnmanagedRegistrationCache Include="$(BaseIntermediateOutputPath)$(MSBuildProjectFile).UnmanagedRegistration.cache" />
    <_ResolveComReferenceCache Include="$(IntermediateOutputPath)$(MSBuildProjectFile).ResolveComReference.cache" />
  </ItemGroup>
  <PropertyGroup>
    <!-- Example, C:\MyProjects\MyProject\bin\Debug\ -->
    <!--
        Condition intentionally omitted on this one, because it causes problems
        when we pick up the value of an environment variable named TargetDir
        -->
    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::Escape($([System.IO.Path]::GetFullPath(`$([System.IO.Path]::Combine(`$(MSBuildProjectDirectory)`, `$(OutDir)`))`))))</TargetDir>
    <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
    <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and '$(ProduceReferenceAssemblyInOutDir)' == 'true' ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' ">$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(IntermediateOutputPath), 'ref', $(TargetFileName)))</TargetRefPath>
    <!-- Example, C:\MyProjects\MyProject\ -->
    <ProjectDir Condition=" '$(ProjectDir)' == '' ">$([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))</ProjectDir>
    <!-- Example, C:\MyProjects\MyProject\MyProject.csproj -->
    <ProjectPath Condition=" '$(ProjectPath)' == '' ">$(ProjectDir)$(ProjectFileName)</ProjectPath>
  </PropertyGroup>
  <ItemGroup>
    <!-- This is not used here but remains for backwards compatibility -->
    <AppConfigFileDestination Include="$(OutDir)$(TargetFileName).config" />
  </ItemGroup>
  <!--
    IDE Macros available only from integrated builds.
    The following properties are 'macros' that are available via IDE for
    pre and post build steps. However, they are not defined when directly building
    a project from the command line, only when building a solution.
    -->
  <PropertyGroup>
    <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
    <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>
    <!-- Example, MySolution -->
    <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>
    <!-- Example, MySolution.sln -->
    <SolutionPath Condition="'$(SolutionPath)'==''">*Undefined*</SolutionPath>
    <!-- Example, f:\MySolutions\MySolution\MySolution.sln -->
    <SolutionDir Condition="'$(SolutionDir)'==''">*Undefined*</SolutionDir>
    <!-- Example, f:\MySolutions\MySolution\ -->
    <SolutionExt Condition="'$(SolutionExt)'==''">*Undefined*</SolutionExt>
    <!-- Example, .sln -->
  </PropertyGroup>
  <PropertyGroup>
    <GenerateBindingRedirectsOutputType Condition="'$(OutputType)'=='exe' or '$(OutputType)'=='winexe'">true</GenerateBindingRedirectsOutputType>
    <!-- It would be a breaking change to automatically turn on binding redirects for existing projects, so turn them on only when opting into a new framework. -->
    <AutoGenerateBindingRedirects Condition="'$(AutoGenerateBindingRedirects)' == '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion.TrimStart(vV))' &gt;= '4.7.2'">true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition="'$(AutoUnifyAssemblyReferences)' == ''">
    <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
    <AutoUnifyAssemblyReferences Condition="'$(GenerateBindingRedirectsOutputType)' == 'true' and '$(AutoGenerateBindingRedirects)' != 'true'">false</AutoUnifyAssemblyReferences>
  </PropertyGroup>
  <PropertyGroup>
    <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
    <!-- During DesignTime Builds, skip project reference build as Design time is only queueing information.-->
    <BuildProjectReferences Condition="'$(BuildProjectReferences)' == '' and '$(DesignTimeBuild)' == 'true'">false</BuildProjectReferences>
    <!-- By default we will build (and if applicable, clean) all project references. But this can be used to disable that-->
    <BuildProjectReferences Condition="'$(BuildProjectReferences)' == ''">true</BuildProjectReferences>
    <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
    <_ResolveReferenceDependencies Condition="'$(_ResolveReferenceDependencies)' == ''">false</_ResolveReferenceDependencies>
    <_GetChildProjectCopyToOutputDirectoryItems Condition="'$(_GetChildProjectCopyToOutputDirectoryItems)' == ''">true</_GetChildProjectCopyToOutputDirectoryItems>
    <OverwriteReadOnlyFiles Condition="'$(OverwriteReadOnlyFiles)' == ''">false</OverwriteReadOnlyFiles>
    <ComReferenceNoClassMembers Condition="'$(ComReferenceNoClassMembers)' == ''">false</ComReferenceNoClassMembers>
  </PropertyGroup>
  <PropertyGroup>
    <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
  </PropertyGroup>
  <PropertyGroup Condition="'$(MSBuildCopyMarkerName)' == ''">
    <MSBuildCopyMarkerName>$(MSBuildProjectFile)</MSBuildCopyMarkerName>
    <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 codepoints of the filename and a filename hash. -->
    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$([MSBuild]::SubstringByAsciiChars($(MSBuildProjectFile), 0, 8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
    <MSBuildCopyMarkerName>$(MSBuildCopyMarkerName).Up2Date</MSBuildCopyMarkerName>
  </PropertyGroup>
  <ItemGroup>
    <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" />
    <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')" />
    <CopyUpToDateMarker Include="$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', '$(IntermediateOutputPath)', '$(MSBuildCopyMarkerName)'))" />
  </ItemGroup>
  <ItemGroup Condition="'$(ProduceReferenceAssembly)' == 'true'">
    <IntermediateRefAssembly Include="$(IntermediateOutputPath)refint\$(TargetName)$(TargetExt)" Condition="'@(IntermediateRefAssembly)' == ''" />
    <CreateDirectory Include="@(IntermediateRefAssembly->'%(RootDir)%(Directory)')" />
    <CreateDirectory Include="$(OutDir)ref" Condition=" '$(ProduceReferenceAssemblyInOutDir)' == 'true'" />
    <CreateDirectory Include="$(IntermediateOutputPath)ref" Condition=" '$(ProduceReferenceAssemblyInOutDir)' != 'true'" />
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' == 'true'">
    <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).compile.pdb" Condition="'$(OutputType)' == 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''" />
    <_DebugSymbolsIntermediatePath Include="$(IntermediateOutputPath)$(TargetName).pdb" Condition="'$(OutputType)' != 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''" />
    <_DebugSymbolsOutputPath Include="@(_DebugSymbolsIntermediatePath->'$(OutDir)%(Filename)%(Extension)')" />
  </ItemGroup>
  <PropertyGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(OutputType)' == 'winmdobj'">
    <WinMDExpOutputPdb Condition="'$(WinMDExpOutputPdb)' == ''">$(IntermediateOutputPath)$(TargetName).pdb</WinMDExpOutputPdb>
    <_WinMDDebugSymbolsOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDExpOutputPdb)'))))</_WinMDDebugSymbolsOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(OutputType)' == 'winmdobj' and '$(DocumentationFile)'!=''">
    <WinMDOutputDocumentationFile Condition="'$(WinMDOutputDocumentationFile)' == ''">$(IntermediateOutputPath)$(TargetName).xml</WinMDOutputDocumentationFile>
    <_WinMDDocFileOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDOutputDocumentationFile)'))))</_WinMDDocFileOutputPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(WinMDExpOutputWindowsMetadataFilename)' != ''">
    <_IntermediateWindowsMetadataPath>$(IntermediateOutputPath)$(WinMDExpOutputWindowsMetadataFilename)</_IntermediateWindowsMetadataPath>
    <_WindowsMetadataOutputPath>$(OutDir)$(WinMDExpOutputWindowsMetadataFilename)</_WindowsMetadataOutputPath>
  </PropertyGroup>
  <!-- ARM64-related properties -->
  <PropertyGroup>
    <_SupportedArchitectures>amd64 arm64</_SupportedArchitectures>
  </PropertyGroup>
  <ItemGroup>
    <!-- Create an item for entry point of the ClickOnce application (Example: WindowsApplication1.exe) -->
    <_DeploymentManifestEntryPoint Include="@(IntermediateAssembly)">
      <TargetPath>$(TargetFileName)</TargetPath>
    </_DeploymentManifestEntryPoint>
    <!-- Create an item for the application icon if one exists in the project (Example: app.ico) -->
    <!-- NOTE: The item Include and the Exists function are operating relative to the PROJECT (.csproj, .vbproj etc.) directory in this case -->
    <_DeploymentManifestIconFile Include="$(ApplicationIcon)" Condition="Exists('$(ApplicationIcon)')">
      <TargetPath>$(ApplicationIcon)</TargetPath>
    </_DeploymentManifestIconFile>
    <!-- Create an item for the output application manifest (Example: WindowsApplication1.exe.manifeset) -->
    <ApplicationManifest Include="$(IntermediateOutputPath)$(_DeploymentTargetApplicationManifestFileName)">
      <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
    </ApplicationManifest>
    <!-- Create an item for the final application manifest (Example: WindowsApplication1.exe.manifeset)
             This item represents the final output application manifest used for project-to-project
             references and for copying to the publish output location. -->
    <_ApplicationManifestFinal Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)">
      <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
    </_ApplicationManifestFinal>
    <!-- Create an item for the output deploy manifest (Example: WindowsApplication1.application) -->
    <DeployManifest Include="$(IntermediateOutputPath)$(TargetDeployManifestFileName)">
      <TargetPath>$(TargetDeployManifestFileName)</TargetPath>
    </DeployManifest>
    <!-- Create an item for the intermediate trust info file -->
    <_DeploymentIntermediateTrustInfoFile Include="$(IntermediateOutputPath)$(TargetName).TrustInfo.xml" Condition="'$(TargetZone)'!=''" />
  </ItemGroup>
  <!--
    Determine the <deploymentProvider> (_DeploymentUrl) for the ClickOnce deployment manifest.
    Prefer the UpdateUrl, falling back to InstallUrl or PublishUrl if not specified.
    If the UpdateUrl is specified then _DeploymentUrl is always set to the UpdateUrl.
    Otherwise, only set the _DeploymentUrl if it's an installed app and updates are enabled.
    -->
  <PropertyGroup>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(UpdateUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(InstallUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'==''">$(PublishUrl)</_DeploymentUrl>
    <_DeploymentUrl Condition="!('$(UpdateUrl)'=='') and '$(Install)'=='false'" />
    <_DeploymentUrl Condition="'$(_DeploymentUrl)'!=''">$(_DeploymentUrl)$(TargetDeployManifestFileName)</_DeploymentUrl>
    <!--
        Need to explicitly blank out the _DeploymentUrl when it's not used. Otherwise an
        inappropriate value may be used. For example a local path from the PublishUrl
        is something we never want to see in the manifest because it means you could
        only install the app from that machine.
        -->
    <_DeploymentUrl Condition="'$(UpdateUrl)'=='' and !('$(Install)'=='true' and '$(UpdateEnabled)'=='true')" />
    <_DeploymentUrl Condition="'$(ExcludeDeploymentUrl)'=='true'" />
  </PropertyGroup>
  <!-- Determine the URLs for the bootstrapper. -->
  <PropertyGroup>
    <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true'">$(InstallUrl)</_DeploymentApplicationUrl>
    <_DeploymentApplicationUrl Condition="'$(IsWebBootstrapper)'=='true' and '$(InstallUrl)'==''">$(PublishUrl)</_DeploymentApplicationUrl>
    <_DeploymentComponentsUrl Condition="'$(BootstrapperComponentsLocation)'=='Absolute'">$(BootstrapperComponentsUrl)</_DeploymentComponentsUrl>
  </PropertyGroup>
  <!-- Output location for publish target. -->
  <PropertyGroup>
    <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
    <PublishDir Condition="'$(PublishDir)'==''">$([MSBuild]::EnsureTrailingSlash('$(OutputPath)'))app.publish\</PublishDir>
  </PropertyGroup>
  <!--
    ClickOncePublishDir property is the output location used by all ClickOnce publish targets. This should be same as PublishDir except
    for a trailing slash. PublishDir when specified as a global property on the command line cannot be changed to add a trailing slash.
  -->
  <PropertyGroup>
    <ClickOncePublishDir>$(PublishDir)</ClickOncePublishDir>
    <ClickOncePublishDir Condition="!HasTrailingSlash('$(ClickOncePublishDir)')">$(ClickOncePublishDir)\</ClickOncePublishDir>
  </PropertyGroup>
  <!--
    ProcessorArchitecture is the target processor architecture.
    -->
  <PropertyGroup Condition="'$(ProcessorArchitecture)'==''">
    <!--
        If ProcessorArchitecture is not set, set it to PlatformTarget
        Note: if $(PlatformTarget) is also blank resolve assembly reference defaults to msil which is the
        desired behavior in this case
        -->
    <ProcessorArchitecture>$(PlatformTarget)</ProcessorArchitecture>
    <!--
        If Processor architecture is not set and PlatformTarget is a known target translate the
        PlatformTarget into something ResolveAssemblyReference knows about
        -->
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'AnyCpu' ">msil</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x64' ">amd64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'Itanium' ">ia64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'x86' ">x86</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(PlatformTarget)' == 'ARM' ">arm</ProcessorArchitecture>
  </PropertyGroup>
  <PropertyGroup>
    <ConsiderPlatformAsProcessorArchitecture Condition="'$(ConsiderPlatformAsProcessorArchitecture)' == ''">true</ConsiderPlatformAsProcessorArchitecture>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ProcessorArchitecture)' == '' and '$(ConsiderPlatformAsProcessorArchitecture)' == 'true'">
    <!-- We need to do this here because if we were to just compare against platform visual would parse them out as available platforms which may not be the case -->
    <ProcessorArchitectureAsPlatform>$(Platform)</ProcessorArchitectureAsPlatform>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'AnyCpu' or '$(ProcessorArchitectureAsPlatform)' == 'Any Cpu'">msil</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'x64' or '$(ProcessorArchitectureAsPlatform)' == 'amd64'">amd64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'Itanium' ">ia64</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'x86' or '$(ProcessorArchitectureAsPlatform)' == 'win32'">x86</ProcessorArchitecture>
    <ProcessorArchitecture Condition=" '$(ProcessorArchitectureAsPlatform)' == 'ARM' ">arm</ProcessorArchitecture>
    <!--For compatibility with the 4.0 behavior, if not set above, default to the environment. To override this, set ProcessorArchitecture explicitly. We also need to disable the warning since we do not know if what the environment is set to is correct-->
    <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ProcessorArchitecture)'==''">None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
    <ProcessorArchitecture Condition="'$(ProcessorArchitecture)'==''">$(PROCESSOR_ARCHITECTURE)</ProcessorArchitecture>
  </PropertyGroup>
  <!-- Sensible defaults for the most-commonly-desired MSBuildRuntime and MSBuildArchitecture values. The Core runtime does not currently support specifying task architecture or runtime.
       If support for out-of-proc task execution is added on other runtimes, make sure each task's logic is checked against the current state of support. -->
  <PropertyGroup Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Full'">
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'">CLR2</TargetFrameworkAsMSBuildRuntime>
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkVersion)' == 'v4.0' or '$(TargetFrameworkVersion)' == 'v4.5'">CLR4</TargetFrameworkAsMSBuildRuntime>
    <TargetFrameworkAsMSBuildRuntime Condition="'$(TargetFrameworkAsMSBuildRuntime)' == ''">CurrentRuntime</TargetFrameworkAsMSBuildRuntime>
    <PlatformTargetAsMSBuildArchitectureExplicitlySet Condition="'$(PlatformTargetAsMSBuildArchitecture)' != ''">true</PlatformTargetAsMSBuildArchitectureExplicitlySet>
    <PlatformTargetAsMSBuildArchitectureExplicitlySet Condition="'$(PlatformTargetAsMSBuildArchitecture)' == ''">false</PlatformTargetAsMSBuildArchitectureExplicitlySet>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTarget)' == 'x86' or ('$(PlatformTarget)' == 'x64' and '$(MSBuildExtensionsPath64)' != '')">$(PlatformTarget)</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTarget)' == 'arm'">x86</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="('$(PlatformTarget)' == 'ia64' and '$(MSBuildExtensionsPath64)' != '')">x64</PlatformTargetAsMSBuildArchitecture>
    <PlatformTargetAsMSBuildArchitecture Condition="'$(PlatformTargetAsMSBuildArchitecture)' == ''">CurrentArchitecture</PlatformTargetAsMSBuildArchitecture>
  </PropertyGroup>
  <!-- Flavor is the project flavor. For example, Client, Smart Devices, SQL Server, etc. -->
  <PropertyGroup>
    <ProjectFlavor Condition="'$(ProjectFlavor)'==''">Client</ProjectFlavor>
  </PropertyGroup>
  <!--
    The default for compilers is to not delay-sign. If $(DelaySign) is false, let the compiler
    use its default rather than forcing a no-delay-sign flag to be passed in. This is so that
    attributes in the source code can override this decision.
    -->
  <PropertyGroup>
    <DelaySign Condition="'$(SignAssembly)' != 'true'">false</DelaySign>
    <DelaySign Condition="'$(DelaySign)'!='true'" />
  </PropertyGroup>
  <!-- These properties control web reference proxy generation. -->
  <PropertyGroup>
    <WebReference_EnableProperties Condition=" '$(WebReference_EnableProperties)' == '' ">true</WebReference_EnableProperties>
    <WebReference_EnableSQLTypes Condition=" '$(WebReference_EnableSQLTypes)' == '' ">true</WebReference_EnableSQLTypes>
    <WebReference_EnableLegacyEventingModel Condition=" '$(WebReference_EnableLegacyEventingModel)' == '' ">false</WebReference_EnableLegacyEventingModel>
  </PropertyGroup>
  <!--
    These parameters control where to look in the registry for directories to search for
    assemblies in the assembly resolution tasks.
    -->
  <PropertyGroup>
    <AssemblyFoldersSuffix Condition=" '$(AssemblyFoldersSuffix)' == '' ">AssemblyFoldersEx</AssemblyFoldersSuffix>
    <FrameworkRegistryBase Condition=" '$(FrameworkRegistryBase)' == '' ">Software\Microsoft\$(TargetFrameworkIdentifier)</FrameworkRegistryBase>
    <TargetPlatformRegistryBase Condition="'$(TargetPlatformRegistryBase)' == ''">Software\Microsoft\Microsoft SDKs\$(TargetPlatformIdentifier)</TargetPlatformRegistryBase>
    <AssemblyFoldersConfigFile Condition="'$(AssemblyFoldersConfigFile)' == ''">$([MSBuild]::GetToolsDirectory32())\AssemblyFolders.config</AssemblyFoldersConfigFile>
    <AssemblyFoldersConfigFileSearchPath Condition="Exists('$(AssemblyFoldersConfigFile)')">{AssemblyFoldersFromConfig:$(AssemblyFoldersConfigFile),$(TargetFrameworkVersion)};</AssemblyFoldersConfigFileSearchPath>
    <!--
        These are the extensions that assembly reference resolution will consider for resolution.
        Add new extensions here if you want to add new file types to consider (for example, .metadata_dll).
        Put the most likely extensions first for reference resolution speed.
        -->
    <AllowedReferenceAssemblyFileExtensions Condition=" '$(AllowedReferenceAssemblyFileExtensions)' == '' ">
      .winmd;
      .dll;
      .exe
    </AllowedReferenceAssemblyFileExtensions>
    <!--
        These are the extensions that reference resolution will consider when looking for files related
        to resolved references.  Add new extensions here if you want to add new file types to consider.
        -->
    <AllowedReferenceRelatedFileExtensions Condition=" '$(AllowedReferenceRelatedFileExtensions)' == '' ">
      .pdb;
      .xml;
      .pri;
      .dll.config;
      .exe.config
    </AllowedReferenceRelatedFileExtensions>
    <!--
        These names are used when determining which TargetFramework subset to use. If the any of the FullReferenceAssemblyNames
        are seen in the list of client subsets, RAR will assume that no client subset is being used. The list is semicolon seperated
        For example :   Full;Complete;AllThere
        -->
    <FullReferenceAssemblyNames Condition="'$(FullReferenceAssemblyNames)' == ''">Full</FullReferenceAssemblyNames>
  </PropertyGroup>
  <PropertyGroup Condition="$(AssemblySearchPaths) == ''">
    <!--
        The SearchPaths property is set to find assemblies in the following order:

            (1) Files from current project - indicated by {CandidateAssemblyFiles}
            (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
            (3) The hintpath from the referenced item itself, indicated by {HintPathFromItem}.
            (4) The directory of MSBuild's "target" runtime from GetFrameworkPath.
                The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
            (5) Assembly folders from AssemblyFolders.config file (provided by Visual Studio Dev15+).
            (6) Registered assembly folders, indicated by {Registry:*,*,*}
            (7) Legacy registered assembly folders, indicated by {AssemblyFolders}
            (8) Resolve to the GAC.
            (9) Treat the reference's Include as if it were a real file name.
            (10) Look in the application's output folder (like bin\debug)
        -->
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseCandidateAssemblyFiles)' != 'false'">{CandidateAssemblyFiles}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseReferencePath)' != 'false'">$(AssemblySearchPaths);$(ReferencePath)</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseHintPathFromItem)' != 'false'">$(AssemblySearchPaths);{HintPathFromItem}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseTargetFrameworkDirectory)' != 'false'">$(AssemblySearchPaths);{TargetFrameworkDirectory}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseAssemblyFoldersConfigFileSearchPath)' != 'false'">$(AssemblySearchPaths);$(AssemblyFoldersConfigFileSearchPath)</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRegistry)' != 'false'">$(AssemblySearchPaths);{Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseAssemblyFolders)' != 'false'">$(AssemblySearchPaths);{AssemblyFolders}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseGAC)' != 'false'">$(AssemblySearchPaths);{GAC}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRawFileName)' != 'false'">$(AssemblySearchPaths);{RawFileName}</AssemblySearchPaths>
    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseOutDir)' != 'false'">$(AssemblySearchPaths);$(OutDir)</AssemblySearchPaths>
  </PropertyGroup>
  <!-- ContinueOnError takes 3 values:  WarnAndContinue (true), ErrorAndStop (false), and ErrorAndContinue.
         Default to ErrorAndStop, since that matches the behaviour in previous versions, and what users
         typically expect -->
  <PropertyGroup>
    <ContinueOnError Condition="'$(ContinueOnError)' == ''">false</ContinueOnError>
  </PropertyGroup>
  <!-- Users familiar with how some other repos work try to use NoWarn with MSBuild in place of MSBuildWarningsAsMessages. -->
  <PropertyGroup>
    <MSBuildWarningsAsMessages Condition="'$(MSBuildWarningsAsMessages)'==''">$(NoWarn)</MSBuildWarningsAsMessages>
    <MSBuildWarningsAsErrors Condition="'$(MSBuildWarningsAsErrors)'==''">$(WarningsAsErrors)</MSBuildWarningsAsErrors>
    <MSBuildWarningsNotAsErrors Condition="'$(MSBuildWarningsNotAsErrors)'==''">$(WarningsNotAsErrors)</MSBuildWarningsNotAsErrors>
  </PropertyGroup>
  <!-- Common Project System support -->
  <PropertyGroup>
    <CommonXamlResourcesDirectory Condition=" '$(CommonXamlResourcesDirectory)' == '' ">$(MSBuildThisFileDirectory)$(LangName)\</CommonXamlResourcesDirectory>
  </PropertyGroup>
  <!-- We need to fallback to en-US in case the xaml rules are not localized (possibly happen on community languages).  -->
  <PropertyGroup Condition="!Exists('$(CommonXamlResourcesDirectory)')">
    <CommonXamlResourcesDirectory>$(MSBuildThisFileDirectory)en-US\</CommonXamlResourcesDirectory>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCommonItemSchemas)' == 'true' ">
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ProjectItemsSchema.xaml" />
    <PropertyPageSchema Include="&#xA;                        $(CommonXamlResourcesDirectory)General.xaml;&#xA;                        $(CommonXamlResourcesDirectory)Debugger_General.xaml">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)General.BrowseObject.xaml">
      <Context>BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)General_File.xaml">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)SCC.xaml">
      <Context>Invisible</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="&#xA;                        $(CommonXamlResourcesDirectory)Folder.xaml;&#xA;                        $(CommonXamlResourcesDirectory)None.xaml;&#xA;                        $(CommonXamlResourcesDirectory)Content.xaml;&#xA;                        $(CommonXamlResourcesDirectory)EmbeddedResource.xaml;&#xA;                        ">
      <Context>File;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)SpecialFolder.xaml;">
      <Context>File;ProjectSubscriptionService</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <PropertyGroup>
    <DefineCommonReferenceSchemas Condition=" '$(DefineCommonReferenceSchemas)' == '' ">$(DefineCommonItemSchemas)</DefineCommonReferenceSchemas>
  </PropertyGroup>
  <ItemGroup Condition=" '$(DefineCommonReferenceSchemas)' == 'true' ">
    <!-- Assembly references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)assemblyreference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedAssemblyReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
    <!-- COM references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)COMReference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedCOMReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
    <!-- Project references -->
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ProjectReference.xaml">
      <Context>;BrowseObject</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(CommonXamlResourcesDirectory)ResolvedProjectReference.xaml">
      <Context>ProjectSubscriptionService;BrowseObject</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <ItemGroup Condition=" '$(DefineCommonCapabilities)' == 'true' ">
    <ProjectCapability Include="&#xA;                          AssemblyReferences;&#xA;                          COMReferences;&#xA;                          ProjectReferences;&#xA;                          SharedProjectReferences;&#xA;                          OutputGroups;&#xA;                          AllTargetOutputGroups;&#xA;                          VisualStudioWellKnownOutputGroups;&#xA;                          SingleFileGenerators;&#xA;                          DeclaredSourceItems;&#xA;                          UserSourceItems;&#xA;                           " />
    <ProjectCapability Condition=" '$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' &lt; 8.0 " Include="BuildWindowsDesktopTarget" />
  </ItemGroup>
  <ItemDefinitionGroup Condition=" '$(DefineExplicitDefaults)' == 'true' ">
    <None>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </None>
    <Content>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Content>
    <Compile>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </Compile>
    <EmbeddedResource>
      <CopyToOutputDirectory>Never</CopyToOutputDirectory>
    </EmbeddedResource>
  </ItemDefinitionGroup>
  <!--
    Target that allows targets consuming source control confirmation to establish a dependency on targets producing this information.

    Any target that reads SourceRevisionId, PrivateRepositoryUrl, SourceRoot, and other source control properties and items
    should depend on this target and be conditioned on '$(SourceControlInformationFeatureSupported)' == 'true'.

    SourceRevisionId property uniquely identifies the source control revision of the repository the project belongs to.
    For Git repositories this id is a commit hash, for TFVC repositories it's the changeset number, etc.

    PrivateRepositoryUrl property stores the URL of the repository supplied by the CI server or retrieved from source control manager.
    Targets consuming this property shall not publish its value implicitly as it might inadvertently reveal an internal URL.
    Instead, they shall only do so if the project sets PublishRepositoryUrl property to true. For example, the NuGet Pack target
    may include the repository URL in the nuspec file generated for NuGet package produced by the project if PublishRepositoryUrl is true.

    SourceRoot item group lists all source roots that the project source files reside under and their mapping to source control server URLs,
    if available. This includes both source files under source control as well as source files in source packages. SourceRoot items are
    used by compilers to determine path map in deterministic build and by SourceLink provider, which maps local paths to URLs of source files
    stored on the source control server.

    Source control information provider that sets these properties and items shall execute before this target (by including
    InitializeSourceControlInformation in its BeforeTargets) and set source control properties and items that haven't been initialized yet.
  -->
  <Target Name="InitializeSourceControlInformation" />
  <PropertyGroup>
    <SourceControlInformationFeatureSupported>true</SourceControlInformationFeatureSupported>
  </PropertyGroup>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Build Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <Target Name="_AddOutputPathToGlobalPropertiesToRemove">
    <PropertyGroup>
      <_GlobalPropertiesToRemoveFromProjectReferences Condition="'$(PassOutputPathToReferencedProjects)'=='false'">$(_GlobalPropertiesToRemoveFromProjectReferences);OutputPath</_GlobalPropertiesToRemoveFromProjectReferences>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _CheckForInvalidConfigurationAndPlatform

    This target checks for errors in statically defined properties.  By setting BeforeTargets, we try
    to ensure that the target runs before any build related targets.
    If your target requires this check and is running as a BeforeTargets of one of the first targets
    of $(BuildDependsOn), $(RebuildDependsOn), or $(CleanDependsOn) you will need to set your DependsOn
    to this target.
    ============================================================
    -->
  <Target Name="_CheckForInvalidConfigurationAndPlatform" BeforeTargets="$(BuildDependsOn);Build;$(RebuildDependsOn);Rebuild;$(CleanDependsOn);Clean">
    <PropertyGroup>
      <_InvalidConfigurationMessageResourceName Condition=" '$(BuildingInsideVisualStudio)' == 'true' ">CommonSdk.InvalidConfigurationTextWhenBuildingInsideVisualStudio</_InvalidConfigurationMessageResourceName>
      <_InvalidConfigurationMessageResourceName Condition=" '$(BuildingInsideVisualStudio)' != 'true' ">CommonSdk.InvalidConfigurationTextWhenBuildingOutsideVisualStudio</_InvalidConfigurationMessageResourceName>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'$(_InvalidConfigurationMessageSeverity)' != ''" ResourceName="$(_InvalidConfigurationMessageResourceName)" Severity="$(_InvalidConfigurationMessageSeverity)" FormatArguments="$(MSBuildProjectFile);$(_OriginalConfiguration);$(_OriginalPlatform)" />
    <Message Condition="'$(DesignTimeBuild)' != 'true'" Text="Configuration=$(Configuration)" Importance="Low" />
    <Message Condition="'$(DesignTimeBuild)' != 'true'" Text="Platform=$(Platform)" Importance="Low" />
    <!-- Although we try to ensure a trailing slash, it's possible to circumvent this if the property is set on the command line -->
    <MSBuildInternalMessage Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="OutDir" />
    <MSBuildInternalMessage Condition="'$(IntermediateOutputPath)' != '' and !HasTrailingSlash('$(IntermediateOutputPath)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="IntermediateOutputPath" />
    <MSBuildInternalMessage Condition="'$(BaseIntermediateOutputPath)' != '' and !HasTrailingSlash('$(BaseIntermediateOutputPath)')" ResourceName="CommonSdk.PropertyWithTrailingSlash" Severity="Error" FormatArguments="BaseIntermediateOutputPath" />
    <!-- Also update the value of PlatformTargetAsMSBuildArchitecture per the value of Prefer32Bit.  We are doing
         this here because Prefer32Bit may be set anywhere in the targets, so we can't depend on it having the
         correct value when we're trying to figure out PlatformTargetAsMSBuildArchitecture -->
    <PropertyGroup Condition="'$(Prefer32Bit)' == 'true' and ('$(PlatformTarget)' == 'AnyCPU' or '$(PlatformTarget)' == '') and '$(PlatformTargetAsMSBuildArchitectureExplicitlySet)' != 'true'">
      <PlatformTargetAsMSBuildArchitecture>x86</PlatformTargetAsMSBuildArchitecture>
    </PropertyGroup>
    <MSBuildInternalMessage Condition=" '$(Prefer32Bit)' == 'true' and '$(PreferNativeArm64)' == 'true' " ResourceName="CommonSdk.Prefer32BitAndPreferNativeArm64Enabled" Severity="Error" />
    <MSBuildInternalMessage Condition=" '$(NoWin32Manifest)' == 'true' and '$(PreferNativeArm64)' == 'true' " ResourceName="CommonSdk.NoWin32ManifestAndPreferNativeArm64Enabled" Severity="Error" />
    <MSBuildInternalMessage Condition=" '$(PreferNativeArm64)' == 'true' and '$(Platform)' != 'AnyCPU' " ResourceName="CommonSdk.PlatformIsAnyCPUAndPreferNativeArm64Enabled" Severity="Warning" FormatArguments="$(Platform)" />
    <!--
      Log an error MSB3540 if the user set MSBuildProjectExtensionsPath in the body of a project. In an SDK style project
      if you set a value in the body, the value is not used by the top implicit import but is used by the bottom.
      This can lead to confusing behavior and builds can fail for obscure reasons.
    -->
    <MSBuildInternalMessage Condition=" '$(_InitialMSBuildProjectExtensionsPath)' != '' And '$(MSBuildProjectExtensionsPath)' != '$(_InitialMSBuildProjectExtensionsPath)' " ResourceName="CommonSdk.MSBuildProjectExtensionsPathModifiedAfterUse" Severity="Error" />
    <!--
      Log a warning MSB3539 if:
        1. $(EnableBaseIntermediateOutputPathMismatchWarning) is 'true'
        2. $(BaseIntermediateOutputPath) was set in the body of a project after its default value was set in Microsoft.Common.props
        3. $(BaseIntermediateOutputPath) is not the same as $(MSBuildProjectExtensionsPath)

      Similar to the error above, there are cases when users set $(BaseIntermediateOutputPath) in the body of their project and things build but only by coincidence.
      MSBuild does not know if $(BaseIntermediateOutputPath) changing would cause problems so tools like NuGet must set $(EnableBaseIntermediateOutputPathMismatchWarning)
      to 'true'.
    -->
    <MSBuildInternalMessage Condition=" '$(EnableBaseIntermediateOutputPathMismatchWarning)' == 'true' And '$(_InitialBaseIntermediateOutputPath)' != '$(BaseIntermediateOutputPath)' And '$(BaseIntermediateOutputPath)' != '$(MSBuildProjectExtensionsPath)' " ResourceName="CommonSdk.BaseIntermediateOutputPathMismatchWarning" Severity="Warning" />
  </Target>
  <!--
    ============================================================
                                        Build

    The main build entry point.
    ============================================================
    -->
  <PropertyGroup>
    <BuildDependsOn>
      BeforeBuild;
      CoreBuild;
      AfterBuild
    </BuildDependsOn>
  </PropertyGroup>
  <Target Name="Build" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(BuildDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" />
  <!--
    ============================================================
                                        BeforeBuild

    Redefine this target in your project in order to run tasks just before Build
    ============================================================
    -->
  <Target Name="BeforeBuild" />
  <!--
    ============================================================
                                        AfterBuild

    Redefine this target in your project in order to run tasks just after Build
    ============================================================
    -->
  <Target Name="AfterBuild" />
  <!--
    ============================================================
                                        CoreBuild

    The core build step calls each of the build targets.
    ============================================================
    -->
  <PropertyGroup>
    <CoreBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      PreBuildEvent;
      ResolveReferences;
      PrepareResources;
      ResolveKeySource;
      Compile;
      ExportWindowsMDFile;
      UnmanagedUnregistration;
      GenerateSerializationAssemblies;
      CreateSatelliteAssemblies;
      GenerateManifests;
      GetTargetPath;
      PrepareForRun;
      UnmanagedRegistration;
      IncrementalClean;
      PostBuildEvent
    </CoreBuildDependsOn>
  </PropertyGroup>
  <Target Name="CoreBuild" DependsOnTargets="$(CoreBuildDependsOn)">
    <OnError ExecuteTargets="_TimeStampAfterCompile;PostBuildEvent" Condition="'$(RunPostBuildEvent)'=='Always' or '$(RunPostBuildEvent)'=='OnOutputUpdated'" />
    <OnError ExecuteTargets="_CleanRecordFileWrites" />
  </Target>
  <!--
    ============================================================
                                        Rebuild

    Delete all intermediate and final build outputs, and then build the project from scratch.
    ============================================================
    -->
  <PropertyGroup>
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' != ''">$(MSBuildProjectDefaultTargets)</_ProjectDefaultTargets>
    <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' == ''">Build</_ProjectDefaultTargets>
    <RebuildDependsOn>
      BeforeRebuild;
      Clean;
      $(_ProjectDefaultTargets);
      AfterRebuild;
    </RebuildDependsOn>
    <RebuildDependsOn Condition=" '$(MSBuildProjectDefaultTargets)' == 'Rebuild' ">
      BeforeRebuild;
      Clean;
      Build;
      AfterRebuild;
    </RebuildDependsOn>
  </PropertyGroup>
  <Target Name="Rebuild" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(RebuildDependsOn)" Returns="$(TargetPath)" />
  <!--
    ============================================================
                                        BeforeRebuild

    Redefine this target in your project in order to run tasks just before Rebuild
    ============================================================
    -->
  <Target Name="BeforeRebuild" />
  <!--
    ============================================================
                                        AfterRebuild

    Redefine this target in your project in order to run tasks just after Rebuild
    ============================================================
    -->
  <Target Name="AfterRebuild" />
  <!--
    ============================================================
                                        BuildGenerateSources

    Redefine this target in your project in order to run tasks for BuildGenerateSources

    Set BuildPassReferences to enable P2P builds
    ============================================================
    -->
  <PropertyGroup>
    <BuildGenerateSourcesAction>Build</BuildGenerateSourcesAction>
  </PropertyGroup>
  <Target Name="BuildGenerateSources" DependsOnTargets="BuildGenerateSourcesTraverse;$(BuildGenerateSourcesAction)" />
  <Target Name="BuildGenerateSourcesTraverse" DependsOnTargets="PrepareProjectReferences">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildGenerateSources" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework);" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != '' and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
    <ProjectReferenceTargets Include="BuildGenerateSources" Targets="BuildGenerateSources" />
  </ItemGroup>
  <!--
    ============================================================
                                        BuildCompile

    Redefine this target in your project in order to run tasks for BuildCompile
    ============================================================
    -->
  <PropertyGroup>
    <BuildCompileAction>Build</BuildCompileAction>
  </PropertyGroup>
  <Target Name="BuildCompile" DependsOnTargets="BuildCompileTraverse;$(BuildCompileAction)" />
  <Target Name="BuildCompileTraverse" DependsOnTargets="PrepareProjectReferences">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildCompile" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
    <ProjectReferenceTargets Include="BuildCompile" Targets="BuildCompile" />
  </ItemGroup>
  <!--
    ============================================================
                                        BuildLink

    Redefine this target in your project in order to run tasks for BuildLink
    ============================================================
    -->
  <PropertyGroup>
    <BuildLinkAction>Build</BuildLinkAction>
  </PropertyGroup>
  <Target Name="BuildLink" DependsOnTargets="BuildLinkTraverse;$(BuildLinkAction)" />
  <Target Name="BuildLinkTraverse" DependsOnTargets="PrepareProjectReferences">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="BuildLink" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(BuildPassReferences)' == 'true'">
    <ProjectReferenceTargets Include="BuildLink" Targets="BuildLink" />
  </ItemGroup>
  <!--
    ============================================================
                                        CopyRunEnvironmentFiles

    Copy environment files necessary to run the user's app to the final directory.
    This is a public target that can be invoked by an IDE.

    This may be used by an IDE to make the app.config file available for running
    the target app.
    ============================================================
    -->
  <Target Name="CopyRunEnvironmentFiles" DependsOnTargets="PrepareForBuild;SetWin32ManifestProperties;_CopyAppConfigFile;_CleanRecordFileWrites" />
  <!--
    ============================================================
                                        Run

    Run the final build output if it is a .EXE
    ============================================================
    -->
  <PropertyGroup>
    <RunDependsOn />
  </PropertyGroup>
  <Target Name="Run" DependsOnTargets="$(RunDependsOn)">
    <MSBuildInternalMessage Condition="'$(TargetExt)'!='.exe'" ResourceName="CommonSdk.RunTargetDependsOnMessage" Severity="Error" FormatArguments="$(TargetPath)" />
    <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(OutDir)" Condition=" '$(StartWorkingDirectory)' == '' " />
    <Exec Command="$(TargetPath) $(StartArguments)" WorkingDirectory="$(StartWorkingDirectory)" Condition=" '$(StartWorkingDirectory)' != '' " />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                BuildOnlySettings Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        BuildOnlySettings

    This target is called only when doing a real build.  It is specifically not called during project load.
    ============================================================
    -->
  <PropertyGroup>
    <BuildingProject>false</BuildingProject>
  </PropertyGroup>
  <Target Name="BuildOnlySettings">
    <PropertyGroup>
      <BuildingProject>true</BuildingProject>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForBuild Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PrepareForBuild

    Prepare the prerequisites for building.
    ============================================================
    -->
  <PropertyGroup>
    <PrepareForBuildDependsOn>$(PrepareForBuildDependsOn);GetFrameworkPaths;GetReferenceAssemblyPaths;AssignLinkMetadata</PrepareForBuildDependsOn>
  </PropertyGroup>
  <Target Name="PrepareForBuild" DependsOnTargets="$(PrepareForBuildDependsOn)">
    <ItemGroup>
      <AppConfigWithTargetPath Include="$(AppConfig)" Condition="'$(AppConfig)'!=''">
        <TargetPath>$(TargetFileName).config</TargetPath>
      </AppConfigWithTargetPath>
    </ItemGroup>
    <FindAppConfigFile PrimaryList="@(None)" SecondaryList="@(Content)" TargetPath="$(TargetFileName).config" Condition="'$(AppConfig)'==''">
      <Output TaskParameter="AppConfigFile" ItemName="AppConfigWithTargetPath" />
      <Output TaskParameter="AppConfigFile" PropertyName="AppConfig" />
    </FindAppConfigFile>
    <!-- Create the directories for intermediate and final build products, and any other arbitrary directories. -->
    <!-- We are going to continue on error here so that if the tree is read only we will still get intellisense -->
    <MakeDir Directories="$(OutDir);$(IntermediateOutputPath);@(DocFileItem->'%(RelativeDir)');@(CreateDirectory)" ContinueOnError="true" />
  </Target>
  <!--
    ============================================================
                                        GetFrameworkPaths

    Get the paths for the .NET Framework installation directory

    These paths are not used directly by this .targets file but are available for pre and
    post build steps.
    ============================================================
    -->
  <PropertyGroup>
    <Framework40Dir>@(_TargetFramework40DirectoryItem)</Framework40Dir>
    <Framework35Dir>@(_TargetFramework35DirectoryItem)</Framework35Dir>
    <Framework30Dir>@(_TargetFramework30DirectoryItem)</Framework30Dir>
    <Framework20Dir>@(_TargetFramework20DirectoryItem)</Framework20Dir>
    <!-- Note we need to make the 4.0 FrameworkDir point to the 2.0 location by default since we shipped msbuild 4.0 that way and to change it would be a breaking change.-->
    <FrameworkDir Condition="'$(FrameworkDir)' == '' and ('$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.5' or '$(TargetFrameworkVersion)' == 'v4.0')">@(_TargetFramework20DirectoryItem)</FrameworkDir>
    <FrameworkDir Condition="'$(FrameworkDir)' == ''">@(_TargetFramework40DirectoryItem)</FrameworkDir>
    <TargetedFrameworkDir Condition="'$(TargetedFrameworkDir)' == ''">@(_TargetedFrameworkDirectoryItem)</TargetedFrameworkDir>
    <FrameworkSDKDir Condition="'$(FrameworkSDKDir)' == ''">@(_TargetFrameworkSDKDirectoryItem)</FrameworkSDKDir>
    <GetFrameworkPathsDependsOn />
  </PropertyGroup>
  <!-- This is a generally overriden target, for example it is overriden in the Microsoft.NETFramework.targets file -->
  <Target Name="GetFrameworkPaths" />
  <!--
    ============================================================
                                        GetReferenceAssemblyPaths

    Get the paths for the Reference Assemblies for the known versions of the
    .NET Framework.

    These paths are used by the build process in order to resolve the correct
    assemblies from the various directories, and to support multi-targeting
    ============================================================
    -->
  <Target Name="GetReferenceAssemblyPaths" DependsOnTargets="$(GetReferenceAssemblyPathsDependsOn);GetFrameworkPaths">
    <!-- if TargetFrameworkDirectory doesn't have a custom value, clear it out; that way we can get reference paths and target framework directories all in the right order -->
    <PropertyGroup>
      <TargetFrameworkDirectory Condition="'@(_CombinedTargetFrameworkDirectoriesItem)' == '$(TargetFrameworkDirectory)'" />
    </PropertyGroup>
    <!-- By default if there is no root path set then the task will assume it is Program Files\Reference Assemblies\Microsoft\Framework-->
    <GetReferenceAssemblyPaths Condition="'$(TargetFrameworkMoniker)' != '' and ('$(_TargetFrameworkDirectories)' == '' or '$(_FullFrameworkReferenceAssemblyPaths)' == '')" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RootPath="$(TargetFrameworkRootPath)" TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)" BypassFrameworkInstallChecks="$(BypassFrameworkInstallChecks)" ContinueOnError="!$(BuildingProject)">
      <Output TaskParameter="ReferenceAssemblyPaths" PropertyName="_TargetFrameworkDirectories" />
      <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths" />
      <Output TaskParameter="TargetFrameworkMonikerDisplayName" PropertyName="TargetFrameworkMonikerDisplayName" Condition="'$(TargetFrameworkMonikerDisplayName)' == ''" />
    </GetReferenceAssemblyPaths>
    <PropertyGroup>
      <TargetFrameworkDirectory>$(_TargetFrameworkDirectories);$(TargetFrameworkDirectory);$(WinFXAssemblyDirectory)</TargetFrameworkDirectory>
      <TargetFrameworkDirectory Condition="'$(TargetPlatformWinMDLocation)' != '' and Exists('$(TargetPlatformWinMDLocation)')">$(TargetFrameworkDirectory);$(TargetPlatformWinMDLocation)</TargetFrameworkDirectory>
    </PropertyGroup>
    <!-- Remove the AssemblyFolders if no target framework directories could be found. This is to prevent us from
             resolving from the assemblyfolders global location if we are not acutally targeting a framework-->
    <PropertyGroup>
      <RemoveAssemblyFoldersIfNoTargetFramework Condition="'$(RemoveAssemblyFoldersIfNoTargetFramework)' == ''">true</RemoveAssemblyFoldersIfNoTargetFramework>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == '' and '$(AssemblySearchPaths)' != '' and '$(RemoveAssemblyFoldersIfNoTargetFramework)' == 'true'">
      <AssemblySearchPaths>$(AssemblySearchPaths.Replace('{AssemblyFolders}', '').Split(';'))</AssemblySearchPaths>
    </PropertyGroup>
    <ItemGroup Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'">
      <DesignTimeFacadeDirectoryRoots Include="$(TargetFrameworkDirectory)" />
      <DesignTimeFacadeDirectories Include="%(DesignTimeFacadeDirectoryRoots.Identity)Facades\" Condition="Exists('%(DesignTimeFacadeDirectoryRoots.Identity)Facades\')" />
    </ItemGroup>
    <PropertyGroup Condition="'@(DesignTimeFacadeDirectories)' != ''">
      <TargetFrameworkDirectory>$(TargetFrameworkDirectory);@(DesignTimeFacadeDirectories)</TargetFrameworkDirectory>
    </PropertyGroup>
    <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == ''">
      <TargetFrameworkProfile />
    </PropertyGroup>
  </Target>
  <!-- Returns target framework moniker. E.g. ".NETFramework,Version=v4.0.1" -->
  <Target Name="GetTargetFrameworkMoniker" Returns="$(TargetFrameworkMoniker)" />
  <!-- Returns target framework moniker display name. E.g. ".NET Framework 4 Platform Update 1 (KB2478063)" -->
  <Target Name="GetTargetFrameworkMonikerDisplayName" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Returns="$(TargetFrameworkMonikerDisplayName)" />
  <!-- Returns semicolon separated list of target framework directories.
  E.g "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0.1\;C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\" -->
  <Target Name="GetTargetFrameworkDirectories" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths" Returns="$(TargetFrameworkDirectory)" />
  <!--
    ============================================================
                                        AssignLinkMetadata

       For items of a certain set of allowlisted types, make sure that
       if they are defined in a file other than the project file, that
       they have "Link" metadata set to an appropriate default.
    ============================================================
    -->
  <Target Name="AssignLinkMetadata" Condition=" '$(SynthesizeLinkMetadata)' == 'true' ">
    <!-- NONE ITEMS -->
    <AssignLinkMetadata Items="@(None)" Condition="'@(None)' != '' and '%(None.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <None Remove="@(_Temp)" />
      <None Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- CONTENT ITEMS -->
    <AssignLinkMetadata Items="@(Content)" Condition="'@(Content)' != '' and '%(Content.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <Content Remove="@(_Temp)" />
      <Content Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- PAGE ITEMS -->
    <AssignLinkMetadata Items="@(Page)" Condition="'@(Page)' != '' and '%(Page.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <Page Remove="@(_Temp)" />
      <Page Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- APPLICATIONDEFINITION ITEMS -->
    <AssignLinkMetadata Items="@(ApplicationDefinition)" Condition="'@(ApplicationDefinition)' != '' and '%(ApplicationDefinition.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <ApplicationDefinition Remove="@(_Temp)" />
      <ApplicationDefinition Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- EMBEDDEDRESOURCE ITEMS -->
    <AssignLinkMetadata Items="@(EmbeddedResource)" Condition="'@(EmbeddedResource)' != '' and '%(EmbeddedResource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup>
      <EmbeddedResource Remove="@(_Temp)" />
      <EmbeddedResource Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
    <!-- RESOURCE ITEMS -->
    <AssignLinkMetadata Items="@(Resource)" Condition="'@(Resource)' != '' and '%(Resource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)' and $([MSBuild]::AreFeaturesEnabled('17.10'))">
      <Output TaskParameter="OutputItems" ItemName="_Temp" />
    </AssignLinkMetadata>
    <ItemGroup Condition="$([MSBuild]::AreFeaturesEnabled('17.10'))">
      <Resource Remove="@(_Temp)" />
      <Resource Include="@(_Temp)" />
      <_Temp Remove="@(_Temp)" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PreBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PreBuildEvent

    Run the pre-build event if there is one.
    ============================================================
    -->
  <PropertyGroup>
    <PreBuildEventDependsOn />
  </PropertyGroup>
  <Target Name="PreBuildEvent" Condition="'$(PreBuildEvent)'!=''" DependsOnTargets="$(PreBuildEventDependsOn)">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PreBuildEvent)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedUnregistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        UnmanagedUnregistration

    If the main assembly had previously been registered for COM interop, unregister it now.
    We will re-register the new version after it has been built.
    ============================================================
    -->
  <PropertyGroup>
    <UnmanagedUnregistrationDependsOn />
  </PropertyGroup>
  <Target Name="UnmanagedUnregistration" Condition="(('$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)' or '$(RegisterForComInterop)' != 'true' or '$(OutputType)' != 'library') or&#xA;                    ('$(_AssemblyTimestampBeforeCompile)' == '')) and&#xA;                   Exists('@(_UnmanagedRegistrationCache)')" DependsOnTargets="$(UnmanagedUnregistrationDependsOn)">
    <PropertyGroup>
      <UnregisterAssemblyMSBuildArchitecture Condition="'$(UnregisterAssemblyMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</UnregisterAssemblyMSBuildArchitecture>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(UnregisterAssemblyMSBuildArchitecture)' != ''">
      <!-- Falling back to the current runtime if we are targeting CLR2 and the task host doesn't exist will lead to
           incorrect behavior in some cases, but it's the same incorrect behavior as Visual Studio 2010, and thus better
           than causing build breaks on upgrade to Win8 the way not doing so would.  For more details, see the
           corresponding comment in GenerateResource. -->
      <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == '' and&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(UnregisterAssemblyMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</UnregisterAssemblyMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</UnregisterAssemblyMSBuildRuntime>
    </PropertyGroup>
    <UnregisterAssembly AssemblyListFile="@(_UnmanagedRegistrationCache)" MSBuildArchitecture="$(UnregisterAssemblyMSBuildArchitecture)" MSBuildRuntime="$(UnregisterAssemblyMSBuildRuntime)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveReferences Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                     GetTargetFrameworkVersion

    This stand-alone target returns the target framework version (i.e. v3.5, v4.0, etc.)
    that would be used if we built this project.

    ============================================================
    -->
  <Target Name="GetTargetFrameworkVersion" Returns="$(TargetFrameworkVersion)" />
  <!--
    ============================================================
                                        ResolveReferences
    ============================================================
    -->
  <PropertyGroup>
    <ResolveReferencesDependsOn>
      BeforeResolveReferences;
      AssignProjectConfiguration;
      ResolveProjectReferences;
      FindInvalidProjectReferences;
      ResolveNativeReferences;
      ResolveAssemblyReferences;
      GenerateBindingRedirects;
      GenerateBindingRedirectsUpdateAppConfig;
      ResolveComReferences;
      AfterResolveReferences
    </ResolveReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ResolveReferences" Returns="@(ReferencePath)" DependsOnTargets="$(ResolveReferencesDependsOn)" />
  <!--
    ============================================================
                                        BeforeResolveReferences

    Redefine this target in your project in order to run tasks just before ResolveReferences
    ============================================================
    -->
  <Target Name="BeforeResolveReferences" />
  <!--
    ============================================================
                                        AfterResolveReferences

    Redefine this target in your project in order to run tasks just after ResolveReferences
    ============================================================
    -->
  <Target Name="AfterResolveReferences" />
  <!--
    ============================================================
                                        IgnoreJavaScriptOutputAssembly

    esproj are JavaScript or TypeScript Projects that never produce an assembly.
    Set ReferenceOutputAssembly to false in any reference to an esproj.
    ============================================================
    -->
  <Target Name="IgnoreJavaScriptOutputAssembly" BeforeTargets="AssignProjectConfiguration">
    <ItemGroup>
      <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
        <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
      </ProjectReference>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        AssignProjectConfiguration

    Assigns the appropriate configuration to each project in the list of project references passed in.
    Adds to the project references passed in any project references implied by dependencies expressed in the solution file, if any.

        [IN]
        @(ProjectReference) - the list of all project references

        [OUT]
        @(ProjectReferenceWithConfiguration) - the list of project references (MSBuild and potentially VSIP projects)
                                               with metadata values FullConfiguration, Configuration, Platform,
                                               SetConfiguration, and SetPlatform
    ============================================================
    -->
  <Target Name="AssignProjectConfiguration" Condition="'$(CurrentSolutionConfigurationContents)' != '' or '@(ProjectReference)'!=''">
    <PropertyGroup>
      <OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration Condition="'$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)' == ''">true</OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration>
      <ShouldUnsetParentConfigurationAndPlatform Condition="'$(ShouldUnsetParentConfigurationAndPlatform)' == '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildingSolutionFile)' == 'true')">true</ShouldUnsetParentConfigurationAndPlatform>
      <ShouldUnsetParentConfigurationAndPlatform Condition="'$(ShouldUnsetParentConfigurationAndPlatform)' == ''">false</ShouldUnsetParentConfigurationAndPlatform>
      <!-- Web Application projects can "secretly" reference Silverlight projects, which can take project dependencies on that same Web Application.  If the project
           dependencies are promoted to project references, this ends up creating a situation where we have a circular reference between the two projects.  We don't
           want this to happen, so just turn off synthetic project reference generation for Silverlight projects. -->
      <AddSyntheticProjectReferencesForSolutionDependencies Condition="'$(AddSyntheticProjectReferencesForSolutionDependencies)' == '' and '$(TargetFrameworkIdentifier)' == 'Silverlight'">false</AddSyntheticProjectReferencesForSolutionDependencies>
      <!-- Inside VS, we do not need to add synthetic references, as VS already organizes the build per any solution-level dependencies; we only do this on the command line-->
      <AddSyntheticProjectReferencesForSolutionDependencies Condition="'$(AddSyntheticProjectReferencesForSolutionDependencies)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">true</AddSyntheticProjectReferencesForSolutionDependencies>
    </PropertyGroup>
    <!-- Assign a project configuration to each project reference if we're building a solution file. -->
    <AssignProjectConfiguration ProjectReferences="@(ProjectReference)" CurrentProject="$(MSBuildProjectFullPath)" CurrentProjectConfiguration="$(Configuration)" CurrentProjectPlatform="$(Platform)" DefaultToVcxPlatformMapping="$(DefaultToVcxPlatformMapping)" VcxToDefaultPlatformMapping="$(VcxToDefaultPlatformMapping)" OutputType="$(OutputType)" ResolveConfigurationPlatformUsingMappings="false" SolutionConfigurationContents="$(CurrentSolutionConfigurationContents)" AddSyntheticProjectReferencesForSolutionDependencies="$(AddSyntheticProjectReferencesForSolutionDependencies)" OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration="$(OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration)" ShouldUnsetParentConfigurationAndPlatform="$(ShouldUnsetParentConfigurationAndPlatform)">
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME PROJECTREFERENCEWITHCONFIGURATION INSTEAD -->
      <Output TaskParameter="AssignedProjects" ItemName="_ProjectReferenceWithConfiguration" />
      <Output TaskParameter="UnassignedProjects" ItemName="_ProjectReferenceWithConfiguration" />
      <Output TaskParameter="AssignedProjects" ItemName="ProjectReferenceWithConfiguration" />
      <Output TaskParameter="UnassignedProjects" ItemName="ProjectReferenceWithConfiguration" />
    </AssignProjectConfiguration>
    <ItemGroup>
      <_ProjectReferenceWithConfiguration>
        <BuildReference Condition="'%(_ProjectReferenceWithConfiguration.BuildReference)' == ''">true</BuildReference>
        <ReferenceOutputAssembly Condition="'%(_ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      </_ProjectReferenceWithConfiguration>
      <ProjectReferenceWithConfiguration>
        <BuildReference Condition="'%(ProjectReferenceWithConfiguration.BuildReference)' == ''">true</BuildReference>
        <ReferenceOutputAssembly Condition="'%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
      </ProjectReferenceWithConfiguration>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _SplitProjectReferencesByFileExistence

    Split referenced projects into two lists: those that exist on
    disk and those that don't.
    ============================================================
    -->
  <Target Name="_SplitProjectReferencesByFileExistence" DependsOnTargets="AssignProjectConfiguration">
    <!--
        Use this task for matching projects with pre-resolved project outputs set by the IDE
        if building inside the IDE.  The IDE only includes non-MSBuild projects in the output list.  We'll
        use MSBuild to resolve MSBuild projects.
        This task will resolve VSIP (3rd party) project references and create a new item list with only project references
        to projects in the MSBuild format.
        -->
    <ResolveNonMSBuildProjectOutput ProjectReferences="@(ProjectReferenceWithConfiguration)" PreresolvedProjectOutputs="$(VSIDEResolvedNonMSBuildProjectOutputs)" Condition="'$(BuildingInsideVisualStudio)'=='true' and '@(ProjectReferenceWithConfiguration)'!=''">
      <Output TaskParameter="ResolvedOutputPaths" ItemName="_ResolvedProjectReferencePaths" />
      <Output TaskParameter="UnresolvedProjectReferences" ItemName="_MSBuildProjectReference" />
    </ResolveNonMSBuildProjectOutput>
    <!--
       If building from the command line, simply copy the ProjectReferenceWithConfiguration item list to _MSBuildProjectReference,
       since we have to assume all projects are in the MSBuild format. We have no way of building
       VSIP (3rd party) projects from the command line.
       -->
    <ItemGroup>
      <_MSBuildProjectReference Include="@(ProjectReferenceWithConfiguration)" Condition="'$(BuildingInsideVisualStudio)'!='true' and '@(ProjectReferenceWithConfiguration)'!=''" />
    </ItemGroup>
    <!-- Break the project list into two lists: those that exist on disk and those that don't. -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Include="@(_MSBuildProjectReference)" Condition="Exists('%(Identity)')" />
      <_MSBuildProjectReferenceNonexistent Include="@(_MSBuildProjectReference)" Condition="!Exists('%(Identity)')" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================
                                        _GetProjectReferencePlatformProperties

    If a project is opted in via $(EnableDynamicPlatformResolution), this target calls the
    GetCompatiblePlatform task on all ProjectReference items to determine the most compatible
    platform for each project. It then sets SetPlatform metadata on each ProjectReference.
    This prevents overbuilding a project when 'AnyCPU' is available.

    ======================================================================================
  -->
  <PropertyGroup>
    <UseDefaultPlatformLookupTables Condition="'$(UseDefaultPlatformLookupTables)' == ''">true</UseDefaultPlatformLookupTables>
  </PropertyGroup>
  <!-- This target skips sln-based builds because they already supply Platform and
       Configuration information. See AssignProjectConfiguration -->
  <Target Name="_GetProjectReferencePlatformProperties" Condition="'$(EnableDynamicPlatformResolution)' == 'true'&#xA;                     and '@(_MSBuildProjectReferenceExistent)' != ''">
    <!-- Allow preset SetPlatform to override this operation -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''">
        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <ItemGroup>
      <_ProjectReferencePlatformPossibilities Include="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'" />
    </ItemGroup>
    <!-- Assign default PlatformLookupTables when doing Managed <-> Unmanaged hops -->
    <ItemGroup>
      <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->
      <_ProjectReferencePlatformPossibilities Condition="'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'">
        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->
        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">x86=Win32</PlatformLookupTable>
      </_ProjectReferencePlatformPossibilities>
      <!-- If we're looking at a managed project from a cpp project, map native to managed platforms. -->
      <_ProjectReferencePlatformPossibilities Condition="('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj') and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' != 'true'">
        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">Win32=x86</PlatformLookupTable>
      </_ProjectReferencePlatformPossibilities>
    </ItemGroup>
    <GetCompatiblePlatform AnnotatedProjects="@(_ProjectReferencePlatformPossibilities)" CurrentProjectPlatform="$(Platform)" PlatformLookupTable="$(PlatformLookupTable)" Condition="'@(_ProjectReferencePlatformPossibilities)' != ''">
      <Output ItemName="_ProjectsWithPlatformAssignment" TaskParameter="AssignedProjectsWithPlatform" />
    </GetCompatiblePlatform>
    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.
         Don't do anything in this case. Ex: A project references many projects
         that can't multiplatform.  -->
    <ItemGroup Condition="'@(_ProjectsWithPlatformAssignment)' != ''">
      <ProjectsWithNearestPlatform Include="@(_ProjectsWithPlatformAssignment)" />
      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' != ''">
        <SetPlatform>Platform=%(ProjectsWithNearestPlatform.NearestPlatform)</SetPlatform>
      </ProjectsWithNearestPlatform>
      <!-- When GetCompatiblePlatform fails to assign NearestPlatform (or determines it's identical to default for the referenced project), undefine Platform and let that project build "on its own" -->
      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' == ''">
        <UndefineProperties>%(ProjectsWithNearestPlatform.UndefineProperties);Platform</UndefineProperties>
      </ProjectsWithNearestPlatform>
      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'" />
      <_MSBuildProjectReferenceExistent Include="@(ProjectsWithNearestPlatform)" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================
                                        _GetProjectReferenceTargetFrameworkProperties

    Builds the GetTargetFrameworks target of all existent project references to get a list
    of all supported TargetFrameworks of the referenced projects. Calls the
    GetReferenceNearestTargetFrameworkTask to determine the closest match for each project.
    This allows a cross-targeting project to select how it should be configured to build
    against the most appropriate target for the referring target framework.

    ======================================================================================
  -->
  <Target Name="_GetProjectReferenceTargetFrameworkProperties" DependsOnTargets="_AddOutputPathToGlobalPropertiesToRemove">
    <!--
      Select the moniker to send to each project reference  if not already set. NugetTargetMoniker (NTM) is preferred by default over
      TargetFrameworkMoniker (TFM) because it is required to disambiguate the UWP case where TFM is fixed at .NETCore,Version=v5.0 and
      has floating NTM=UAP,Version=vX.Y.Z. However, in other cases (classic PCLs), NTM contains multiple values and that will cause the MSBuild
      invocation below to fail by passing invalid properties. Therefore we do not use the NTM if it contains a semicolon.
    -->
    <PropertyGroup Condition="'$(ReferringTargetFrameworkForProjectReferences)' == ''">
      <ReferringTargetFrameworkForProjectReferences Condition="'$(NuGetTargetMoniker)' != '' and !$(NuGetTargetMoniker.Contains(';'))">$(NuGetTargetMoniker)</ReferringTargetFrameworkForProjectReferences>
      <ReferringTargetFrameworkForProjectReferences Condition="'$(NuGetTargetMoniker)' == ''">$(TargetFrameworkMoniker)</ReferringTargetFrameworkForProjectReferences>
    </PropertyGroup>
    <!--
      Honor SkipGetTargetFrameworkProperties=true metadata on project references
      to mean that the project reference is known not to target multiple frameworks
      and the mechanism here for selecting the best one can be skipped as an optimization.

      We give this treatment to .vcxproj by default since no .vcxproj can target more
      than one framework currently. The user must specify exactly one TargetFramework.

      vcxproj files compile down to OS-specific binaries, either native or .NET. In the
      _GetProjectReferenceTargetFrameworkProperties target of Microsoft.Common.CurrentVersion.targets,
      SkipTargetFrameworkProperties is set to true for vcxproj to account for that.

      This means we do not fill the Item _ProjectReferenceTargetFrameworkPossibilities or, by extension,
      the AnnotatedProjects Item.

      For single-targeted projects, we normally decorate the AnnotatedProjects Item with
      UndefineProperties metadata specifying that TargetFramework should be undefined. Because it
      isn't defined properly at that stage, however, this does not happen, and TargetFramework is
      defined at this point in addition to having been defined globally. Currently, this is always
      true for vcxproj.

      MSBuild permits building the same project twice as long as it has different sets of global properties.
      Because the TargetFramework global property is not being removed as expected by the multitargeting
      part of MSBuild, the engine recognizes that there are differences and builds it twice. This can
      become more noticeable if the projects build in parallel, since they could try to access the same
      resources and conflict, failing the build. Note, however, that building the same project twice in
      this way is always wrong even if it seems minor because they do not conflict, and the second build is
      relatively fast.
   -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and ('%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj')">
        <!--
          Platform negotiation requires the MSBuild task call to GetTargetFrameworks.
          Don't skip when opted into the feature.
        -->
        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
        <UndefineProperties>%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework</UndefineProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <!--
       Allow project references to specify which target framework properties to set and their values
       without consulting the referenced project. This has two use cases:

       1. A caller may wish to pick a compatible but sub-optimal target framework. For example,
          to unit test the .NETStandard implementation using a .NETFramework caller even though
          there is also a .NETFramework implementation.

       2. As an escape hatch for cases where the compatibility check performed by
          GetTargetFrameworkProperties is faulty.
    -->
    <ItemGroup>
      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetTargetFramework)' != ''">
        <!--
          Platform negotiation requires the MSBuild task call to GetTargetFrameworks.
          Don't skip when opted into the feature.
        -->
        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
      </_MSBuildProjectReferenceExistent>
    </ItemGroup>
    <!--
       Get reference target framework lists.
       Note: A future optimization could cache the closest match and set the target framework on
       this MSBuild task invocation. This would (optimistically) save an evaluation of the referenced
       project when the answer is the same.
    -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetFrameworks" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;$(_GlobalPropertiesToRemoveFromProjectReferences)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' != 'true'" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
    </MSBuild>
    <!--
       SetPlatform negotiation requires the 'GetTargetFrameworks' MSBuild call to NOT pass global properties. This is to verify
       whether or not the referenced project would build as the same platform as the current project by default. The above
       MSBuild call is kept for legacy scenarios that may depend on passing %(SetConfiguration) and %(SetPlatform).
    -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetFrameworks" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;SelfContained;Platform;Configuration;$(_GlobalPropertiesToRemoveFromProjectReferences)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' == 'true'" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
    </MSBuild>
    <ItemGroup>
      <!--
        Preserve the ItemSpec value on the _ProjectReferenceTargetFrameworkPossibilities. Because relative paths in another project
        context would be incorrect, the MSBuild task invocation needs expands the project reference paths in the MSBuild task above.
        This is generally OK, but if the list is copied the OriginalItemSpec can become the expanded value and cause issues correlating
        a project reference back to an Item instance.
      -->
      <_ProjectReferenceTargetFrameworkPossibilitiesOriginalItemSpec Include="@(_ProjectReferenceTargetFrameworkPossibilities->'%(OriginalItemSpec)')" />
      <_ProjectReferenceTargetFrameworkPossibilities Remove="@(_ProjectReferenceTargetFrameworkPossibilities)" />
      <_ProjectReferenceTargetFrameworkPossibilities Include="@(_ProjectReferenceTargetFrameworkPossibilitiesOriginalItemSpec)" />
    </ItemGroup>
    <!-- For each reference, get closest match -->
    <!-- Pass the CurrentProjectTargetPlatform parameter to the task only if GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter is true.  This means
         that we are using a version of NuGet which supports that parameter on this task. -->
    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)" CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)" CurrentProjectTargetPlatform="$(TargetPlatformMoniker)" CurrentProjectName="$(MSBuildProjectName)" FallbackTargetFrameworks="$(AssetTargetFallback)" Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''&#xA;                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
    </GetReferenceNearestTargetFrameworkTask>
    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)" CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)" CurrentProjectName="$(MSBuildProjectName)" FallbackTargetFrameworks="$(AssetTargetFallback)" Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''&#xA;                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
    </GetReferenceNearestTargetFrameworkTask>
    <ItemGroup>
      <!--
         If the task was skipped or the current TargetFramework is empty, AnnotatedProjects will be empty.
         In this case, copy _ProjectReferenceTargetFrameworkPossibilities as is. See:
            https://github.com/dotnet/sdk/issues/416

        Furthermore, if we're referencing a .vcxproj or .nativeproj, those items won't be populated into `AnnotatedProjects`
        by `GetReferenceNearestTargetFrameworkTask`, so let them flow when `EnableDynamicPlatformResolution` is set.
      -->
      <AnnotatedProjects Include="@(_ProjectReferenceTargetFrameworkPossibilities)" Condition="'$(ReferringTargetFrameworkForProjectReferences)' == '' or&#xA;                                    ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')" />
    </ItemGroup>
    <!-- IsRidAgnostic metadata is used to determine whether global properties such as RuntimeIdentifier and SelfContained flow to a referenced project.
         However, for multi-targeted projects there may be a different IsRidAgnostic value for each TargetFramework.  In that case, this task selects
         the IsRidAgnostic value for the NearestTargetFramework for the project. -->
    <SetRidAgnosticValueForProjects Projects="@(AnnotatedProjects)">
      <Output ItemName="UpdatedAnnotatedProjects" TaskParameter="UpdatedProjects" />
    </SetRidAgnosticValueForProjects>
    <ItemGroup>
      <AnnotatedProjects Remove="@(AnnotatedProjects)" />
      <AnnotatedProjects Include="@(UpdatedAnnotatedProjects)" />
      <UpdatedAnnotatedProjects Remove="@(UpdatedAnnotatedProjects)" />
      <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.NearestTargetFramework)' != '' and '%(AnnotatedProjects.HasSingleTargetFramework)' != 'true'">
        <SetTargetFramework>TargetFramework=%(AnnotatedProjects.NearestTargetFramework)</SetTargetFramework>
      </AnnotatedProjects>
      <!--
         If the NearestTargetFramework property was not set or the project has a single TargetFramework, we need to Undefine
         TargetFramework to avoid another project evaluation.
      -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and ('%(AnnotatedProjects.NearestTargetFramework)' == '' or '%(AnnotatedProjects.HasSingleTargetFramework)' == 'true')">
        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);TargetFramework</UndefineProperties>
      </AnnotatedProjects>
      <!-- Add RuntimeIdentifier and SelfContained to the list of global properties that should not flow to the referenced project,
           unless the project is expecting those properties to flow. -->
      <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.IsRidAgnostic)' != 'false'">
        <UndefineProperties>%(AnnotatedProjects.UndefineProperties);RuntimeIdentifier;SelfContained</UndefineProperties>
      </AnnotatedProjects>
      <!--
         Remove the items we've touched from _MSBuildProjectReferenceExistent. This will leave all projects where
         SkipGetTargetFrameworkProperties was set. Then add all AnnotatedProjects back.
      -->
      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'" />
      <_MSBuildProjectReferenceExistent Include="@(AnnotatedProjects)" />
    </ItemGroup>
  </Target>
  <Target Name="GetTargetFrameworks" DependsOnTargets="GetTargetFrameworksWithPlatformForSingleTargetFramework" Returns="@(_ThisProjectBuildMetadata)">
    <MSBuildInternalMessage Condition="'$(IsCrossTargetingBuild)' == 'true'" ResourceName="CommonSdk.CrossTargetingGetTargetFrameworks" Severity="Error" />
    <CombineXmlElements RootElementName="AdditionalProjectProperties" XmlElements="@(_TargetFrameworkInfo->'%(AdditionalPropertiesFromProject)')">
      <Output TaskParameter="Result" PropertyName="_AdditionalPropertiesFromProject" />
    </CombineXmlElements>
    <ItemGroup>
      <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
        <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
        <HasSingleTargetFramework>true</HasSingleTargetFramework>
        <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
        <!-- Extract necessary information for SetPlatform negotiation -->
        <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
        <Platform>$(Platform)</Platform>
        <Platforms>$(Platforms)</Platforms>
        <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
             Build the `Platforms` property from that. -->
        <Platforms Condition="'$(UsePlatformFromProjectConfiguration)' != 'false' and '@(ProjectConfiguration)' != '' and ('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj')">@(ProjectConfiguration-&gt;'%(Platform)'-&gt;Distinct())</Platforms>
      </_ThisProjectBuildMetadata>
    </ItemGroup>
  </Target>
  <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework" Returns="@(_TargetFrameworkInfo)">
    <ItemGroup>
      <_AdditionalTargetFrameworkInfoPropertyWithValue Include="@(AdditionalTargetFrameworkInfoProperty)">
        <Value>$(%(AdditionalTargetFrameworkInfoProperty.Identity))</Value>
      </_AdditionalTargetFrameworkInfoPropertyWithValue>
    </ItemGroup>
    <PropertyGroup>
      <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="'$(_UseAttributeForTargetFrameworkInfoPropertyNames)' == ''">false</_UseAttributeForTargetFrameworkInfoPropertyNames>
    </PropertyGroup>
    <CombineTargetFrameworkInfoProperties RootElementName="$(TargetFramework)" PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)" UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)">
      <Output TaskParameter="Result" PropertyName="_AdditionalTargetFrameworkInfoProperties" />
    </CombineTargetFrameworkInfoProperties>
    <ItemGroup>
      <_TargetFrameworkInfo Include="$(TargetFramework)">
        <TargetFrameworks>$(TargetFramework)</TargetFrameworks>
        <TargetFrameworkMonikers>$(TargetFrameworkMoniker)</TargetFrameworkMonikers>
        <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
        <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
        <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>
        <!-- Determine whether a project is "RID agnostic" for each TargetFramework.  "RID agnostic" means that global properties such as
             SelfContained and RuntimeIdentifier should not flow across project references.  The IsRidAgnostic metadata value is consumed in the
             _GetProjectReferenceTargetFrameworkProperties target, where those properties are added to a project's UndefineProperties if
             IsRidAgnostic is set.

             Generally we set the IsRidAgnostic metadata based on the IsRidAgnostic property set by the .NET SDK.  If that's not set, then the
             fallback logic here will be that the project is RID agnostic if it doesn't have RuntimeIdentifier or RuntimeIdentifiers properties set. -->
        <IsRidAgnostic>$(IsRidAgnostic)</IsRidAgnostic>
        <IsRidAgnostic Condition=" '%(IsRidAgnostic)' == '' and '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
        <IsRidAgnostic Condition=" '%(IsRidAgnostic)' == ''">false</IsRidAgnostic>
      </_TargetFrameworkInfo>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                    GetTargetFrameworkProperties

    OBSOLETE: present only for theoretical backward compatibility.
  -->
  <Target Name="GetTargetFrameworkProperties" />
  <!--
    ============================================================
                                        PrepareProjectReferences

    Prepares project references for consumption by other targets.

        [IN]
        @(ProjectReference) - The list of project references.

        [OUT]
        @(ProjectReferenceWithConfiguration)   - Project references with apporpriate metadata
        @(_MSBuildProjectReferenceExistent)    - Subset of @(ProjectReferenceWithConfiguration) that exist
                                                 with added SetTargetFramework metadata for cross-targeting
        @(_MSBuildProjectReferenceNonExistent) - Subset of  @(ProjectReferenceWithConfiguration) that do not exist
    ============================================================
  -->
  <PropertyGroup>
    <PrepareProjectReferencesDependsOn>
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence;
      _GetProjectReferenceTargetFrameworkProperties;
      _GetProjectReferencePlatformProperties
    </PrepareProjectReferencesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareProjectReferences" DependsOnTargets="$(PrepareProjectReferencesDependsOn)" />
  <!--
    ============================================================
                                        ResolveProjectReferences

    Build referenced projects:

        [IN]
        @(ProjectReferenceWithConfiguration) - The list of project references.

        [OUT]
        @(_ResolvedNativeProjectReferencePaths) - Paths to referenced native projects.
        @(_ResolvedProjectReferencePaths) - Paths to referenced managed projects.
    ============================================================
    -->
  <!-- By default, the outputs of project references are passed to the compiler -->
  <ItemDefinitionGroup>
    <ProjectReference>
      <!-- Target to build in the project reference; by default, this property is blank, indicating the default targets-->
      <Targets>$(ProjectReferenceBuildTargets)</Targets>
      <!-- Extra item type to emit outputs of the destination into. Defaults to blank. To emit only into this list, set the ReferenceOutputAssembly metadata to false as well. -->
      <OutputItemType />
      <ReferenceSourceTarget>ProjectReference</ReferenceSourceTarget>
    </ProjectReference>
  </ItemDefinitionGroup>
  <Target Name="ResolveProjectReferences" DependsOnTargets="PrepareProjectReferences" Returns="@(_ResolvedNativeProjectReferencePaths);@(_ResolvedProjectReferencePaths)">
    <!--
        When building this project from the IDE, just gather the referenced build outputs.
        The IDE will already have built the project, so there's no need to do it again here.

        The ContinueOnError setting is here so that, during project load, as
        much information as possible will be passed to the compilers.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetTargetPath" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '$(VisualStudioVersion)' != '10.0' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        Build referenced projects when building from the command line.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="%(_MSBuildProjectReferenceExistent.Targets)" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform);  %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true' or '$(DesignTimeBuild)' == 'true'" />
      <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''" />
    </MSBuild>
    <!--
        Get manifest items from the (non-exe) built project references (to feed them into ResolveNativeReference).
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetNativeManifest" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingProject)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" SkipNonexistentTargets="true" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="NativeReference" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)' == 'true'" />
    </MSBuild>
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(_ResolvedProjectReferencePaths)" Condition="'%(_ResolvedProjectReferencePaths.ResolveableAssembly)' == 'false'" />
      <!--
          Copy OriginalItemSpec to OriginalProjectReferenceItemSpec, so that when ResolveAssemblyReferences
          takes these items and resolves them to ReferencePath, we can still recover the _real_ OriginalItemSpec
          for the unresolved reference items.
          -->
      <_ResolvedProjectReferencePaths>
        <OriginalProjectReferenceItemSpec>%(_ResolvedProjectReferencePaths.OriginalItemSpec)</OriginalProjectReferenceItemSpec>
      </_ResolvedProjectReferencePaths>
    </ItemGroup>
    <!-- Issue a warning or error MSB9008 for each non-existent project. -->
    <PropertyGroup>
      <_NonExistentProjectReferenceSeverity Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != '' and '$(ErrorOnMissingProjectReference)' != 'True'">Warning</_NonExistentProjectReferenceSeverity>
      <_NonExistentProjectReferenceSeverity Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != '' and '$(ErrorOnMissingProjectReference)' == 'True'">Error</_NonExistentProjectReferenceSeverity>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'$(_NonExistentProjectReferenceSeverity)' != ''" ResourceName="CommonSdk.NonExistentProjectReference" Severity="$(_NonExistentProjectReferenceSeverity)" FormatArguments="@(_MSBuildProjectReferenceNonexistent->'%(Identity)')" />
  </Target>
  <Target Name="ResolveProjectReferencesDesignTime" Returns="@(_ProjectReferencesFromRAR);@(_ResolvedNativeProjectReferencePaths)" DependsOnTargets="ResolveProjectReferences;ResolveAssemblyReferences">
    <!-- We need to do this here because we only want project references which have passed through rar and have not been unresolved due to violating some MT rule
        which means we need to pull the project references out of the referencepath item because they will only exist there if they were correctly resolved.
    -->
    <ItemGroup>
      <_ProjectReferencesFromRAR Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))">
        <OriginalItemSpec>%(ReferencePath.ProjectReferenceOriginalItemSpec)</OriginalItemSpec>
      </_ProjectReferencesFromRAR>
    </ItemGroup>
  </Target>
  <Target Name="ExpandSDKReferencesDesignTime" Returns="@(ReferencesFromSDK)" DependsOnTargets="ExpandSDKReferences" />
  <!--
    ============================================================
                                        GetTargetPath

    This target returns an item containing the build product (i.e. EXE, DLL)
    that would be produced if we built this project, with some relevant
    metadata.
    ============================================================
    -->
  <Target Name="GetTargetPath" DependsOnTargets="$(GetTargetPathDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)" />
  <!--
    ============================================================
                                        GetTargetPathWithTargetPlatformMoniker

    This stand-alone target returns the name and version of the target platform for this project.

    NOTE: The ProjectReference protocol uses only GetTargetPath. Computing the item
    in this target allows projects to override GetTargetPath without having to reimplement
    the details of the metadata computation.
    ============================================================
    -->
  <PropertyGroup>
    <GetTargetPathWithTargetPlatformMonikerDependsOn>$(GetTargetPathDependsOn)</GetTargetPathWithTargetPlatformMonikerDependsOn>
  </PropertyGroup>
  <!--NOTE: since an overridden GetTargetPath might not include a DependsOn
      for this target, it's safer to establish the dependency here with a
      BeforeTargets. -->
  <Target Name="GetTargetPathWithTargetPlatformMoniker" BeforeTargets="GetTargetPath" DependsOnTargets="$(GetTargetPathWithTargetPlatformMonikerDependsOn)" Returns="@(TargetPathWithTargetPlatformMoniker)">
    <ItemGroup>
      <TargetPathWithTargetPlatformMoniker Include="$(TargetPath)">
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
        <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$(TargetFrameworkVersion.TrimStart('vV'))</TargetFrameworkVersion>
        <ReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == 'true'">$(TargetRefPath)</ReferenceAssembly>
        <CopyUpToDateMarker>@(CopyUpToDateMarker)</CopyUpToDateMarker>
      </TargetPathWithTargetPlatformMoniker>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetNativeManifest

    Compute the manifest item for this project.

        [IN]
        $(_DeploymentApplicationManifestIdentity) - the manifest identity
        @(ApplicationManifest)         - the original application manifest item

        [OUT]
        @(ComputedApplicationManifest) - application manifest item with full hint path, if generated
    ============================================================
    -->
  <Target Name="GetNativeManifest" Returns="@(ComputedApplicationManifest)">
    <ItemGroup>
      <ComputedApplicationManifest Include="$(_DeploymentApplicationManifestIdentity)" Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe' and Exists('%(_ApplicationManifestFinal.FullPath)')">
        <HintPath>%(_ApplicationManifestFinal.FullPath)</HintPath>
      </ComputedApplicationManifest>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ResolveNativeReferences

    Resolve native references

        [IN]
        @(NativeReference) - The manifest reference (or list of manifest references)

        [OUT]
        @(NativeReferenceFile)  - List of manifest files referenced.
        @(_DeploymentNativePrerequisite)   - List of native assembly prerequisites contained in the manifest.
        @(ComClassReference)    - List of COM components contained in the manifest.
        @(COMReferenceFromNative) List of type libraries contained in the manifest.
        @(COMFileReference)     - List of loose files contained in the manifest.
        @(_DeploymentLooseManifestFile)    - List of extra files that should be published.
    ============================================================
    -->
  <Target Name="ResolveNativeReferences" Condition="'@(NativeReference)'!=''" DependsOnTargets="ResolveProjectReferences">
    <ResolveNativeReference NativeReferences="@(NativeReference)" AdditionalSearchPaths="$(ReferencePath);$(OutDir)">
      <Output TaskParameter="ContainingReferenceFiles" ItemName="NativeReferenceFile" />
      <Output TaskParameter="ContainedPrerequisiteAssemblies" ItemName="_DeploymentNativePrerequisite" />
      <Output TaskParameter="ContainedComComponents" ItemName="ComClassReference" />
      <Output TaskParameter="ContainedTypeLibraries" ItemName="COMReferenceFromNative" />
      <Output TaskParameter="ContainedLooseTlbFiles" ItemName="COMFileReference" />
      <Output TaskParameter="ContainedLooseEtcFiles" ItemName="_DeploymentLooseManifestFile" />
    </ResolveNativeReference>
  </Target>
  <!--
    ============================================================

                                        ResolveAssemblyReferences

    Given the list of assemblies, find the closure of all assemblies that they depend on. These are
    what we need to copy to the output directory.

        [IN]
        @(Reference) - List of assembly references as fusion names.
        @(_ResolvedProjectReferencePaths) - List of project references produced by projects that this project depends on.

            The 'Private' attribute on the reference corresponds to the Copy Local flag in IDE.
            The 'Private' flag can have three possible values:
                - 'True' means the reference should be Copied Local
                - 'False' means the reference should not be Copied Local
                - [Missing] means this task will decide whether to treat this reference as CopyLocal or not.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.
        @(ReferenceDependencyPaths) - Paths to resolved dependency files.
        @(_ReferenceRelatedPaths) - Paths to .xmls and .pdbs.
        @(ReferenceSatellitePaths) - Paths to satellites.
        @(_ReferenceSerializationAssemblyPaths) - Paths to XML serialization assemblies created by sgen.
        @(_ReferenceScatterPaths) - Paths to scatter files.
        @(ReferenceCopyLocalPaths) - Paths to files that should be copied to the local directory.
    ============================================================
    -->
  <PropertyGroup>
    <ResolveAssemblyReferencesDependsOn>
      ResolveProjectReferences;
      FindInvalidProjectReferences;
      GetFrameworkPaths;
      GetReferenceAssemblyPaths;
      PrepareForBuild;
      ResolveSDKReferences;
      ExpandSDKReferences;
    </ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <Target Name="ResolveAssemblyReferences" Returns="@(ReferencePath)" DependsOnTargets="$(ResolveAssemblyReferencesDependsOn)">
    <ItemGroup>
      <_ReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
      <_ReferenceInstalledAssemblySubsets Include="$(TargetFrameworkSubset)" />
    </ItemGroup>
    <!--
        Only read and write cache file at build time, skip it for load time because its more
        expensive to write the newly created cache file.
        -->
    <PropertyGroup>
      <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <PropertyGroup>
      <AllowResolveAssemblyReferencesOutOfProcNode Condition="'$(AllowResolveAssemblyReferencesOutOfProcNode)' == ''">false</AllowResolveAssemblyReferencesOutOfProcNode>
    </PropertyGroup>
    <!-- Make an App.Config item that exists when AutoUnify is false. -->
    <ItemGroup>
      <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoGenerateBindingRedirects)'=='true' or '$(AutoUnifyAssemblyReferences)'=='false'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Default in task is true -->
      <_FindDependencies Condition="'$(BuildingProject)' != 'true' and '$(_ResolveReferenceDependencies)' != 'true'">false</_FindDependencies>
      <ResolveAssemblyReferencesSilent Condition="'$(ResolveAssemblyReferencesSilent)' == '' and '$(TraceDesignTime)' != 'true' and '$(BuildingProject)' == 'false'">true</ResolveAssemblyReferencesSilent>
      <ResolveAssemblyReferencesSilent Condition="'$(ResolveAssemblyReferencesSilent)' == ''">false</ResolveAssemblyReferencesSilent>
      <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch Condition="'$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)' == ''">Warning</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
      <ResolveAssemblyReferencesFindRelatedSatellites Condition="'$(ResolveAssemblyReferencesFindRelatedSatellites)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedSatellites>
      <ResolveAssemblyReferencesFindSerializationAssemblies Condition="'$(ResolveAssemblyReferencesFindSerializationAssemblies)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindSerializationAssemblies>
      <ResolveAssemblyReferencesFindRelatedFiles Condition="'$(ResolveAssemblyReferencesFindRelatedFiles)' == ''">$(BuildingProject)</ResolveAssemblyReferencesFindRelatedFiles>
      <ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts Condition="'$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)' == ''">false</ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts>
    </PropertyGroup>
    <ItemGroup>
      <!-- Remove any references which we have added as explicit reference so that we do not get duplicates. We need to make sure we do not have duplicates
             because this confuses the IDE  when it tries to compare the list of references passed in to the list of resolved references. If it does not match then the
             ide will show one of the references as not resolved, this will not break the build but is a display issue -->
      <Reference Remove="$(AdditionalExplicitAssemblyReferences)" />
      <Reference Include="$(AdditionalExplicitAssemblyReferences)">
        <Implicit>true</Implicit>
      </Reference>
    </ItemGroup>
    <!--Converts string property NonCultureResourceDirectories to array if present. NonCultureResourceDirectories defines exclusions for the custom cultures.  -->
    <ItemGroup Condition="'$(NonCultureResourceDirectories)' != ''">
      <NonCultureResourceDirectory Include="$(NonCultureResourceDirectories)" />
    </ItemGroup>
    <PropertyGroup Condition="'$(EnableCustomCulture)' == ''">
      <EnableCustomCulture>false</EnableCustomCulture>
    </PropertyGroup>
    <!--
      Normally, as an optimization, finding dependencies of references marked with ExternallyResolved=true metadata is skipped.
      However, skipping that step breaks binding redirect generation when there are conflicting versions within the externally
      resolved graph.
    -->
    <PropertyGroup Condition="'$(FindDependenciesOfExternallyResolvedReferences)' == ''">
      <FindDependenciesOfExternallyResolvedReferences>false</FindDependenciesOfExternallyResolvedReferences>
      <FindDependenciesOfExternallyResolvedReferences Condition="'$(AutoGenerateBindingRedirects)' == 'true'">true</FindDependenciesOfExternallyResolvedReferences>
    </PropertyGroup>
    <ResolveAssemblyReference Assemblies="@(Reference)" AssemblyFiles="@(_ResolvedProjectReferencePaths);@(_ExplicitReference)" TargetFrameworkDirectories="@(_ReferenceInstalledAssemblyDirectory)" InstalledAssemblyTables="@(InstalledAssemblyTables);@(RedistList)" IgnoreDefaultInstalledAssemblyTables="$(IgnoreDefaultInstalledAssemblyTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" CandidateAssemblyFiles="@(Content);@(None)" SearchPaths="$(AssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" AllowedRelatedFileExtensions="$(AllowedReferenceRelatedFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" AppConfigFile="@(_ResolveAssemblyReferencesApplicationConfigFileForExes)" AutoUnify="$(AutoUnifyAssemblyReferences)" SupportsBindingRedirectGeneration="$(GenerateBindingRedirectsOutputType)" IgnoreVersionForFrameworkReferences="$(IgnoreVersionForFrameworkReferences)" FindDependencies="$(_FindDependencies)" FindSatellites="$(ResolveAssemblyReferencesFindRelatedSatellites)" FindSerializationAssemblies="$(ResolveAssemblyReferencesFindSerializationAssemblies)" FindRelatedFiles="$(ResolveAssemblyReferencesFindRelatedFiles)" Silent="$(ResolveAssemblyReferencesSilent)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(ResolveAssemblyReferencesStateFile)" AssemblyInformationCachePaths="$(AssemblyInformationCachePaths)" AssemblyInformationCacheOutputPath="$(AssemblyInformationCacheOutputPath)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="$(TargetFrameworkProfile)" LatestTargetFrameworkDirectories="@(LatestTargetFrameworkDirectories)" CopyLocalDependenciesWhenParentReferenceInGac="$(CopyLocalDependenciesWhenParentReferenceInGac)" DoNotCopyLocalIfInGac="$(DoNotCopyLocalIfInGac)" ResolvedSDKReferences="@(ResolvedSDKReference)" WarnOrErrorOnTargetArchitectureMismatch="$(ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch)" IgnoreTargetFrameworkAttributeVersionMismatch="$(ResolveAssemblyReferenceIgnoreTargetFrameworkAttributeVersionMismatch)" FindDependenciesOfExternallyResolvedReferences="$(FindDependenciesOfExternallyResolvedReferences)" ContinueOnError="$(ContinueOnError)" OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)" NonCultureResourceDirectories="@(NonCultureResourceDirectory)" EnableCustomCulture="$(EnableCustomCulture)" AllowOutOfProcNode="$(AllowResolveAssemblyReferencesOutOfProcNode)" Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''">
      <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath" />
      <Output TaskParameter="ResolvedFiles" ItemName="_ResolveAssemblyReferenceResolvedFiles" />
      <Output TaskParameter="ResolvedDependencyFiles" ItemName="ReferenceDependencyPaths" />
      <Output TaskParameter="RelatedFiles" ItemName="_ReferenceRelatedPaths" />
      <Output TaskParameter="SatelliteFiles" ItemName="ReferenceSatellitePaths" />
      <Output TaskParameter="SerializationAssemblyFiles" ItemName="_ReferenceSerializationAssemblyPaths" />
      <Output TaskParameter="ScatterFiles" ItemName="_ReferenceScatterPaths" />
      <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="SuggestedRedirects" ItemName="SuggestedBindingRedirects" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="DependsOnSystemRuntime" PropertyName="DependsOnSystemRuntime" />
      <Output TaskParameter="DependsOnNETStandard" PropertyName="_DependsOnNETStandard" />
      <Output TaskParameter="UnresolvedAssemblyConflicts" ItemName="ResolveAssemblyReferenceUnresolvedAssemblyConflicts" />
    </ResolveAssemblyReference>
  </Target>
  <!--
    ============================================================

                                        FindReferenceAssembliesForReferences

    Given the list of references, create a list of assemblies to pass to the compiler that
    includes reference assemblies rather than implementation assemblies where possible.

        [IN]
        @(ReferencePath) - List of assembly references as resolved paths with ReferenceAssembly metadata

        [OUT]
        @(ReferencePathWithRefAssemblies) - Paths to resolved reference (or implementation) assemblies.
    ============================================================
    -->
  <Target Name="FindReferenceAssembliesForReferences" DependsOnTargets="ResolveReferences">
    <ItemGroup>
      <!-- Reference assemblies are not produced in all cases, but it's easier to consume them
           if this metadatum is always populated. Ensure that it points to the implementation
           assembly unless already specified. -->
      <ReferencePath Condition="'%(ReferencePath.ReferenceAssembly)' == ''">
        <ReferenceAssembly>%(FullPath)</ReferenceAssembly>
      </ReferencePath>
      <ReferencePathWithRefAssemblies Include="@(ReferencePath->'%(ReferenceAssembly)')" Condition="'$(CompileUsingReferenceAssemblies)' != 'false'">
        <OriginalPath Condition="'%(ReferencePath.Identity)' != '@(ReferencePath->'%(ReferenceAssembly)')'">%(ReferencePath.Identity)</OriginalPath>
      </ReferencePathWithRefAssemblies>
      <ReferencePathWithRefAssemblies Include="@(ReferencePath)" Condition="'$(CompileUsingReferenceAssemblies)' == 'false'" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================================

                                        GenerateBindingRedirects
    Inject the binding redirects into the app config file based on suggested redirects as output from
    ResolveAssemblyReferences.

        [IN]
        @(AppConfigWithTargetPath) - Path to the source app config file. This can be null if the project
                                     doesn't contain an app config file.
        $(TargetFileName) -          The file name of the build target.

        [OUT]
        @(OutputAppConfigFile) -     Path to the output app config file in the intermediate directory.

    ====================================================================================================
  -->
  <Target Name="GenerateBindingRedirects" Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(SuggestedBindingRedirectsCacheFile)" Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)" Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != '' and '$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="_GenerateSuggestedBindingRedirectsCache">
    <GenerateBindingRedirects AppConfigFile="@(AppConfigWithTargetPath)" TargetName="$(TargetFileName).config" OutputAppConfigFile="$(_GenerateBindingRedirectsIntermediateAppConfig)" SuggestedRedirects="@(SuggestedBindingRedirects)" />
    <ItemGroup>
      <FileWrites Include="$(_GenerateBindingRedirectsIntermediateAppConfig)" />
    </ItemGroup>
  </Target>
  <!--
    ====================================================================================================

                                        GenerateBindingRedirectsUpdateAppConfig
    Updates the project to use the generated app.config content.  This needs to run regardless of
    inputs/outputs so it is seperate from GenerateBindingRedirects.
    ====================================================================================================
  -->
  <Target Name="GenerateBindingRedirectsUpdateAppConfig" Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true'">
    <PropertyGroup>
      <_NewGenerateBindingRedirectsIntermediateAppConfig Condition="Exists('$(_GenerateBindingRedirectsIntermediateAppConfig)')">true</_NewGenerateBindingRedirectsIntermediateAppConfig>
      <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
    </PropertyGroup>
    <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
      <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
      <AppConfigWithTargetPath Include="$(AppConfig)">
        <TargetPath>$(TargetFileName).config</TargetPath>
      </AppConfigWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ===========================================================================================
                                        GetInstalledSDKs

    Gets the list of SDKs installed in the SDKDirectoryRoot and SDKRegistryRoot locations

    These paths are used by the ResolveSDKReference task and the ResolveAssemblyReference task.
    ===========================================================================================
  -->
  <PropertyGroup>
    <SDKReferenceRegistryRoot Condition="'$(SDKReferenceRegistryRoot)' == ''">Software\Microsoft\Microsoft SDKs</SDKReferenceRegistryRoot>
    <SDKReferenceDirectoryRoot Condition="'$(SDKReferenceDirectoryRoot)' == ''">$(LocalAppData)\Microsoft SDKs;$(MSBuildProgramFiles32)\Microsoft SDKs</SDKReferenceDirectoryRoot>
    <!-- Manifest driven extension SDK locations -->
    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(WindowsKitsRoot)</SDKExtensionDirectoryRoot>
    <!-- UAP projects by default should support Windows 8.1 SDKs -->
    <SupportWindows81SDKs Condition="'$(SupportWindows81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">true</SupportWindows81SDKs>
    <TargetPlatformIdentifierWindows81 Condition="'$(TargetPlatformIdentifierWindows81)' == '' and '$(SupportWindows81SDKs)' == 'true'">Windows</TargetPlatformIdentifierWindows81>
    <TargetPlatformVersionWindows81 Condition="'$(TargetPlatformVersionWindows81)' == '' and '$(SupportWindows81SDKs)' == 'true'">8.1</TargetPlatformVersionWindows81>
    <!-- Desktop and phone SDKs often have the exact same identifiers, don't enable phone by default -->
    <SupportWindowsPhone81SDKs Condition="'$(SupportWindowsPhone81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">false</SupportWindowsPhone81SDKs>
    <TargetPlatformIdentifierWindowsPhone81 Condition="'$(TargetPlatformIdentifierWindowsPhone81)' == '' and '$(SupportWindowsPhone81SDKs)' == 'true'">WindowsPhoneApp</TargetPlatformIdentifierWindowsPhone81>
    <TargetPlatformVersionWindowsPhone81 Condition="'$(TargetPlatformVersionWindowsPhone81)' == '' and '$(SupportWindowsPhone81SDKs)' == 'true'">8.1</TargetPlatformVersionWindowsPhone81>
  </PropertyGroup>
  <Target Name="GetInstalledSDKLocations" Condition="'@(SDKReference)' != ''" DependsOnTargets="$(GetInstalledSDKLocationsDependsOn)" Returns="@(InstalledSDKLocations)">
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="$(SDKExtensionDirectoryRoot)" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <!-- Also lookup 8.1 SDKs if requested -->
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersionWindows81)" TargetPlatformIdentifier="$(TargetPlatformIdentifierWindows81)" Condition="'$(SupportWindows81SDKs)' == 'true' and '$(TargetPlatformIdentifierWindows81)' != '' and '$(TargetPlatformVersionWindows81)' != ''" WarnWhenNoSDKsFound="false">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
    <GetInstalledSDKLocations SDKDirectoryRoots="$(SDKReferenceDirectoryRoot)" SDKExtensionDirectoryRoots="" SDKRegistryRoot="$(SDKReferenceRegistryRoot)" TargetPlatformVersion="$(TargetPlatformVersionWindowsPhone81)" TargetPlatformIdentifier="$(TargetPlatformIdentifierWindowsPhone81)" Condition="'$(SupportWindowsPhone81SDKs)' == 'true' and '$(TargetPlatformIdentifierWindowsPhone81)' != '' and '$(TargetPlatformVersionWindowsPhone81)' != ''" WarnWhenNoSDKsFound="false">
      <Output TaskParameter="InstalledSDKs" ItemName="InstalledSDKLocations" />
    </GetInstalledSDKLocations>
  </Target>
  <!--
    ============================================================

                                        ResolveSDKReferences

    Given a list of SDKReference items and a list of resolved winmd files which may contain metadata as to which sdk they came from
    we need to find the sdk root folders on disk and populate a ResolvedSDKReference item which has the full path to the SDK ROOT
    and the sdk identity as a piece of metadata.

        [IN]
        @(SDKReference) - List of sdk references (the identity in the sdk manifest file).
        @(ReferencePath) -List of resolved assemblies, we are interested in the ones which have IsWinMDFile set to true.

        [OUT]
        @(ResolvedSDKReference) - Full path to the root of the SDK
    ============================================================
  -->
  <PropertyGroup>
    <ResolveSDKReferencesDependsOn>
      GetInstalledSDKLocations
    </ResolveSDKReferencesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == '' and '_$(Configuration)' == '_Debug'">Debug</TargetedSDKConfiguration>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == '' and '_$(Configuration)' == '_Release'">Retail</TargetedSDKConfiguration>
    <TargetedSDKConfiguration Condition="'$(TargetedSDKConfiguration)' == ''">Retail</TargetedSDKConfiguration>
    <TargetedSDKArchitecture Condition="'$(TargetedSDKArchitecture)' == ''">$(ProcessorArchitecture)</TargetedSDKArchitecture>
    <TargetedSDKArchitecture Condition="'$(TargetedSDKArchitecture)' == ''">Neutral</TargetedSDKArchitecture>
  </PropertyGroup>
  <PropertyGroup>
    <ShouldMarkCertainSDKReferencesAsRuntimeOnly Condition="'$(ShouldMarkCertainSDKReferencesAsRuntimeOnly)' == ''">true</ShouldMarkCertainSDKReferencesAsRuntimeOnly>
  </PropertyGroup>
  <ItemGroup Condition="'$(ShouldMarkCertainSDKReferencesAsRuntimeOnly)' == 'true'">
    <!-- Dependencies that are specified as runtime-only dependencies. Therefore the associated files are not used to build Appx package.  -->
    <!-- TODO: Do we need to do anything like this for the new SDK? -->
    <RuntimeReferenceOnlySDKDependencies Condition="'$(TargetPlatformVersion)' == '8.1'" Include="Microsoft.VCLibs, Version=11.0" />
  </ItemGroup>
  <Target Name="ResolveSDKReferences" Returns="@(ResolvedSDKReference)" DependsOnTargets="$(ResolveSDKReferencesDependsOn)">
    <ResolveSDKReference SDKReferences="@(SDKReference)" RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)" References="@(Reference)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" WarnOnMissingPlatformVersion="$(SDKReferenceWarnOnMissingMaxPlatformVersion)" ProjectName="$(MSBuildProjectName)" TargetedSDKConfiguration="$(TargetedSDKConfiguration)" TargetedSDKArchitecture="$(TargetedSDKArchitecture)" InstalledSDKs="@(InstalledSDKLocations)" LogResolutionErrorsAsWarnings="$(LogSDKReferenceResolutionErrorsAsWarnings)" Prefer32Bit="$(Prefer32Bit)" ContinueOnError="$(ContinueOnError)" Condition="'@(SDKReference)'!=''">
      <Output TaskParameter="ResolvedSDKReferences" ItemName="ResolvedSDKReference" />
    </ResolveSDKReference>
  </Target>
  <Target Name="ResolveSDKReferencesDesignTime" Returns="@(ResolvedSDKReference)" DependsOnTargets="ResolveSDKReferences" />
  <!--
    ============================================================

                                        FindInvalidProjectReferences

    Find project to project references with target platform version higher than the one used by the current project and
    creates a list of invalid references to be unresolved. It issues a warning for each invalid reference.

        [IN]
        $(TargetPlatformVersion) - Project's target platform version
        @(_ProjectReferenceTargetPlatformMonikers) - List of monikers of all referenced projects gathered by the helper
                                                     target GetTargetPlatformMonikers.

        [OUT]
    @(InvalidProjectReferences) - List of invalid project references

    ============================================================
    -->
  <PropertyGroup>
    <FindInvalidProjectReferencesDependsOn>
      GetReferenceTargetPlatformMonikers
    </FindInvalidProjectReferencesDependsOn>
  </PropertyGroup>
  <Target Name="FindInvalidProjectReferences" Condition="'$(FindInvalidProjectReferences)' == 'true'" DependsOnTargets="$(FindInvalidProjectReferencesDependsOn)">
    <FindInvalidProjectReferences TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" ProjectReferences="@(_ProjectReferenceTargetPlatformMonikers)">
      <Output TaskParameter="InvalidReferences" ItemName="InvalidProjectReferences" />
    </FindInvalidProjectReferences>
    <ItemGroup>
      <_ResolvedProjectReferencePaths Remove="@(InvalidProjectReferences)" />
    </ItemGroup>
  </Target>
  <Target Name="GetReferenceTargetPlatformMonikers" DependsOnTargets="PrepareProjectReferences">
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Targets="GetTargetPathWithTargetPlatformMoniker" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetPlatformMonikers" />
    </MSBuild>
  </Target>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true' and '$(FindInvalidProjectReferences)' == 'true'">
    <ProjectReferenceTargets Include="Build" Targets="GetTargetPathWithTargetPlatformMoniker" />
  </ItemGroup>
  <!--
    ============================================================

                       ExpandSDKReferences

        After we have resolved the sdk refrence we need to make sure that we automatically include the references which are part of the SDK (both winmd and dll)
        as part of the assemblies passed to the compiler.

        Project systems or project which do not want to reference all dlls or winmd files should override this target to do nothing.
   ============================================================
    -->
  <PropertyGroup>
    <ExpandSDKReferencesDependsOn>
      ResolveSDKReferences
    </ExpandSDKReferencesDependsOn>
    <ExpandSDKAllowedReferenceExtensions Condition="'$(ExpandSDKAllowedReferenceExtensions)' == ''">
      .winmd;
      .dll
    </ExpandSDKAllowedReferenceExtensions>
  </PropertyGroup>
  <Target Name="ExpandSDKReferences" Returns="@(ReferencesFromSDK)" DependsOnTargets="$(ExpandSDKReferencesDependsOn)">
    <GetSDKReferenceFiles ResolvedSDKReferences="@(ResolvedSDKReference)" ReferenceExtensions="$(ExpandSDKAllowedReferenceExtensions)" TargetSDKIdentifier="$(SDKIdentifier)" TargetSDKVersion="$(SDKVersion)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" LogRedistFilesList="$(GetSDKReferenceFilesLogRedistFilesList)" LogRedistConflictWithinSDKAsWarning="$(GetSDKReferenceFilesLogRedistConflictsWithinSDKAsWarning)" LogRedistConflictBetweenSDKsAsWarning="$(GetSDKReferenceFilesLogRedistConflictsBetweenSDKsAsWarning)" LogReferencesList="$(GetSDKReferenceFilesLogReferencesList)" LogReferenceConflictWithinSDKAsWarning="$(GetSDKReferenceFilesLogReferenceConflictsWithinSDKAsWarning)" LogReferenceConflictBetweenSDKsAsWarning="$(GetSDKReferenceFilesLogReferenceConflictsBetweenSDKsAsWarning)" CacheFileFolderPath="$(GetSDKReferenceFilesCacheFolder)" LogCacheFileExceptions="$(GetSDKReferenceFilesLogCacheFileExceptions)" Condition="'@(ResolvedSDKReference)'!=''">
      <Output TaskParameter="References" ItemName="ReferencePath" />
      <Output TaskParameter="References" ItemName="ReferencesFromSDK" />
      <Output TaskParameter="References" ItemName="_ResolveAssemblyReferenceResolvedFiles" />
      <Output TaskParameter="CopyLocalFiles" ItemName="ReferenceCopyLocalPaths" />
      <Output TaskParameter="RedistFiles" ItemName="ResolvedRedistFiles" />
    </GetSDKReferenceFiles>
  </Target>
  <!--
    ============================================================

                                        ExportWindowsMDFile

    When a project is generating a a winmd file through c# or vb, ect the compiler will create a WinMDModule file. This file needs to be run
    through the winmdexp tool in order to generate the resulting WinMD file.

    ===========================================================
    -->
  <Target Name="ExportWindowsMDFile" DependsOnTargets="Compile" Condition="'$(ExportWinMDFile)' == 'true'" Inputs="@(IntermediateAssembly);@(DocFileItem);@(_DebugSymbolsIntermediatePath);@(ReferencePathWithRefAssemblies);$(MSBuildAllProjects)" Outputs="$(_IntermediateWindowsMetadataPath);$(WinMDExpOutputPdb);$(WinMDOutputDocumentationFile)">
    <PropertyGroup>
      <!-- Will be copied by the "copy WinMD artifacts" step instead -->
      <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory>false</CopyOutputSymbolsToOutputDirectory>
      <CopyDocumentationFileToOutputDirectory>false</CopyDocumentationFileToOutputDirectory>
      <WinMdExpToolPath Condition="'$(WinMdExpToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</WinMdExpToolPath>
      <WinMdExpUTF8Ouput Condition="'$(WinMdExpUTF8Ouput)' == ''">true</WinMdExpUTF8Ouput>
    </PropertyGroup>
    <WinMDExp WinMDModule="@(IntermediateAssembly)" References="@(ReferencePathWithRefAssemblies)" DisabledWarnings="$(WinMdExpNoWarn)" InputDocumentationFile="@(DocFileItem)" OutputDocumentationFile="$(WinMDOutputDocumentationFile)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" InputPDBFile="@(_DebugSymbolsIntermediatePath)" OutputPDBFile="$(WinMDExpOutputPdb)" OutputWindowsMetadataFile="$(_IntermediateWindowsMetadataPath)" EnvironmentVariables="$(WinMDExpEnvironment)" UTF8Output="$(WinMdExpUTF8Ouput)" SdkToolsPath="$(WinMdExpToolPath)" AssemblyUnificationPolicy="$(WinMDExpAssemblyUnificationPolicy)">
      <Output TaskParameter="OutputWindowsMetadataFile" ItemName="FileWrites" />
    </WinMDExp>
    <ItemGroup>
      <WinMDExpArtifacts Include="$(_IntermediateWindowsMetadataPath)" />
      <WinMDExpArtifacts Include="$(WinMDOutputDocumentationFile)" />
      <WinMDExpArtifacts Include="$(WinMDExpOutputPdb)" />
      <FileWrites Include="$(WinMDOutputDocumentationFile);$(WinMDExpOutputPdb)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveAssemblyReferencesDesignTime" Returns="@(_ReferencesFromRAR)" DependsOnTargets="ResolveProjectReferences;ResolveAssemblyReferences">
    <!-- We need to do this here because we only want references which have been passed into rar but are not project to project references. -->
    <ItemGroup>
      <_ReferencesFromRAR Include="@(ReferencePath-&gt;WithMetadataValue('ReferenceSourceTarget', 'ResolveAssemblyReference'))" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ProjectDesignTimeAssemblyResolutionSearchPaths Condition=" '$(ProjectDesignTimeAssemblyResolutionSearchPaths)' == '' ">
      {CandidateAssemblyFiles};
      $(ReferencePath);
      {HintPathFromItem};
      {TargetFrameworkDirectory};
      {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
      {RawFileName};
      $(TargetDir)
    </ProjectDesignTimeAssemblyResolutionSearchPaths>
  </PropertyGroup>
  <!--
    ==============================================================

                                       DesignTimeResolveAssemblyReferences

    Given the list of assemblies, resolve their reference paths.
    This target is called by Visual Studio at run time in order to filter references
    according to the targeted framework.

        [IN]
        @(DesignTimeReference) - List of assembly references as simple/fusion names.

        [OUT]
        @(ReferencePath) - Paths to resolved primary files.

    ==============================================================
    -->
  <PropertyGroup>
    <DesignTimeResolveAssemblyReferencesDependsOn>
      GetFrameworkPaths;
      GetReferenceAssemblyPaths;
      ResolveReferences
    </DesignTimeResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <Target Name="DesignTimeResolveAssemblyReferences" Condition="'$(DesignTimeReference)'!=''" DependsOnTargets="$(DesignTimeResolveAssemblyReferencesDependsOn)">
    <ItemGroup>
      <_DesignTimeReferenceInstalledAssemblyDirectory Include="$(TargetFrameworkDirectory)" />
    </ItemGroup>
    <PropertyGroup>
      <DesignTimeResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true'">$(IntermediateOutputPath)$(MSBuildProjectFile)DesignTimeResolveAssemblyReferences.cache</DesignTimeResolveAssemblyReferencesStateFile>
    </PropertyGroup>
    <PropertyGroup>
      <DesignTimeAssemblySearchPaths Condition=" '$(DesignTimeAssemblySearchPaths)' == '' ">
        {CandidateAssemblyFiles};
        $(ReferencePath);
        {HintPathFromItem};
        {TargetFrameworkDirectory};
        {Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)};
        {RawFileName};
        $(OutDir)
      </DesignTimeAssemblySearchPaths>
    </PropertyGroup>
    <PropertyGroup>
      <DesignTimeFindDependencies Condition=" '$(DesignTimeFindDependencies)' == '' ">false</DesignTimeFindDependencies>
      <DesignTimeIgnoreVersionForFrameworkReferences Condition=" '$(DesignTimeIgnoreVersionForFrameworkReferences)' == '' ">false</DesignTimeIgnoreVersionForFrameworkReferences>
      <DesignTimeFindSatellites Condition=" '$(DesignTimeFindSatellites)' == '' ">false</DesignTimeFindSatellites>
      <DesignTimeFindSerializationAssemblies Condition=" '$(DesignTimeFindSerializationAssemblies)' == '' ">false</DesignTimeFindSerializationAssemblies>
      <DesignTimeFindRelatedFiles Condition=" '$(DesignTimeFindRelatedFiles)' == '' ">false</DesignTimeFindRelatedFiles>
      <DesignTimeSilentResolution Condition=" '$(DesignTimeSilentResolution)' == '' and '$(TraceDesignTime)' != 'true'">true</DesignTimeSilentResolution>
      <DesignTimeAutoUnify Condition="'$(DesignTimeAutoUnify)' == ''">false</DesignTimeAutoUnify>
    </PropertyGroup>
    <ItemGroup>
      <_DesignTimeReferenceAssemblies Include="$(DesignTimeReference)" />
    </ItemGroup>
    <ItemGroup>
      <_RARResolvedReferencePath Include="@(ReferencePath)" />
      <ReferencePath Remove="@(ReferencePath)" />
    </ItemGroup>
    <ResolveAssemblyReference Assemblies="@(_DesignTimeReferenceAssemblies)" TargetFrameworkDirectories="@(_DesignTimeReferenceInstalledAssemblyDirectory)" SearchPaths="$(DesignTimeAssemblySearchPaths)" AllowedAssemblyExtensions="$(AllowedReferenceAssemblyFileExtensions)" TargetProcessorArchitecture="$(ProcessorArchitecture)" CandidateAssemblyFiles="@(Content);@(None);@(_RARResolvedReferencePath)" FindDependencies="$(DesignTimeFindDependencies)" AutoUnify="$(DesignTimeAutoUnify)" IgnoreVersionForFrameworkReferences="$(DesignTimeIgnoreVersionForFrameworkReferences)" FindSatellites="$(DesignTimeFindSatellites)" FindSerializationAssemblies="$(DesignTimeFindSerializationAssemblies)" FindRelatedFiles="$(DesignTimeFindRelatedFiles)" Silent="$(DesignTimeSilentResolution)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)" TargetedRuntimeVersion="$(TargetedRuntimeVersion)" StateFile="$(DesignTimeResolveAssemblyReferencesStateFile)" InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)" IgnoreDefaultInstalledAssemblySubsetTables="$(IgnoreInstalledAssemblySubsetTables)" TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)" FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)" FullFrameworkFolders="$(_FullFrameworkReferenceAssemblyPaths)" FullFrameworkAssemblyTables="@(FullFrameworkAssemblyTables)" ProfileName="$(TargetFrameworkProfile)" ResolvedSDKReferences="@(ResolvedSDKReference)" IgnoreTargetFrameworkAttributeVersionMismatch="$(DesignTimeIgnoreTargetFrameworkAttributeVersionMismatch)">
      <Output TaskParameter="ResolvedFiles" ItemName="DesignTimeReferencePath" />
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
    </ResolveAssemblyReference>
  </Target>
  <!--
    ============================================================
                                        ResolveComReferences

    Resolve COM references

        [IN]
        @(COMReference) - The list of COM references
        $(InteropOutputPath) - The output directory in which to generate wrapper assemblies
                               When $(InteropOutputPath) is not set, then it defaults to $(IntermediateOutputPath).

        [OUT]
        @(ReferencePath) - Paths to referenced wrappers.

        If ResolveComReferences is invoked from the IDE, PrepareForBuild may need to run to create directories.
    ============================================================
    -->
  <PropertyGroup>
    <ComReferenceExecuteAsTool Condition="'$(ComReferenceExecuteAsTool)'==''">false</ComReferenceExecuteAsTool>
  </PropertyGroup>
  <Target Name="ResolveComReferences" Condition="'@(COMReference)'!='' or '@(COMFileReference)'!=''" Returns="@(ReferencePath)" DependsOnTargets="PrepareForBuild;ResolveKeySource;ResolveAssemblyReferences">
    <PropertyGroup Condition=" '$(InteropOutputPath)' == '' ">
      <InteropOutputPath>$(IntermediateOutputPath)</InteropOutputPath>
    </PropertyGroup>
    <MakeDir Directories="$(InteropOutputPath)" />
    <!--
        Note: This task should not be batched, since it relies on having all the COM references fed into it at once.
        -->
    <PropertyGroup>
      <ResolveComReferenceMSBuildArchitecture Condition="'$(ResolveComReferenceMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</ResolveComReferenceMSBuildArchitecture>
      <ResolveComReferenceToolPath Condition="'$(ResolveComReferenceToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResolveComReferenceToolPath>
      <ResolveComReferenceSilent Condition="'$(ResolveComReferenceSilent)' == ''">false</ResolveComReferenceSilent>
    </PropertyGroup>
    <ResolveComReference TypeLibNames="@(COMReference)" TypeLibFiles="@(COMFileReference)" ResolvedAssemblyReferences="@(ReferencePath)" WrapperOutputDirectory="$(InteropOutputPath)" IncludeVersionInInteropName="$(IncludeVersionInInteropName)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" DelaySign="$(DelaySign)" StateFile="@(_ResolveComReferenceCache)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetProcessorArchitecture="$(ProcessorArchitecture)" NoClassMembers="$(ComReferenceNoClassMembers)" Silent="$(ResolveComReferenceSilent)" EnvironmentVariables="$(ResolveComReferenceEnvironment)" SdkToolsPath="$(ResolveComReferenceToolPath)" ExecuteAsTool="$(ComReferenceExecuteAsTool)" MSBuildArchitecture="$(ResolveComReferenceMSBuildArchitecture)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="ResolvedFiles" ItemName="ReferencePath" />
      <Output TaskParameter="ResolvedFiles" ItemName="ComReferenceWrappers" />
      <Output TaskParameter="ResolvedFiles" ItemName="FileWrites" />
      <!-- This output list only includes items with Isolated attribute set to True.  It's done by the task itself. -->
      <Output TaskParameter="ResolvedModules" ItemName="ResolvedIsolatedComModules" />
    </ResolveComReference>
    <ItemGroup>
      <FileWrites Include="@(_ResolveComReferenceCache)" />
      <ReferenceComWrappersToCopyLocal Include="@(ComReferenceWrappers)" Condition="'%(ComReferenceWrappers.CopyLocal)'!='false'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _GetAssembliesMetadata

    Resolve Assembly attributes for assemblies
    The ResolveComReferences dependency is needed for defining COM-referenced wrappers only,
    but this target handles all the assembly references from ResolveAssemblyReferences
    This target is needed by the Visual Studio legacy project system during design time build only

        [IN]
        @(ReferencePath) - Paths to COM-referenced wrappers and other types of assembly references.

        [OUT]
        @(AssembliesMetadata) - Resolved assemblies attributes.
    ============================================================
    -->
  <Target Name="_GetAssembliesMetadata" Condition="'@(ReferencePath)'!=''and '$(DesignTimeBuild)' == 'true' " Returns="@(_AssembliesMetadata)" DependsOnTargets="ResolveComReferences">
    <GetAssembliesMetadata AssemblyPaths="@(ReferencePath)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="AssembliesMetadata" ItemName="_AssembliesMetadata" />
    </GetAssembliesMetadata>
  </Target>
  <Target Name="ResolveComReferencesDesignTime" Returns="@(ComReferenceWrappers)" DependsOnTargets="ResolveComReferences" />
  <!--
    ============================================================
                                      ResolveFrameworkReferences

    Overrridden by Microsoft.NET.Sdk to return
    ResolvedFrameworkReference items in order to populate the
    Frameworks node of the Solution Explorer in the IDE.
  -->
  <Target Name="ResolveFrameworkReferences" />
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareResources Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PrepareResources

    Prepare resources for the Compile step.
    ============================================================
    -->
  <PropertyGroup>
    <PrepareResourcesDependsOn>
      $(PrepareResourcesDependsOn);
      PrepareResourceNames;
      ResGen;
      CompileLicxFiles
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareResources" DependsOnTargets="$(PrepareResourcesDependsOn)" />
  <!--
    ============================================================
                                        PrepareResourceNames

    Prepare the names of resource files.
    ============================================================
    -->
  <PropertyGroup>
    <PrepareResourceNamesDependsOn>
      AssignTargetPaths;
      SplitResourcesByCulture;
      CreateManifestResourceNames;
      CreateCustomManifestResourceNames
    </PrepareResourceNamesDependsOn>
  </PropertyGroup>
  <Target Name="PrepareResourceNames" DependsOnTargets="$(PrepareResourceNamesDependsOn)" />
  <!--
    ============================================================
                                        AssignTargetPaths

    This target creates <TargetPath> tags for items. <TargetPath> is a relative folder plus filename
    for the destination of this item.
    ============================================================
    -->
  <PropertyGroup>
    <AssignTargetPathsDependsOn />
  </PropertyGroup>
  <Target Name="AssignTargetPaths" DependsOnTargets="$(AssignTargetPathsDependsOn)">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <!-- AssignTargetPath generates TargetPath metadata that is consumed by CreateManifestResourceNames target for manifest name generation -->
    <AssignTargetPath Files="@(EmbeddedResource)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_Temporary" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- Replace items in EmbeddedResource with the items emitted by the AssignTargetPath task that have the TargetPath metadata -->
      <EmbeddedResource Remove="@(_Temporary)" />
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <AssignTargetPath Files="@(Content)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="ContentWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_NoneWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(BaseApplicationManifest)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
    </AssignTargetPath>
    <AssignTargetPath Files="@(None)" RootFolder="$(MSBuildProjectDirectory)" Condition="'@(_DeploymentBaseManifestWithTargetPath)'=='' and '%(None.Extension)'=='.manifest'">
      <Output TaskParameter="AssignedFiles" ItemName="_DeploymentBaseManifestWithTargetPath" />
    </AssignTargetPath>
  </Target>
  <!--
    ============================================================
                                        GetItemTargetPaths

    This target returns all items that have TargetPath metadata assigned by the AssignTargetPaths target.
    ============================================================
    -->
  <Target Name="GetItemTargetPaths" DependsOnTargets="AssignTargetPaths" Returns="&#xA;      @(EmbeddedResource);&#xA;      @(ContentWithTargetPath);&#xA;      @(_NoneWithTargetPath);&#xA;      @(_DeploymentBaseManifestWithTargetPath);&#xA;      " />
  <!--
    ============================================================
                                        SplitResourcesByCulture

    Split EmbeddedResource items into five lists based on whether
    they are resx files, licx files or other resources and whether they should be localized. Also adds Type and Culture
    metadata. Type indicates whether the resource is "Resx" or "Non-Resx".

        [IN]/[OUT]
        @(EmbeddedResource) - The raw list of resources.

        [OUT]
        @(_LicxFile) - The EmbeddedResource items with extension equal to '.licx'.
    ============================================================
    -->
  <Target Name="SplitResourcesByCulture" DependsOnTargets="AssignTargetPaths">
    <PropertyGroup>
      <RespectAlreadyAssignedItemCulture Condition="'$(RespectAlreadyAssignedItemCulture)' == ''">false</RespectAlreadyAssignedItemCulture>
      <WarnOnCultureOverwritten Condition="'$(WarnOnCultureOverwritten)' == ''">false</WarnOnCultureOverwritten>
    </PropertyGroup>
    <MSBuildInternalMessage Condition="'@(ResxWithNoCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9000;ResxWithNoCulture" />
    <MSBuildInternalMessage Condition="'@(ResxWithCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9001;ResxWithCulture" />
    <MSBuildInternalMessage Condition="'@(NonResxWithCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9002;NonResxWithCulture" />
    <MSBuildInternalMessage Condition="'@(NonResxWithNoCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9003;NonResxWithNoCulture" />
    <ItemGroup>
      <_LicxFile Include="@(EmbeddedResource)" Condition="'%(Extension)'=='.licx'" />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <EmbeddedResource Include="@(ResxWithNoCulture);@(ResxWithCulture)">
        <Type>Resx</Type>
      </EmbeddedResource>
      <EmbeddedResource Include="@(NonResxWithCulture);@(NonResxWithNoCulture)">
        <Type>Non-Resx</Type>
      </EmbeddedResource>
    </ItemGroup>
    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'" RespectAlreadyAssignedItemCulture="$(RespectAlreadyAssignedItemCulture)" WarnOnCultureOverwritten="$(WarnOnCultureOverwritten)">
      <!-- Create the list of culture resx and embedded resource files -->
      <Output TaskParameter="AssignedFilesWithCulture" ItemName="_MixedResourceWithCulture" />
      <!-- Create the list of non-culture resx and embedded resource files -->
      <Output TaskParameter="AssignedFilesWithNoCulture" ItemName="_MixedResourceWithNoCulture" />
    </AssignCulture>
    <ItemGroup>
      <!-- Remove EmbeddedResource items that we have processed already
                 i.e. either Licx, or resources that don't have culture info -->
      <EmbeddedResource Remove="@(_MixedResourceWithCulture)" />
      <EmbeddedResource Remove="@(_MixedResourceWithNoCulture)" />
      <EmbeddedResource Remove="@(_LicxFile)" />
      <!-- Add back everything except Licx, so that we have culture info -->
      <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'=='.resx' or '%(Extension)'=='.restext'">
        <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Resx</Type>
      </EmbeddedResource>
      <EmbeddedResource Include="@(_MixedResourceWithNoCulture);@(_MixedResourceWithCulture)" Condition="'%(Extension)'!='.resx' and '%(Extension)'!='.restext'">
        <Type Condition="'%(_MixedResourceWithNoCulture.Type)'=='' and '%(_MixedResourceWithCulture.Type)'==''">Non-Resx</Type>
      </EmbeddedResource>
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ResxWithNoCulture Remove="@(ResxWithNoCulture)" />
      <NonResxWithNoCulture Remove="@(NonResxWithNoCulture)" />
      <ResxWithCulture Remove="@(ResxWithCulture)" />
      <NonResxWithCulture Remove="@(NonResxWithCulture)" />
      <ResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')" />
      <NonResxWithNoCulture Include="@(_MixedResourceWithNoCulture)" Condition="'%(WithCulture)'=='false' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')" />
      <ResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'=='.resx' or '%(Extension)'=='.restext')" />
      <NonResxWithCulture Include="@(_MixedResourceWithCulture)" Condition="'%(WithCulture)'=='true' and ('%(Extension)'!='.resx' and '%(Extension)'!='.restext')" />
      <!-- Clean up temporary lists -->
      <_MixedResourceWithNoCulture Remove="@(_MixedResourceWithNoCulture)" />
      <_MixedResourceWithCulture Remove="@(_MixedResourceWithCulture)" />
    </ItemGroup>
  </Target>
  <!--
    =======================================================================
                                        CreateCustomManifestResourceNames

    Allows custom manifest resource name generation tasks to plug
    into the build process
    =======================================================================
    -->
  <PropertyGroup>
    <CreateCustomManifestResourceNamesDependsOn />
  </PropertyGroup>
  <Target Name="CreateCustomManifestResourceNames" DependsOnTargets="$(CreateCustomManifestResourceNamesDependsOn)" />
  <!--
    ============================================================
                                        ResGen

    Run GenerateResource on the given resx files.

    ============================================================
    -->
  <PropertyGroup>
    <ResGenDependsOn>ResolveAssemblyReferences;SplitResourcesByCulture;BeforeResGen;CoreResGen;AfterResGen</ResGenDependsOn>
    <CoreResGenDependsOn>FindReferenceAssembliesForReferences</CoreResGenDependsOn>
    <UseSourcePath Condition="'$(UseSourcePath)'==''">true</UseSourcePath>
    <ResGenExecuteAsTool Condition="'$(ResGenExecuteAsTool)'==''">false</ResGenExecuteAsTool>
  </PropertyGroup>
  <Target Name="ResGen" DependsOnTargets="$(ResGenDependsOn)" />
  <!--
    ============================================================
                                        BeforeResGen

    Redefine this target in your project in order to run tasks just before Resgen.
    ============================================================
    -->
  <Target Name="BeforeResGen" />
  <!--
    ============================================================
                                        AfterResGen

    Redefine this target in your project in order to run tasks just after Resgen.
    ============================================================
    -->
  <Target Name="AfterResGen" />
  <!--
    ============================================================
                                        CoreResGen
    ============================================================
    -->
  <Target Name="CoreResGen" DependsOnTargets="$(CoreResGenDependsOn)">
    <ItemGroup>
      <_Temporary Remove="@(_Temporary)" />
    </ItemGroup>
    <PropertyGroup>
      <GenerateResourceMSBuildArchitecture Condition="'$(GenerateResourceMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</GenerateResourceMSBuildArchitecture>
      <ResgenToolPath Condition="'$(ResgenToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResgenToolPath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(GenerateResourceMSBuildArchitecture)' != ''">
      <!-- In the general case, we want to fail to run the task if the task host it's requesting doesn't exist, because we'd rather let the
           user know there's something wrong than just silently generate something that's probably not quite right. However, in a few
           circumstances, there are tasks that are already aware of runtime / bitness concerns, in which case even if we go ahead and run
           the more recent version of the task, it should be able to generate something correct.  GenerateResource is one such task, so
           we check for the existence of the targeted task host so that we can use it preferentially, but if it can't be found, we'll fall
           back to the current task since it's still mostly correct.

           In particular, we need to do this because otherwise people with Dev10 on a machine that they upgrade to Win8 will be broken:
           they'll have ResGen from the 7.0A SDK installed, so launching ResGen will still work, but the CLR2 task host is only installed by
           the 8.0A SDK, which they won't have installed, and thus without this fallback mechanism, their projects targeting v3.5 will
           suddenly start failing to build.-->
      <GenerateResourceMSBuildRuntime Condition="'$(GenerateResourceMSBuildRuntime)' == '' and&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(GenerateResourceMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</GenerateResourceMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <GenerateResourceMSBuildRuntime Condition="'$(GenerateResourceMSBuildRuntime)' == ''">CurrentRuntime</GenerateResourceMSBuildRuntime>
    </PropertyGroup>
    <!-- 4.0 task has some new parameters that we want to make use of if we're targeting 4.0 -->
    <GenerateResource Sources="@(EmbeddedResource)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePathWithRefAssemblies)" UsePreserializedResources="$(GenerateResourceUsePreserializedResources)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.cache" StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)" StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)" StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)" StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)" StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" PublicClass="%(EmbeddedResource.PublicClass)" OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' != 'CLR2'" SdkToolsPath="$(ResgenToolPath)" ExecuteAsTool="$(ResGenExecuteAsTool)" EnvironmentVariables="$(ResGenEnvironment)" WarnOnBinaryFormatterUse="$(GenerateResourceWarnOnBinaryFormatterUse)" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="StronglyTypedFileName" ItemName="Compile" />
      <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
      <Output TaskParameter="Sources" ItemName="_Temporary" />
    </GenerateResource>
    <!-- But we can't use those parameters if we're targeting 3.5, since we're using the 3.5 task -->
    <GenerateResource Sources="@(EmbeddedResource)" UseSourcePath="$(UseSourcePath)" References="@(ReferencePath)" AdditionalInputs="$(MSBuildAllProjects)" NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)" StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.cache" StronglyTypedClassName="%(EmbeddedResource.StronglyTypedClassName)" StronglyTypedFileName="%(EmbeddedResource.StronglyTypedFileName)" StronglyTypedLanguage="%(EmbeddedResource.StronglyTypedLanguage)" StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)" StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)" PublicClass="%(EmbeddedResource.PublicClass)" OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')" MSBuildRuntime="$(GenerateResourceMSBuildRuntime)" MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)" Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' == 'CLR2'">
      <Output TaskParameter="FilesWritten" ItemName="FileWrites" />
      <Output TaskParameter="StronglyTypedFileName" ItemName="Compile" />
      <!-- Gather Sources as an output since it will contain OutputResource metadata indicating the final output resource that it was compiled into -->
      <Output TaskParameter="Sources" ItemName="_Temporary" />
    </GenerateResource>
    <ItemGroup>
      <EmbeddedResource Remove="@(_Temporary)" />
      <!-- Add back the Sources list (with OutputResource metadata) that we output from GenerateResource into EmbeddedResource -->
      <EmbeddedResource Include="@(_Temporary)" />
      <_Temporary Remove="@(_Temporary)" />
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ManifestResourceWithNoCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestResourceWithNoCulture>
      <ManifestNonResxWithNoCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='false' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestNonResxWithNoCultureOnDisk>
      <!-- EMITTED FOR COMPATIBILITY REASONS ONLY. CONSUME EMBEDDEDRESOURCE INSTEAD -->
      <ManifestResourceWithCulture Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestResourceWithCulture>
      <ManifestNonResxWithCultureOnDisk Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)'=='true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
        <EmittedForCompatibilityOnly>true</EmittedForCompatibilityOnly>
      </ManifestNonResxWithCultureOnDisk>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        CompileLicxFiles

    Compile .licx files (containing information about licensed controls used by the application) into .licenses files.

        [IN]
        @(_LicxFile) - The list of .licx files in the project (usually there will be just one)

        [OUT]
        @(CompiledLicenseFile) - The list of compiled .licenses files (there will be just one)
    ============================================================
    -->
  <PropertyGroup>
    <CompileLicxFilesDependsOn />
  </PropertyGroup>
  <Target Name="CompileLicxFiles" Condition="'@(_LicxFile)'!=''" DependsOnTargets="$(CompileLicxFilesDependsOn)" Inputs="$(MSBuildAllProjects);@(_LicxFile);@(ReferencePathWithRefAssemblies);@(ReferenceDependencyPaths)" Outputs="$(IntermediateOutputPath)$(TargetFileName).licenses">
    <PropertyGroup>
      <LCMSBuildArchitecture Condition="'$(LCMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</LCMSBuildArchitecture>
    </PropertyGroup>
    <LC Sources="@(_LicxFile)" LicenseTarget="$(TargetFileName)" OutputDirectory="$(IntermediateOutputPath)" OutputLicense="$(IntermediateOutputPath)$(TargetFileName).licenses" ReferencedAssemblies="@(ReferencePathWithRefAssemblies);@(ReferenceDependencyPaths)" NoLogo="$(NoLogo)" ToolPath="$(LCToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" EnvironmentVariables="$(LCEnvironment)" MSBuildArchitecture="$(LCMSBuildArchitecture)" TargetFrameworkVersion="$(TargetFrameworkVersion)">
      <Output TaskParameter="OutputLicense" ItemName="CompiledLicenseFile" />
      <Output TaskParameter="OutputLicense" ItemName="FileWrites" />
    </LC>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                ResolveKeySource Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        ResolveKeySource

    Resolve the strong name key used to sign the assembly as well as the certificate used to
    sign the ClickOnce manifests.

        [IN]
        $(AssemblyOriginatorKeyFile)     - The file used to sign the assembly (.snk or .pfx)
        $(ManifestCertificateThumbprint) - The thumbprint used to locate the certificate in the
                                           user's certificate store.
        $(ManifestKeyFile)               - The key file that contains the certificate in case the
                                           certificate is not in the user's store.

        [OUT]
        $(ResolvedAssemblyKeyFile)        - Key used to sign the assembly
        $(_DeploymentResolvedManifestCertificateThumbprint) - Certificate used to sign the manifests
    ============================================================
    -->
  <Target Name="ResolveKeySource" Condition="$(SignManifests) == 'true' or $(SignAssembly) == 'true'">
    <ResolveKeySource KeyFile="$(AssemblyOriginatorKeyFile)" CertificateThumbprint="$(ManifestCertificateThumbprint)" CertificateFile="$(ManifestKeyFile)" SuppressAutoClosePasswordPrompt="$(BuildingInsideVisualStudio)" ShowImportDialogDespitePreviousFailures="$(BuildingProject)" ContinueOnError="!$(BuildingProject)">
      <Output TaskParameter="ResolvedKeyFile" PropertyName="KeyOriginatorFile" Condition=" '$(SignAssembly)' == 'true' " />
      <Output TaskParameter="ResolvedKeyContainer" PropertyName="KeyContainerName" Condition=" '$(SignAssembly)' == 'true' " />
      <Output TaskParameter="ResolvedThumbprint" PropertyName="_DeploymentResolvedManifestCertificateThumbprint" Condition=" '$(SignManifests)' == 'true' " />
    </ResolveKeySource>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Compile Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Compile
    ============================================================
    -->
  <PropertyGroup>
    <CompileDependsOn>
      ResolveReferences;
      ResolveKeySource;
      SetWin32ManifestProperties;
      _SetPreferNativeArm64Win32ManifestProperties;
      FindReferenceAssembliesForReferences;
      _GenerateCompileInputs;
      BeforeCompile;
      _TimeStampBeforeCompile;
      _GenerateCompileDependencyCache;
      CoreCompile;
      _TimeStampAfterCompile;
      AfterCompile;
    </CompileDependsOn>
  </PropertyGroup>
  <Target Name="Compile" DependsOnTargets="$(CompileDependsOn)" />
  <!--
    ============================================================
                                        _GenerateCompileInputs

    Create the _CoreCompileResourceInputs list of inputs to the CoreCompile target.
    ============================================================
    -->
  <Target Name="_GenerateCompileInputs">
    <MSBuildInternalMessage Condition="'@(ManifestResourceWithNoCulture)'!='' and '%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9004;ManifestResourceWithNoCulture;false;Resx" />
    <MSBuildInternalMessage Condition="'@(ManifestNonResxWithNoCultureOnDisk)'!='' and '%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9005;ManifestNonResxWithNoCultureOnDisk;false;Non-Resx" />
    <ItemGroup>
      <!-- _CoreCompileResourceInputs is the list of TLDA inputs that should trigger CoreCompile, and are listed as inputs to that target -->
      <_CoreCompileResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Resx'" />
      <_CoreCompileResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'false' and '%(EmbeddedResource.Type)' == 'Non-Resx' " />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <_CoreCompileResourceInputs Include="@(ManifestResourceWithNoCulture)" Condition="'%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''">
        <Type>Resx</Type>
        <WithCulture>false</WithCulture>
      </_CoreCompileResourceInputs>
      <_CoreCompileResourceInputs Include="@(ManifestNonResxWithNoCultureOnDisk)" Condition="'%(ManifestNonResxWithNoCultureOnDisk.EmittedForCompatibilityOnly)'==''">
        <Type>Non-Resx</Type>
        <WithCulture>false</WithCulture>
      </_CoreCompileResourceInputs>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateTargetFrameworkMonikerAttribute

    Emit the target framework moniker attribute as  a code fragment into a temporary source file for the compiler.
    ============================================================
    -->
  <PropertyGroup Condition="'$(TargetFrameworkMoniker)' != ''">
    <!-- Do not clean if we are going to default the path to the temp directory -->
    <TargetFrameworkMonikerAssemblyAttributesFileClean Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == '' and '$(TargetFrameworkMonikerAssemblyAttributesPath)' != ''">true</TargetFrameworkMonikerAssemblyAttributesFileClean>
    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$([System.IO.Path]::Combine('$(IntermediateOutputPath)','$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)'))</TargetFrameworkMonikerAssemblyAttributesPath>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateTargetFrameworkAttribute Condition="'$(GenerateTargetFrameworkAttribute)' == '' and '$(TargetFrameworkMoniker)' != '' and '$(TargetingClr2Framework)' != 'true'">true</GenerateTargetFrameworkAttribute>
  </PropertyGroup>
  <ItemGroup Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == 'true'">
    <Clean Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
  </ItemGroup>
  <Target Name="GenerateTargetFrameworkMonikerAttribute" BeforeTargets="BeforeCompile" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildToolsPath)\Microsoft.Common.targets" Outputs="$(TargetFrameworkMonikerAssemblyAttributesPath)" Condition="'@(Compile)' != '' and '$(GenerateTargetFrameworkAttribute)' == 'true'">
    <!-- This is a file shared between projects so we have to take care to handle simultaneous writes (by ContinueOnError)
             and a race between clean from one project and build from another (by not adding to FilesWritten so it doesn't clean) -->
    <WriteLinesToFile File="$(TargetFrameworkMonikerAssemblyAttributesPath)" Lines="$(TargetFrameworkMonikerAssemblyAttributeText)" Overwrite="true" ContinueOnError="true" Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''" />
    <ItemGroup Condition="'@(Compile)' != '' and '$(TargetFrameworkMonikerAssemblyAttributeText)' != ''">
      <Compile Include="$(TargetFrameworkMonikerAssemblyAttributesPath)" />
      <!-- Do not put in FileWrites: this is a file shared between projects in %temp%, and cleaning it would create a race between projects during rebuild -->
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateAdditionalSources

    Emit any specified code fragments into a temporary source file for the compiler.
    ============================================================
    -->
  <PropertyGroup Condition="'$(AssemblyAttributesPath)' != ''">
    <GenerateAdditionalSources Condition="'$(GenerateAdditionalSources)' == ''">true</GenerateAdditionalSources>
  </PropertyGroup>
  <ItemGroup Condition="'$(AssemblyAttributesPath)' != ''">
    <Clean Include="$(AssemblyAttributesPath)" Condition="'$(AssemblyAttributesFileClean)' != 'false'" />
  </ItemGroup>
  <Target Name="GenerateAdditionalSources" BeforeTargets="BeforeCompile" DependsOnTargets="PrepareForBuild;GetReferenceAssemblyPaths" Inputs="$(MSBuildAllProjects)" Outputs="$(AssemblyAttributesPath)" Condition="'@(AssemblyAttributes)' != '' and '$(GenerateAdditionalSources)' == 'true'">
    <WriteCodeFragment AssemblyAttributes="@(AssemblyAttributes)" OutputFile="$(AssemblyAttributesPath)" Language="$(Language)">
      <Output TaskParameter="OutputFile" ItemName="Compile" />
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
  </Target>
  <!--
    ============================================================
                                        BeforeCompile

    Redefine this target in your project in order to run tasks just before Compile.
    ============================================================
    -->
  <Target Name="BeforeCompile" />
  <!--
    ============================================================
                                        AfterCompile

    Redefine this target in your project in order to run tasks just after Compile.
    ============================================================
    -->
  <Target Name="AfterCompile" />
  <!--
    ============================================================
                                        _TimeStampBeforeCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
  <Target Name="_TimeStampBeforeCompile" Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')">
    <PropertyGroup>
      <_AssemblyTimestampBeforeCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampBeforeCompile>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _GenerateSuggestedBindingRedirectsCache
    Generate a file used to track whether suggested binding redirects changed between builds.
    @(SuggestedBindingRedirects) never contains a file on disk, so create a file
    that contains a hash of the items to prevent `GenerateBindingRedirects`
    from running every build.

    See https://github.com/dotnet/msbuild/issues/5943 for details.
    ============================================================
    -->
  <Target Name="_GenerateSuggestedBindingRedirectsCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences">
    <PropertyGroup>
      <SuggestedBindingRedirectsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectFile).SuggestedBindingRedirects.cache</SuggestedBindingRedirectsCacheFile>
    </PropertyGroup>
    <Hash ItemsToHash="@(SuggestedBindingRedirects)">
      <Output TaskParameter="HashResult" PropertyName="SuggestedBindingRedirectsHash" />
    </Hash>
    <WriteLinesToFile Lines="$(SuggestedBindingRedirectsHash)" File="$(SuggestedBindingRedirectsCacheFile)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(SuggestedBindingRedirectsCacheFile)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _GenerateCompileDependencyCache

    Generate a file used to track compiler dependencies between incremental build
    executions. This handles cases where items are added or removed from a glob (e.g.
    <Compile Include="**\*.cs" />) and can't otherwise be detected with timestamp
    comparisons. The file contains a hash of compiler inputs that are known to
    contribute to incremental build inconsistencies.
    ============================================================
    -->
  <Target Name="_GenerateCompileDependencyCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences;_GenerateCompileInputs">
    <ItemGroup>
      <CustomAdditionalCompileInputs Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" />
      <CoreCompileCache Include="@(Compile)" />
      <CoreCompileCache Include="@(ReferencePath)" />
      <CoreCompileCache Include="$(DefineConstants)" />
      <CoreCompileCache Include="$(LangVersion)" />
      <CoreCompileCache Include="$(Deterministic)" />
      <CoreCompileCache Include="$(PathMap)" />
      <CoreCompileCache Include="@(_CoreCompileResourceInputs)" />
    </ItemGroup>
    <Hash ItemsToHash="@(CoreCompileCache)" IgnoreCase="$([MSBuild]::ValueOrDefault(`$(CoreCompileCacheIgnoreCase)`, `true`))">
      <Output TaskParameter="HashResult" PropertyName="CoreCompileDependencyHash" />
    </Hash>
    <WriteLinesToFile Lines="$(CoreCompileDependencyHash)" File="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _TimeStampAfterCompile

    If post-build events are set to fire "OnOutputUpdated", then take before
    and after timestamps so that we can compare them.
    ============================================================
    -->
  <Target Name="_TimeStampAfterCompile" Condition="'$(RunPostBuildEvent)'=='OnOutputUpdated' or ('$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library')">
    <PropertyGroup>
      <_AssemblyTimestampAfterCompile>%(IntermediateAssembly.ModifiedTime)</_AssemblyTimestampAfterCompile>
    </PropertyGroup>
  </Target>
  <!--
    ================================================================
                                        _ComputeNonExistentFileProperty

    There are certain situations in which we want to always run the CoreCompile target (and
    thus the Csc task), even if the timestamps of the outputs appear to be up-to-date on disk.
    If we're inside the IDE during design-time, then the Csc/Vbc/Vjc task is simply being used to
    initialize the host compiler, so we always want to run it.  Also, if we're inside the IDE, and
    the host compiler is responsible for doing the compilation during an actual build, we want to let
    the host compiler determine whether the output is up-to-date, because there may be source files
    in the IDE's in-memory buffers that we don't know about.

    So, we always run the CoreCompile target if we're in the IDE, and either we're in design-time or
    we're delegating to the host compiler for the actual build.

    We compare against BuildOutOfProcess != true because we cannot assume that the build process will
    have set BuildOutOfProcess to true or false. Therefore the default behavior should be to do the
    legacy behavior seen before BuildingOutOfProcess was introduced if the property is not set.
    ================================================================
    -->
  <Target Name="_ComputeNonExistentFileProperty" Condition="('$(BuildingInsideVisualStudio)' == 'true') and ('$(BuildingOutOfProcess)' != 'true') and (('$(BuildingProject)' == 'false') or ('$(UseHostCompilerIfAvailable)' == 'true'))">
    <PropertyGroup>
      <NonExistentFile>__NonExistentSubDir__\__NonExistentFile__</NonExistentFile>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateSerializationAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <_SGenDllName>$(TargetName).XmlSerializers.dll</_SGenDllName>
    <_SGenDllCreated>false</_SGenDllCreated>
    <_SGenGenerateSerializationAssembliesConfig>$(GenerateSerializationAssemblies)</_SGenGenerateSerializationAssembliesConfig>
    <_SGenGenerateSerializationAssembliesConfig Condition="'$(GenerateSerializationAssemblies)' == ''">Auto</_SGenGenerateSerializationAssembliesConfig>
    <_SGenGenerateSerializationAssembliesConfig Condition="'$(ConfigurationName)'=='Debug' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto'">Off</_SGenGenerateSerializationAssembliesConfig>
    <SGenUseProxyTypes Condition="'$(SGenUseProxyTypes)' == ''">true</SGenUseProxyTypes>
    <SGenUseKeep Condition="'$(SGenUseKeep)'==''">false</SGenUseKeep>
    <SGenShouldGenerateSerializer Condition="'$(SGenShouldGenerateSerializer)' == ''">true</SGenShouldGenerateSerializer>
  </PropertyGroup>
  <!--
    ============================================================
                                        GenerateSerializationAssemblies

    Run GenerateSerializationAssemblies on the assembly produced by this build.

        [IN]
        @(BuildAssemblyName) - The assembly generated by this build.
        @(BuildAssemblyPath) - The path where the assembly resides.
        @(ReferencePath) - The list of references used by this assembly.

        [OUT]
        @(SerializationAssembly) - The path to the serialization assembly.  Maybe we'll just append to an existing list.
    ============================================================
    -->
  <Target Name="GenerateSerializationAssemblies" Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')" DependsOnTargets="AssignTargetPaths;Compile;ResolveKeySource" Inputs="$(MSBuildAllProjects);@(IntermediateAssembly)" Outputs="$(IntermediateOutputPath)$(_SGenDllName)">
    <PropertyGroup>
      <SGenMSBuildArchitecture Condition="'$(SGenMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</SGenMSBuildArchitecture>
    </PropertyGroup>
    <SGen BuildAssemblyName="$(TargetFileName)" BuildAssemblyPath="$(IntermediateOutputPath)" References="@(ReferencePath)" ShouldGenerateSerializer="$(SGenShouldGenerateSerializer)" UseProxyTypes="$(SGenUseProxyTypes)" UseKeep="$(SGenUseKeep)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" DelaySign="$(DelaySign)" ToolPath="$(SGenToolPath)" SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)" EnvironmentVariables="$(SGenEnvironment)" MSBuildArchitecture="$(SGenMSBuildArchitecture)" SerializationAssembly="$(IntermediateOutputPath)$(_SGenDllName)" Platform="$(SGenPlatformTarget)" Types="$(SGenSerializationTypes)">
      <Output TaskParameter="SerializationAssembly" ItemName="SerializationAssembly" />
    </SGen>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                CreateSatelliteAssemblies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        CreateSatelliteAssemblies

    Create one satellite assembly for every unique culture in the resources.
    ============================================================
    -->
  <PropertyGroup>
    <CreateSatelliteAssembliesDependsOn>
      $(CreateSatelliteAssembliesDependsOn);
      _GenerateSatelliteAssemblyInputs;
      ComputeIntermediateSatelliteAssemblies;
      GenerateSatelliteAssemblies
    </CreateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="CreateSatelliteAssemblies" DependsOnTargets="$(CreateSatelliteAssembliesDependsOn)" />
  <!--
    ============================================================
                                        _GenerateSatelliteAssemblyInputs

    Create the _SatelliteAssemblyResourceInputs list of inputs to the CreateSatelliteAssemblies target.
    ============================================================
    -->
  <Target Name="_GenerateSatelliteAssemblyInputs">
    <MSBuildInternalMessage Condition="'@(ManifestResourceWithCulture)'!='' and '%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9006;ManifestResourceWithCulture;true;Resx" />
    <MSBuildInternalMessage Condition="'@(ManifestNonResxWithCultureOnDisk)'!='' and '%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''" ResourceName="CommonSdk.ManifestResourceWithNoCultureWarning" Severity="Warning" FormatArguments="MSB9007;ManifestNonResxWithCultureOnDisk;true;Non-Resx" />
    <ItemGroup>
      <!-- _SatelliteAssemblyResourceInputs is the list of TLDA inputs that should trigger CreateSatelliteAssemblies, so listed as inputs to that target -->
      <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource->'%(OutputResource)')" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Resx'" />
      <_SatelliteAssemblyResourceInputs Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'" />
      <!-- CONSUMED FOR COMPATIBILITY REASONS ONLY. EMIT EMBEDDEDRESOURCE INSTEAD -->
      <_SatelliteAssemblyResourceInputs Include="@(ManifestResourceWithCulture)" Condition="'%(ManifestResourceWithCulture.EmittedForCompatibilityOnly)'==''">
        <Type>Resx</Type>
        <WithCulture>true</WithCulture>
      </_SatelliteAssemblyResourceInputs>
      <_SatelliteAssemblyResourceInputs Include="@(ManifestNonResxWithCultureOnDisk)" Condition="'%(ManifestNonResxWithCultureOnDisk.EmittedForCompatibilityOnly)'==''">
        <Type>Non-Resx</Type>
        <WithCulture>true</WithCulture>
      </_SatelliteAssemblyResourceInputs>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateSatelliteAssemblies

    Actually run al.exe to create the satellite assemblies.
    ============================================================
    -->
  <Target Name="GenerateSatelliteAssemblies" Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Condition="'@(_SatelliteAssemblyResourceInputs)' != '' and '$(GenerateSatelliteAssembliesForCore)' != 'true'">
    <PropertyGroup>
      <_ALExeToolPath Condition="'$(_ALExeToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</_ALExeToolPath>
    </PropertyGroup>
    <MakeDir Directories="@(EmbeddedResource->'$(IntermediateOutputPath)%(Culture)')" />
    <AL AlgorithmId="$(Satellite_AlgorithmId)" BaseAddress="$(Satellite_BaseAddress)" CompanyName="$(Satellite_CompanyName)" Configuration="$(Satellite_Configuration)" Copyright="$(Satellite_Copyright)" Culture="%(Culture)" DelaySign="$(DelaySign)" Description="$(Satellite_Description)" EmbedResources="@(_SatelliteAssemblyResourceInputs)" EnvironmentVariables="$(AlEnvironment)" EvidenceFile="$(Satellite_EvidenceFile)" FileVersion="$(Satellite_FileVersion)" Flags="$(Satellite_Flags)" GenerateFullPaths="$(Satellite_GenerateFullPaths)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" LinkResources="@(Satellite_LinkResource)" MainEntryPoint="$(Satellite_MainEntryPoint)" OutputAssembly="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Platform="$(PlatformTarget)" ProductName="$(Satellite_ProductName)" ProductVersion="$(Satellite_ProductVersion)" ResponseFiles="@(AlResponseFile)" SourceModules="@(Satellite_SourceModule)" TargetType="$(Satellite_TargetType)" TemplateFile="$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Title="$(Satellite_Title)" ToolPath="$(AlToolPath)" ToolExe="$(AlToolExe)" SdkToolsPath="$(_ALExeToolPath)" Trademark="$(Satellite_Trademark)" Version="$(Satellite_Version)" Win32Icon="$(Satellite_Win32Icon)" Win32Resource="$(Satellite_Win32Resource)">
      <Output TaskParameter="OutputAssembly" ItemName="FileWrites" />
    </AL>
  </Target>
  <!--
    ============================================================
                                        ComputeIntermediateSatelliteAssemblies

    Compute the paths to the intermediate satellite assemblies,
    with culture attributes so we can copy them to the right place.
    ============================================================
    -->
  <PropertyGroup>
    <ComputeIntermediateSatelliteAssembliesDependsOn>
      CreateManifestResourceNames
    </ComputeIntermediateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <Target Name="ComputeIntermediateSatelliteAssemblies" Condition="@(EmbeddedResource->'%(WithCulture)') != ''" DependsOnTargets="$(ComputeIntermediateSatelliteAssembliesDependsOn)">
    <ItemGroup>
      <IntermediateSatelliteAssembliesWithTargetPath Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" Condition="'%(EmbeddedResource.Culture)' != ''">
        <Culture>%(EmbeddedResource.Culture)</Culture>
        <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
      </IntermediateSatelliteAssembliesWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                SetWin32ManifestProperties Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <EmbeddedWin32Manifest>$(Win32Manifest)</EmbeddedWin32Manifest>
  </PropertyGroup>
  <!--
    ============================================================
                                        SetWin32ManifestProperties

    Set Win32Manifest and EmbeddedManifest properties to be used later in the build.
    ============================================================
    -->
  <Target Name="SetWin32ManifestProperties" Condition="'$(Win32Manifest)'==''" DependsOnTargets="ResolveComReferences;ResolveNativeReferences;_SetExternalWin32ManifestProperties;_SetEmbeddedWin32ManifestProperties" />
  <Target Name="_SetExternalWin32ManifestProperties" Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!=''">
    <PropertyGroup>
      <!-- set _DeploymentBaseManifest property to the value of $(ApplicationManifest) if the property is set,
                 but use _DeploymentBaseManifestWithTargetPath item-group if the property is not set to support backwards
                 compat with earlier MSBuild versions when manifest files were determined by the item-group. If the newer
                 property is set though, prefer that one be used to specify the manifest. -->
      <_DeploymentBaseManifest>$(ApplicationManifest)</_DeploymentBaseManifest>
      <_DeploymentBaseManifest Condition="'$(_DeploymentBaseManifest)'==''">@(_DeploymentBaseManifestWithTargetPath)</_DeploymentBaseManifest>
      <!-- when using external manifests, always set the NoWin32Manifest property to
                 true if there is no value set in the incoming project file so the
                 compilers that support manifest embedding know not to add
                 a manifest to their built assemblies -->
      <NoWin32Manifest Condition="'$(NoWin32Manifest)'==''">true</NoWin32Manifest>
    </PropertyGroup>
  </Target>
  <Target Name="_SetEmbeddedWin32ManifestProperties" Condition="'$(GenerateClickOnceManifests)'!='true' and '@(NativeReference)'=='' and '@(ResolvedIsolatedComModules)'==''">
    <PropertyGroup>
      <EmbeddedWin32Manifest>$(ApplicationManifest)</EmbeddedWin32Manifest>
      <Win32Manifest>$(ApplicationManifest)</Win32Manifest>
    </PropertyGroup>
    <!-- If PreferNativeArm64 is enabled, it searches for the same default.win32manifest  -->
    <GetFrameworkPath Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and '$(PreferNativeArm64)' != 'true'">
      <Output TaskParameter="FrameworkVersion40Path" PropertyName="_FrameworkVersion40Path" />
    </GetFrameworkPath>
    <PropertyGroup>
      <EmbeddedWin32Manifest Condition="'$(ApplicationManifest)'=='' and '$(NoWin32Manifest)'!='true' and '$(PreferNativeArm64)' != 'true' and Exists('$(_FrameworkVersion40Path)\default.win32manifest')">$(_FrameworkVersion40Path)\default.win32manifest</EmbeddedWin32Manifest>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _SetPreferNativeArm64Win32ManifestProperties

    Populates Manifest with SupportedArchitectures and updates Win32Manifest property to be used later in the build.
    ============================================================
    -->
  <Target Name="_SetPreferNativeArm64Win32ManifestProperties" Condition=" '$(PreferNativeArm64)'=='true' and '$(NoWin32Manifest)'!='true'" DependsOnTargets="SetWin32ManifestProperties">
    <AddToWin32Manifest ApplicationManifest="$(Win32Manifest)" OutputDirectory="$(IntermediateOutputPath)" SupportedArchitectures="$(_SupportedArchitectures)">
      <Output TaskParameter="ManifestPath" PropertyName="_Win32Manifest" />
    </AddToWin32Manifest>
    <PropertyGroup>
      <Win32Manifest Condition="'$(_Win32Manifest)' != ''">$(_Win32Manifest)</Win32Manifest>
    </PropertyGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                GenerateManifests Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        GenerateManifests

    Generates ClickOnce application and deployment manifests or a native manifest.
    ============================================================
    -->
  <PropertyGroup>
    <GenerateManifestsDependsOn>
      SetWin32ManifestProperties;
      GenerateApplicationManifest;
      GenerateDeploymentManifest
    </GenerateManifestsDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                  _GenerateResolvedDeploymentManifestEntryPoint

    Use the ResolveManifestFiles to generate the GenerateResolvedDeploymentManifestEntryPoint

    ============================================================
    -->
  <Target Name="_GenerateResolvedDeploymentManifestEntryPoint">
    <ItemGroup>
      <_DeploymentPublishFileOfTypeManifestEntryPoint Include="@(PublishFile)" Condition="'%(FileType)'=='ManifestEntryPoint'" />
    </ItemGroup>
    <ResolveManifestFiles TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" SigningManifests="$(SignManifests)" DeploymentManifestEntryPoint="@(ApplicationManifest)" PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">
      <Output TaskParameter="OutputDeploymentManifestEntryPoint" ItemName="_DeploymentResolvedDeploymentManifestEntryPoint" />
    </ResolveManifestFiles>
  </Target>
  <Target Name="GenerateManifests" Condition="'$(GenerateClickOnceManifests)'=='true' or '@(NativeReference)'!='' or '@(ResolvedIsolatedComModules)'!='' or '$(GenerateAppxManifest)' == 'true'" DependsOnTargets="$(GenerateManifestsDependsOn)" />
  <!--
    ============================================================
                                        GenerateApplicationManifest

    Generates a ClickOnce or native application manifest.
    An application manifest specifies declarative application identity, dependency and security information.

        [IN]
        $(_DeploymentBaseManifest) - The base app.manifest from project.
        @(ResolvedIsolatedComModules) - The list of COM references to be isolated as reg-free COM dependencies for native assembly loader.
        @(_DeploymentManifestFiles) - The list of loose files (content, pdb, xml, etc.) for ClickOnce.
        @(_DeploymentManifestDependencies) - The list of application dependencies (typically this is the set of assembly dependencies in bin\) for ClickOnce.
        @(AppConfigWithTargetPath) - App config file, if present.
        $(_DeploymentManifestType) - Type of manifest to be generated, either "Native" or "ClickOnce".

        [OUT]
        @(ApplicationManifest) - Generated native or ClickOnce application manifest, i.e. WindowsApplication1.exe.manifest
    ============================================================
    -->
  <Target Name="GenerateApplicationManifest" DependsOnTargets="&#xA;            _DeploymentSetClickOnceVersions;&#xA;            _DeploymentGenerateLauncher;&#xA;            _DeploymentComputeNativeManifestInfo;&#xA;            _DeploymentComputeClickOnceManifestInfo;&#xA;            ResolveComReferences;&#xA;            ResolveNativeReferences;&#xA;            _GenerateResolvedDeploymentManifestEntryPoint" Inputs="&#xA;            $(MSBuildAllProjects);&#xA;            @(AppConfigWithTargetPath);&#xA;            $(_DeploymentBaseManifest);&#xA;            @(ResolvedIsolatedComModules);&#xA;            @(_DeploymentManifestDependencies);&#xA;            @(_DeploymentResolvedManifestEntryPoint);&#xA;            @(_DeploymentManifestFiles)" Outputs="@(ApplicationManifest)">
    <RequiresFramework35SP1Assembly ReferencedAssemblies="@(Reference)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" TargetFrameworkVersion="$(TargetFrameworkVersion)" CreateDesktopShortcut="$(CreateDesktopShortcut)" SigningManifests="$(SignManifests)" Assemblies="@(_DeploymentManifestDependencies)" DeploymentManifestEntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)" EntryPoint="@(_DeploymentResolvedManifestEntryPoint)" Files="@(_DeploymentManifestFiles)" SuiteName="$(SuiteName)">
      <Output TaskParameter="RequiresMinimumFramework35SP1" PropertyName="_DeploymentRequiresMinimumFramework35SP1" />
    </RequiresFramework35SP1Assembly>
    <GenerateApplicationManifest AssemblyName="$(_DeploymentApplicationManifestIdentity)" AssemblyVersion="$(_DeploymentManifestVersion)" ConfigFile="@(AppConfigWithTargetPath)" ClrVersion="$(ClrVersion)" Dependencies="@(_DeploymentManifestDependencies)" Description="$(Description)" EntryPoint="@(_DeploymentResolvedManifestEntryPoint)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" FileAssociations="@(FileAssociation)" Files="@(_DeploymentManifestFiles)" HostInBrowser="$(HostInBrowser)" IconFile="@(_DeploymentManifestIconFile)" InputManifest="$(_DeploymentBaseManifest)" IsolatedComReferences="@(ResolvedIsolatedComModules)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" ManifestType="$(_DeploymentManifestType)" MaxTargetPath="$(MaxTargetPath)" OutputManifest="@(ApplicationManifest)" OSVersion="$(OSVersion)" Platform="$(_DeploymentPlatformTarget)" Product="$(ProductName)" Publisher="$(PublisherName)" RequiresMinimumFramework35SP1="$(_DeploymentRequiresMinimumFramework35SP1)" SuiteName="$(SuiteName)" SupportUrl="$(_DeploymentFormattedSupportUrl)" TargetCulture="$(TargetCulture)" TargetFrameworkSubset="$(TargetFrameworkSubset)" TargetFrameworkProfile="$(TargetFrameworkProfile)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)" UseApplicationTrust="$(UseApplicationTrust)">
      <Output TaskParameter="OutputManifest" ItemName="FileWrites" />
    </GenerateApplicationManifest>
    <AddToWin32Manifest Condition="'$(PreferNativeArm64)'=='true'" ApplicationManifest="@(ApplicationManifest)" OutputDirectory="$(IntermediateOutputPath)" SupportedArchitectures="$(_SupportedArchitectures)" />
    <PropertyGroup>
      <_DeploymentCopyApplicationManifest>true</_DeploymentCopyApplicationManifest>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentSetClickOnceVersions

    Sets ClickOnce versions
    ============================================================
    -->
  <Target Name="_DeploymentSetClickOnceVersions" Condition="'$(GenerateClickOnceManifests)'=='true'">
    <PropertyGroup>
      <_DeploymentManifestTargetFrameworkMoniker>$(TargetFrameworkMoniker)</_DeploymentManifestTargetFrameworkMoniker>
      <_DeploymentManifestTargetFrameworkVersion>$(TargetFrameworkVersion)</_DeploymentManifestTargetFrameworkVersion>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateLauncher

    Generates Launcher if needed
    ============================================================
    -->
  <Target Name="_DeploymentGenerateLauncher" Condition="'$(GenerateClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true'">
    <!--
      If apphost based built EXE is found, use that as the Launcher.exe's entry point otherwise
      use the built DLL as the entry point
    -->
    <ItemGroup Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')">
      <EntryPointForLauncher Include="$(AppHostIntermediatePath)" TargetPath="$(AssemblyName).exe" />
      <ContentWithTargetPath Include="@(EntryPointForLauncher)" />
    </ItemGroup>
    <ItemGroup Condition="'$(EntryPointForLauncher)'==''">
      <EntryPointForLauncher Include="$(_DeploymentManifestEntryPoint)" />
    </ItemGroup>
    <!-- Generates Launcher and obtains its Framework version and moniker -->
    <GenerateLauncher AssemblyName="$(_DeploymentApplicationManifestIdentity)" EntryPoint="@(EntryPointForLauncher)" OutputPath="$(IntermediateOutputPath)" VisualStudioVersion="$(VisualStudioVersion)">
      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentManifestLauncherEntryPoint" />
    </GenerateLauncher>
    <!--
      .NET Core ClickOnce deployments use Launcher, which targets .NET FX 4.5 as the minimum
      supported ClickOnce runtime version on target user's machine.

      TargetFramework Verion and Moniker properties are used in Deployment manifest generation
      task to set compatibleFrameworks element, which needs to match Launcher's target version.

      Version can be overriden with DeploymentManifestTargetFrameworkVersionOverride property.
    -->
    <PropertyGroup>
      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' == ''">v4.5</_DeploymentManifestTargetFrameworkVersion>
      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' != ''">$(DeploymentManifestTargetFrameworkVersionOverride)</_DeploymentManifestTargetFrameworkVersion>
      <_DeploymentManifestTargetFrameworkMoniker>.NETFramework,Version=$(_DeploymentManifestTargetFrameworkVersion)</_DeploymentManifestTargetFrameworkMoniker>
    </PropertyGroup>
    <!-- Sign Launcher EXE -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentManifestLauncherEntryPoint)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Sign the original ClickOnce entrypoint -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentManifestEntryPoint)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Sign apphost.exe if it's the entrypoint for the Launcher.exe. This is the case in loose file publish -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(AppHostIntermediatePath)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(UseAppHost)' == 'true' and '$(PublishSingleFile)' != 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')" />
    <!--
      Replace entry-point with Launcher and move original project's entry-point to content group.
    -->
    <ItemGroup>
      <ContentWithTargetPath Include="@(_DeploymentManifestEntryPoint)" />
      <_DeploymentManifestEntryPoint Remove="@(_DeploymentManifestEntryPoint)" />
      <_DeploymentManifestEntryPoint Include="@(_DeploymentManifestLauncherEntryPoint)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentComputeNativeManifestInfo

    Compute info for native manifest generation
    ============================================================
    -->
  <Target Name="_DeploymentComputeNativeManifestInfo" Condition="'$(GenerateClickOnceManifests)'!='true'">
    <!-- Create list of items for manifest generation -->
    <ResolveManifestFiles NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)">
      <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependencies" />
    </ResolveManifestFiles>
    <PropertyGroup>
      <_DeploymentManifestType>Native</_DeploymentManifestType>
    </PropertyGroup>
    <!-- Obtain manifest version from the built assembly -->
    <GetAssemblyIdentity AssemblyFiles="@(IntermediateAssembly)">
      <Output TaskParameter="Assemblies" ItemName="_IntermediateAssemblyIdentity" />
    </GetAssemblyIdentity>
    <PropertyGroup>
      <_DeploymentManifestVersion>@(_IntermediateAssemblyIdentity->'%(Version)')</_DeploymentManifestVersion>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _DeploymentComputeClickOnceManifestInfo

    Compute info for  ClickOnce manifest generation
    ============================================================
    -->
  <Target Name="_DeploymentComputeClickOnceManifestInfo" Condition="'$(GenerateClickOnceManifests)'=='true'" DependsOnTargets="$(DeploymentComputeClickOnceManifestInfoDependsOn)">
    <!-- Grab just the serialization assemblies for a referenced assembly.  There may also be a symbols file in ReferenceRelatedPaths -->
    <ItemGroup>
      <_SGenDllsRelatedToCurrentDll Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
      <_SGenDllsRelatedToCurrentDll Include="@(SerializationAssembly->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
    <ItemGroup Condition="!exists('$(ProjectLockFile)')">
      <_CopyLocalFalseRefPaths Include="@(ReferencePath)" Condition="'%(CopyLocal)' == 'false'" />
      <_CopyLocalFalseRefPathsWithExclusion Include="@(_CopyLocalFalseRefPaths)" Exclude="@(ReferenceCopyLocalPaths);@(_NETStandardLibraryNETFrameworkLib)" />
    </ItemGroup>
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <_ClickOnceSatelliteAssemblies Include="@(IntermediateSatelliteAssembliesWithTargetPath);@(ReferenceSatellitePaths)" />
    </ItemGroup>
    <!-- Flag primary dependencies-certain warnings emitted during application manifest generation apply only to them. -->
    <ItemGroup>
      <_DeploymentReferencePaths Include="@(ReferenceCopyLocalPaths)" Condition="('%(Extension)' == '.dll' Or '%(Extension)' == '.exe' Or '%(Extension)' == '.md') and ('%(ReferenceCopyLocalPaths.CopyToPublishDirectory)' != 'false')">
        <IsPrimary>true</IsPrimary>
      </_DeploymentReferencePaths>
      <_DeploymentReferencePaths Include="@(_CopyLocalFalseRefPathsWithExclusion)" />
    </ItemGroup>
    <!-- Include managed references in clickonce manifest only if single file publish is false -->
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <_ManifestManagedReferences Include="@(_DeploymentReferencePaths);@(ReferenceDependencyPaths);@(_SGenDllsRelatedToCurrentDll);@(SerializationAssembly);@(ReferenceCOMWrappersToCopyLocal)" Exclude="@(_ClickOnceSatelliteAssemblies);@(_ReferenceScatterPaths);@(_ExcludedAssembliesFromManifestGeneration)" />
    </ItemGroup>
    <!-- Include the following files in clickonce manifest only if single file publish is false -->
    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
      <!--
      _ClickOnceRuntimeCopyLocalItems group contains any runtimes folder assets of Nuget packages that are not included in
      _DeploymentReferencePaths (e.g. pdbs). They are populated from the RuntimeTargetsCopyLocalItems and NativeCopyLocalItems
      group that contain the RID-specific assets that go in runtimes folder on publish. They are output groups of the
      ResolvePackageAssets target in dotnet/sdk
      -->
      <_ClickOnceRuntimeCopyLocalItems Include="@(RuntimeTargetsCopyLocalItems)" Condition="'%(RuntimeTargetsCopyLocalItems.CopyLocal)' == 'true'" />
      <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
      <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
      <!--
        For .NET>=5, we need to check if we need to publish any content items from transitive project references. For such items to be published, they
        either have the .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
      -->
      <_ClickOnceTransitiveContentItemsTemp Include="@(_TransitiveItemsToCopyToOutputDirectory-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never')-&gt;'%(TargetPath)')" Condition="'$(PublishProtocol)' == 'ClickOnce'">
        <SavedIdentity>%(Identity)</SavedIdentity>
      </_ClickOnceTransitiveContentItemsTemp>
      <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
      <!--
        ClickOnce content items is union of transitive content items and content items from this project.
        We also exclude content items from this project that have set CopyToPublishDirectory to Never.
      -->
      <_ClickOnceContentItems Include="@(ContentWithTargetPath-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never'))" />
      <_ClickOnceContentItems Include="@(_ClickOnceTransitiveContentItems)" />
      <!--
        For .NET>=5, we need to check if we need to publish any copylocal items from None group. For such items to be published, they either
        have .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
      -->
      <!-- Include items from None group for publishing -->
      <_ClickOnceNoneItemsTemp Include="@(_NoneWithTargetPath-&gt;WithoutMetadataValue('CopyToPublishDirectory', 'Never')-&gt;'%(TargetPath)')" Condition="'$(PublishProtocol)'=='Clickonce' And ('%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent')">
        <SavedIdentity>%(Identity)</SavedIdentity>
      </_ClickOnceNoneItemsTemp>
      <_ClickOnceNoneItems Include="@(_ClickOnceNoneItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
      <_ClickOnceFiles Include="@(_ClickOnceContentItems);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems)" />
      <!-- clear temporary item groups to free memory -->
      <_ClickOnceNoneItemsTemp Remove="@(_ClickOnceNoneItemsTemp)" />
      <_ClickOnceNoneItems Remove="@(_ClickOnceNoneItems)" />
      <_ClickOnceTransitiveContentItemsTemp Remove="@(_ClickOnceTransitiveContentItemsTemp)" />
      <_ClickOnceTransitiveContentItems Remove="@(_ClickOnceTransitiveContentItems)" />
      <_ClickOnceContentItems Remove="@(_ClickOnceContentItems)" />
      <_ClickOnceRuntimeCopyLocalItems Remove="@(_ClickOnceRuntimeCopyLocalItems)" />
    </ItemGroup>
    <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
      <_ClickOnceFiles Include="$(PublishedSingleFilePath);@(_DeploymentManifestIconFile)" />
      <_ClickOnceFiles Include="@(_FilesExcludedFromBundle)" />
      <!-- Include file association icons from Content as loose files -->
      <_FileAssociationIcons Include="%(FileAssociation.DefaultIcon)" />
      <_ClickOnceFiles Include="@(ContentWithTargetPath)" Condition="'%(Identity)'=='@(_FileAssociationIcons)'" />
    </ItemGroup>
    <!-- For single file publish in .net core app, sign the SF EXE if signing is enabled -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(PublishedSingleFilePath)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true' and '$(PublishSingleFile)' == 'true'" />
    <!--
    If ReadyToRun is enabled in loose files scenario, we need to remove entries of the IL images that have gone through R2R
    compiler and replace them with the entries for their R2R images. The R2R application image also needs to be signed if necessary.
    -->
    <ItemGroup Condition="'$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'">
      <_ManifestManagedReferences Remove="@(_ReadyToRunCompileList)" />
      <_ClickOnceFiles Remove="@(_ReadyToRunCompileList)" />
      <_ClickOnceFiles Include="@(_ReadyToRunFilesToPublish)" />
      <_ClickOnceTargetFile Include="@(_ReadyToRunFilesToPublish)" Condition="'%(Filename)%(Extension)' == '$(TargetFileName)'" />
    </ItemGroup>
    <!-- Sign application image created by R2R -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_ClickOnceTargetFile)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" Condition="'$(_DeploymentSignClickOnceManifests)' == 'true' and '$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'" />
    <!-- Copy the application executable from Obj folder to app.publish folder.
    This is being done to avoid Windows Forms designer memory issues that can arise while operating directly on files located in Obj directory. -->
    <Copy SourceFiles="@(_DeploymentManifestEntryPoint)" DestinationFolder="$(ClickOncePublishDir)">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentClickOnceApplicationExecutable" />
    </Copy>
    <!-- Sign the application executable located in app.publish folder.  Signing this file is done to comply with SmartScreen. -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="@(_DeploymentClickOnceApplicationExecutable)" Condition="'$(_DeploymentResolvedManifestCertificateThumbprint)'!='' and '$(_DeploymentSignClickOnceManifests)'=='true' and '$(TargetExt)' == '.exe'" />
    <!-- Create list of items for manifest generation -->
    <ResolveManifestFiles AssemblyName="$(_DeploymentApplicationManifestIdentity)" EntryPoint="@(_DeploymentClickOnceApplicationExecutable)" ExtraFiles="@(_DebugSymbolsIntermediatePath);$(IntermediateOutputPath)$(TargetName).xml;@(_ReferenceRelatedPaths)" Files="@(_ClickOnceFiles)" IsSelfContainedPublish="$(SelfContained)" IsSingleFilePublish="$(PublishSingleFile)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" ManagedAssemblies="@(_ManifestManagedReferences)" NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)" PublishFiles="@(PublishFile)" RuntimePackAssets="@(RuntimePackAsset)" SatelliteAssemblies="@(_ClickOnceSatelliteAssemblies)" SigningManifests="$(SignManifests)" TargetCulture="$(TargetCulture)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)">
      <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependenciesUnfiltered" />
      <Output TaskParameter="OutputFiles" ItemName="_DeploymentManifestFiles" />
      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentResolvedManifestEntryPoint" />
    </ResolveManifestFiles>
    <!-- We have to filter items out of the dependencies that have neither CopyLocal set to true, -->
    <!-- nor the dependency type manually set to 'Install'.                                       -->
    <ItemGroup>
      <_DeploymentManifestDependencies Include="@(_DeploymentManifestDependenciesUnfiltered)" Condition="!('%(_DeploymentManifestDependenciesUnfiltered.CopyLocal)' == 'false' And '%(_DeploymentManifestDependenciesUnfiltered.DependencyType)' != 'Install')" />
    </ItemGroup>
    <PropertyGroup>
      <_DeploymentManifestType>ClickOnce</_DeploymentManifestType>
    </PropertyGroup>
    <!--
      Manifest platform should always be MSIL for Launcher-based deployments, as the Launcher is MSIL.
      Do not set _DeploymentPlatformTarget property in Launcher case - this is interpreted as MSIL,
      by GenerateApplicationManifest and GenerateDeploymentManifest tasks.
      Otherwise, set it to PlatformTarget.
    -->
    <PropertyGroup>
      <_DeploymentPlatformTarget Condition="'$(_DeploymentLauncherBased)' != 'true'">$(PlatformTarget)</_DeploymentPlatformTarget>
    </PropertyGroup>
    <!-- Obtain manifest version from ApplicationVersion and ApplicationRevision properties -->
    <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)">
      <Output TaskParameter="OutputVersion" PropertyName="_DeploymentManifestVersion" />
    </FormatVersion>
    <FormatUrl InputUrl="$(_DeploymentUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedDeploymentUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(SupportUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedSupportUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(ErrorReportUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedErrorReportUrl" />
    </FormatUrl>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateTrustInfo

    Generates the application permission set for inclusion in the generated ClickOnce application manifest.
    ============================================================
    -->
  <Target Name="_DeploymentGenerateTrustInfo" Condition="'$(TargetZone)'!=''" Inputs="&#xA;            $(MSBuildAllProjects);&#xA;            $(_DeploymentBaseManifest);&#xA;            " Outputs="@(_DeploymentIntermediateTrustInfoFile)">
    <GenerateTrustInfo BaseManifest="$(_DeploymentBaseManifest)" ApplicationDependencies="@(ReferencePath);@(ReferenceDependencyPaths)" ExcludedPermissions="$(ExcludedPermissions)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetZone="$(TargetZone)" TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)">
      <Output TaskParameter="TrustInfoFile" ItemName="FileWrites" />
    </GenerateTrustInfo>
  </Target>
  <!--
    ============================================================
                                        GenerateDeploymentManifest

    Generates a ClickOnce deployment manifest.
    An deployment manifest specifies declarative application identity and application update information.
    ============================================================
    -->
  <Target Name="GenerateDeploymentManifest" DependsOnTargets="GenerateApplicationManifest" Inputs="&#xA;            $(MSBuildAllProjects);&#xA;            @(ApplicationManifest)&#xA;            " Outputs="@(DeployManifest)">
    <GenerateDeploymentManifest AssemblyName="$(_DeploymentDeployManifestIdentity)" AssemblyVersion="$(_DeploymentManifestVersion)" CreateDesktopShortcut="$(CreateDesktopShortcut)" DeploymentUrl="$(_DeploymentFormattedDeploymentUrl)" Description="$(Description)" DisallowUrlActivation="$(DisallowUrlActivation)" EntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)" ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)" Install="$(Install)" LauncherBasedDeployment="$(_DeploymentLauncherBased)" MapFileExtensions="$(MapFileExtensions)" MaxTargetPath="$(MaxTargetPath)" MinimumRequiredVersion="$(_DeploymentBuiltMinimumRequiredVersion)" OutputManifest="@(DeployManifest)" Platform="$(_DeploymentPlatformTarget)" Product="$(ProductName)" Publisher="$(PublisherName)" SuiteName="$(SuiteName)" SupportUrl="$(_DeploymentFormattedSupportUrl)" TargetCulture="$(TargetCulture)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" TargetFrameworkMoniker="$(_DeploymentManifestTargetFrameworkMoniker)" TrustUrlParameters="$(TrustUrlParameters)" UpdateEnabled="$(UpdateEnabled)" UpdateInterval="$(_DeploymentBuiltUpdateInterval)" UpdateMode="$(UpdateMode)" UpdateUnit="$(_DeploymentBuiltUpdateIntervalUnits)" Condition="'$(GenerateClickOnceManifests)'=='true'">
      <Output TaskParameter="OutputManifest" ItemName="FileWrites" />
    </GenerateDeploymentManifest>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PrepareForRun Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <SkipCopyUnchangedFiles Condition="'$(SkipCopyUnchangedFiles)' == ''">true</SkipCopyUnchangedFiles>
    <UseCommonOutputDirectory Condition="'$(UseCommonOutputDirectory)' == ''">false</UseCommonOutputDirectory>
  </PropertyGroup>
  <!--
    ============================================================
                                        PrepareForRun

    Copy the build outputs to the final directory if they have changed.
    ============================================================
    -->
  <PropertyGroup>
    <PrepareForRunDependsOn>
      CopyFilesToOutputDirectory
    </PrepareForRunDependsOn>
  </PropertyGroup>
  <Target Name="PrepareForRun" DependsOnTargets="$(PrepareForRunDependsOn)" />
  <!--
    ============================================================
                                        CopyFilesToOutputDirectory

    Copy all build outputs, satellites and other necessary files to the final directory.
    ============================================================
    -->
  <PropertyGroup>
    <!-- By default we're not using Hard or Symbolic Links to copy to the output directory, and never when building in VS -->
    <CreateHardLinksForCopyAdditionalFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyAdditionalFilesIfPossible)' == ''">false</CreateHardLinksForCopyAdditionalFilesIfPossible>
    <CreateSymbolicLinksForCopyAdditionalFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)' == ''">false</CreateSymbolicLinksForCopyAdditionalFilesIfPossible>
  </PropertyGroup>
  <Target Name="CopyFilesToOutputDirectory" DependsOnTargets="&#xA;            ComputeIntermediateSatelliteAssemblies;&#xA;            _CopyFilesMarkedCopyLocal;&#xA;            _CopySourceItemsToOutputDirectory;&#xA;            _CopyAppConfigFile;&#xA;            _CopyManifestFiles;&#xA;            _CheckForCompileOutputs;&#xA;            _SGenCheckForOutputs">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateHardLinksForCopyFilesToOutputDirectoryIfPossible>
      <CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)' == ''">false</CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible>
      <ErrorIfLinkFailsForCopyFilesToOutputDirectory Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)' == ''">false</ErrorIfLinkFailsForCopyFilesToOutputDirectory>
    </PropertyGroup>
    <PropertyGroup>
      <CopyBuildOutputToOutputDirectory Condition="'$(CopyBuildOutputToOutputDirectory)'==''">true</CopyBuildOutputToOutputDirectory>
      <CopyOutputSymbolsToOutputDirectory Condition="'$(CopyOutputSymbolsToOutputDirectory)'==''">true</CopyOutputSymbolsToOutputDirectory>
      <CopyDocumentationFileToOutputDirectory Condition="'$(CopyDocumentationFileToOutputDirectory)'==''">true</CopyDocumentationFileToOutputDirectory>
    </PropertyGroup>
    <!-- Copy the build product (.dll or .exe). -->
    <Copy SourceFiles="@(IntermediateAssembly)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="MainAssembly" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the reference assembly build product (.dll or .exe). -->
    <CopyRefAssembly SourcePath="@(IntermediateRefAssembly)" DestinationPath="$(TargetRefPath)" Condition="'$(ProduceReferenceAssembly)' == 'true' and '$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
      <Output TaskParameter="DestinationPath" ItemName="ReferenceAssembly" />
      <Output TaskParameter="DestinationPath" ItemName="FileWrites" />
    </CopyRefAssembly>
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; @(MainAssembly->'%(FullPath)')" Condition="'$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)'!='true'" />
    <!-- Copy the additional modules. -->
    <Copy SourceFiles="@(AddModules)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)" Condition="'@(AddModules)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the serialization assembly if it exists. -->
    <Copy SourceFiles="$(IntermediateOutputPath)$(_SGenDllName)" DestinationFiles="$(OutDir)$(_SGenDllName)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_SGenDllCreated)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the debug information file (.pdb), if any -->
    <Copy SourceFiles="@(_DebugSymbolsIntermediatePath)" DestinationFiles="@(_DebugSymbolsOutputPath)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_DebugSymbolsProduced)'=='true' and '$(SkipCopyingSymbolsToOutputDirectory)' != 'true' and '$(CopyOutputSymbolsToOutputDirectory)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy the resulting XML documentation file, if any. -->
    <Copy SourceFiles="@(DocFileItem)" DestinationFiles="@(FinalDocFile)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(_DocumentationFileProduced)'=='true' and '$(CopyDocumentationFileToOutputDirectory)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Copy satellite assemblies. -->
    <Copy SourceFiles="@(IntermediateSatelliteAssembliesWithTargetPath)" DestinationFiles="@(IntermediateSatelliteAssembliesWithTargetPath->'$(OutDir)%(Culture)\$(TargetName).resources.dll')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'@(IntermediateSatelliteAssembliesWithTargetPath)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!--
        Copy COM reference wrappers, isolated COM references, COM references included by
        native (manifest) references, native (manifest) reference files themselves.
        -->
    <Copy SourceFiles="@(ReferenceComWrappersToCopyLocal); @(ResolvedIsolatedComModules); @(_DeploymentLooseManifestFile); @(NativeReferenceFile)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyAdditionalFilesIfPossible)" Condition="'@(ReferenceComWrappersToCopyLocal)' != '' or '@(ResolvedIsolatedComModules)' != '' or '@(_DeploymentLooseManifestFile)' != '' or '@(NativeReferenceFile)' != '' ">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
    </Copy>
    <!-- Copy the build product of WinMDExp. -->
    <Copy SourceFiles="@(WinMDExpArtifacts)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)" ErrorIfLinkFails="$(ErrorIfLinkFailsForCopyFilesToOutputDirectory)" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '@(WinMDExpArtifacts)' != ''">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
      <Output TaskParameter="DestinationFiles" ItemName="FinalWinmdExpArtifacts" />
    </Copy>
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([System.IO.Path]::GetFullPath('$(_WindowsMetadataOutputPath)'))" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '$(_WindowsMetadataOutputPath)' != ''" />
  </Target>
  <!--
    ============================================================
                                        _CopyFilesMarkedCopyLocal

    Copy references that are marked as "CopyLocal" and their dependencies, including .pdbs, .xmls and satellites.
    ============================================================
    -->
  <Target Name="_CopyFilesMarkedCopyLocal" Condition="'@(ReferenceCopyLocalPaths)' != ''">
    <PropertyGroup>
      <!-- By default we're not using Hard Links to copy to the output directory, and never when building in VS -->
      <CreateHardLinksForCopyLocalIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForCopyLocalIfPossible)' == ''">false</CreateHardLinksForCopyLocalIfPossible>
      <CreateSymbolicLinksForCopyLocalIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForCopyLocalIfPossible)' == ''">false</CreateSymbolicLinksForCopyLocalIfPossible>
    </PropertyGroup>
    <Copy SourceFiles="@(ReferenceCopyLocalPaths)" DestinationFiles="@(ReferenceCopyLocalPaths->'$(OutDir)%(DestinationSubDirectory)%(Filename)%(Extension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyLocalIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyLocalIfPossible)" Condition="'$(UseCommonOutputDirectory)' != 'true'">
      <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable" />
      <Output TaskParameter="CopiedFiles" ItemName="ReferencesCopiedInThisBuild" />
      <Output TaskParameter="WroteAtLeastOneFile" PropertyName="WroteAtLeastOneFile" />
    </Copy>
    <!-- If this project produces reference assemblies *and* copied (possibly transitive)
         references on this build, subsequent builds of projects that depend on it must
         not be considered up to date, so touch this marker file that is considered an
         input to projects that reference this one. -->
    <Touch Files="@(CopyUpToDateMarker)" AlwaysCreate="true" Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'" />
    <ItemGroup>
      <FileWrites Include="@(CopyUpToDateMarker)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopySourceItemsToOutputDirectory
    ============================================================
    -->
  <Target Name="_CopySourceItemsToOutputDirectory" DependsOnTargets="&#xA;            GetCopyToOutputDirectoryItems;&#xA;            _CopyOutOfDateSourceItemsToOutputDirectory;&#xA;            _CopyOutOfDateSourceItemsToOutputDirectoryAlways;&#xA;            _CopyDifferingSourceItemsToOutputDirectory" />
  <!--
    ============================================================
                                        GetCopyToOutputDirectoryItems

    Get all project items that may need to be transferred to the output directory.
    This includes baggage items from transitively referenced projects.

    As of 17.0, content items are copied transitively by default.
    Set `MSBuildCopyContentTransitively` to false to opt out.
    See https://github.com/dotnet/msbuild/pull/6622 for more info.
    ============================================================
    -->
  <PropertyGroup>
    <_TargetsThatPrepareProjectReferences>_SplitProjectReferencesByFileExistence</_TargetsThatPrepareProjectReferences>
    <!--
      GetCopyToOutputDirectoryItems depends on an unspecified dependency _SplitProjectReferencesByFileExistence -> AssignProjectConfiguration (https://github.com/dotnet/msbuild/issues/4677).
      When the unspecified dependency does not happen by accident, content copying is only 1 level deep instead of transitive.
      This target enforces the dependency.
    -->
    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == ''">true</MSBuildCopyContentTransitively>
    <_TargetsThatPrepareProjectReferences Condition=" '$(MSBuildCopyContentTransitively)' == 'true' ">
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence
    </_TargetsThatPrepareProjectReferences>
    <GetCopyToOutputDirectoryItemsDependsOn>
      AssignTargetPaths;
      $(_TargetsThatPrepareProjectReferences);
      _GetProjectReferenceTargetFrameworkProperties;
      _PopulateCommonStateForGetCopyToOutputDirectoryItems
    </GetCopyToOutputDirectoryItemsDependsOn>
    <!--
      Mitigation for https://github.com/dotnet/msbuild/issues/4677
      When MSBuildCopyContentTransitively == true, all content copying is transitive.
      When MSBuildCopyContentTransitively == false, content copying is 1 level deep.
      When MSBuildCopyContentTransitively != {true, false}, the legacy behaviour in https://github.com/dotnet/msbuild/issues/4677 manifests.
     -->
    <_RecursiveTargetForContentCopying>GetCopyToOutputDirectoryItems</_RecursiveTargetForContentCopying>
    <!-- Enforce 1 level deep content copying by replacing the recursive content target with the target that retrieves the content for the current project only. -->
    <_RecursiveTargetForContentCopying Condition=" '$(MSBuildCopyContentTransitively)' == 'false' ">_GetCopyToOutputDirectoryItemsFromThisProject</_RecursiveTargetForContentCopying>
  </PropertyGroup>
  <Target Name="_PopulateCommonStateForGetCopyToOutputDirectoryItems">
    <!-- In the general case, clients need very little of the metadata which is generated by invoking this target on this project and its children.  For those
         cases, we can immediately discard the unwanted metadata, reducing memory usage, particularly in very large and interconnected systems of projects.
         However, if some client does require the original functionality, it is sufficient to set MSBuildDisableGetCopyToOutputDirectoryItemsOptimization to
         a non-empty value and the original behavior will be restored. -->
    <PropertyGroup Condition=" '$(MSBuildDisableGetCopyToOutputDirectoryItemsOptimization)' == '' ">
      <_GCTODIKeepDuplicates>false</_GCTODIKeepDuplicates>
      <_GCTODIKeepMetadata>CopyToOutputDirectory;TargetPath</_GCTODIKeepMetadata>
    </PropertyGroup>
  </Target>
  <Target Name="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences" DependsOnTargets="_PopulateCommonStateForGetCopyToOutputDirectoryItems;_AddOutputPathToGlobalPropertiesToRemove" Returns="@(_CopyToOutputDirectoryTransitiveItems)">
    <!-- Get items from child projects first. -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="$(_RecursiveTargetForContentCopying)" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToOutputDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false' and '$(UseCommonOutputDirectory)' != 'true'" ContinueOnError="$(ContinueOnError)" SkipNonexistentTargets="true" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_AllChildProjectItemsWithTargetPath" />
    </MSBuild>
    <!-- Target outputs must be full paths because they will be consumed by a different project. -->
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_CopyToOutputDirectoryTransitiveItems KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
    <ItemGroup>
      <_AllChildProjectItemsWithTargetPath Remove="@(_AllChildProjectItemsWithTargetPath)" />
    </ItemGroup>
    <!-- Copy paste _GetCopyToOutputDirectoryItemsFromThisProject but keep the items that came from other projects via ProjectReference's OutputItemType metadata -->
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='IfDifferent' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToCopy Include="@(Compile->'%(FullPath)')" Condition="('%(Compile.CopyToOutputDirectory)'=='Always' or '%(Compile.CopyToOutputDirectory)'=='PreserveNewest' or '%(Compile.CopyToOutputDirectory)'=='IfDifferent') AND '%(Compile.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <ItemGroup>
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
      <_CopyToOutputDirectoryTransitiveItems KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''" />
    </ItemGroup>
  </Target>
  <Target Name="_GetCopyToOutputDirectoryItemsFromThisProject" DependsOnTargets="AssignTargetPaths;_PopulateCommonStateForGetCopyToOutputDirectoryItems" Returns="@(_ThisProjectItemsToCopyToOutputDirectory)">
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='IfDifferent' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToCopy Include="@(Compile->'%(FullPath)')" Condition="('%(Compile.CopyToOutputDirectory)'=='Always' or '%(Compile.CopyToOutputDirectory)'=='PreserveNewest' or '%(Compile.CopyToOutputDirectory)'=='IfDifferent') AND '%(Compile.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToCopy)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToCopyWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='IfDifferent'" />
    </ItemGroup>
    <ItemGroup>
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
      <_ThisProjectItemsToCopyToOutputDirectory KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='IfDifferent' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'==''" />
    </ItemGroup>
  </Target>
  <Target Name="GetCopyToOutputDirectoryItems" Returns="@(AllItemsFullPathWithTargetPath)" KeepDuplicateOutputs=" '$(MSBuildDisableGetCopyToOutputDirectoryItemsOptimization)' == '' " DependsOnTargets="$(GetCopyToOutputDirectoryItemsDependsOn)">
    <!-- Compose the content items as the union between transitive content items and content items from this project. -->
    <!-- Use CallTarget to avoid breaking targets that hook right before GetCopyToOutputDirectoryItems but expect to run after _GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences and _GetCopyToOutputDirectoryItemsFromThisProject -->
    <CallTarget Targets="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences">
      <Output TaskParameter="TargetOutputs" ItemName="_TransitiveItemsToCopyToOutputDirectory" />
    </CallTarget>
    <CallTarget Targets="_GetCopyToOutputDirectoryItemsFromThisProject">
      <Output TaskParameter="TargetOutputs" ItemName="_ThisProjectItemsToCopyToOutputDirectory" />
    </CallTarget>
    <ItemGroup Condition="'$(CopyConflictingTransitiveContent)' == 'false'">
      <_TransitiveItemsToCopyToOutputDirectory Remove="@(_ThisProjectItemsToCopyToOutputDirectory)" MatchOnMetadata="TargetPath" MatchOnMetadataOptions="PathLike" />
    </ItemGroup>
    <ItemGroup>
      <_TransitiveItemsToCopyToOutputDirectoryAlways KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='Always'" />
      <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_TransitiveItemsToCopyToOutputDirectoryIfDifferent KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_TransitiveItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='IfDifferent'" />
      <_ThisProjectItemsToCopyToOutputDirectoryAlways KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='Always'" />
      <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='PreserveNewest'" />
      <_ThisProjectItemsToCopyToOutputDirectoryIfDifferent KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_ThisProjectItemsToCopyToOutputDirectory->'%(FullPath)')" Condition="'%(_ThisProjectItemsToCopyToOutputDirectory.CopyToOutputDirectory)'=='IfDifferent'" />
      <!-- Append the items from this project last so that they will be copied last. -->
      <_SourceItemsToCopyToOutputDirectoryAlways Include="@(_TransitiveItemsToCopyToOutputDirectoryAlways);@(_ThisProjectItemsToCopyToOutputDirectoryAlways)" />
      <_SourceItemsToCopyToOutputDirectory Include="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest);@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_SourceItemsToCopyToOutputDirectoryIfDifferent Include="@(_TransitiveItemsToCopyToOutputDirectoryIfDifferent);@(_ThisProjectItemsToCopyToOutputDirectoryIfDifferent)" />
      <AllItemsFullPathWithTargetPath Include="@(_SourceItemsToCopyToOutputDirectoryAlways->'%(FullPath)');@(_SourceItemsToCopyToOutputDirectory->'%(FullPath)');@(_SourceItemsToCopyToOutputDirectoryIfDifferent->'%(FullPath)')" />
      <!-- Empty intermediate items to release memory -->
      <_TransitiveItemsToCopyToOutputDirectoryAlways Remove="@(_TransitiveItemsToCopyToOutputDirectoryAlways)" />
      <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest Remove="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_TransitiveItemsToCopyToOutputDirectoryIfDifferent Remove="@(_TransitiveItemsToCopyToOutputDirectoryIfDifferent)" />
      <_ThisProjectItemsToCopyToOutputDirectoryAlways Remove="@(_ThisProjectItemsToCopyToOutputDirectoryAlways)" />
      <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest Remove="@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)" />
      <_ThisProjectItemsToCopyToOutputDirectory Remove="@(_ThisProjectItemsToCopyToOutputDirectory)" />
      <_ThisProjectItemsToCopyToOutputDirectoryIfDifferent Remove="@(_ThisProjectItemsToCopyToOutputDirectoryIfDifferent)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetCopyToPublishDirectoryItems

    Default implementation of GetCopyToPublishDirectoryItems for projects that do not
    use Microsoft.NET.Sdk. It simply returns whatever GetCopyToOutputDirectoryItems
    does with CopyToPublishDirectory implied  by CopyToOutputDirectory, which is the
    same as Microsoft.NET.Sdk default when its CopyToPublishDirectory is not used.

    Microsoft.NET.Sdk projects  will override this to allow the publish output to be
    customized independently from the build output.

    Having a default implementation here allows the Microsoft.NET.Sdk Publish target
    to work when a Microsoft.NET.Sdk-based project references a non-Microsoft.NET.Sdk-based
    project.
    ============================================================
    -->
  <Target Name="GetCopyToPublishDirectoryItems" DependsOnTargets="GetCopyToOutputDirectoryItems" Returns="@(AllPublishItemsFullPathWithTargetPath)">
    <ItemGroup>
      <AllPublishItemsFullPathWithTargetPath Include="@(AllItemsFullPathWithTargetPath)">
        <CopyToPublishDirectory>%(CopyToOutputDirectory)</CopyToPublishDirectory>
      </AllPublishItemsFullPathWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectory

    Copy files that have the CopyToOutputDirectory attribute set to 'PreserveNewest'.
    ============================================================
    -->
  <Target Name="_CopyOutOfDateSourceItemsToOutputDirectory" Condition=" '@(_SourceItemsToCopyToOutputDirectory)' != '' " Inputs="@(_SourceItemsToCopyToOutputDirectory)" Outputs="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')">
    <!--
        Not using SkipUnchangedFiles="true" because the items we pass in are already only those that have newer timestampts in the source (determined by _GetCopyToOutputDirectoryItemsFromThisProject).
        -->
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectory)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectory->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyOutOfDateSourceItemsToOutputDirectoryAlways

    Copy files that have the CopyToOutputDirectory attribute set to 'Always'.
    ============================================================
    -->
  <Target Name="_CopyOutOfDateSourceItemsToOutputDirectoryAlways" Condition=" '@(_SourceItemsToCopyToOutputDirectoryAlways)' != '' ">
    <!--
        Not using SkipUnchangedFiles="true" by default for backwards compatibility.
        -->
    <PropertyGroup>
      <SkipUnchangedFilesOnCopyAlways Condition="'$(SkipUnchangedFilesOnCopyAlways)' == ''">false</SkipUnchangedFilesOnCopyAlways>
    </PropertyGroup>
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectoryAlways)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectoryAlways->'$(OutDir)%(TargetPath)')" SkipUnchangedFiles="$(SkipUnchangedFilesOnCopyAlways)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyDifferingSourceItemsToOutputDirectory

    Copy files that have the CopyToOutputDirectory attribute set to 'IfDifferent'.
    ============================================================
    -->
  <Target Name="_CopyDifferingSourceItemsToOutputDirectory" Condition=" '@(_SourceItemsToCopyToOutputDirectoryIfDifferent)' != '' ">
    <!--
        Using SkipUnchangedFiles="true" because we want only differing files.
        -->
    <Copy SourceFiles="@(_SourceItemsToCopyToOutputDirectoryIfDifferent)" DestinationFiles="@(_SourceItemsToCopyToOutputDirectoryIfDifferent->'$(OutDir)%(TargetPath)')" SkipUnchangedFiles="true" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyAppConfigFile

    Copy the application config file.
    ============================================================
    -->
  <Target Name="_CopyAppConfigFile" Condition=" '@(AppConfigWithTargetPath)' != '' " Inputs="@(AppConfigWithTargetPath)" Outputs="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')">
    <!--
        Copy the application's .config file, if any.
        Not using SkipUnchangedFiles="true" because the application may want to change
        the app.config and not have an incremental build replace it.
        -->
    <Copy SourceFiles="@(AppConfigWithTargetPath)" DestinationFiles="@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ================================================================
                                         _CopyManifestFiles
    ================================================================

    Copy the built manifests (.exe.manifest, .application/.xbap) to the final directory.
    -->
  <Target Name="_CopyManifestFiles" Condition=" '$(_DeploymentCopyApplicationManifest)'=='true' or '$(GenerateClickOnceManifests)'=='true' " DependsOnTargets="PrepareForBuild">
    <Copy SourceFiles="@(ApplicationManifest)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)" Condition="'$(GenerateClickOnceManifests)'=='true' or '$(_DeploymentCopyApplicationManifest)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainApplicationManifest" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="Normal" Condition="'$(_DeploymentCopyApplicationManifest)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainApplicationManifest->'%(FullPath)')" />
    <Copy SourceFiles="@(DeployManifest)" DestinationFolder="$(OutDir)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForAdditionalFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForAdditionalFilesIfPossible)" Condition="'$(GenerateClickOnceManifests)'=='true'">
      <Output TaskParameter="DestinationFiles" ItemName="_DeploymentMainDeployManifest" />
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Message Importance="Normal" Condition="'$(GenerateClickOnceManifests)'=='true'" Text="$(MSBuildProjectName) -&gt; @(_DeploymentMainDeployManifest->'%(FullPath)')" />
  </Target>
  <!--
    ================================================================
                                         _CheckForCompileOutputs

    Checks each file output from the main "Compile" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
  <Target Name="_CheckForCompileOutputs">
    <!--Record the main compile outputs.-->
    <ItemGroup>
      <FileWrites Include="@(IntermediateAssembly)" Condition="Exists('@(IntermediateAssembly)')" />
      <FileWrites Include="@(IntermediateRefAssembly)" Condition="'$(ProduceReferenceAssembly)' == 'true' and Exists('@(IntermediateRefAssembly)')" />
    </ItemGroup>
    <!-- Record the .xml if one was produced. -->
    <PropertyGroup>
      <_DocumentationFileProduced Condition="!Exists('@(DocFileItem)')">false</_DocumentationFileProduced>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(DocFileItem)" Condition="'$(_DocumentationFileProduced)'=='true'" />
    </ItemGroup>
    <!-- Record the .pdb if one was produced. -->
    <PropertyGroup>
      <_DebugSymbolsProduced Condition="!Exists('@(_DebugSymbolsIntermediatePath)')">false</_DebugSymbolsProduced>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _SGenCheckForOutputs

    Checks each file output from the "GenerateSerializationAssemblies" target to make sure they really exist.
    If they do, then record them in the clean cache.
    ============================================================
    -->
  <Target Name="_SGenCheckForOutputs" Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')">
    <!-- Record the serializer .dll if one was produced.-->
    <PropertyGroup>
      <_SGenDllCreated Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')">true</_SGenDllCreated>
    </PropertyGroup>
    <ItemGroup>
      <FileWrites Include="$(IntermediateOutputPath)$(_SGenDllName)" Condition="Exists('$(IntermediateOutputPath)$(_SGenDllName)')" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                UnmanagedRegistration Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        UnmanagedRegistration

    Registers the main assembly for COM interop.
    ============================================================
    -->
  <PropertyGroup>
    <UnmanagedRegistrationDependsOn />
  </PropertyGroup>
  <Target Name="UnmanagedRegistration" Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'" DependsOnTargets="$(UnmanagedRegistrationDependsOn)">
    <PropertyGroup>
      <RegisterAssemblyMSBuildArchitecture Condition="'$(RegisterAssemblyMSBuildArchitecture)' == ''">$(PlatformTargetAsMSBuildArchitecture)</RegisterAssemblyMSBuildArchitecture>
    </PropertyGroup>
    <PropertyGroup Condition="'$(TargetFrameworkAsMSBuildRuntime)' != '' and '$(RegisterAssemblyMSBuildArchitecture)' != ''">
      <!-- Falling back to the current runtime if we are targeting CLR2 and the task host doesn't exist will lead to
           incorrect behavior in some cases, but it's the same incorrect behavior as Visual Studio 2010, and thus better
           than causing build breaks on upgrade to Win8 the way not doing so would.  For more details, see the
           corresponding comment in GenerateResource. -->
      <RegisterAssemblyMSBuildRuntime Condition="'$(RegisterAssemblyMSBuildRuntime)' == '' and&#xA;                     $([MSBuild]::DoesTaskHostExist(`$(TargetFrameworkAsMSBuildRuntime)`, `$(RegisterAssemblyMSBuildArchitecture)`))">$(TargetFrameworkAsMSBuildRuntime)</RegisterAssemblyMSBuildRuntime>
      <!-- If the targeted runtime doesn't exist, fall back to current -->
      <RegisterAssemblyMSBuildRuntime Condition="'$(RegisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</RegisterAssemblyMSBuildRuntime>
    </PropertyGroup>
    <RegisterAssembly Assemblies="@(_OutputPathItem->'%(FullPath)$(TargetFileName)')" TypeLibFiles="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')" AssemblyListFile="@(_UnmanagedRegistrationCache)" CreateCodeBase="true" MSBuildRuntime="$(RegisterAssemblyMSBuildRuntime)" MSBuildArchitecture="$(RegisterAssemblyMSBuildArchitecture)" Condition="!Exists('@(_UnmanagedRegistrationCache)')" />
    <ItemGroup>
      <FileWrites Include="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                IncrementalClean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        IncrementalClean

    Remove files that were produced in a prior build but weren't produced in the current build.
    The reason is that if, for example, the name of the .exe has changed we want to delete the
    old copy.

    Leave the Clean cache file containing only the files produced in the current build.
    ============================================================
    -->
  <Target Name="IncrementalClean" DependsOnTargets="$(IncrementalCleanDependsOn);_CleanGetCurrentAndPriorFileWrites">
    <!-- Subtract list of files produced in prior builds from list of files produced in this build. -->
    <ItemGroup>
      <_CleanOrphanFileWrites Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanCurrentFileWrites)" />
    </ItemGroup>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanOrphanFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(_CleanOrphanFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanOrphanFileWritesInIntermediate" />
    </FindUnderPath>
    <!-- Delete the orphaned files. -->
    <Delete Files="@(_CleanOrphanFileWritesInIntermediate);@(_CleanOrphanFileWritesInOutput)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanOrphanFilesDeleted" />
    </Delete>
    <!-- Create a list of everything that wasn't deleted or was outside
             the current final output and intermediate output directories. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterIncrementalClean Include="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)" Exclude="@(_CleanOrphanFilesDeleted)" />
    </ItemGroup>
    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterIncrementalClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWritesAfterIncrementalClean" />
    </RemoveDuplicates>
    <!-- Write new list of current files back to disk, replacing the existing list.-->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)" Condition="'@(_CleanUnfilteredPriorFileWrites)'!='@(_CleanUniqueRemainingFileWritesAfterIncrementalClean)'" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _CleanGetCurrentAndPriorFileWrites

    Get the list of files built in the current build and in prior builds.
    ============================================================
    -->
  <Target Name="_CleanGetCurrentAndPriorFileWrites" DependsOnTargets="_CheckForCompileOutputs;_SGenCheckForOutputs">
    <!-- Read the list of files produced by a prior builds from disk. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanUnfilteredPriorFileWrites" />
    </ReadLinesFromFile>
    <!--
        Convert the list of references to the absolute paths so we can make valid comparisons
        across two lists
         -->
    <ConvertToAbsolutePath Paths="@(_ResolveAssemblyReferenceResolvedFiles)">
      <Output TaskParameter="AbsolutePaths" ItemName="_ResolveAssemblyReferenceResolvedFilesAbsolute" />
    </ConvertToAbsolutePath>
    <!--
        Subtract any resolved assembly files from *prior* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.
         -->
    <ItemGroup>
      <_CleanPriorFileWrites Include="@(_CleanUnfilteredPriorFileWrites)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)" />
    </ItemGroup>
    <!--
        Of shareable files, keep only those that are in the project's directory.
        We never clean shareable files outside of the project directory because
        the build may be to a common output directory and other projects may need
        them.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
        -->
    <FindUnderPath Path="$(MSBuildProjectDirectory)" Files="@(FileWritesShareable)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="FileWrites" />
    </FindUnderPath>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(FileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_CleanCurrentFileWritesInIntermediate" />
    </FindUnderPath>
    <!--
        Subtract any resolved assembly files from *current* file writes because deleting
        these would break subsequent builds because the assemblies would be unresolvable.

        Only subtract the outputs from ResolveAssemblyReferences target because that's the
        only "Resolve" target that tries to resolve assemblies directly from the output
        directory.
         -->
    <ItemGroup>
      <_CleanCurrentFileWritesWithNoReferences Include="@(_CleanCurrentFileWritesInOutput);@(_CleanCurrentFileWritesInIntermediate)" Exclude="@(_ResolveAssemblyReferenceResolvedFilesAbsolute)" />
    </ItemGroup>
    <!-- Remove duplicates from files produced in this build. -->
    <RemoveDuplicates Inputs="@(_CleanCurrentFileWritesWithNoReferences)">
      <Output TaskParameter="Filtered" ItemName="_CleanCurrentFileWrites" />
    </RemoveDuplicates>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Clean Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        Clean

    Delete all intermediate and final build outputs.
    ============================================================
    -->
  <PropertyGroup>
    <CleanDependsOn>
      BeforeClean;
      UnmanagedUnregistration;
      CoreClean;
      CleanReferencedProjects;
      CleanPublishFolder;
      AfterClean
    </CleanDependsOn>
  </PropertyGroup>
  <Target Name="Clean" Condition=" '$(_InvalidConfigurationWarning)' != 'true' " DependsOnTargets="$(CleanDependsOn)" />
  <!--
    ============================================================
                                        BeforeClean

    Redefine this target in your project in order to run tasks just before Clean.
    ============================================================
    -->
  <Target Name="BeforeClean" />
  <!--
    ============================================================
                                        AfterClean

    Redefine this target in your project in order to run tasks just after Clean.
    ============================================================
    -->
  <Target Name="AfterClean" />
  <!--
    ============================================================
                                        CleanReferencedProjects

    Call Clean target on all Referenced Projects.
    ============================================================
    -->
  <Target Name="CleanReferencedProjects" DependsOnTargets="PrepareProjectReferences">
    <!--
        When building the project directly from the command-line, clean those referenced projects
        that exist on disk.  For IDE builds and command-line .SLN builds, the solution build manager
        takes care of this.
        -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="Clean" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" BuildInParallel="$(BuildInParallel)" Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)" />
  </Target>
  <!--
    ============================================================
                                        CoreClean
    ============================================================
    -->
  <PropertyGroup>
    <CoreCleanDependsOn />
  </PropertyGroup>
  <Target Name="CoreClean" DependsOnTargets="$(CoreCleanDependsOn)">
    <!-- First clean any explicitly specified cleanable files.
             Declare items of this type if you want Clean to delete them. -->
    <Delete Files="@(Clean)" TreatErrorsAsWarnings="true" />
    <!-- Read in list of files that were written to disk in past builds. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(CleanFile)">
      <Output TaskParameter="Lines" ItemName="_CleanPriorFileWrites" />
    </ReadLinesFromFile>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(OutDir)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInOutput" />
    </FindUnderPath>
    <!-- Find all files in the intermediate output directory. -->
    <FindUnderPath Path="$(IntermediateOutputPath)" Files="@(_CleanPriorFileWrites)">
      <Output TaskParameter="InPath" ItemName="_CleanPriorFileWritesInIntermediate" />
    </FindUnderPath>
    <!-- Delete those files. -->
    <Delete Files="@(_CleanPriorFileWritesInOutput);@(_CleanPriorFileWritesInIntermediate)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_CleanPriorFileWritesDeleted" />
    </Delete>
    <!-- Create a list of everything that wasn't deleted. -->
    <ItemGroup>
      <_CleanRemainingFileWritesAfterClean Include="@(_CleanPriorFileWrites)" Exclude="@(_CleanPriorFileWritesDeleted)" />
    </ItemGroup>
    <!-- Remove duplicates. -->
    <RemoveDuplicates Inputs="@(_CleanRemainingFileWritesAfterClean)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueRemainingFileWrites" />
    </RemoveDuplicates>
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)" />
    <!-- Write new list of current files back to disk. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueRemainingFileWrites)" WriteOnlyWhenDifferent="true" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _CleanRecordFileWrites

    Save the list of all files written to disk so that it can be used for "Clean" later.

    Files written in prior builds are not removed from Clean cache.
    ============================================================
    -->
  <Target Name="_CleanRecordFileWrites" DependsOnTargets="_CleanGetCurrentAndPriorFileWrites">
    <!--
        Merge list of files from prior builds with the current build and then
        remove duplicates.
        -->
    <RemoveDuplicates Inputs="@(_CleanPriorFileWrites);@(_CleanCurrentFileWrites)">
      <Output TaskParameter="Filtered" ItemName="_CleanUniqueFileWrites" />
    </RemoveDuplicates>
    <!-- Make sure the directory exists. -->
    <MakeDir Directories="$(IntermediateOutputPath)" />
    <!-- Write merged file list back to disk, replacing existing contents. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(CleanFile)" Lines="@(_CleanUniqueFileWrites)" Overwrite="true" WriteOnlyWhenDifferent="true" />
  </Target>
  <!--
    ============================================================
                                        CleanPublishFolder
    ============================================================
    -->
  <Target Name="CleanPublishFolder">
    <RemoveDir Directories="$(ClickOncePublishDir)" Condition="'$(ClickOncePublishDir)'=='$(OutputPath)app.publish\' and Exists('$(ClickOncePublishDir)')" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                PostBuildEvent Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        PostBuildEvent

    Run the post-build event. This step is driven by two parameters:

    (1) The $(RunPostBuildEvent) property is set by the user through the IDE and can be one of four values.

        - OnBuildSuccess: In this case, every step of the build must succeed for the post-build step to run.
        - <Blank>: This is the same as OnBuildSuccess.
        - OnOutputUpdated: In this case, the post-build step will run only if the main output assembly was
        actually updated.
        - Always: The post-build step is always run.

    (2) The $(_AssemblyTimestampBeforeCompile) and $(_AssemblyTimestampAfterCompile) values are
        set by the _TimeStampBeforeCompile and _TimeStampAfterCompile targets.  If the assembly was actually
        rebuilt during this build, then the two values will be different.
    ============================================================
    -->
  <PropertyGroup>
    <PostBuildEventDependsOn />
  </PropertyGroup>
  <Target Name="PostBuildEvent" Condition="'$(PostBuildEvent)' != '' and ('$(RunPostBuildEvent)' != 'OnOutputUpdated' or '$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)')" DependsOnTargets="$(PostBuildEventDependsOn)">
    <Exec WorkingDirectory="$(OutDir)" Command="$(PostBuildEvent)" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                Publish Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <DeploymentComputeClickOnceManifestInfoDependsOn>
      CleanPublishFolder;
      $(_RecursiveTargetForContentCopying);
      _DeploymentGenerateTrustInfo;
      $(DeploymentComputeClickOnceManifestInfoDependsOn)
    </DeploymentComputeClickOnceManifestInfoDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        Publish

    This target is only called when doing ClickOnce publishing outside the IDE, which implicitly builds before publishing.
    ============================================================
    -->
  <PropertyGroup>
    <PublishDependsOn Condition="'$(PublishableProject)'=='true'">
      SetGenerateManifests;
      Build;
      PublishOnly
    </PublishDependsOn>
    <PublishDependsOn Condition="'$(PublishableProject)'!='true'">
      _DeploymentUnpublishable
    </PublishDependsOn>
  </PropertyGroup>
  <Target Name="Publish" DependsOnTargets="$(PublishDependsOn)" />
  <!--
    ============================================================
                                        _DeploymentUnpublishable

    This target is used to block an attempt to ClickOnce publish a non-publishable project, such as a ClassLibrary, when building outside the IDE.
    ============================================================
    -->
  <Target Name="_DeploymentUnpublishable">
    <MSBuildInternalMessage ResourceName="CommonSdk.DeploymentUnpublishable" Severity="Message" />
  </Target>
  <!--
    ============================================================
                                        SetGenerateManifests

    This target simply assures the GenerateClickOnceManifests property is set whenever the publish target is invoked.
    ============================================================
    -->
  <Target Name="SetGenerateManifests">
    <MSBuildInternalMessage Condition="'$(OutputType)'!='winexe' and '$(OutputType)'!='exe' and '$(OutputType)'!='appcontainerexe'" ResourceName="CommonSdk.GenerateManifestsOnlyForExe" Severity="Error" />
    <MSBuildInternalMessage Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(ManifestCertificateThumbprint)'=='' and '$(ManifestKeyFile)'==''" ResourceName="CommonSdk.SigningKeyRequired" Severity="Error" />
    <PropertyGroup>
      <GenerateClickOnceManifests>true</GenerateClickOnceManifests>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        PublishOnly

    The "PublishOnly" target is intended for ClickOnce publishing inside the IDE, where the build has already been done
    by the BuildManager.
    ============================================================
    -->
  <PropertyGroup>
    <PublishOnlyDependsOn>
      SetGenerateManifests;
      PublishBuild;
      BeforePublish;
      GenerateManifests;
      CopyFilesToOutputDirectory;
      _CopyFilesToPublishFolder;
      _DeploymentGenerateBootstrapper;
      ResolveKeySource;
      _DeploymentSignClickOnceDeployment;
      AfterPublish
    </PublishOnlyDependsOn>
  </PropertyGroup>
  <Target Name="PublishOnly" DependsOnTargets="$(PublishOnlyDependsOn)" />
  <!--
    ============================================================
                                        BeforePublish

    Redefine this target in your project in order to run tasks just before Publish.
    ============================================================
    -->
  <Target Name="BeforePublish" />
  <!--
    ============================================================
                                        AfterPublish

    Redefine this target in your project in order to run tasks just after Publish.
    ============================================================
    -->
  <Target Name="AfterPublish" />
  <!--
    ============================================================
                                        PublishBuild

    Defines the set of targets that publishing is directly dependent on.
    ============================================================
    -->
  <PropertyGroup>
    <PublishBuildDependsOn>
      BuildOnlySettings;
      PrepareForBuild;
      ResolveReferences;
      PrepareResources;
      ResolveKeySource;
      GenerateSerializationAssemblies;
      CreateSatelliteAssemblies;
    </PublishBuildDependsOn>
  </PropertyGroup>
  <Target Name="PublishBuild" DependsOnTargets="$(PublishBuildDependsOn)" />
  <!--
    ============================================================
                                        _CopyFilesToPublishFolder
    ============================================================
    -->
  <Target Name="_CopyFilesToPublishFolder">
    <!-- Compute name of application folder, which includes the assembly name plus formatted application version.
             The application version is formatted to use "_" in place of "." chars (i.e. "1_0_0_0" instead of "1.0.0.0").
             This is done because some servers misinterpret "." as a file extension. -->
    <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)" FormatType="Path">
      <Output TaskParameter="OutputVersion" PropertyName="_DeploymentApplicationVersionFragment" />
    </FormatVersion>
    <PropertyGroup>
      <_DeploymentApplicationFolderName>Application Files\$(AssemblyName)_$(_DeploymentApplicationVersionFragment)</_DeploymentApplicationFolderName>
      <_DeploymentApplicationDir>$(ClickOncePublishDir)$(_DeploymentApplicationFolderName)\</_DeploymentApplicationDir>
    </PropertyGroup>
    <PropertyGroup>
      <!-- By default we're not using Hard or Symbolic Links to copy to the publish directory, and never when building in VS -->
      <CreateHardLinksForPublishFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateHardLinksForPublishFilesIfPossible)' == ''">false</CreateHardLinksForPublishFilesIfPossible>
      <CreateSymbolicLinksForPublishFilesIfPossible Condition="'$(BuildingInsideVisualStudio)' == 'true' or '$(CreateSymbolicLinksForPublishFilesIfPossible)' == ''">false</CreateSymbolicLinksForPublishFilesIfPossible>
    </PropertyGroup>
    <!-- Copy files to publish folder -->
    <Copy Condition="'$(PublishSingleFile)' != 'true'" SourceFiles="@(_ApplicationManifestFinal);&#xA;                @(_DeploymentResolvedManifestEntryPoint);&#xA;                @(_DeploymentManifestFiles);&#xA;                @(ReferenceComWrappersToCopyLocal);&#xA;                @(ResolvedIsolatedComModules);&#xA;                @(_DeploymentLooseManifestFile)" DestinationFiles="@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');&#xA;                @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xA;                @(_DeploymentManifestFiles->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xA;                @(ReferenceComWrappersToCopyLocal->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');&#xA;                @(ResolvedIsolatedComModules->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)');&#xA;                @(_DeploymentLooseManifestFile->'$(_DeploymentApplicationDir)%(FileName)%(Extension)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" />
    <Copy SourceFiles="@(_DeploymentManifestDependencies)" DestinationFiles="@(_DeploymentManifestDependencies->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" Condition="'$(PublishSingleFile)' != 'true' and '%(_DeploymentManifestDependencies.DependencyType)'=='Install'" />
    <Copy Condition="'$(PublishSingleFile)' != 'true'" SourceFiles="@(_ReferenceScatterPaths)" DestinationFiles="@(_ReferenceScatterPaths->'$(_DeploymentApplicationDir)%(Filename)%(Extension)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" />
    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
      <PublishedSingleFileToBeCopied Include="@(_DeploymentManifestFiles)" />
    </ItemGroup>
    <!-- For single-file publish case, we need to only copy the clickonce manifest, manifest entry point (launcher) and the SF EXE -->
    <Copy Condition="'$(PublishSingleFile)' == 'true'" SourceFiles="@(_ApplicationManifestFinal);&#xA;                 @(_DeploymentResolvedManifestEntryPoint);&#xA;                 @(PublishedSingleFileToBeCopied);" DestinationFiles="@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');&#xA;                 @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');&#xA;                 @(PublishedSingleFileToBeCopied->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" />
    <FormatUrl InputUrl="$(_DeploymentApplicationUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedApplicationUrl" />
    </FormatUrl>
    <FormatUrl InputUrl="$(_DeploymentComponentsUrl)">
      <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedComponentsUrl" />
    </FormatUrl>
  </Target>
  <!--
    ============================================================
                                        _DeploymentGenerateBootstrapper
    ============================================================
    -->
  <Target Name="_DeploymentGenerateBootstrapper">
    <!-- Build setup.exe bootstrapper and copy referenced packages -->
    <GenerateBootstrapper ApplicationFile="$(TargetDeployManifestFileName)" ApplicationName="$(AssemblyName)" ApplicationUrl="$(_DeploymentFormattedApplicationUrl)" BootstrapperItems="@(BootstrapperPackage)" ComponentsLocation="$(BootstrapperComponentsLocation)" ComponentsUrl="$(_DeploymentFormattedComponentsUrl)" Culture="$(TargetCulture)" FallbackCulture="$(FallbackCulture)" OutputPath="$(ClickOncePublishDir)" SupportUrl="$(_DeploymentFormattedSupportUrl)" Path="$(GenerateBootstrapperSdkPath)" VisualStudioVersion="$(VisualStudioVersion)" Condition="'$(BootstrapperEnabled)'=='true'" />
  </Target>
  <!--
    ============================================================
                                        _DeploymentSignClickOnceDeployment
    ============================================================
    -->
  <Target Name="_DeploymentSignClickOnceDeployment">
    <!-- Sign manifests and the bootstrapper -->
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)" DisallowMansignTimestampFallback="$(DisallowMansignTimestampFallback)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <!-- Update entry point path in deploy manifest -->
    <UpdateManifest ApplicationPath="$(_DeploymentApplicationFolderName)\$(_DeploymentTargetApplicationManifestFileName)" TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)" ApplicationManifest="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)" InputManifest="$(OutDir)$(TargetDeployManifestFileName)" OutputManifest="$(ClickOncePublishDir)$(TargetDeployManifestFileName)">
      <Output TaskParameter="OutputManifest" ItemName="PublishedDeployManifest" />
    </UpdateManifest>
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(ClickOncePublishDir)$(TargetDeployManifestFileName)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)" DisallowMansignTimestampFallback="$(DisallowMansignTimestampFallback)" Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
    <SignFile CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)" TimestampUrl="$(ManifestTimestampUrl)" SigningTarget="$(ClickOncePublishDir)setup.exe" Condition="'$(BootstrapperEnabled)'=='true' and '$(_DeploymentSignClickOnceManifests)'=='true'" />
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroups Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        AllProjectOutputGroups

    The targets below drive output groups, which provide generic information about a
    project's inputs (e.g., content files, compilation sources, etc.) and built outputs
    (e.g., built EXE/DLL, PDB, XML documentation files, etc.)

    Each target may produce two kinds of items:  outputs and dependencies.  Outputs are
    items from the current project; dependencies are items that are brought into the
    current project as a result of referencing other projects or components.

    For both outputs and dependencies, the Include attribute
    specifies the location of the output/dependency; it must be a full path.  Any number
    of additional attributes may be placed on an output/dependency item.
    ============================================================
    -->
  <Target Name="AllProjectOutputGroups" DependsOnTargets="&#xA;            BuiltProjectOutputGroup;&#xA;            DebugSymbolsProjectOutputGroup;&#xA;            DocumentationProjectOutputGroup;&#xA;            SatelliteDllsProjectOutputGroup;&#xA;            SourceFilesProjectOutputGroup;&#xA;            ContentFilesProjectOutputGroup;&#xA;            SGenFilesOutputGroup" />
  <!--
    This is the key output for the BuiltProjectOutputGroup and is meant to be read directly from the IDE.
    Reading an item is faster than invoking a target.
    -->
  <ItemGroup Condition=" '$(OutputType)' != 'winmdobj' ">
    <BuiltProjectOutputGroupKeyOutput Include="@(IntermediateAssembly->'%(FullPath)')">
      <IsKeyOutput>true</IsKeyOutput>
      <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      <TargetPath>$(TargetFileName)</TargetPath>
      <COM2REG Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'">true</COM2REG>
    </BuiltProjectOutputGroupKeyOutput>
  </ItemGroup>
  <ItemGroup Condition=" '$(OutputType)' == 'winmdobj' ">
    <WinMDExpOutputWindowsMetadataFileItem Include="$(_IntermediateWindowsMetadataPath)" Condition="'$(_IntermediateWindowsMetadataPath)' != ''" />
    <BuiltProjectOutputGroupKeyOutput Include="@(WinMDExpOutputWindowsMetadataFileItem->'%(FullPath)')">
      <IsKeyOutput>true</IsKeyOutput>
      <FinalOutputPath>$(TargetPath)</FinalOutputPath>
      <TargetPath>$(TargetFileName)</TargetPath>
    </BuiltProjectOutputGroupKeyOutput>
  </ItemGroup>
  <!--
    ============================================================
                                        BuiltProjectOutputGroup
    ============================================================
    -->
  <PropertyGroup>
    <BuiltProjectOutputGroupDependsOn>PrepareForBuild</BuiltProjectOutputGroupDependsOn>
    <AddAppConfigToBuildOutputs Condition="('$(AddAppConfigToBuildOutputs)'=='') and ('$(OutputType)'!='library' and '$(OutputType)'!='winmdobj')">true</AddAppConfigToBuildOutputs>
  </PropertyGroup>
  <Target Name="BuiltProjectOutputGroup" Returns="@(BuiltProjectOutputGroupOutput)" DependsOnTargets="$(BuiltProjectOutputGroupDependsOn)">
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="@(BuiltProjectOutputGroupKeyOutput)" />
    </ItemGroup>
    <!-- This item represents the app.config file -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(AppConfig)" Condition="'$(AddAppConfigToBuildOutputs)'=='true'">
        <FinalOutputPath>$(TargetDir)$(TargetFileName).config</FinalOutputPath>
        <TargetPath>$(TargetFileName).config</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(AppConfig)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <ItemGroup>
      <_IsolatedComReference Include="@(COMReference)" Condition=" '%(COMReference.Isolated)' == 'true' " />
      <_IsolatedComReference Include="@(COMFileReference)" Condition=" '%(COMFileReference.Isolated)' == 'true' " />
    </ItemGroup>
    <!-- This item represents the native manifest, example: WindowsApplication1.exe.manifest or Native.ClassLibrary1.manifest -->
    <ItemGroup>
      <_BuiltProjectOutputGroupOutputIntermediate Include="$(OutDir)$(_DeploymentTargetApplicationManifestFileName)" Condition="('@(NativeReference)'!='' or '@(_IsolatedComReference)'!='') And Exists('$(OutDir)$(_DeploymentTargetApplicationManifestFileName)')">
        <TargetPath>$(_DeploymentTargetApplicationManifestFileName)</TargetPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(OutDir)$(_DeploymentTargetApplicationManifestFileName)</OriginalItemSpec>
      </_BuiltProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item -->
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="@(_BuiltProjectOutputGroupOutputIntermediate->'%(FullPath)')">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec Condition="'%(_BuiltProjectOutputGroupOutputIntermediate.OriginalItemSpec)' == ''">%(_BuiltProjectOutputGroupOutputIntermediate.FullPath)</OriginalItemSpec>
      </BuiltProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroup

    This target performs population of the Debug Symbols project output group.
    ============================================================
    -->
  <PropertyGroup>
    <DebugSymbolsProjectOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' != 'winmdobj'">
    <DebugSymbolsProjectOutputGroupOutput Include="@(_DebugSymbolsIntermediatePath->'%(FullPath)')">
      <FinalOutputPath>@(_DebugSymbolsOutputPath->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</TargetPath>
    </DebugSymbolsProjectOutputGroupOutput>
  </ItemGroup>
  <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' == 'winmdobj'">
    <WinMDExpOutputPdbItem Include="$(WinMDExpOutputPdb)" Condition="'$(WinMDExpOutputPdb)' != ''" />
    <WinMDExpFinalOutputPdbItem Include="$(_WinMDDebugSymbolsOutputPath)" Condition="'$(_WinMDDebugSymbolsOutputPath)' != ''" />
    <DebugSymbolsProjectOutputGroupOutput Include="@(WinMDExpOutputPdbItem->'%(FullPath)')">
      <FinalOutputPath>@(WinMDExpFinalOutputPdbItem->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(WinMDExpOutputPdbItem->'%(Filename)%(Extension)')</TargetPath>
    </DebugSymbolsProjectOutputGroupOutput>
  </ItemGroup>
  <Target Name="DebugSymbolsProjectOutputGroup" Returns="@(DebugSymbolsProjectOutputGroupOutput)" DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependsOn)" />
  <!--
    ============================================================
                                        DocumentationProjectOutputGroup

    This target performs population of the Documentation project output group.
    ============================================================
    -->
  <PropertyGroup>
    <DocumentationProjectOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(DocumentationFile)'!='' and '$(OutputType)' != 'winmdobj'">
    <DocumentationProjectOutputGroupOutput Include="@(DocFileItem->'%(FullPath)')">
      <FinalOutputPath>@(FinalDocFile->'%(FullPath)')</FinalOutputPath>
      <IsKeyOutput>true</IsKeyOutput>
      <TargetPath>@(DocFileItem->'%(Filename)%(Extension)')</TargetPath>
    </DocumentationProjectOutputGroupOutput>
  </ItemGroup>
  <ItemGroup Condition="'$(DocumentationFile)' != '' and '$(OutputType)' == 'winmdobj'">
    <WinMDOutputDocumentationFileItem Include="$(WinMDOutputDocumentationFile)" Condition="'$(WinMDOutputDocumentationFile)' != ''" />
    <WinMDExpFinalOutputDocItem Include="$(_WinMDDocFileOutputPath)" Condition="'$(_WinMDDocFileOutputPath)' != ''" />
    <DocumentationProjectOutputGroupOutput Include="@(WinMDOutputDocumentationFileItem->'%(FullPath)')">
      <FinalOutputPath>@(WinMDExpFinalOutputDocItem->'%(FullPath)')</FinalOutputPath>
      <TargetPath>@(WinMDOutputDocumentationFileItem->'%(Filename)%(Extension)')</TargetPath>
    </DocumentationProjectOutputGroupOutput>
  </ItemGroup>
  <Target Name="DocumentationProjectOutputGroup" Returns="@(DocumentationProjectOutputGroupOutput)" DependsOnTargets="$(DocumentationProjectOutputGroupDependsOn)" />
  <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroup

    This target performs population of the Satellite Files project output group.
    ============================================================
    -->
  <PropertyGroup>
    <SatelliteDllsProjectOutputGroupDependsOn>$(SatelliteDllsProjectOutputGroupDependsOn);PrepareForBuild;PrepareResourceNames</SatelliteDllsProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SatelliteDllsProjectOutputGroup" Returns="@(SatelliteDllsProjectOutputGroupOutput)" DependsOnTargets="$(SatelliteDllsProjectOutputGroupDependsOn)">
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupOutputIntermediate Include="$(IntermediateOutputPath)%(EmbeddedResource.Culture)\$(TargetName).resources.dll" Condition="'%(EmbeddedResource.WithCulture)' == 'true'">
        <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
        <Culture>%(EmbeddedResource.Culture)</Culture>
      </SatelliteDllsProjectOutputGroupOutputIntermediate>
    </ItemGroup>
    <!-- Convert intermediate items into final items; this way we can get the full path for each item. -->
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupOutput Include="@(SatelliteDllsProjectOutputGroupOutputIntermediate->'%(FullPath)')">
        <FinalOutputPath Condition=" '%(SatelliteDllsProjectOutputGroupOutputIntermediate.FinalOutputPath)' == '' ">$(TargetDir)%(SatelliteDllsProjectOutputGroupOutputIntermediate.TargetPath)</FinalOutputPath>
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>%(SatelliteDllsProjectOutputGroupOutputIntermediate.Identity)</OriginalItemSpec>
      </SatelliteDllsProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SourceFilesProjectOutputGroup

    This target performs population of the Source Files project output group.
    Source files are items in the project whose type is "Compile" and "EmbeddedResource".
    ============================================================
    -->
  <PropertyGroup>
    <SourceFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</SourceFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="SourceFilesProjectOutputGroup" Returns="@(SourceFilesProjectOutputGroupOutput)" DependsOnTargets="$(SourceFilesProjectOutputGroupDependsOn)">
    <AssignTargetPath Files="@(Compile)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <!-- First we deal with Compile, EmbeddedResource and AppConfig -->
      <SourceFilesProjectOutputGroupOutput Include="@(_CompileWithTargetPath->'%(FullPath)');@(EmbeddedResource->'%(FullPath)');@(_LicxFile->'%(FullPath)');@(AppConfigWithTargetPath->'%(FullPath)')" />
      <!-- Include the project file -->
      <SourceFilesProjectOutputGroupOutput Include="$(MSBuildProjectFullPath)">
        <!-- For compatibility with 2.0 -->
        <OriginalItemSpec>$(MSBuildProjectFullPath)</OriginalItemSpec>
        <TargetPath>$(ProjectFileName)</TargetPath>
      </SourceFilesProjectOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!-- Get just the compile items -->
  <Target Name="GetCompile" Returns="@(Compile)" />
  <!--
    ============================================================
                                        ContentFilesProjectOutputGroup

    This target performs population of the Content Files project output group.
    Content files are items in the project whose type is "Content".
    ============================================================
    -->
  <PropertyGroup>
    <ContentFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</ContentFilesProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ContentFilesProjectOutputGroup" Returns="@(ContentFilesProjectOutputGroupOutput)" DependsOnTargets="$(ContentFilesProjectOutputGroupDependsOn)">
    <!-- Convert items into final items; this way we can get the full path for each item. -->
    <ItemGroup>
      <ContentFilesProjectOutputGroupOutput Include="@(ContentWithTargetPath->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SGenFilesOutputGroup

    This target performs population of the GenerateSerializationAssemblies Files project output group.
    GenerateSerializationAssemblies files are those generated by the GenerateSerializationAssemblies target and task.
    ============================================================
    -->
  <PropertyGroup>
    <SGenFilesOutputGroupDependsOn />
  </PropertyGroup>
  <ItemGroup Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')">
    <SGenFilesOutputGroupOutput Include="@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')">
      <FinalOutputPath>@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')</FinalOutputPath>
      <TargetPath>$(_SGenDllName)</TargetPath>
    </SGenFilesOutputGroupOutput>
  </ItemGroup>
  <Target Name="SGenFilesOutputGroup" Returns="@(SGenFilesOutputGroupOutput)" DependsOnTargets="$(SGenFilesOutputGroupDependsOn)" />
  <!--
    ============================================================
                                        SDKRelated Output groups

    These targets are to gather information from the SDKs.
    ============================================================
   -->
  <!-- Get the resolved SDK reference items -->
  <Target Name="GetResolvedSDKReferences" DependsOnTargets="ResolveSDKReferences" Returns="@(ResolvedSDKReference)" />
  <!-- Target will return no results by default but will be populated by other targets elsewhere.
       Needed for certain build environments that import partial sets of targets. -->
  <Target Name="CollectReferencedNuGetPackages" Returns="@(ReferencedNuGetPackages)" />
  <!-- Get the TargetFrameworks that are supported for the Visual Studio TargetFramework drop down -->
  <Target Name="GenerateSupportedTargetFrameworkAlias" Returns="@(SupportedTargetFrameworkAlias)" />
  <!--
    ============================================================
                                        PriFilesOutputGroup

    This target performs population of the pri files output group
    ============================================================
    -->
  <Target Name="PriFilesOutputGroup" Condition="'@(_ReferenceRelatedPaths)' != ''" DependsOnTargets="BuildOnlySettings;PrepareForBuild;AssignTargetPaths;ResolveReferences" Returns="@(PriFilesOutputGroupOutput)">
    <!-- This item represents dependent pri file's -->
    <ItemGroup>
      <PriFilesOutputGroupOutput Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pri'" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <SDKRedistOutputGroupDependsOn>ResolveSDKReferences;ExpandSDKReferences</SDKRedistOutputGroupDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        SDKRedistOutputGroup

    This target gathers the Redist folders from the SDKs which have been resolved.
    ============================================================
  -->
  <Target Name="SDKRedistOutputGroup" Returns="@(SDKRedistOutputGroupOutput)" DependsOnTargets="$(SDKRedistOutputGroupDependsOn)">
    <!-- This list starts with the least specific files to the most specific so that later files can overwrite earlier files-->
    <ItemGroup>
      <SDKRedistOutputGroupOutput Include="@(ResolvedRedistFiles)" />
    </ItemGroup>
  </Target>
  <!--
    ***********************************************************************************************
    ***********************************************************************************************
                                                                AllProjectOutputGroupsDependencies Section
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <!--
    ============================================================
                                        CommonOutputGroupsDependsOn

    Dependencies common to many of the *OutputGroupDependencies targets.
    ============================================================
    -->
  <PropertyGroup>
    <CommonOutputGroupsDependsOn>
      $(CommonOutputGroupsDependsOn);
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </CommonOutputGroupsDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                                        AllProjectOutputGroupsDependencies
    ============================================================
    -->
  <Target Name="AllProjectOutputGroupsDependencies" DependsOnTargets="&#xA;            BuiltProjectOutputGroupDependencies;&#xA;            DebugSymbolsProjectOutputGroupDependencies;&#xA;            SatelliteDllsProjectOutputGroupDependencies;&#xA;            DocumentationProjectOutputGroupDependencies;&#xA;            SGenFilesOutputGroupDependencies" />
  <!--
    ============================================================
                                        BuiltProjectOutputGroupDependencies

    This target performs population of the Built project output group dependencies.
    ============================================================
    -->
  <PropertyGroup>
    <BuiltProjectOutputGroupDependenciesDependsOn>
      $(BuiltProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </BuiltProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="BuiltProjectOutputGroupDependencies" DependsOnTargets="$(BuiltProjectOutputGroupDependenciesDependsOn)" Returns="@(BuiltProjectOutputGroupDependency)">
    <ItemGroup>
      <BuiltProjectOutputGroupDependency Include="@(ReferencePath->'%(FullPath)');&#xA;                                                         @(ReferenceDependencyPaths->'%(FullPath)');&#xA;                                                         @(NativeReferenceFile->'%(FullPath)');&#xA;                                                         @(_DeploymentLooseManifestFile->'%(FullPath)');&#xA;                                                         @(ResolvedIsolatedComModules->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DebugSymbolsProjectOutputGroupDependencies

    This target performs population of the dependencies for the debug symbols project output group.
    ============================================================
    -->
  <PropertyGroup>
    <DebugSymbolsProjectOutputGroupDependenciesDependsOn>
      $(DebugSymbolsProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DebugSymbolsProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="DebugSymbolsProjectOutputGroupDependencies" Condition="'$(DebugSymbols)'!='false'" DependsOnTargets="$(DebugSymbolsProjectOutputGroupDependenciesDependsOn)" Returns="@(DebugSymbolsProjectOutputGroupDependency)">
    <!-- This item represents dependent PDB's -->
    <ItemGroup>
      <DebugSymbolsProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SatelliteDllsProjectOutputGroupDependencies

    This target performs population of the dependencies for the satellite files project output group.
    ============================================================
    -->
  <PropertyGroup>
    <SatelliteDllsProjectOutputGroupDependenciesDependsOn>
      $(SatelliteDllsProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </SatelliteDllsProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="SatelliteDllsProjectOutputGroupDependencies" DependsOnTargets="$(SatelliteDllsProjectOutputGroupDependenciesDependsOn)" Returns="@(SatelliteDllsProjectOutputGroupDependency)">
    <!-- This item represents dependent satellites -->
    <ItemGroup>
      <SatelliteDllsProjectOutputGroupDependency Include="@(ReferenceSatellitePaths->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DocumentationProjectOutputGroupDependencies

    This target performs population of the dependencies for the documentation project output group.
    ============================================================
    -->
  <PropertyGroup>
    <DocumentationProjectOutputGroupDependenciesDependsOn>
      $(DocumentationProjectOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DocumentationProjectOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="DocumentationProjectOutputGroupDependencies" Condition="'$(DocumentationFile)'!=''" DependsOnTargets="$(DocumentationProjectOutputGroupDependenciesDependsOn)" Returns="@(DocumentationProjectOutputGroupDependency)">
    <!-- This item represents dependent XMLs -->
    <ItemGroup>
      <DocumentationProjectOutputGroupDependency Include="@(_ReferenceRelatedPaths->'%(FullPath)')" Condition="'%(Extension)' == '.xml'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        SGenFilesOutputGroupDependencies

    This target performs population of the dependencies for the GenerateSerializationAssemblies project output group.
    ============================================================
    -->
  <PropertyGroup>
    <SGenFilesOutputGroupDependenciesDependsOn>
      $(SGenFilesOutputGroupDependenciesDependsOn);
      $(CommonOutputGroupsDependsOn)
    </SGenFilesOutputGroupDependenciesDependsOn>
  </PropertyGroup>
  <Target Name="SGenFilesOutputGroupDependencies" DependsOnTargets="$(SGenFilesOutputGroupDependenciesDependsOn)" Returns="@(SGenFilesOutputGroupDependency)">
    <!-- This item represents sgen xml serializer dll's -->
    <ItemGroup>
      <SGenFilesOutputGroupDependency Include="@(_ReferenceSerializationAssemblyPaths->'%(FullPath)')" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ReferenceCopyLocalPathsOutputGroup

    Exposes the set of items that should be copied locally based on the project's references.
    ============================================================
    -->
  <PropertyGroup>
    <ReferenceCopyLocalPathsOutputGroupDependsOn>
      $(ReferenceCopyLocalPathsOutputGroupDependsOn);
      $(CommonOutputGroupsDependsOn)
    </ReferenceCopyLocalPathsOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="ReferenceCopyLocalPathsOutputGroup" DependsOnTargets="$(ReferenceCopyLocalPathsOutputGroupDependsOn)" Returns="@(ReferenceCopyLocalPathsOutputGroupOutput)">
    <ItemGroup>
      <ReferenceCopyLocalPathsOutputGroupOutput Include="@(ReferenceCopyLocalPaths)">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </ReferenceCopyLocalPathsOutputGroupOutput>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
         DesignerRuntimeImplementationProjectOutputGroup

    Exposes build items to be used by designer. The default is empty, but
    SDKs can override it as appropriate. The empty stub is required so that
    the project system can always rely on calling it even if it is not
    overridden.
    ============================================================
    -->
  <PropertyGroup>
    <DesignerRuntimeImplementationProjectOutputGroupDependsOn>
      $(DesignerRuntimeImplementationProjectOutputGroupDependsOn);
      $(CommonOutputGroupsDependsOn)
    </DesignerRuntimeImplementationProjectOutputGroupDependsOn>
  </PropertyGroup>
  <Target Name="DesignerRuntimeImplementationProjectOutputGroup" DependsOnTargets="$(DesignerRuntimeImplementationProjectOutputGroupDependsOn)" Returns="@(DesignerRuntimeImplementationProjectOutputGroupOutput)" />
  <!--
    ============================================================
                       .editorconfig support
    ============================================================
  -->
  <!-- Expose the set of potential .editorconfig files so the project system can
       retrieve them. -->
  <Target Name="GetPotentialEditorConfigFiles" Returns="@(PotentialEditorConfigFiles)" />
  <PropertyGroup>
    <CodeAnalysisTargets Condition="'$(CodeAnalysisTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\CodeAnalysis\Microsoft.CodeAnalysis.targets</CodeAnalysisTargets>
  </PropertyGroup>
  <!--<Import Project="$(CodeAnalysisTargets)" Condition="Exists('$(CodeAnalysisTargets)')" />-->
  <!--<Import Project="$(ReportingServicesTargets)" Condition="Exists('$(ReportingServicesTargets)')" />-->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.NETFramework.targets" Condition="('$(TargetFrameworkIdentifier)' == ''  or '$(TargetFrameworkIdentifier)' == '.NETFramework') and ('$(TargetRuntime)' == 'Managed')" />-->
  <PropertyGroup>
    <ImportXamlTargets Condition="'$(ImportXamlTargets)'=='' and ('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.Xaml.targets')">true</ImportXamlTargets>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Xaml.targets" Condition="('$(ImportXamlTargets)' == 'true')" />-->
  <!-- imports Microsoft.WorkflowBuildExtensions.targets only if TargetFrameworkVersion is v4.5 or above or TargetFrameworkfVersion specified does not conform to the format of vX.X[.X.X] -->
  <!-- Underlying assumption is that there shouldn't be any other versions between v4.0.* and v4.5 -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.WorkflowBuildExtensions.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.5' and (!$([System.String]::IsNullOrEmpty('$(TargetFrameworkVersion)')) and !$(TargetFrameworkVersion.StartsWith('v4.0')))) and Exists('$(MSBuildToolsPath)\Microsoft.WorkflowBuildExtensions.targets')" />-->
  <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.WinFX.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.WinFX.targets')" />-->
  <PropertyGroup>
    <MsTestToolsTargets Condition="'$(MsTestToolsTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TeamTest\Microsoft.TeamTest.targets</MsTestToolsTargets>
  </PropertyGroup>
  <!--<Import Project="$(MsTestToolsTargets)" Condition="Exists('$(MsTestToolsTargets)')" />-->
  <PropertyGroup>
    <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
  </PropertyGroup>
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'" />-->
  <!-- App packaging support -->
  <!--
    Following two targets are needed to be present in every project being built
    because the app packaging targets recursively scan all projects referenced
    from projects that generate app packages for them.
  -->
  <Target Name="CleanAppxPackage" />
  <Target Name="GetPackagingOutputs" />
  <PropertyGroup>
    <MsAppxPackageTargets Condition="'$(MsAppxPackageTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\Microsoft.AppXPackage.Targets</MsAppxPackageTargets>
    <!-- Opt-out switch to allow disabling importing the 'AppxPackage' targets for UWP class libraries using modern .NET -->
    <EnableAppxPackageTargetsForUwpClassLibraries Condition="'$(EnableAppxPackageTargetsForUwpClassLibraries)' == ''">true</EnableAppxPackageTargetsForUwpClassLibraries>
  </PropertyGroup>
  <!--
    We want to import the 'AppXPackage' .targets in two scenarios:
      - For legacy UWP, in all cases (original behavior). These projects will always set 'WindowsAppContainer' by default.
      - For UWP (XAML) apps and libraries on modern .NET, we only enable this for class libraries. This allows the existing
        .appx tooling to take care of generating .pri resources without the need to pull in WinAppSDK or other external tools.
        We cannot use this for applications, because the rest of that tooling is not capable of handling modern .NET projects.
        In that case, we either leverage the tooling in WinAppSDK, or DesktopBridge (via a .wapproj project for packaging).
  -->
  <!--<Import Project="$(MsAppxPackageTargets)" Condition="('$(WindowsAppContainer)' == 'true' or ('$(UseUwpTools)' == 'true' and '$(OutputType)' == 'Library' and '$(EnableAppxPackageTargetsForUwpClassLibraries)' != 'false')) and Exists('$(MsAppxPackageTargets)')" />-->
  <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')" />-->
  <!-- Import NuGet.targets (required for GetReferenceNearestTargetFrameworkTask and used for Restore functionality) -->
  <PropertyGroup>
    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'==''">$(MSBuildToolsPath)\NuGet.targets</NuGetRestoreTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetRestoreTargets)" Condition="'$(IsRestoreTargetsFileLoaded)' != 'true' and Exists('$(NuGetRestoreTargets)')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/NuGet.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************

  This target file contains the NuGet Restore target for walking the project and reference graph
  and restoring dependencies from the graph.

  Ways to use this targets file:
  1. Invoke it directly and provide project file paths using $(RestoreGraphProjectInput).
  2. With a solution this may be used as a target in the metaproj.
  3. Import the targets file from a project.

  Restore flow summary:
  1. Top level projects (entry points) are determined.
  2. Each project and all of its project references are walked recursively.
  3. The project is evaluated for each $(TargetFramework). Items are created
     for project properties and dependencies. Each item is marked
     with the project it came from so that it can be matched up later.
  4. All restore items generated by the walk are grouped together by
     project and convert into a project spec.

  The result file contains:
  1. A list of projects to restore.
  2. The complete closure of all projects referenced (Includes project references that are not being restored directly).
  3. Package and project dependencies for each project.
  4. DotnetCliTool references
  -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Mark that this target file has been loaded.  -->
    <IsRestoreTargetsFileLoaded>true</IsRestoreTargetsFileLoaded>
    <!-- Load NuGet.Build.Tasks.dll, this can be overridden to use a different version with $(RestoreTaskAssemblyFile) -->
    <RestoreTaskAssemblyFile Condition=" '$(RestoreTaskAssemblyFile)' == '' ">NuGet.Build.Tasks.dll</RestoreTaskAssemblyFile>
    <!-- Do not hide errors and warnings by default -->
    <HideWarningsAndErrors Condition=" '$(HideWarningsAndErrors)' == '' ">false</HideWarningsAndErrors>
    <!-- Recurse by default -->
    <RestoreRecursive Condition=" '$(RestoreRecursive)' == '' ">true</RestoreRecursive>
    <RestoreUseSkipNonexistentTargets Condition=" '$(RestoreUseSkipNonexistentTargets)' == '' ">true</RestoreUseSkipNonexistentTargets>
    <!-- RuntimeIdentifier compatibility check -->
    <ValidateRuntimeIdentifierCompatibility Condition=" '$(ValidateRuntimeIdentifierCompatibility)' == '' ">false</ValidateRuntimeIdentifierCompatibility>
    <!-- Error handling while walking projects -->
    <RestoreContinueOnError Condition=" '$(RestoreContinueOnError)' == '' ">WarnAndContinue</RestoreContinueOnError>
    <!-- Build in parallel -->
    <RestoreBuildInParallel Condition=" '$(BuildInParallel)' != '' ">$(BuildInParallel)</RestoreBuildInParallel>
    <RestoreBuildInParallel Condition=" '$(RestoreBuildInParallel)' == '' ">true</RestoreBuildInParallel>
    <!-- Check if the restore target was executed on a sln file -->
    <_RestoreSolutionFileUsed Condition=" '$(_RestoreSolutionFileUsed)' == '' AND '$(SolutionDir)' != '' AND $(MSBuildProjectFullPath.EndsWith('.metaproj')) == 'true' ">true</_RestoreSolutionFileUsed>
    <!-- We default to MSBuildInteractive. -->
    <NuGetInteractive Condition=" '$(NuGetInteractive)' == '' ">$(MSBuildInteractive)</NuGetInteractive>
    <!-- Mark that this targets file supports package download. -->
    <PackageDownloadSupported>true</PackageDownloadSupported>
    <!-- Mark that this targets file GetReferenceNearestTargetFrameworkTask task supports the TargetPlatformMoniker -->
    <GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter>true</GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter>
    <!-- Flag if the Central package file is enabled -->
    <_CentralPackageVersionsEnabled Condition="'$(ManagePackageVersionsCentrally)' == 'true' AND '$(CentralPackageVersionsFileImported)' == 'true'">true</_CentralPackageVersionsEnabled>
  </PropertyGroup>
  <!--
    Visual Studio's project property page requires defaults to be set to inform customers what the default values are.
    Project-system uses DefaultValueSourceLocation.AfterContext to detect when a customer's project changes the value, so these defaults must be set here in the targets file.
  -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Enable NuGetAudit by default -->
    <NuGetAudit Condition=" '$(NuGetAudit)' == '' ">true</NuGetAudit>
    <!-- Report all severity vulnerabilities (low severity and higher). Allowed values are: low, moderate, high, critical -->
    <NuGetAuditLevel Condition=" '$(NuGetAuditLevel)' == '' ">low</NuGetAuditLevel>
    <!-- Report known vulnerabilities on direct and transitive dependencies for .NET 10 and higher, direct only otherwise -->
    <NuGetAuditMode Condition=" '$(NuGetAuditMode)' == ''&#xD;&#xA;                    AND '$(NuGetExeSkipSdkAnalysisLevelCheck)' != 'true'&#xD;&#xA;                    AND '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xD;&#xA;                    AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '10.0'))">all</NuGetAuditMode>
    <NuGetAuditMode Condition=" '$(NuGetAuditMode)' == '' ">direct</NuGetAuditMode>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RestoreEnablePackagePruning Condition="'$(RestoreEnablePackagePruning)' == ''&#xD;&#xA;                    AND '$(UsingMicrosoftNETSdk)' == 'true'&#xD;&#xA;                    AND '$(NuGetExeSkipSdkAnalysisLevelCheck)' != 'true'&#xD;&#xA;                    AND '$(SdkAnalysisLevel)' != ''&#xD;&#xA;                    AND $([MSBuild]::VersionGreaterThanOrEquals('$(SdkAnalysisLevel)', '10.0.100'))&#xD;&#xA;                    AND ('$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xD;&#xA;                        OR ('$(TargetFrameworkIdentifier)' == '.NETStandard' AND '$(TargetFrameworkVersion)' != '' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '2.0'))))">true</RestoreEnablePackagePruning>
    <RestoreEnablePackagePruning Condition="$(RestoreEnablePackagePruning) == '' ">false</RestoreEnablePackagePruning>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Exclude packages from changing restore inputs.  -->
    <_GenerateRestoreGraphProjectEntryInputProperties>ExcludeRestorePackageImports=true</_GenerateRestoreGraphProjectEntryInputProperties>
    <!-- Standalone mode
         This is used by NuGet.exe to inject targets into the project that will be
         walked next. In normal /t:Restore mode this causes a duplicate import
         since NuGet.targets it loaded as part of MSBuild, there is should be
         skipped. -->
    <_GenerateRestoreGraphProjectEntryInputProperties Condition=" '$(RestoreUseCustomAfterTargets)' == 'true' ">
      $(_GenerateRestoreGraphProjectEntryInputProperties);
      NuGetRestoreTargets=$(MSBuildThisFileFullPath);
      RestoreUseCustomAfterTargets=$(RestoreUseCustomAfterTargets);
      CustomAfterMicrosoftCommonCrossTargetingTargets=$(MSBuildThisFileFullPath);
      CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);
    </_GenerateRestoreGraphProjectEntryInputProperties>
    <!-- Include SolutionDir and SolutionName for solution restores and persist these properties during the walk. -->
    <_GenerateRestoreGraphProjectEntryInputProperties Condition=" '$(_RestoreSolutionFileUsed)' == 'true' ">
      $(_GenerateRestoreGraphProjectEntryInputProperties);
      _RestoreSolutionFileUsed=true;
      SolutionDir=$(SolutionDir);
      SolutionName=$(SolutionName);
      SolutionFileName=$(SolutionFileName);
      SolutionPath=$(SolutionPath);
      SolutionExt=$(SolutionExt);
    </_GenerateRestoreGraphProjectEntryInputProperties>
  </PropertyGroup>
  <ItemGroup Condition="'$(ManagePackageVersionsCentrally)' == 'true' And '$(RestoreEnableGlobalPackageReference)' != 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
        Add GlobalPackageReference items to the PackageReference item group with no version.

        Global package references only include the same assets as a development dependency (runtime; build; native; contentfiles; analyzers)
        because those kind of packages are the best candidate for a global package reference.  They are generally packages that
        extend the build.

        Global package references have all assets private because central package references are generally packages that provide
        versioning, signing, etc and should not flow to downstream dependencies.  Also, central package references are already
        referenced by every project in the tree so they don't need to be transitive.
      -->
    <PackageReference Include="@(GlobalPackageReference)" Version="" IncludeAssets="Runtime;Build;Native;contentFiles;Analyzers" PrivateAssets="All" />
    <!--
        Add GlobalPackageReference items to the PackageVersion item group with the version.
      -->
    <PackageVersion Include="@(GlobalPackageReference)" Version="%(Version)" />
  </ItemGroup>
  <!-- Tasks -->
  <UsingTask TaskName="NuGet.Build.Tasks.RestoreTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.WriteRestoreGraphTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectJsonPathTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePackageReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetCentralPackageVersionsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePackageDownloadsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreFrameworkReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreNuGetAuditSuppressionsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestorePrunePackageReferencesTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreDotnetCliToolsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetProjectTargetFrameworksTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreSolutionProjectsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreSettingsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.WarnForInvalidProjectsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetReferenceNearestTargetFrameworkTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetRestoreProjectStyleTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.NuGetMessageTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.CheckForDuplicateNuGetItemsTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetGlobalPropertyValueTask" AssemblyFile="$(RestoreTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    Restore
    Main entry point for restoring packages
    ============================================================
  -->
  <Target Name="Restore" DependsOnTargets="_GenerateRestoreGraph" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreGraphEntry)">
      <Output TaskParameter="Filtered" ItemName="_RestoreGraphEntryFiltered" />
    </RemoveDuplicates>
    <!-- Call restore -->
    <RestoreTask RestoreGraphItems="@(_RestoreGraphEntryFiltered)" RestoreDisableParallel="$(RestoreDisableParallel)" RestoreNoCache="$(RestoreNoCache)" RestoreNoHttpCache="$(RestoreNoHttpCache)" RestoreIgnoreFailedSources="$(RestoreIgnoreFailedSources)" RestoreRecursive="$(RestoreRecursive)" RestoreForce="$(RestoreForce)" HideWarningsAndErrors="$(HideWarningsAndErrors)" Interactive="$(NuGetInteractive)" RestoreForceEvaluate="$(RestoreForceEvaluate)" RestorePackagesConfig="$(RestorePackagesConfig)" EmbedFilesInBinlog="$(RestoreEmbedFilesInBinlog)">
      <Output TaskParameter="EmbedInBinlog" ItemName="EmbedInBinlog" />
      <Output TaskParameter="ProjectsRestored" PropertyName="RestoreProjectCount" />
      <Output TaskParameter="ProjectsAlreadyUpToDate" PropertyName="RestoreSkippedCount" />
      <Output TaskParameter="ProjectsAudited" PropertyName="RestoreProjectsAuditedCount" />
    </RestoreTask>
  </Target>
  <!--
    ============================================================
    GenerateRestoreGraphFile
    Writes the output of _GenerateRestoreGraph to disk
    ============================================================
  -->
  <Target Name="GenerateRestoreGraphFile" DependsOnTargets="_GenerateRestoreGraph" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Validate  -->
    <Error Condition="$(RestoreGraphOutputPath) == ''" Text="Missing RestoreGraphOutputPath property!" />
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreGraphEntry)">
      <Output TaskParameter="Filtered" ItemName="_RestoreGraphEntryFiltered" />
    </RemoveDuplicates>
    <!-- Write file -->
    <WriteRestoreGraphTask RestoreGraphItems="@(_RestoreGraphEntryFiltered)" RestoreGraphOutputPath="$(RestoreGraphOutputPath)" RestoreRecursive="$(RestoreRecursive)" />
  </Target>
  <!--
    ============================================================
    CollectPackageReferences
    Gathers all PackageReference items from the project.
    This target may be used as an extension point to modify
    package references before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectPackageReferences" Returns="@(PackageReference)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPackageReferencesContinueOnError>$(ContinueOnError)</CollectPackageReferencesContinueOnError>
      <CollectPackageReferencesContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPackageReferencesContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageReference)" ItemName="PackageReference" LogCode="NU1504" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPackageReferencesContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageReferences" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageReferences)' != ''">
      <PackageReference Remove="@(PackageReference)" />
      <PackageReference Include="@(DeduplicatedPackageReferences)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectCentralPackageVersions
    Gathers all PackageVersion items from the central package versions file.
    ============================================================
  -->
  <Target Name="CollectCentralPackageVersions" Returns="@(PackageVersion)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectCentralPackageVersionsContinueOnError>$(ContinueOnError)</CollectCentralPackageVersionsContinueOnError>
      <CollectCentralPackageVersionsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectCentralPackageVersionsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageVersion)" ItemName="PackageVersion" LogCode="NU1506" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectCentralPackageVersionsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageVersions" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageVersions)' != ''">
      <PackageVersion Remove="@(PackageVersion)" />
      <PackageVersion Include="@(DeduplicatedPackageVersions)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectPackageDownloads
    Gathers all PackageDownload items from the project.
    This target may be used as an extension point to modify
    package downloads before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectPackageDownloads" Returns="@(PackageDownload)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPackageDownloadsContinueOnError>$(ContinueOnError)</CollectPackageDownloadsContinueOnError>
      <CollectPackageDownloadsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPackageDownloadsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PackageDownload)" ItemName="PackageDownload" LogCode="NU1505" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPackageDownloadsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPackageDownloads" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPackageDownloads)' != ''">
      <PackageDownload Remove="@(PackageDownload)" />
      <PackageDownload Include="@(DeduplicatedPackageDownloads)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectFrameworkReferences
    ============================================================
  -->
  <Target Name="CollectFrameworkReferences" Returns="@(_FrameworkReferenceForRestore)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_FrameworkReferenceForRestore Include="@(FrameworkReference)" Condition="'%(FrameworkReference.IsTransitiveFrameworkReference)' != 'true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    CollectNuGetAuditSuppressions
    Gathers all NuGetAuditSuppress items from the project.
    This target may be used as an extension point to modify
    advisory suppressions before NuGet reads them.
    ============================================================
  -->
  <Target Name="CollectNuGetAuditSuppressions" Returns="@(NuGetAuditSuppress)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectNuGetAuditSuppressionsContinueOnError>$(ContinueOnError)</CollectNuGetAuditSuppressionsContinueOnError>
      <CollectNuGetAuditSuppressionsContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectNuGetAuditSuppressionsContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Items="@(NuGetAuditSuppress)" ItemName="NuGetAuditSuppress" LogCode="NU1508" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectNuGetAuditSuppressionsContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedNuGetAuditSuppressions" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedNuGetAuditSuppressions)' != ''">
      <NuGetAuditSuppress Remove="@(NuGetAuditSuppress)" />
      <NuGetAuditSuppress Include="@(DeduplicatedNuGetAuditSuppressions)" />
    </ItemGroup>
  </Target>
  <Target Name="CollectPrunePackageReferences" Returns="@(PrunePackageReference)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- NOTE for design-time builds we need to ensure that we continue on error. -->
    <PropertyGroup>
      <CollectPrunePackageReferencesContinueOnError>$(ContinueOnError)</CollectPrunePackageReferencesContinueOnError>
      <CollectPrunePackageReferencesContinueOnError Condition="'$(ContinueOnError)' == '' ">false</CollectPrunePackageReferencesContinueOnError>
    </PropertyGroup>
    <CheckForDuplicateNuGetItemsTask Condition="'$(DisableCheckingDuplicateNuGetItems)' != 'true' " Items="@(PrunePackageReference)" ItemName="PrunePackageReference" LogCode="NU1509" MSBuildProjectFullPath="$(MSBuildProjectFullPath)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" NoWarn="$(NoWarn)" ContinueOnError="$(CollectPrunePackageReferencesContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedPrunePackageReference" />
    </CheckForDuplicateNuGetItemsTask>
    <ItemGroup Condition="'@(DeduplicatedPrunePackageReference)' != ''">
      <PrunePackageReference Remove="@(PrunePackageReference)" />
      <PrunePackageReference Include="@(DeduplicatedPrunePackageReference)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _CollectRestoreInputs
    Runs all the 'Collect' targets
    ============================================================
  -->
  <Target Name="_CollectRestoreInputs" DependsOnTargets="CollectPackageReferences;CollectPackageDownloads;CollectFrameworkReferences;CollectCentralPackageVersions;CollectNuGetAuditSuppressions;CollectPrunePackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    _LoadRestoreGraphEntryPoints
    Find project entry points and load them into items.
    ============================================================
  -->
  <Target Name="_LoadRestoreGraphEntryPoints" Returns="@(RestoreGraphProjectInputItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Allow overriding items with RestoreGraphProjectInput -->
    <ItemGroup Condition=" @(RestoreGraphProjectInputItems) == '' ">
      <RestoreGraphProjectInputItems Include="$(RestoreGraphProjectInput)" />
    </ItemGroup>
    <!-- Project case -->
    <ItemGroup Condition=" $(MSBuildProjectFullPath.EndsWith('.metaproj')) != 'true' AND @(RestoreGraphProjectInputItems) == '' ">
      <RestoreGraphProjectInputItems Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
    <!-- Solution case -->
    <GetRestoreSolutionProjectsTask Condition=" $(MSBuildProjectFullPath.EndsWith('.metaproj')) == 'true' AND @(RestoreGraphProjectInputItems) == '' " ProjectReferences="@(ProjectReference)" SolutionFilePath="$(MSBuildProjectFullPath)">
      <Output TaskParameter="OutputProjectReferences" ItemName="RestoreGraphProjectInputItems" />
    </GetRestoreSolutionProjectsTask>
  </Target>
  <!--
    ============================================================
    _FilterRestoreGraphProjectInputItems
    Filter out unsupported project entry points.
    ============================================================
  -->
  <Target Name="_FilterRestoreGraphProjectInputItems" DependsOnTargets="_LoadRestoreGraphEntryPoints" Returns="@(FilteredRestoreGraphProjectInputItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <RestoreProjectFilterMode Condition=" '$(RestoreProjectFilterMode)' == '' ">exclusionlist</RestoreProjectFilterMode>
    </PropertyGroup>
    <!-- Filter to a list of known supported types -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' == 'inclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" Condition=" '%(RestoreGraphProjectInputItems.Extension)' == '.csproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.vbproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.fsproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.nuproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.proj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.msbuildproj' Or&#xD;&#xA;                   '%(RestoreGraphProjectInputItems.Extension)' == '.vcxproj' " />
    </ItemGroup>
    <!-- Filter out disallowed types -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' == 'exclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" Condition=" '%(RestoreGraphProjectInputItems.Extension)' != '.metaproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.shproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.vcxitems'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '.vdproj'&#xD;&#xA;                   AND '%(RestoreGraphProjectInputItems.Extension)' != '' " />
    </ItemGroup>
    <!-- No filtering -->
    <ItemGroup Condition=" '$(RestoreProjectFilterMode)' != 'exclusionlist' AND '$(RestoreProjectFilterMode)' != 'inclusionlist' ">
      <_FilteredRestoreGraphProjectInputItemsTmp Include="@(RestoreGraphProjectInputItems)" />
    </ItemGroup>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_FilteredRestoreGraphProjectInputItemsTmp)">
      <Output TaskParameter="Filtered" ItemName="FilteredRestoreGraphProjectInputItemsWithoutDuplicates" />
    </RemoveDuplicates>
    <!-- Remove projects that do not support restore. -->
    <!-- With SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" Targets="_IsProjectRestoreSupported" SkipNonexistentTargets="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="FilteredRestoreGraphProjectInputItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" Targets="_IsProjectRestoreSupported" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="FilteredRestoreGraphProjectInputItems" />
    </MSBuild>
    <!-- Warn for projects that do not support restore. -->
    <WarnForInvalidProjectsTask Condition=" '$(DisableWarnForInvalidRestoreProjects)' != 'true' AND '$(HideWarningsAndErrors)' != 'true' " AllProjects="@(FilteredRestoreGraphProjectInputItemsWithoutDuplicates)" ValidProjects="@(FilteredRestoreGraphProjectInputItems)" />
  </Target>
  <!--
    ============================================================
    _GenerateRestoreGraph
    Entry point for creating the project to project restore graph.
    ============================================================
  -->
  <Target Name="_GenerateRestoreGraph" DependsOnTargets="_FilterRestoreGraphProjectInputItems;_GetAllRestoreProjectPathItems" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Message Text="Generating dg file" Importance="low" />
    <Message Text="%(_RestoreProjectPathItems.Identity)" Importance="low" />
    <!-- Use all projects if RestoreRecursive is true. Otherwise use only the top level projects. -->
    <ItemGroup>
      <_GenerateRestoreGraphProjectEntryInput Include="@(FilteredRestoreGraphProjectInputItems)" Condition=" '$(RestoreRecursive)' != 'true' " />
      <_GenerateRestoreGraphProjectEntryInput Include="@(_RestoreProjectPathItems)" Condition=" '$(RestoreRecursive)' == 'true' " />
    </ItemGroup>
    <!-- Add top level entries to the direct restore list. These projects will also restore tools. -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_GenerateRestoreGraphProjectEntryInput)" Targets="_GenerateRestoreGraphProjectEntry" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
    <!-- Generate a spec for every project including dependencies. -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_RestoreProjectPathItems)" Targets="_GenerateProjectRestoreGraph" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreGraphProjectEntry
    Top level entry point within a project.
    ============================================================
  -->
  <Target Name="_GenerateRestoreGraphProjectEntry" DependsOnTargets="_GenerateRestoreSpecs;_GenerateDotnetCliToolReferenceSpecs" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Returns restore graph entries for the project and all dependencies -->
  </Target>
  <!--
    ============================================================
    _GenerateRestoreSpecs
    Mark entry points for restore.
    ============================================================
  -->
  <Target Name="_GenerateRestoreSpecs" DependsOnTargets="_GetRestoreProjectStyle" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Message Text="Restore entry point $(MSBuildProjectFullPath)" Importance="low" />
    <!-- Mark entry point -->
    <ItemGroup Condition=" '$(RestoreProjects)' == '' OR '$(RestoreProjects)' == 'true' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())" Condition=" '$(RestoreProjectStyle)' != 'Unknown' ">
        <Type>RestoreSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateDotnetCliToolReferenceSpecs
    Collect DotnetCliToolReferences
    ============================================================
  -->
  <Target Name="_GenerateDotnetCliToolReferenceSpecs" DependsOnTargets="_GetRestoreSettings" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <DotnetCliToolTargetFramework Condition=" '$(DotnetCliToolTargetFramework)' == '' ">netcoreapp1.0</DotnetCliToolTargetFramework>
    </PropertyGroup>
    <!-- Write out tool references -->
    <GetRestoreDotnetCliToolsTask Condition=" '$(RestoreDotnetCliToolReferences)' == '' OR '$(RestoreDotnetCliToolReferences)' == 'true' " ProjectPath="$(MSBuildProjectFullPath)" ToolFramework="$(DotnetCliToolTargetFramework)" RestorePackagesPath="$(_OutputPackagesPath)" RestoreFallbackFolders="$(_OutputFallbackFolders)" RestoreSources="$(_OutputSources)" RestoreConfigFilePaths="$(_OutputConfigFilePaths)" DotnetCliToolReferences="@(DotnetCliToolReference)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreDotnetCliToolsTask>
  </Target>
  <!--
    ============================================================
    _GetProjectJsonPath
    Discover the project.json path if one exists for the project.
    ============================================================
  -->
  <Target Name="_GetProjectJsonPath" Returns="$(_CurrentProjectJsonPath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Get project.json path -->
    <!-- Skip this if the project style is already set. -->
    <GetRestoreProjectJsonPathTask ProjectPath="$(MSBuildProjectFullPath)" Condition=" '$(RestoreProjectStyle)' == 'ProjectJson' OR '$(RestoreProjectStyle)' == '' ">
      <Output TaskParameter="ProjectJsonPath" PropertyName="_CurrentProjectJsonPath" />
    </GetRestoreProjectJsonPathTask>
  </Target>
  <!--
    ============================================================
    _GetRestoreProjectStyle
    Determine the project restore type.
    ============================================================
  -->
  <Target Name="_GetRestoreProjectStyle" DependsOnTargets="_GetProjectJsonPath;CollectPackageReferences" Returns="$(RestoreProjectStyle);$(PackageReferenceCompatibleProjectStyle)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Older versions of MSBuild do not support the Count() item function which is an optimization.  Expanding the
      entire item list into a semicolon delimited string is slower but older versions of MSBuild don't support it so
      use the older logic if necessary
    -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' &lt; '15.0'">
      <_HasPackageReferenceItems Condition="'@(PackageReference)' != ''">true</_HasPackageReferenceItems>
    </PropertyGroup>
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' &gt;= '15.0'">
      <_HasPackageReferenceItems Condition="@(PackageReference-&gt;Count()) &gt; 0">true</_HasPackageReferenceItems>
    </PropertyGroup>
    <GetRestoreProjectStyleTask HasPackageReferenceItems="$(_HasPackageReferenceItems)" MSBuildProjectDirectory="$(MSBuildProjectDirectory)" MSBuildProjectName="$(MSBuildProjectName)" ProjectJsonPath="$(_CurrentProjectJsonPath)" RestoreProjectStyle="$(RestoreProjectStyle)">
      <Output TaskParameter="ProjectStyle" PropertyName="RestoreProjectStyle" />
      <Output TaskParameter="IsPackageReferenceCompatibleProjectStyle" PropertyName="PackageReferenceCompatibleProjectStyle" />
    </GetRestoreProjectStyleTask>
    <PropertyGroup>
      <_HasPackageReferenceItems />
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    EnableIntermediateOutputPathMismatchWarning
    If using PackageReference, enable an MSBuild warning if BaseIntermediateOutputPath is set to something different
    than MSBuildProjectExtensionsPath, because it may be unexpected that the assets and related files wouldn't be written
    to the BaseIntermediateOutputPath.
    ============================================================
  -->
  <Target Name="EnableIntermediateOutputPathMismatchWarning" DependsOnTargets="_GetRestoreProjectStyle" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(RestoreProjectStyle)' == 'PackageReference'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(EnableBaseIntermediateOutputPathMismatchWarning)' == ''">
      <EnableBaseIntermediateOutputPathMismatchWarning>true</EnableBaseIntermediateOutputPathMismatchWarning>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworksOutput
    Read target frameworks from the project.
    Non-NETCore project frameworks will be returned.
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworksOutput" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworkOverride" Returns="@(_RestoreTargetFrameworksOutputFiltered)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_RestoreProjectFramework />
      <_TargetFrameworkToBeUsed Condition=" '$(_TargetFrameworkOverride)' == '' ">$(TargetFrameworks)</_TargetFrameworkToBeUsed>
    </PropertyGroup>
    <!-- For project.json projects target frameworks will be read from project.json. -->
    <GetProjectTargetFrameworksTask Condition=" '$(RestoreProjectStyle)' != 'ProjectJson'" ProjectPath="$(MSBuildProjectFullPath)" TargetFrameworks="$(_TargetFrameworkToBeUsed)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)">
      <Output TaskParameter="ProjectTargetFrameworks" PropertyName="_RestoreProjectFramework" />
    </GetProjectTargetFrameworksTask>
    <ItemGroup Condition=" '$(_RestoreProjectFramework)' != '' ">
      <_RestoreTargetFrameworksOutputFiltered Include="$(_RestoreProjectFramework.Split(';'))" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworksAsItems
    Read $(TargetFrameworks) from the project as items.
    Projects that do not have $(TargetFrameworks) will noop.
    If $(TargetFramework) is specified globally, it'll be preferred over $(TargetFrameworks)
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworksAsItems" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworkOverride" Returns="@(_RestoreTargetFrameworkItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition=" '$(TargetFrameworks)' != '' AND '$(_TargetFrameworkOverride)' == '' ">
      <_RestoreTargetFrameworkItems Include="$(TargetFrameworks.Split(';'))" />
    </ItemGroup>
    <ItemGroup Condition=" '$(TargetFrameworks)' != '' AND '$(_TargetFrameworkOverride)' != '' ">
      <_RestoreTargetFrameworkItems Include="$(_TargetFrameworkOverride)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettings
    ============================================================
  -->
  <Target Name="_GetRestoreSettings" Condition=" '$(RestoreProjectStyle)' == 'PackageReference' OR '$(RestoreProjectStyle)' == 'ProjectJson' OR '$(RestoreProjectStyle)' == 'DotnetToolReference' OR '$(RestoreProjectStyle)' == 'PackagesConfig'" DependsOnTargets="_GetRestoreSettingsOverrides;_GetRestoreSettingsCurrentProject;_GetRestoreSettingsAllFrameworks" Returns="$(_OutputSources);$(_OutputPackagesPath);$(_OutputRepositoryPath);$(_OutputFallbackFolders);$(_OutputConfigFilePaths)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition=" '$(RestoreSolutionDirectory)' == '' AND '$(RestoreProjectStyle)' == 'PackagesConfig' AND '$(SolutionDir)' != '*Undefined*'">
      <RestoreSolutionDirectory>$(SolutionDir)</RestoreSolutionDirectory>
    </PropertyGroup>
    <!-- For transitive project styles, we rely on evaluating all the settings and including them in the dg spec to faciliate no-op restore-->
    <GetRestoreSettingsTask ProjectUniqueName="$(MSBuildProjectFullPath)" RestoreSources="$(RestoreSources)" RestorePackagesPath="$(RestorePackagesPath)" RestoreRepositoryPath="$(RestoreRepositoryPath)" RestoreFallbackFolders="$(RestoreFallbackFolders)" RestoreConfigFile="$(RestoreConfigFile)" RestoreRootConfigDirectory="$(RestoreRootConfigDirectory)" RestoreSolutionDirectory="$(RestoreSolutionDirectory)" RestoreSettingsPerFramework="@(_RestoreSettingsPerFramework)" RestorePackagesPathOverride="$(_RestorePackagesPathOverride)" RestoreRepositoryPathOverride="$(_RestoreRepositoryPathOverride)" RestoreSourcesOverride="$(_RestoreSourcesOverride)" RestoreFallbackFoldersOverride="$(_RestoreFallbackFoldersOverride)" RestoreProjectStyle="$(RestoreProjectStyle)" MSBuildStartupDirectory="$(MSBuildStartupDirectory)">
      <Output TaskParameter="OutputSources" PropertyName="_OutputSources" />
      <Output TaskParameter="OutputPackagesPath" PropertyName="_OutputPackagesPath" />
      <Output TaskParameter="OutputRepositoryPath" PropertyName="_OutputRepositoryPath" />
      <Output TaskParameter="OutputFallbackFolders" PropertyName="_OutputFallbackFolders" />
      <Output TaskParameter="OutputConfigFilePaths" PropertyName="_OutputConfigFilePaths" />
    </GetRestoreSettingsTask>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsCurrentProject
    Generate items for a single framework.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsCurrentProject" Condition=" '$(TargetFrameworks)' == '' AND '$(PackageReferenceCompatibleProjectStyle)' == 'true' " DependsOnTargets="_GetRestoreSettingsPerFramework" Returns="@(_RestoreSettingsPerFramework)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    _GetRestoreSettingsAllFrameworks
    Generate items for all frameworks.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsAllFrameworks" Condition=" '$(TargetFrameworks)' != '' AND '$(PackageReferenceCompatibleProjectStyle)' == 'true' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems;_GetRestoreProjectStyle" Returns="@(_RestoreSettingsPerFramework)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Read additional sources and fallback folders for each framework  -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GetRestoreSettingsPerFramework" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreSettingsPerFramework" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsPerFramework
    Generate items with framework specific settings.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsPerFramework" Returns="@(_RestoreSettingsPerFramework)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_RestoreSettingsPerFramework Include="$([System.Guid]::NewGuid())">
        <RestoreAdditionalProjectSources>$(RestoreAdditionalProjectSources)</RestoreAdditionalProjectSources>
        <RestoreAdditionalProjectFallbackFolders>$(RestoreAdditionalProjectFallbackFolders)</RestoreAdditionalProjectFallbackFolders>
        <RestoreAdditionalProjectFallbackFoldersExcludes>$(RestoreAdditionalProjectFallbackFoldersExcludes)</RestoreAdditionalProjectFallbackFoldersExcludes>
      </_RestoreSettingsPerFramework>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectSpec
    Generate a restore project spec for the current project.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectSpec" DependsOnTargets="_GetRestoreProjectStyle;_GetRestoreTargetFrameworksOutput;_GetRestoreSettings" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Determine the restore output path -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' OR '$(RestoreProjectStyle)' == 'ProjectJson' ">
      <RestoreOutputPath Condition=" '$(RestoreOutputPath)' == '' ">$(MSBuildProjectExtensionsPath)</RestoreOutputPath>
    </PropertyGroup>
    <ConvertToAbsolutePath Paths="$(RestoreOutputPath)" Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' OR '$(RestoreProjectStyle)' == 'ProjectJson'">
      <Output TaskParameter="AbsolutePaths" PropertyName="RestoreOutputAbsolutePath" />
    </ConvertToAbsolutePath>
    <!--
      Determine project name for the assets file.
      Highest priority: PackageId
      If PackageId does not exist use: AssemblyName
      If AssemblyName does not exist fallback to the project file name without the extension: $(MSBuildProjectName)

      For non-PackageReference projects use only: $(MSBuildProjectName)
    -->
    <PropertyGroup>
      <_RestoreProjectName>$(MSBuildProjectName)</_RestoreProjectName>
      <_RestoreProjectName Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(AssemblyName)' != '' ">$(AssemblyName)</_RestoreProjectName>
      <_RestoreProjectName Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(PackageId)' != '' ">$(PackageId)</_RestoreProjectName>
    </PropertyGroup>
    <!--
      Determine project version for .NETCore projects
      Default to 1.0.0
      Use Version if it exists
      Override with PackageVersion if it exists (same as pack)
    -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' ">
      <_RestoreProjectVersion>1.0.0</_RestoreProjectVersion>
      <_RestoreProjectVersion Condition=" '$(Version)' != '' ">$(Version)</_RestoreProjectVersion>
      <_RestoreProjectVersion Condition=" '$(PackageVersion)' != '' ">$(PackageVersion)</_RestoreProjectVersion>
    </PropertyGroup>
    <!-- Determine if this will use cross targeting -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(TargetFrameworks)' != '' ">
      <_RestoreCrossTargeting>true</_RestoreCrossTargeting>
    </PropertyGroup>
    <!-- Determine if ContentFiles should be written by NuGet -->
    <PropertyGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(_RestoreSkipContentFileWrite)' == '' ">
      <_RestoreSkipContentFileWrite Condition=" '$(TargetFrameworks)' == '' AND '$(TargetFramework)' == '' ">true</_RestoreSkipContentFileWrite>
    </PropertyGroup>
    <!-- Write properties for the top level entry point -->
    <ItemGroup Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <Version>$(_RestoreProjectVersion)</Version>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <Sources>$(_OutputSources)</Sources>
        <FallbackFolders>$(_OutputFallbackFolders)</FallbackFolders>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <OutputPath>$(RestoreOutputAbsolutePath)</OutputPath>
        <RuntimeIdentifiers>$(RuntimeIdentifiers);$(RuntimeIdentifier)</RuntimeIdentifiers>
        <RuntimeSupports>$(RuntimeSupports)</RuntimeSupports>
        <CrossTargeting>$(_RestoreCrossTargeting)</CrossTargeting>
        <RestoreLegacyPackagesDirectory>$(RestoreLegacyPackagesDirectory)</RestoreLegacyPackagesDirectory>
        <ValidateRuntimeAssets>$(ValidateRuntimeIdentifierCompatibility)</ValidateRuntimeAssets>
        <SkipContentFileWrite>$(_RestoreSkipContentFileWrite)</SkipContentFileWrite>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
        <TreatWarningsAsErrors>$(TreatWarningsAsErrors)</TreatWarningsAsErrors>
        <WarningsAsErrors>$(WarningsAsErrors)</WarningsAsErrors>
        <WarningsNotAsErrors>$(WarningsNotAsErrors)</WarningsNotAsErrors>
        <NoWarn>$(NoWarn)</NoWarn>
        <RestorePackagesWithLockFile>$(RestorePackagesWithLockFile)</RestorePackagesWithLockFile>
        <NuGetLockFilePath>$(NuGetLockFilePath)</NuGetLockFilePath>
        <RestoreLockedMode>$(RestoreLockedMode)</RestoreLockedMode>
        <_CentralPackageVersionsEnabled>$(_CentralPackageVersionsEnabled)</_CentralPackageVersionsEnabled>
        <CentralPackageFloatingVersionsEnabled>$(CentralPackageFloatingVersionsEnabled)</CentralPackageFloatingVersionsEnabled>
        <CentralPackageVersionOverrideEnabled>$(CentralPackageVersionOverrideEnabled)</CentralPackageVersionOverrideEnabled>
        <CentralPackageTransitivePinningEnabled>$(CentralPackageTransitivePinningEnabled)</CentralPackageTransitivePinningEnabled>
        <NuGetAudit>$(NuGetAudit)</NuGetAudit>
        <NuGetAuditLevel>$(NuGetAuditLevel)</NuGetAuditLevel>
        <NuGetAuditMode>$(NuGetAuditMode)</NuGetAuditMode>
        <SdkAnalysisLevel>$(SdkAnalysisLevel)</SdkAnalysisLevel>
        <UsingMicrosoftNETSdk>$(UsingMicrosoftNETSdk)</UsingMicrosoftNETSdk>
        <RestoreUseLegacyDependencyResolver>$(RestoreUseLegacyDependencyResolver)</RestoreUseLegacyDependencyResolver>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Use project.json -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'ProjectJson' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <Sources>$(_OutputSources)</Sources>
        <OutputPath>$(RestoreOutputAbsolutePath)</OutputPath>
        <FallbackFolders>$(_OutputFallbackFolders)</FallbackFolders>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <ProjectJsonPath>$(_CurrentProjectJsonPath)</ProjectJsonPath>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Use packages.config -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'PackagesConfig' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <PackagesConfigPath Condition="Exists('$(MSBuildProjectDirectory)\packages.$(MSBuildProjectName).config')">$(MSBuildProjectDirectory)\packages.$(MSBuildProjectName).config</PackagesConfigPath>
        <PackagesConfigPath Condition="Exists('$(MSBuildProjectDirectory)\packages.config')">$(MSBuildProjectDirectory)\packages.config</PackagesConfigPath>
        <RestorePackagesWithLockFile>$(RestorePackagesWithLockFile)</RestorePackagesWithLockFile>
        <NuGetLockFilePath>$(NuGetLockFilePath)</NuGetLockFilePath>
        <RestoreLockedMode>$(RestoreLockedMode)</RestoreLockedMode>
        <Sources>$(_OutputSources)</Sources>
        <SolutionDir>$(SolutionDir)</SolutionDir>
        <RepositoryPath>$(_OutputRepositoryPath)</RepositoryPath>
        <ConfigFilePaths>$(_OutputConfigFilePaths)</ConfigFilePaths>
        <PackagesPath>$(_OutputPackagesPath)</PackagesPath>
        <TargetFrameworks>@(_RestoreTargetFrameworksOutputFiltered)</TargetFrameworks>
        <NuGetAudit>$(NuGetAudit)</NuGetAudit>
        <NuGetAuditLevel>$(NuGetAuditLevel)</NuGetAuditLevel>
      </_RestoreGraphEntry>
    </ItemGroup>
    <!-- Non-NuGet type -->
    <ItemGroup Condition=" '$(RestoreProjectStyle)' == 'Unknown' ">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>ProjectSpec</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
        <ProjectName>$(_RestoreProjectName)</ProjectName>
        <ProjectStyle>$(RestoreProjectStyle)</ProjectStyle>
        <TargetFrameworks>@(_RestoreTargetFrameworksOutputFiltered)</TargetFrameworks>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateProjectRestoreGraph
    Recursively walk project to project references.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraph" DependsOnTargets="&#xD;&#xA;      _GetRestoreProjectStyle;&#xD;&#xA;      _GenerateRestoreProjectSpec;&#xD;&#xA;      _GenerateRestoreDependencies" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Output from dependency targets -->
  </Target>
  <!--
    ============================================================
    _GenerateRestoreDependencies
    Generate items for package and project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreDependencies" DependsOnTargets="_GenerateProjectRestoreGraphAllFrameworks;_GenerateProjectRestoreGraphCurrentProject" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    _GenerateProjectRestoreGraphAllFrameworks
    Walk dependencies for all frameworks.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphAllFrameworks" Condition=" '$(TargetFrameworks)' != '' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Get project and package references  -->
    <!-- Evaluate for each framework -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GenerateProjectRestoreGraphPerFramework" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreGraphEntry" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateProjectRestoreGraphCurrentProject
    Walk dependencies with the current framework.
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphCurrentProject" Condition=" '$(TargetFrameworks)' == '' " DependsOnTargets="_GenerateProjectRestoreGraphPerFramework" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    _GenerateProjectRestoreGraphPerFramework
    Walk dependencies using $(TargetFramework)
    ============================================================
  -->
  <Target Name="_GenerateProjectRestoreGraphPerFramework" DependsOnTargets="_GetRestoreProjectStyle;_CollectRestoreInputs" Returns="@(_RestoreGraphEntry)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Write out project references -->
    <GetRestoreProjectReferencesTask ProjectUniqueName="$(MSBuildProjectFullPath)" ProjectReferences="@(ProjectReference)" TargetFrameworks="$(TargetFramework)" ParentProjectPath="$(MSBuildProjectFullPath)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreProjectReferencesTask>
    <!-- Write out package references-->
    <GetRestorePackageReferencesTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" PackageReferences="@(PackageReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePackageReferencesTask>
    <!-- Write out central package versions -->
    <GetCentralPackageVersionsTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' AND '$(_CentralPackageVersionsEnabled)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" CentralPackageVersions="@(PackageVersion)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetCentralPackageVersionsTask>
    <!-- Write out package downloads -->
    <GetRestorePackageDownloadsTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" PackageDownloads="@(PackageDownload)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePackageDownloadsTask>
    <!-- Write out Framework References-->
    <GetRestoreFrameworkReferencesTask Condition=" '$(PackageReferenceCompatibleProjectStyle)' == 'true' " ProjectUniqueName="$(MSBuildProjectFullPath)" FrameworkReferences="@(FrameworkReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreFrameworkReferencesTask>
    <!-- Write out advisory suppressions-->
    <GetRestoreNuGetAuditSuppressionsTask ProjectUniqueName="$(MSBuildProjectFullPath)" NuGetAuditSuppressions="@(NuGetAuditSuppress)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestoreNuGetAuditSuppressionsTask>
    <!-- Write out pruned package references-->
    <GetRestorePrunePackageReferencesTask ProjectUniqueName="$(MSBuildProjectFullPath)" PrunePackageReferences="@(PrunePackageReference)" TargetFrameworks="$(TargetFramework)">
      <Output TaskParameter="RestoreGraphItems" ItemName="_RestoreGraphEntry" />
    </GetRestorePrunePackageReferencesTask>
    <!-- Write out target framework information -->
    <ItemGroup Condition="  '$(PackageReferenceCompatibleProjectStyle)' == 'true'">
      <_RestoreGraphEntry Include="$([System.Guid]::NewGuid())">
        <Type>TargetFrameworkInformation</Type>
        <ProjectUniqueName>$(MSBuildProjectFullPath)</ProjectUniqueName>
        <PackageTargetFallback>$(PackageTargetFallback)</PackageTargetFallback>
        <AssetTargetFallback>$(AssetTargetFallback)</AssetTargetFallback>
        <TargetFramework>$(TargetFramework)</TargetFramework>
        <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$(TargetFrameworkVersion)</TargetFrameworkVersion>
        <TargetFrameworkMoniker>$(TargetFrameworkMoniker)</TargetFrameworkMoniker>
        <TargetFrameworkProfile>$(TargetFrameworkProfile)</TargetFrameworkProfile>
        <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
        <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
        <TargetPlatformVersion>$(TargetPlatformVersion)</TargetPlatformVersion>
        <TargetPlatformMinVersion>$(TargetPlatformMinVersion)</TargetPlatformMinVersion>
        <CLRSupport>$(CLRSupport)</CLRSupport>
        <RuntimeIdentifierGraphPath>$(RuntimeIdentifierGraphPath)</RuntimeIdentifierGraphPath>
        <WindowsTargetPlatformMinVersion>$(WindowsTargetPlatformMinVersion)</WindowsTargetPlatformMinVersion>
        <RestoreEnablePackagePruning>$(RestoreEnablePackagePruning)</RestoreEnablePackagePruning>
        <NuGetAuditMode>$(NuGetAuditMode)</NuGetAuditMode>
      </_RestoreGraphEntry>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsCurrentProject
    Get absolute paths for all project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsCurrentProject" Condition=" '$(TargetFrameworks)' == '' " DependsOnTargets="_GenerateRestoreProjectPathItemsPerFramework" Returns="@(_RestoreProjectPathItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsPerFramework
    Get absolute paths for all project references.
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsPerFramework" Returns="@(_RestoreProjectPathItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Get the absolute paths to all projects -->
    <ConvertToAbsolutePath Paths="@(ProjectReference)">
      <Output TaskParameter="AbsolutePaths" PropertyName="_RestoreGraphAbsoluteProjectPaths" />
    </ConvertToAbsolutePath>
    <ItemGroup>
      <_RestoreProjectPathItems Include="$(_RestoreGraphAbsoluteProjectPaths)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItems
    Get all project references regardless of framework
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItems" DependsOnTargets="_GenerateRestoreProjectPathItemsAllFrameworks;_GenerateRestoreProjectPathItemsCurrentProject" Returns="@(_CurrentRestoreProjectPathItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Drop any duplicate items -->
    <RemoveDuplicates Inputs="@(_RestoreProjectPathItems)">
      <Output TaskParameter="Filtered" ItemName="_CurrentRestoreProjectPathItems" />
    </RemoveDuplicates>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathItemsAllFrameworks
    Get all project references regardless of framework
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathItemsAllFrameworks" Condition=" '$(TargetFrameworks)' != '' " DependsOnTargets="_GetRestoreTargetFrameworksAsItems" Returns="@(_RestoreProjectPathItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Get all project references for the current project  -->
    <!-- With SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="$(MSBuildProjectFullPath)" Targets="_GenerateRestoreProjectPathItemsPerFramework" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets support -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="$(MSBuildProjectFullPath)" Targets="_GenerateRestoreProjectPathItemsPerFramework" ContinueOnError="$(RestoreContinueOnError)" Properties="TargetFramework=%(_RestoreTargetFrameworkItems.Identity);&#xD;&#xA;                  $(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GenerateRestoreProjectPathWalk
    Recursively walk projects
    ============================================================
  -->
  <Target Name="_GenerateRestoreProjectPathWalk" DependsOnTargets="_GenerateRestoreProjectPathItems" Returns="@(_RestoreProjectPathItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Walk project references  -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_CurrentRestoreProjectPathItems)" Targets="_GenerateRestoreProjectPathWalk" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_GenerateRestoreProjectPathWalkOutputs" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(_CurrentRestoreProjectPathItems)" Targets="_GenerateRestoreProjectPathWalk" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_GenerateRestoreProjectPathWalkOutputs" />
    </MSBuild>
    <!-- Include the current project in the result -->
    <ItemGroup>
      <_GenerateRestoreProjectPathWalkOutputs Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_GenerateRestoreProjectPathWalkOutputs)">
      <Output TaskParameter="Filtered" ItemName="_RestoreProjectPathItems" />
    </RemoveDuplicates>
  </Target>
  <!--
    ============================================================
    _GetAllRestoreProjectPathItems
    Get the full list of known projects.
    This includes all child projects from all target frameworks.
    ============================================================
  -->
  <Target Name="_GetAllRestoreProjectPathItems" DependsOnTargets="_FilterRestoreGraphProjectInputItems" Returns="@(_RestoreProjectPathItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NuGetMessageTask Name="DeterminingProjectsToRestore" Importance="High" />
    <!-- Walk projects -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(FilteredRestoreGraphProjectInputItems)" Targets="_GenerateRestoreProjectPathWalk" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItemsOutputs" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(FilteredRestoreGraphProjectInputItems)" Targets="_GenerateRestoreProjectPathWalk" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItemsOutputs" />
    </MSBuild>
    <!-- Remove duplicates -->
    <RemoveDuplicates Inputs="@(_RestoreProjectPathItemsOutputs)">
      <Output TaskParameter="Filtered" ItemName="_RestoreProjectPathItemsWithoutDupes" />
    </RemoveDuplicates>
    <!-- Remove projects that do not support restore. -->
    <!-- With SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' == 'true' " BuildInParallel="$(RestoreBuildInParallel)" Projects="@(_RestoreProjectPathItemsWithoutDupes)" Targets="_IsProjectRestoreSupported" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
    <!-- Without SkipNonexistentTargets -->
    <MSBuild Condition=" '$(RestoreUseSkipNonexistentTargets)' != 'true' " Projects="@(_RestoreProjectPathItemsWithoutDupes)" Targets="_IsProjectRestoreSupported" ContinueOnError="$(RestoreContinueOnError)" Properties="$(_GenerateRestoreGraphProjectEntryInputProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_RestoreProjectPathItems" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestoreSettingsOverrides
    Get global property overrides that should be resolved
    against the current working directory instead of the project.
    This is done by calling into NuGet.targets in a new scope,
    project properties will not be returned by the calls below.
    ============================================================
  -->
  <Target Name="_GetRestoreSettingsOverrides" Returns="$(_RestorePackagesPathOverride);$(_RestoreRepositoryPathOverride);$(_RestoreSourcesOverride);$(_RestoreFallbackFoldersOverride)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- RestorePackagesPathOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestorePackagesPath)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestorePackagesPathOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestorePackagesPathOverride" />
    </MSBuild>
    <!-- RestoreRepositoryPathOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreRepositoryPathOverride)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreRepositoryPathOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreRepositoryPathOverride" />
    </MSBuild>
    <!-- RestoreSourcesOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreSources)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreSourcesOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreSourcesOverride" />
    </MSBuild>
    <!-- RestoreFallbackFoldersOverride -->
    <MSBuild BuildInParallel="$(RestoreBuildInParallel)" Condition=" '$(RestoreFallbackFolders)' != '' " Projects="$(MSBuildThisFileFullPath)" Targets="_GetRestoreFallbackFoldersOverride">
      <Output TaskParameter="TargetOutputs" PropertyName="_RestoreFallbackFoldersOverride" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
    _GetRestorePackagesPathOverride
    ============================================================
  -->
  <Target Name="_GetRestorePackagesPathOverride" Returns="$(_RestorePackagesPathOverride)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_RestorePackagesPathOverride>$(RestorePackagesPath)</_RestorePackagesPathOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreRepositoryPathOverride
    ============================================================
  -->
  <Target Name="_GetRestoreRepositoryPathOverride" Returns="$(_RestoreRepositoryPathOverride)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_RestorePackagesPathOverride>$(RestoreRepositoryPath)</_RestorePackagesPathOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreSourcesOverride
    ============================================================
  -->
  <Target Name="_GetRestoreSourcesOverride" Returns="$(_RestoreSourcesOverride)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_RestoreSourcesOverride>$(RestoreSources)</_RestoreSourcesOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreFallbackFoldersOverride
    ============================================================
  -->
  <Target Name="_GetRestoreFallbackFoldersOverride" Returns="$(_RestoreFallbackFoldersOverride)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_RestoreFallbackFoldersOverride>$(RestoreFallbackFolders)</_RestoreFallbackFoldersOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _GetRestoreTargetFrameworkOverride
    ============================================================
  -->
  <Target Name="_GetRestoreTargetFrameworkOverride" Condition=" '$(_DisableNuGetRestoreTargetFrameworksOverride)' != 'true' " Returns="$(_TargetFrameworkOverride)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetGlobalPropertyValueTask PropertyName="TargetFramework" Condition=" '$(TargetFrameworks)' != '' ">
      <Output TaskParameter="GlobalPropertyValue" PropertyName="_TargetFrameworkOverride" />
    </GetGlobalPropertyValueTask>
    <!-- Only set the override if TargetFrameworks has not been overriden as well. In that case, prefer it. -->
  </Target>
  <!--
    ============================================================
    _GetTargetFrameworkOverrides
    ============================================================
  -->
  <Target Name="_GetTargetFrameworkOverrides" Returns="$(_TargetFrameworkOverride)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_TargetFrameworkOverride Condition=" '$(TargetFrameworks)' == '' ">$(TargetFramework)</_TargetFrameworkOverride>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _IsProjectRestoreSupported
    Verify restore targets exist in the project.
    ============================================================
  -->
  <Target Name="_IsProjectRestoreSupported" Returns="@(_ValidProjectsForRestore)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ValidProjectsForRestore Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Import NuGet.RestoreEx.targets if the MSBuild property 'RestoreEnableStaticGraph'
    is 'true'.  This file overrides the Restore target to use MSBuild Static Graph
    to load and evaluate projects which is much faster.

    This feature is not supported for NuGet.exe scenarios and NuGet.RestoreEx.targets
    won't exist in that case.
    ============================================================
  -->
  <!--<Import Project="NuGet.RestoreEx.targets" Condition="'$(RestoreUseStaticGraphEvaluation)' == 'true' And Exists('NuGet.RestoreEx.targets')" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(CustomAfterMicrosoftCommonTargets)" Condition="'$(CustomAfterMicrosoftCommonTargets)' != '' and Exists('$(CustomAfterMicrosoftCommonTargets)')" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.targets/ImportAfter/Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MicrosoftNETBuildExtensionsTargets Condition="'$(MicrosoftNETBuildExtensionsTargets)' == ''">$(MSBuildExtensionsPath)\Microsoft\Microsoft.NET.Build.Extensions\Microsoft.NET.Build.Extensions.targets</MicrosoftNETBuildExtensionsTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MicrosoftNETBuildExtensionsTargets)" Condition="Exists('$(MicrosoftNETBuildExtensionsTargets)')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft/Microsoft.NET.Build.Extensions/Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Build.Extensions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_TargetFrameworkVersionWithoutV>$(TargetFrameworkVersion.TrimStart('vV'))</_TargetFrameworkVersionWithoutV>
    <MicrosoftNETBuildExtensionsTasksAssembly Condition="'$(MicrosoftNETBuildExtensionsTasksAssembly)' == '' AND '$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)\tools\net10.0\Microsoft.NET.Build.Extensions.Tasks.dll</MicrosoftNETBuildExtensionsTasksAssembly>
    <MicrosoftNETBuildExtensionsTasksAssembly Condition="'$(MicrosoftNETBuildExtensionsTasksAssembly)' == ''">$(MSBuildThisFileDirectory)\tools\net472\Microsoft.NET.Build.Extensions.Tasks.dll</MicrosoftNETBuildExtensionsTasksAssembly>
    <!-- Include conflict resolution targets for NETFramework and allow other frameworks to opt-in -->
    <ResolveAssemblyConflicts Condition="'$(ResolveAssemblyConflicts)' == '' AND '$(TargetFrameworkIdentifier)' == '.NETFramework'">true</ResolveAssemblyConflicts>
  </PropertyGroup>
  <!--<Import Project="Microsoft.NET.Build.Extensions.NETFramework.targets" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />-->
  <!-- Only import ConflictResolution targets for non-SDK projects, SDK projects have ConflictResolution built in -->
  <!--<Import Project="Microsoft.NET.Build.Extensions.ConflictResolution.targets" Condition="'$(ResolveAssemblyConflicts)' == 'true' AND '$(UsingMicrosoftNETSdk)' != 'true'" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.targets/ImportAfter/Microsoft.NET.Build.Extensions.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.targets/ImportAfter/Microsoft.TestPlatform.ImportAfter.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.TestPlatform.ImportAfter.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Import Microsoft.TestPlatform.targets for VSTest target -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <VSTestTargets Condition="'$(VSTestTargets)'==''">$(MSBuildExtensionsPath)\Microsoft.TestPlatform.targets</VSTestTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(VSTestTargets)" Condition="Exists('$(VSTestTargets)')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.TestPlatform.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.TestPlatform.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
  <!-- Load Microsoft.TestPlatform.Build.Tasks.dll, this can be overridden to use a different version with $(VSTestTaskAssemblyFile) -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <VSTestTaskAssemblyFile Condition="$(VSTestTaskAssemblyFile) == ''">Microsoft.TestPlatform.Build.dll</VSTestTaskAssemblyFile>
    <VSTestConsolePath Condition="$(VSTestConsolePath) == ''">$([System.IO.Path]::Combine($(MSBuildThisFileDirectory),"vstest.console.dll"))</VSTestConsolePath>
    <VSTestNoBuild Condition="'$(VSTestNoBuild)' == ''">False</VSTestNoBuild>
    <VsTestUseMSBuildOutput Condition="'$(VsTestUseMSBuildOutput)' == ''">False</VsTestUseMSBuildOutput>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.TestPlatform.Build.Tasks.VSTestTask" AssemblyFile="$(VSTestTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.TestPlatform.Build.Tasks.VSTestLogsTask" AssemblyFile="$(VSTestTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.TestPlatform.Build.Tasks.VSTestTask2" AssemblyFile="$(VSTestTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    Test target
    Main entry point for running tests through vstest.console.exe
    ============================================================
  -->
  <Target Name="VSTest" DependsOnTargets="ShowInfoMessageIfProjectHasNoIsTestProjectProperty" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Unloggable colorized output (cf. https://github.com/microsoft/vstest/issues/680) -->
    <!-- Fallback to this old view when terminal logger is not enabled (_MSBUILDTLENABLED==0) , or when user explicitly opts out (VsTestUseMSBuildOutput != true) -->
    <CallTarget Targets="_VSTestConsole" Condition="$(_MSBUILDTLENABLED) == '0' OR !$(VsTestUseMSBuildOutput) OR $(MSBUILDENSURESTDOUTFORTASKPROCESSES) == '1'" />
    <!-- Proper MSBuild integration, but no custom colorization -->
    <!-- Use the new view whe terminal logger is enabled (_MSBUILDTLENABLED==0), and user did not opt out (VsTestUseMSBuildOutput == true) -->
    <CallTarget Targets="_VSTestMSBuild" Condition="$(_MSBUILDTLENABLED) == '1' AND $(VsTestUseMSBuildOutput)" />
  </Target>
  <!--
    Used when called from dotnet msbuild command line: uses MSBuild logs but does not allow for console colorization.
    We call to empty target _TestRunStart to mark start of the actual test running, in case we need to do build before
    the test running. This is used in MSBuild Terminal Logger to detect that the current project will run some tests.
  -->
  <Target Name="_VSTestMSBuild" Condition="'$(IsTestProject)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CallTarget Condition="!$(VSTestNoBuild)" Targets="BuildProject" />
    <CallTarget Targets="_TestRunStart" />
    <VSTestTask2 TestFileFullPath="$(TargetPath)" VSTestSetting="$([MSBuild]::ValueOrDefault($(VSTestSetting), '$(RunSettingsFilePath)'))" VSTestTestAdapterPath="$(VSTestTestAdapterPath)" VSTestFramework="$(TargetFrameworkMoniker)" VSTestPlatform="$(PlatformTarget)" VSTestTestCaseFilter="$(VSTestTestCaseFilter)" VSTestLogger="$(VSTestLogger)" VSTestListTests="$(VSTestListTests)" VSTestDiag="$(VSTestDiag)" VSTestCLIRunSettings="$(VSTestCLIRunSettings)" VSTestConsolePath="$(VSTestConsolePath)" VSTestResultsDirectory="$(VSTestResultsDirectory)" VSTestVerbosity="$(VSTestVerbosity)" VSTestCollect="$(VSTestCollect)" VSTestBlame="$(VSTestBlame)" VSTestBlameCrash="$(VSTestBlameCrash)" VSTestBlameCrashDumpType="$(VSTestBlameCrashDumpType)" VSTestBlameCrashCollectAlways="$(VSTestBlameCrashCollectAlways)" VSTestBlameHang="$(VSTestBlameHang)" VSTestBlameHangDumpType="$(VSTestBlameHangDumpType)" VSTestBlameHangTimeout="$(VSTestBlameHangTimeout)" VSTestTraceDataCollectorDirectoryPath="$(TraceDataCollectorDirectoryPath)" VSTestArtifactsProcessingMode="$(VSTestArtifactsProcessingMode)" VSTestSessionCorrelationId="$(VSTestSessionCorrelationId)" VSTestNoLogo="$(VSTestNoLogo)" />
  </Target>
  <Target Name="_TestRunStart" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!-- Used when called from dotnet test command line: does not use MSBuild logs to allow for console colorization -->
  <Target Name="_VSTestConsole" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CallTarget Condition="'$(VSTestNoBuild)' != 'true' AND '$(IsTestProject)' == 'true'" Targets="BuildProject" />
    <CallTarget Targets="ShowCallOfVSTestTaskWithParameter" />
    <VSTestTask TestFileFullPath="$(TargetPath)" VSTestSetting="$([MSBuild]::ValueOrDefault($(VSTestSetting), '$(RunSettingsFilePath)'))" VSTestTestAdapterPath="$(VSTestTestAdapterPath)" VSTestFramework="$(TargetFrameworkMoniker)" VSTestPlatform="$(PlatformTarget)" VSTestTestCaseFilter="$(VSTestTestCaseFilter)" VSTestLogger="$(VSTestLogger)" VSTestListTests="$(VSTestListTests)" VSTestDiag="$(VSTestDiag)" VSTestCLIRunSettings="$(VSTestCLIRunSettings)" VSTestConsolePath="$(VSTestConsolePath)" VSTestResultsDirectory="$(VSTestResultsDirectory)" VSTestVerbosity="$(VSTestVerbosity)" VSTestCollect="$(VSTestCollect)" VSTestBlame="$(VSTestBlame)" VSTestBlameCrash="$(VSTestBlameCrash)" VSTestBlameCrashDumpType="$(VSTestBlameCrashDumpType)" VSTestBlameCrashCollectAlways="$(VSTestBlameCrashCollectAlways)" VSTestBlameHang="$(VSTestBlameHang)" VSTestBlameHangDumpType="$(VSTestBlameHangDumpType)" VSTestBlameHangTimeout="$(VSTestBlameHangTimeout)" VSTestTraceDataCollectorDirectoryPath="$(TraceDataCollectorDirectoryPath)" VSTestArtifactsProcessingMode="$(VSTestArtifactsProcessingMode)" VSTestSessionCorrelationId="$(VSTestSessionCorrelationId)" VSTestNoLogo="$(VSTestNoLogo)" Condition="'$(IsTestProject)' == 'true'" />
  </Target>
  <Target Name="ShowInfoMessageIfProjectHasNoIsTestProjectProperty" Condition="'$(IsTestProject)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <VSTestLogsTask LogType="NoIsTestProjectProperty" ProjectFilePath="$(MSBuildProjectFullPath)" />
  </Target>
  <Target Name="BuildProject" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CallTarget Targets="ShowMsbuildWithParameter" />
    <VSTestLogsTask LogType="BuildStarted" />
    <MSBuild Projects="$(MSBuildProjectFullPath)" />
    <VSTestLogsTask LogType="BuildCompleted" />
    <Message Importance="Low" Text="Done Building project $(MSBuildProjectFullPath) for TargetFramework=$(TargetFramework)" />
  </Target>
  <Target Name="ShowMsbuildWithParameter" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Message Importance="Low" Text="Building project $(MSBuildProjectFullPath) for TargetFramework=$(TargetFramework)" />
    <Message Importance="Low" Text="Value passed to msbuild are..." />
    <Message Importance="Low" Text="Configuration = $(Configuration)" />
    <Message Importance="Low" Text="TargetFramework = $(TargetFramework)" />
    <Message Importance="Low" Text="Platform = $(PlatformTarget)" />
    <Message Importance="Low" Text="OutputPath = $(OutputPath)" />
  </Target>
  <Target Name="ShowCallOfVSTestTaskWithParameter" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Message Importance="Low" Text="Calling task Microsoft.TestPlatform.Build.Tasks.VSTestTask with following parameter..." />
    <Message Importance="Low" Text="TestFileFullPath = $(TargetPath)" />
    <Message Importance="Low" Text="VSTestSetting = $(VSTestSetting)" />
    <Message Importance="Low" Text="VSTestTestAdapterPath = $(VSTestTestAdapterPath)" />
    <Message Importance="Low" Text="VSTestFramework = $(TargetFrameworkMoniker)" />
    <Message Importance="Low" Text="VSTestPlatform = $(PlatformTarget)" />
    <Message Importance="Low" Text="VSTestTestCaseFilter = $(VSTestTestCaseFilter)" />
    <Message Importance="Low" Text="VSTestLogger = $(VSTestLogger)" />
    <Message Importance="Low" Text="VSTestListTests = $(VSTestListTests)" />
    <Message Importance="Low" Text="VSTestDiag = $(VSTestDiag)" />
    <Message Importance="Low" Text="VSTestCLIRunSettings = $(VSTestCLIRunSettings)" />
    <Message Importance="Low" Text="VSTestResultsDirectory = $(VSTestResultsDirectory)" />
    <Message Importance="Low" Text="VSTestConsolePath = $(VSTestConsolePath)" />
    <Message Importance="Low" Text="VSTestVerbosity = $(VSTestVerbosity)" />
    <Message Importance="Low" Text="VSTestCollect = $(VSTestCollect)" />
    <Message Importance="Low" Text="VSTestBlame = $(VSTestBlame)" />
    <Message Importance="Low" Text="VSTestTraceDataCollectorDirectoryPath = $(TraceDataCollectorDirectoryPath)" />
    <Message Importance="Low" Text="VSTestNoLogo = $(VSTestNoLogo)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Current/Microsoft.Common.targets/ImportAfter/Microsoft.TestPlatform.ImportAfter.targets
============================================================================================================================================
-->
  <Target Name="_MTPBuild" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CallTarget Targets="Build" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.targets
============================================================================================================================================
-->
  <!--
      Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
          $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.targets

        Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
        management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
  -->
  <PropertyGroup>
    <!--
        Don't import project extensions during restore because NuGet restore generates them.  Importing them during restore will embed
        the pre-restore files in the binary log and then NuGet won't be able to embed the generated one after restore.  If some other
        project extension mechanism wants to import project extensions during restore, they need to explicitly set ImportProjectExtensionTargets
    -->
    <ImportProjectExtensionTargets Condition="$([MSBuild]::AreFeaturesEnabled('17.10')) And '$(ImportProjectExtensionTargets)' == '' And '$(MSBuildIsRestoring)' == 'true'">false</ImportProjectExtensionTargets>
    <ImportProjectExtensionTargets Condition="'$(ImportProjectExtensionTargets)' == ''">true</ImportProjectExtensionTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.targets" Condition="'$(ImportProjectExtensionTargets)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')">

/home/runner/work/aspnetcore/aspnetcore/artifacts/obj/Microsoft.AspNetCore.Components.CustomElements/Microsoft.AspNetCore.Components.CustomElements.csproj.nuget.g.targets
============================================================================================================================================
-->
  <!--<ImportGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.codeanalysis.publicapianalyzers/3.3.3/build/Microsoft.CodeAnalysis.PublicApiAnalyzers.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.codeanalysis.publicapianalyzers/3.3.3/build/Microsoft.CodeAnalysis.PublicApiAnalyzers.targets')">

/home/runner/.nuget/packages/microsoft.codeanalysis.publicapianalyzers/3.3.3/build/Microsoft.CodeAnalysis.PublicApiAnalyzers.targets
============================================================================================================================================
-->
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisPublicApiAnalyzers" BeforeTargets="CoreCompile" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true'">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers>$(AnalysisLevelSuffix)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers)' == ''">$(AnalysisMode)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisPublicApiAnalyzersRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzers Condition="'$(MicrosoftCodeAnalysisPublicApiAnalyzersRulesVersion)' != ''">AnalysisLevel_$(MicrosoftCodeAnalysisPublicApiAnalyzersRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzers).editorconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzers>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzers>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzers.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzers>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisPublicApiAnalyzers Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisPublicApiAnalyzers)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisPublicApiAnalyzers>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisPublicApiAnalyzers Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzers)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisPublicApiAnalyzers)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzers)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisPublicApiAnalyzers>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisPublicApiAnalyzers)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisPublicApiAnalyzers)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisPublicApiAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelApiDesign)' != '' or '$(AnalysisModeApiDesign)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>$(AnalysisLevelSuffixApiDesign)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)' == ''">$(AnalysisModeApiDesign)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisPublicApiAnalyzersApiDesignRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign Condition="'$(MicrosoftCodeAnalysisPublicApiAnalyzersApiDesignRulesVersion)' != ''">AnalysisLevelApiDesign_$(MicrosoftCodeAnalysisPublicApiAnalyzersApiDesignRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign).editorconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisPublicApiAnalyzersApiDesign)" />
    </ItemGroup>
  </Target>
  <!-- MSBuild properties to thread to the analyzers as options -->
  <ItemGroup>
    <CompilerVisibleProperty Include="TargetFramework" />
    <CompilerVisibleProperty Include="TargetPlatformMinVersion" />
    <CompilerVisibleProperty Include="UsingMicrosoftNETSdkWeb" />
    <CompilerVisibleProperty Include="ProjectTypeGuids" />
    <CompilerVisibleProperty Include="InvariantGlobalization" />
    <CompilerVisibleProperty Include="PlatformNeutralAssembly" />
  </ItemGroup>
  <!-- MSBuild item metadata to thread to the analyzers as options -->
  <PropertyGroup>
    <_SupportedPlatformList>@(SupportedPlatform, ',')</_SupportedPlatformList>
  </PropertyGroup>
  <!-- MSBuild properties to thread to the analyzers as options -->
  <ItemGroup>
    <CompilerVisibleProperty Include="_SupportedPlatformList" />
  </ItemGroup>
  <!--
    Design-time target to prevent the rule ids implemented in this package to be bumped to errors in the IDE
    when 'CodeAnalysisTreatWarningsAsErrors' = 'false'. Note that a similar 'WarningsNotAsErrors'
    property group is present in the generated props file to ensure this functionality on command line builds.
  -->
  <Target Name="_CodeAnalysisTreatWarningsNotAsErrors" BeforeTargets="CoreCompile" Condition="'$(CodeAnalysisTreatWarningsAsErrors)' == 'false' AND ('$(DesignTimeBuild)' == 'true' OR '$(BuildingProject)' != 'true')">
    <PropertyGroup>
      <WarningsNotAsErrors>$(WarningsNotAsErrors);$(CodeAnalysisRuleIds)</WarningsNotAsErrors>
    </PropertyGroup>
  </Target>
  <!-- Workaround for https://github.com/dotnet/roslyn/issues/4655 -->
  <ItemGroup Condition="Exists('$(MSBuildProjectDirectory)\PublicAPI.Shipped.txt')">
    <AdditionalFiles Include="PublicAPI.Shipped.txt" />
  </ItemGroup>
  <ItemGroup Condition="Exists('$(MSBuildProjectDirectory)\PublicAPI.Unshipped.txt')">
    <AdditionalFiles Include="PublicAPI.Unshipped.txt" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/artifacts/obj/Microsoft.AspNetCore.Components.CustomElements/Microsoft.AspNetCore.Components.CustomElements.csproj.nuget.g.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.extensions.options/10.0.0-preview.7.25377.103/buildTransitive/net8.0/Microsoft.Extensions.Options.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.extensions.options/10.0.0-preview.7.25377.103/buildTransitive/net8.0/Microsoft.Extensions.Options.targets')">

/home/runner/.nuget/packages/microsoft.extensions.options/10.0.0-preview.7.25377.103/buildTransitive/net8.0/Microsoft.Extensions.Options.targets
============================================================================================================================================
-->
  <Target Name="_Microsoft_Extensions_OptionsGatherAnalyzers">
    <ItemGroup>
      <_Microsoft_Extensions_OptionsAnalyzer Include="@(Analyzer)" Condition="'%(Analyzer.NuGetPackageId)' == 'Microsoft.Extensions.Options'" />
    </ItemGroup>
  </Target>
  <Target Name="_Microsoft_Extensions_OptionsAnalyzerMultiTargeting" Condition="'$(SupportsRoslynComponentVersioning)' != 'true'" AfterTargets="ResolvePackageDependenciesForBuild;ResolveNuGetPackageAssets" DependsOnTargets="_Microsoft_Extensions_OptionsGatherAnalyzers">
    <ItemGroup>
      <!-- Remove our analyzers targeting roslyn4.x -->
      <Analyzer Remove="@(_Microsoft_Extensions_OptionsAnalyzer)" Condition="$([System.String]::Copy('%(_Microsoft_Extensions_OptionsAnalyzer.Identity)').IndexOf('roslyn4')) &gt;= 0" />
    </ItemGroup>
  </Target>
  <Target Name="_Microsoft_Extensions_OptionsRemoveAnalyzers" Condition="'$(DisableMicrosoftExtensionsOptionsSourceGenerator)' == 'true'" AfterTargets="ResolvePackageDependenciesForBuild;ResolveNuGetPackageAssets" DependsOnTargets="_Microsoft_Extensions_OptionsGatherAnalyzers">
    <!-- Remove all our analyzers -->
    <ItemGroup>
      <Analyzer Remove="@(_Microsoft_Extensions_OptionsAnalyzer)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/artifacts/obj/Microsoft.AspNetCore.Components.CustomElements/Microsoft.AspNetCore.Components.CustomElements.csproj.nuget.g.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(NuGetPackageRoot)microsoft.extensions.logging.abstractions/10.0.0-preview.7.25377.103/buildTransitive/net8.0/Microsoft.Extensions.Logging.Abstractions.targets" Condition="Exists('$(NuGetPackageRoot)microsoft.extensions.logging.abstractions/10.0.0-preview.7.25377.103/buildTransitive/net8.0/Microsoft.Extensions.Logging.Abstractions.targets')">

/home/runner/.nuget/packages/microsoft.extensions.logging.abstractions/10.0.0-preview.7.25377.103/buildTransitive/net8.0/Microsoft.Extensions.Logging.Abstractions.targets
============================================================================================================================================
-->
  <Target Name="_Microsoft_Extensions_Logging_AbstractionsGatherAnalyzers">
    <ItemGroup>
      <_Microsoft_Extensions_Logging_AbstractionsAnalyzer Include="@(Analyzer)" Condition="'%(Analyzer.NuGetPackageId)' == 'Microsoft.Extensions.Logging.Abstractions'" />
    </ItemGroup>
  </Target>
  <Target Name="_Microsoft_Extensions_Logging_AbstractionsAnalyzerMultiTargeting" Condition="'$(SupportsRoslynComponentVersioning)' != 'true'" AfterTargets="ResolvePackageDependenciesForBuild;ResolveNuGetPackageAssets" DependsOnTargets="_Microsoft_Extensions_Logging_AbstractionsGatherAnalyzers">
    <ItemGroup>
      <!-- Remove our analyzers targeting roslyn4.x -->
      <Analyzer Remove="@(_Microsoft_Extensions_Logging_AbstractionsAnalyzer)" Condition="$([System.String]::Copy('%(_Microsoft_Extensions_Logging_AbstractionsAnalyzer.Identity)').IndexOf('roslyn4')) &gt;= 0" />
    </ItemGroup>
  </Target>
  <Target Name="_Microsoft_Extensions_Logging_AbstractionsRemoveAnalyzers" Condition="'$(DisableMicrosoftExtensionsLoggingSourceGenerator)' == 'true'" AfterTargets="ResolvePackageDependenciesForBuild;ResolveNuGetPackageAssets" DependsOnTargets="_Microsoft_Extensions_Logging_AbstractionsGatherAnalyzers">
    <!-- Remove all our analyzers -->
    <ItemGroup>
      <Analyzer Remove="@(_Microsoft_Extensions_Logging_AbstractionsAnalyzer)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/artifacts/obj/Microsoft.AspNetCore.Components.CustomElements/Microsoft.AspNetCore.Components.CustomElements.csproj.nuget.g.targets
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <ImportDirectoryBuildTargets Condition="'$(ImportDirectoryBuildTargets)' == ''">true</ImportDirectoryBuildTargets>
  </PropertyGroup>
  <!--
      Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
      they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
  -->
  <PropertyGroup Condition="'$(ImportDirectoryBuildTargets)' == 'true' and '$(DirectoryBuildTargetsPath)' == ''">
    <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
    <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
  </PropertyGroup>
  <!--<Import Project="$(CustomBeforeDirectoryBuildTargets)" Condition="'$(CustomBeforeDirectoryBuildTargets)' != ''" />-->
  <!--
============================================================================================================================================
  <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')">

/home/runner/work/aspnetcore/aspnetcore/src/Components/Directory.Build.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(UsingMicrosoftNETSdkBlazorWebAssembly)' == 'true' and '$(BuildNodeJS)' != 'false'">
    <BlazorWebAssemblyJSPath Condition=" '$(Configuration)' == 'Debug' ">$(RepoRoot)src\Components\Web.JS\dist\Debug\blazor.webassembly.js</BlazorWebAssemblyJSPath>
    <BlazorWebAssemblyJSPath Condition=" '$(Configuration)' != 'Debug' ">$(RepoRoot)src\Components\Web.JS\dist\Release\blazor.webassembly.js</BlazorWebAssemblyJSPath>
    <BlazorWebAssemblyJSMapPath>$(BlazorWebAssemblyJSPath).map</BlazorWebAssemblyJSMapPath>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory)..\, Directory.Build.targets))\Directory.Build.targets">

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- Disable IsTrimmable on non-DefaultNetCoreTargetFrameworks even if explicitly enabled or else we'll get NETSDK1195 and NETSDK1210 errors -->
    <IsTrimmable Condition="'$(TargetFramework)' != '$(DefaultNetCoreTargetFramework)'" />
    <EnableAOTAnalyzer Condition=" '$(EnableAOTAnalyzer)' == '' ">$([MSBuild]::ValueOrDefault($(IsTrimmable),'false'))</EnableAOTAnalyzer>
    <!-- TODO: Remove when analyzer is enabled by default with AOT in SDK. See https://github.com/dotnet/sdk/issues/31284 -->
    <EnableSingleFileAnalyzer Condition=" '$(EnableSingleFileAnalyzer)' == '' ">$(EnableAOTAnalyzer)</EnableSingleFileAnalyzer>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Ignore API doc requirements for test assets -->
    <NoWarn Condition="'$(IsTestAssetProject)' == 'true' or '$(IsSampleProject)' == 'true' or '$(IsBenchmarkProject)' == 'true' or&#xA;      '$(IsMicrobenchmarksProject)' == 'true'">$(NoWarn);CS1591</NoWarn>
  </PropertyGroup>
  <PropertyGroup Label="Resx settings">
    <GenerateResxSource Condition="'$(GenerateResxSource)' == ''">true</GenerateResxSource>
    <GenerateResxSourceEmitFormatMethods Condition="'$(GenerateResxSourceEmitFormatMethods)' == ''">true</GenerateResxSourceEmitFormatMethods>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Sdk.targets" Sdk="Microsoft.DotNet.Arcade.Sdk">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/sdk/Sdk.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    Some projects do not import Common targets, so BeforeCommonTargets.targets doesn't get imported. 
    (https://github.com/dotnet/arcade/issues/2676).
  -->
  <PropertyGroup>
    <_BeforeCommonTargetsHookUsed>true</_BeforeCommonTargetsHookUsed>
    <_BeforeCommonTargetsHookUsed Condition="'$(_ArcadeBeforeCommonTargetsImported)' != 'true'">false</_BeforeCommonTargetsHookUsed>
  </PropertyGroup>
  <!--<Import Project="..\tools\BeforeCommonTargets.targets" Condition="'$(_SuppressSdkImports)' != 'true' and '$(_ArcadeBeforeCommonTargetsImported)' != 'true' and '$(IsCrossTargetingBuild)' != 'true'" />-->
  <!--<Import Project="..\tools\BeforeCommonTargets.CrossTargeting.targets" Condition="'$(_SuppressSdkImports)' != 'true' and '$(_ArcadeBeforeCommonTargetsImported)' != 'true' and '$(IsCrossTargetingBuild)' == 'true'" />-->
  <!-- 
    Output the location of the Build.proj so that the build driver can find where it was restored.
    Ideally we would have msbuild API to do that for an SDK: https://github.com/Microsoft/msbuild/issues/2992
  -->
  <Target Name="__WriteToolsetLocation" Outputs="$(__ToolsetLocationOutputFile)" Condition="'$(__ToolsetLocationOutputFile)' != ''">
    <WriteLinesToFile File="$(__ToolsetLocationOutputFile)" Lines="$([System.IO.Path]::GetFullPath('$(MSBuildThisFileDirectory)..\tools\Build.proj'))" Overwrite="true" />
    <ItemGroup>
      <FileWrites Include="$(__ToolsetLocationOutputFile)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  <Import Project="..\tools\Imports.targets" Condition="'$(_SuppressSdkImports)' != 'true' and '$(_SuppressAllTargets)' != 'true'">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
============================================================================================================================================
  <Import Project="ProjectDefaults.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/ProjectDefaults.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <DeployProjectOutput Condition="'$(DeployProjectOutput)' == ''">$(__DeployProjectOutput)</DeployProjectOutput>
    <!-- Run Deploy step by default when the solution is build directly via msbuild (from command line or VS). -->
    <DeployProjectOutput Condition="'$(DeployProjectOutput)' == ''">true</DeployProjectOutput>
  </PropertyGroup>
  <!-- Default empty deploy target. -->
  <Target Name="Deploy" AfterTargets="Build" Condition="'$(DeployProjectOutput)' == 'true'" />
  <PropertyGroup>
    <!--
      Set PackageOutputPath based on the IsShippingPackage flag set by projects.
      This distinction allows publishing tools to determine which assets to publish to official channels.

      Visual Studio Build (aka CoreXT) packages are non-shipping packages that are used to insert binaries into an internal 
      Visual Studio repository that builds the product from components. These packages are not standard NuGet packages.
    -->
    <PackageOutputPath Condition="'$(IsShippingPackage)' == 'true'">$(ArtifactsShippingPackagesDir)</PackageOutputPath>
    <PackageOutputPath Condition="'$(IsShippingPackage)' != 'true'">$(ArtifactsNonShippingPackagesDir)</PackageOutputPath>
    <PackageOutputPath Condition="'$(IsVisualStudioBuildPackage)' == 'true'">$(VisualStudioBuildPackagesDir)</PackageOutputPath>
    <IsSwixProject>false</IsSwixProject>
    <IsSwixProject Condition="'$(VisualStudioInsertionComponent)' != '' and '$(IsVsixProject)' != 'true'">true</IsSwixProject>
  </PropertyGroup>
  <!--
    Closed source license must be added to the package. 
    NuGet.org accepts only OSI or FSF approved licenses when using license type expression. 
  -->
  <PropertyGroup Condition="'$(PackageLicenseExpressionInternal)' != '' and '$(IsPackable)' == 'true' and '$(PackageLicenseFile)' == ''">
    <PackageLicenseFile>License.txt</PackageLicenseFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(PackageLicenseExpressionInternal)' != '' and '$(IsPackable)' == 'true' and '$(PackageLicenseFullPath)' == ''">
    <PackageLicenseFullPath>$(MSBuildThisFileDirectory)Licenses\$(PackageLicenseExpressionInternal).txt</PackageLicenseFullPath>
  </PropertyGroup>
  <ItemGroup Condition="'$(PackageLicenseExpressionInternal)' != '' and '$(IsPackable)' == 'true'">
    <None Include="$(PackageLicenseFullPath)" Pack="true" PackagePath="$(PackageLicenseFile)" Visible="false" />
  </ItemGroup>
  <!--
    Include package icon in the package.
  -->
  <ItemGroup Condition="'$(PackageIcon)' != '' and '$(IsPackable)' == 'true'">
    <None Include="$(PackageIconFullPath)" Pack="true" PackagePath="$(PackageIcon)" Visible="false" />
  </ItemGroup>
  <!--
    Copyright used for binary assets (assemblies and packages) built by Microsoft must be Microsoft copyright.
    Override any other value the project may set.
  -->
  <PropertyGroup>
    <Copyright>$(CopyrightMicrosoft)</Copyright>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="StrongName.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/StrongName.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    Reads variables:
      SignAssembly    "true" to sign the output assembly of the current project
      FullAssemblySigningSupported    "false" to use public signing even when full signing is possible. This is useful
                                      in environments where full signing is non-functional or not desired. For example,
                                      in some Linux distributions RSA+SHA1 (required for full signing) is not
                                      functional/available, and trying to use full signing results in the runtime
                                      throwing an exception. For more details and an example, see
                                      https://github.com/dotnet/runtime/issues/65874. We default to full assembly
                                      signing not being supported in source-only modes.
      StrongNameKeyId The id of the key used for strong name generation

    Writes variables:
      DelaySign
      PublicSign
      PublicKey
      PublicKeyToken
      AssemblyOriginatorKeyFile
  -->
  <PropertyGroup Condition="'$(SignAssembly)' != 'false'">
    <DelaySign>false</DelaySign>
    <PublicSign>true</PublicSign>
  </PropertyGroup>
  <!-- Binaries are delay or public-signed with one of these keys; later, the signing system will finish the strong-name signing. -->
  <Choose>
    <When Condition="'$(SignAssembly)' == 'false'" />
    <When Condition="'$(StrongNameKeyId)' == 'Microsoft'">
      <PropertyGroup>
        <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)snk/MSFT.snk</AssemblyOriginatorKeyFile>
        <PublicKey>$(MicrosoftPublicKey)</PublicKey>
        <PublicKeyToken>b03f5f7f11d50a3a</PublicKeyToken>
      </PropertyGroup>
    </When>
    <When Condition="'$(StrongNameKeyId)' == 'MicrosoftShared'">
      <PropertyGroup>
        <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)snk/35MSSharedLib1024.snk</AssemblyOriginatorKeyFile>
        <PublicKey>$(MicrosoftSharedPublicKey)</PublicKey>
        <PublicKeyToken>31BF3856AD364E35</PublicKeyToken>
      </PropertyGroup>
    </When>
    <When Condition="'$(StrongNameKeyId)' == 'MicrosoftAspNetCore'">
      <PropertyGroup>
        <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)snk/AspNetCore.snk</AssemblyOriginatorKeyFile>
        <PublicKey>$(MicrosoftAspNetCorePublicKey)</PublicKey>
        <PublicKeyToken>adb9793829ddae60</PublicKeyToken>
        <PublicSign Condition="'$(FullAssemblySigningSupported)' != 'false'">false</PublicSign>
        <!-- The MicrosoftAspNetCore strong name key is a full key -->
      </PropertyGroup>
    </When>
    <When Condition="'$(StrongNameKeyId)' == 'ECMA'">
      <PropertyGroup>
        <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)snk/ECMA.snk</AssemblyOriginatorKeyFile>
        <PublicKey>$(ECMAPublicKey)</PublicKey>
        <PublicKeyToken>b77a5c561934e089</PublicKeyToken>
      </PropertyGroup>
    </When>
    <!--
      The Open key can be used by any library that needs strong name signing that doesn't
      have to be protected by the closed MS based keys. The idea is to have a key for identity but
      not for any security purposes.
    -->
    <When Condition="'$(StrongNameKeyId)' == 'Open'">
      <PropertyGroup>
        <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)snk/Open.snk</AssemblyOriginatorKeyFile>
        <PublicKey>$(OpenPublicKey)</PublicKey>
        <PublicKeyToken>cc7b13ffcd2ddd51</PublicKeyToken>
        <DelaySign>false</DelaySign>
        <PublicSign Condition="'$(FullAssemblySigningSupported)' != 'false'">false</PublicSign>
        <!-- The Open strong name key is a full key -->
      </PropertyGroup>
    </When>
    <When Condition="'$(StrongNameKeyId)' == 'SilverlightPlatform'">
      <PropertyGroup>
        <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)snk/SilverlightPlatformPublicKey.snk</AssemblyOriginatorKeyFile>
        <PublicKey>$(SilverlightPlatformPublicKey)</PublicKey>
        <PublicKeyToken>7cec85d7bea7798e</PublicKeyToken>
      </PropertyGroup>
    </When>
  </Choose>
  <!-- Build Flag Verification -->
  <PropertyGroup>
    <PrepareForBuildDependsOn>$(PrepareForBuildDependsOn);VerifyBuildFlags</PrepareForBuildDependsOn>
  </PropertyGroup>
  <Target Name="VerifyBuildFlags">
    <Error Condition="'$(SignAssembly)' != 'false' and&#xD;&#xA;                      ('$(PublicKey)' == '' or '$(PublicKeyToken)' == '' or '$(AssemblyOriginatorKeyFile)' == '')" Text="PublicKey, PublicKeyToken and AssemblyOriginatorKeyFile must be specified" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="GenerateChecksums.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/GenerateChecksums.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <UsingTask TaskName="Microsoft.DotNet.Arcade.Sdk.GenerateChecksums" AssemblyFile="$(ArcadeSdkBuildTasksAssembly)" />
  <!--
    Generate Checksums for the specified assets. Runs after the build of a project.
  -->
  <Target Name="GenerateChecksums" Condition="'@(GenerateChecksumItems)' != ''" AfterTargets="Build">
    <Error Condition="'%(GenerateChecksumItems.DestinationPath)' == ''" Text="Item &quot;%(GenerateChecksumItems.Identity)&quot; does not define required metadata &quot;DestinationPath&quot;" />
    <GenerateChecksums Items="@(GenerateChecksumItems)" />
    <!-- Automatically include generated checksums in the asset manifest -->
    <ItemGroup>
      <ItemsToPushToBlobFeed Include="@(GenerateChecksumItems -> '%(DestinationPath)')" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="GenerateInternalsVisibleTo.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/GenerateInternalsVisibleTo.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup>
    <GeneratedInternalsVisibleToFile>$(IntermediateOutputPath)$(MSBuildProjectName).InternalsVisibleTo$(DefaultLanguageSourceExtension)</GeneratedInternalsVisibleToFile>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <InternalsVisibleTo>
      <Visible>false</Visible>
    </InternalsVisibleTo>
  </ItemDefinitionGroup>
  <Target Name="PrepareGenerateInternalsVisibleToFile" Condition="'@(InternalsVisibleTo)' != ''">
    <ItemGroup>
      <_InternalsVisibleToAttribute Include="System.Runtime.CompilerServices.InternalsVisibleToAttribute">
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' != ''">%(InternalsVisibleTo.Identity), PublicKey=%(InternalsVisibleTo.Key)</_Parameter1>
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' == '' and '$(PublicKey)' != ''">%(InternalsVisibleTo.Identity), PublicKey=$(PublicKey)</_Parameter1>
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' == '' and '$(PublicKey)' == ''">%(InternalsVisibleTo.Identity)</_Parameter1>
      </_InternalsVisibleToAttribute>
    </ItemGroup>
  </Target>
  <!--
    Dependency on PrepareForBuild is necessary so that we don't accidentally get ordered before it.
    We rely on PrepareForBuild to create the IntermediateOutputDirectory if it doesn't exist.

    Must run before BeforeCompile, as it's the MSBuild's convention for code generators.
  -->
  <Target Name="GenerateInternalsVisibleToFile" Inputs="$(MSBuildThisFileFullPath);$(MSBuildProjectFile)" Outputs="$(GeneratedInternalsVisibleToFile)" DependsOnTargets="PrepareGenerateInternalsVisibleToFile;PrepareForBuild" Condition="'@(InternalsVisibleTo)' != ''" BeforeTargets="BeforeCompile;CoreCompile">
    <WriteCodeFragment AssemblyAttributes="@(_InternalsVisibleToAttribute)" Language="$(Language)" OutputFile="$(GeneratedInternalsVisibleToFile)">
      <Output TaskParameter="OutputFile" ItemName="CompileBefore" Condition="'$(Language)' == 'F#'" />
      <Output TaskParameter="OutputFile" ItemName="Compile" Condition="'$(Language)' != 'F#'" />
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="GenerateResxSource.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/GenerateResxSource.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    Generates a class source for EmbeddedResource whose GenerateSource property is set to true.
    The source file is generated to intermediate output dir to avoid polluting the source tree.
    See https://github.com/dotnet/sdk/issues/94 that tracks productization of this code.
  -->
  <UsingTask TaskName="Microsoft.DotNet.Arcade.Sdk.GenerateResxSource" AssemblyFile="$(ArcadeSdkBuildTasksAssembly)" />
  <!-- Set the Generator metadata so that VS triggers design-time build whenever the .resx file is saved -->
  <ItemGroup>
    <EmbeddedResource Update="@(EmbeddedResource)">
      <GenerateSource Condition="'%(Extension)' == '.resx' and '%(GenerateSource)' == '' and '$(GenerateResxSource)' == 'true'">true</GenerateSource>
      <Generator Condition="'%(Extension)' == '.resx' and '%(Generator)' == '' and ('%(GenerateSource)' == 'true' or ('%(GenerateSource)' == '' and '$(GenerateResxSource)' == 'true') )">MSBuild:_GenerateResxSource</Generator>
    </EmbeddedResource>
  </ItemGroup>
  <!--
    Note: Targets that generate Compile items are expected to run before BeforeCompile targets (common targets convention).
  -->
  <Target Name="_GenerateResxSource" BeforeTargets="BeforeCompile;CoreCompile" DependsOnTargets="PrepareResourceNames;&#xD;&#xA;                            _GetEmbeddedResourcesWithSourceGeneration;&#xD;&#xA;                            _BatchGenerateResxSource">
    <ItemGroup>
      <GeneratedResxSource Include="@(EmbeddedResourceSGResx->'%(SourceOutputPath)')" />
      <FileWrites Include="@(GeneratedResxSource)" />
      <Compile Include="@(GeneratedResxSource)" />
    </ItemGroup>
  </Target>
  <Target Name="_CustomizeResourceNames" BeforeTargets="PrepareResourceNames">
    <ItemGroup>
      <EmbeddedResource>
        <ManifestResourceName Condition="'%(EmbeddedResource.Namespace)' != ''">%(EmbeddedResource.Namespace).%(EmbeddedResource.Filename)</ManifestResourceName>
      </EmbeddedResource>
    </ItemGroup>
  </Target>
  <Target Name="_BatchGenerateResxSource" Inputs="@(EmbeddedResourceSGResx)" Outputs="%(EmbeddedResourceSGResx.SourceOutputPath)">
    <Microsoft.DotNet.Arcade.Sdk.GenerateResxSource Language="$(Language)" ResourceFile="%(EmbeddedResourceSGResx.FullPath)" ResourceName="%(EmbeddedResourceSGResx.ManifestResourceName)" ResourceClassName="%(EmbeddedResourceSGResx.ClassName)" AsConstants="%(EmbeddedResourceSGResx.GenerateResourcesCodeAsConstants)" OmitGetResourceString="$(GenerateResxSourceOmitGetResourceString)" IncludeDefaultValues="$(GenerateResxSourceIncludeDefaultValues)" EmitFormatMethods="$(GenerateResxSourceEmitFormatMethods)" OutputPath="%(EmbeddedResourceSGResx.SourceOutputPath)" />
  </Target>
  <Target Name="_GetEmbeddedResourcesWithSourceGeneration" Condition="'@(EmbeddedResource)' != ''">
    <PropertyGroup>
      <_EmbeddedResourceSourceExtension Condition="'$(Language)' == 'C#'">cs</_EmbeddedResourceSourceExtension>
      <_EmbeddedResourceSourceExtension Condition="'$(Language)' == 'VB'">vb</_EmbeddedResourceSourceExtension>
      <_EmbeddedResourceSourceExtension Condition="'$(Language)' == 'F#'">fs</_EmbeddedResourceSourceExtension>
    </PropertyGroup>
    <Error Text="GenerateResxSource doesn't support language: '$(Language)'" Condition="'$(_EmbeddedResourceSourceExtension)' == ''" />
    <ItemGroup>
      <EmbeddedResourceSG Include="@(EmbeddedResource)" Condition="'%(EmbeddedResource.GenerateSource)' == 'true' and '%(EmbeddedResource.XlfLanguage)' == ''" />
      <EmbeddedResourceSG Condition="'$(Language)' != 'F#'">
        <SourceOutputPath Condition="'%(EmbeddedResourceSG.SourceOutputPath)' == '' AND '%(EmbeddedResourceSG.ClassName)' != ''">$(IntermediateOutputPath)%(EmbeddedResourceSG.ClassName).$(_EmbeddedResourceSourceExtension)</SourceOutputPath>
        <SourceOutputPath Condition="'%(EmbeddedResourceSG.SourceOutputPath)' == '' AND '%(EmbeddedResourceSG.ClassName)' == ''">$(IntermediateOutputPath)%(EmbeddedResourceSG.ManifestResourceName).$(_EmbeddedResourceSourceExtension)</SourceOutputPath>
      </EmbeddedResourceSG>
      <!-- Other source generators might exist, so create a separate group for the items that are set to use the generator from this targets file. -->
      <EmbeddedResourceSGResx Include="@(EmbeddedResourceSG-&gt;WithMetadataValue('Generator', 'MSBuild:_GenerateResxSource'))" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Workarounds.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Workarounds.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!-- Workaround for https://github.com/Microsoft/msbuild/issues/1310 -->
  <Target Name="ForceGenerationOfBindingRedirects" AfterTargets="ResolveAssemblyReferences" BeforeTargets="GenerateBindingRedirects" Condition="'$(AutoGenerateBindingRedirects)' == 'true'">
    <PropertyGroup>
      <!-- Needs to be set in a target because it has to be set after the initial evaluation in the common targets -->
      <GenerateBindingRedirectsOutputType>true</GenerateBindingRedirectsOutputType>
    </PropertyGroup>
  </Target>
  <!--
    WPF temp project sets OutDir, which makes the SDK create an empty directory for it,
    polluting the output dir. Avoid creating these directories.
    https://github.com/dotnet/sdk/issues/1367
  -->
  <PropertyGroup Condition="'$(IsWpfTempProject)' == 'true'">
    <OutDir />
  </PropertyGroup>
  <!--
    Workaround to fix that Visual Studio sometimes uses a special MSBuild evaluation
    mode where all common conditions (e.g., inside ItemGroup) are ignored.
  -->
  <Choose>
    <When Condition=" '$(IsWpfTempProject)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETFramework' ">
      <ItemGroup>
        <Reference Include="mscorlib" Pack="false" />
      </ItemGroup>
    </When>
  </Choose>
  <!--
     Portable PDBs are not included in .nupkg by default. Include them unless the project produces symbol packages.
     Remove this once we migrate to .snupkg. See https://github.com/dotnet/arcade/issues/1959.
   -->
  <PropertyGroup Condition="'$(DebugType)' == 'portable' and '$(IncludeSymbols)' != 'true'">
    <AllowedOutputExtensionsInPackageBuildOutputFolder>$(AllowedOutputExtensionsInPackageBuildOutputFolder);.pdb</AllowedOutputExtensionsInPackageBuildOutputFolder>
  </PropertyGroup>
  <!--
    Workarounds for insufficient support for tools packages by NuGet Pack: https://github.com/NuGet/Home/issues/6321.

    Project that produce tools packages use .nuspec file in order to include all the needed dependencies.
    This target translates common msbuild properties to NuSpec properties.
  -->
  <Target Name="InitializeStandardNuspecProperties" BeforeTargets="GenerateNuspec" DependsOnTargets="_InitializeNuspecRepositoryInformationPropertiesWorkaround" Condition="'$(IsPackable)' == 'true'">
    <PropertyGroup>
      <PackageId Condition="'$(NuspecPackageId)' != ''">$(NuspecPackageId)</PackageId>
      <PackageProjectUrl Condition="'$(PackageProjectUrl)' == ''">$(RepositoryUrl)</PackageProjectUrl>
    </PropertyGroup>
    <Error Text="PackageDescription must be specified" Condition="'$(PackageDescription)' == ''" />
    <Error Text="PackageProjectUrl must be specified" Condition="'$(PackageProjectUrl)' == ''" />
    <Error Text="RepositoryUrl must be specified" Condition="'$(RepositoryUrl)' == ''" />
    <Error Text="RepositoryCommit must be specified" Condition="'$(RepositoryCommit)' == ''" />
    <Error Text="RepositoryType must be specified" Condition="'$(RepositoryType)' == ''" />
    <Error Text="Either PackageLicenseExpression or PackageLicenseFile must be specified" Condition="'$(PackageLicenseExpression)' == '' and '$(PackageLicenseFile)' == ''" />
    <PropertyGroup Condition="'$(NuspecFile)' != '' and '$(NuspecProperties)' == ''">
      <_LicenseElement />
      <_LicenseElement Condition="'$(PackageLicenseExpression)' != ''">
        <license type="expression">$(PackageLicenseExpression)</license>
      </_LicenseElement>
      <_LicenseElement Condition="'$(PackageLicenseFile)' != ''">
        <license type="file">$(PackageLicenseFile)</license>
      </_LicenseElement>
      <_LicenseFileElement />
      <_LicenseFileElement Condition="'$(PackageLicenseFile)' != ''">
        <file src="$(PackageLicenseFullPath)" target="$(PackageLicenseFile)" />
      </_LicenseFileElement>
      <_TagsElement />
      <_TagsElement Condition="'$(PackageTags)' != ''">
        <tags>$(PackageTags.Replace(';', ' '))</tags>
      </_TagsElement>
      <_IconUrlElement />
      <_IconUrlElement Condition="'$(PackageIcon)' == '' and '$(PackageIconUrl)' != ''">
        <iconUrl>$(PackageIconUrl)</iconUrl>
      </_IconUrlElement>
      <_IconElement />
      <_IconElement Condition="'$(PackageIcon)' != ''">
        <icon>$(PackageIcon)</icon>
      </_IconElement>
      <_IconFileElement />
      <_IconFileElement Condition="'$(PackageIcon)' != ''">
        <file src="$(PackageIconFullPath)" target="$(PackageIcon)" />
      </_IconFileElement>
      <_ReleaseNotesElement />
      <_ReleaseNotesElement Condition="'$(PackageReleaseNotes)' != ''">
        <releaseNotes>$(PackageReleaseNotes)</releaseNotes>
      </_ReleaseNotesElement>
      <_CommonMetadataElements>
        <id>$(PackageId)</id>
        <description>$(PackageDescription)</description>
        <version>$(PackageVersion)</version>
        <authors>$(Authors)</authors>
        <requireLicenseAcceptance>$(PackageRequireLicenseAcceptance)</requireLicenseAcceptance>
        $(_TagsElement)
        $(_LicenseElement)
        $(_IconElement)
        $(_IconUrlElement)
        $(_ReleaseNotesElement)
        <projectUrl>$(PackageProjectUrl)</projectUrl><copyright>$(Copyright)</copyright><developmentDependency>$(DevelopmentDependency)</developmentDependency><serviceable>$(Serviceable)</serviceable><repository type="$(RepositoryType)" url="$(RepositoryUrl)" commit="$(RepositoryCommit)" /></_CommonMetadataElements>
      <_CommonFileElements>
        $(_IconFileElement)
        $(_LicenseFileElement)
      </_CommonFileElements>
    </PropertyGroup>
    <ItemGroup Condition="'$(NuspecFile)' != '' and '$(NuspecProperties)' == ''">
      <NuspecProperty Include="CommonMetadataElements=$(_CommonMetadataElements)" />
      <NuspecProperty Include="CommonFileElements=$(_CommonFileElements)" />
      <NuspecProperty Include="PackageId=$(PackageId)" />
      <NuspecProperty Include="Version=$(PackageVersion)" />
      <NuspecProperty Include="ProjectDirectory=$(MSBuildProjectDirectory)" />
    </ItemGroup>
    <PropertyGroup Condition="'$(NuspecFile)' != '' and '$(NuspecProperties)' == ''">
      <NuspecProperties>@(NuspecProperty, ';')</NuspecProperties>
    </PropertyGroup>
  </Target>
  <!--
    Initialize Repository* properties from properties set by a source control package, if available in the project.
  -->
  <Target Name="_InitializeNuspecRepositoryInformationPropertiesWorkaround" DependsOnTargets="InitializeSourceControlInformation" Condition="'$(SourceControlInformationFeatureSupported)' == 'true'">
    <PropertyGroup>
      <!-- The project must specify PublishRepositoryUrl=true in order to publish the URL, in order to prevent inadvertent leak of internal URL. -->
      <RepositoryUrl Condition="'$(RepositoryUrl)' == '' and '$(PublishRepositoryUrl)' == 'true'">$(PrivateRepositoryUrl)</RepositoryUrl>
      <RepositoryCommit Condition="'$(RepositoryCommit)' == ''">$(SourceRevisionId)</RepositoryCommit>
    </PropertyGroup>
  </Target>
  <!--
    NuGet Restore uses PackageId and project name in the same namespace, so that project reference can be interchanged with a package reference.
    This causes issues however for leaf packages that are not to be referenced (such as analyzer or tools packages) when we want to name the package
    the same as an existing project in the solution. In that case we set PackageId to an invalid but unique value for Restore and override it for Pack
    with the desired name stored in $(NuspecPackageId).
  -->
  <PropertyGroup Condition="'$(NuspecPackageId)' != ''">
    <PackageId>*$(MSBuildProjectName)*</PackageId>
  </PropertyGroup>
  <!--
    Source packaging helpers.
  -->
  <PropertyGroup Condition="'$(IsPackable)' == 'true' and '$(IsSourcePackage)' == 'true'">
    <TargetsForTfmSpecificContentInPackage Condition="'$(NuspecFile)' == ''">$(TargetsForTfmSpecificContentInPackage);_AddSourceFilesToSourcePackage</TargetsForTfmSpecificContentInPackage>
  </PropertyGroup>
  <Target Name="_AddSourceFilesToSourcePackage">
    <PropertyGroup>
      <!-- TODO: language to dir name mapping (https://github.com/Microsoft/msbuild/issues/2101) -->
      <_LanguageDirName>$(DefaultLanguageSourceExtension.TrimStart('.'))</_LanguageDirName>
    </PropertyGroup>
    <ItemGroup>
      <_File Remove="@(_File)" />
      <_File Include="$(MSBuildProjectDirectory)\**\*$(DefaultLanguageSourceExtension)" TargetDir="contentFiles/$(_LanguageDirName)/$(TargetFramework)" BuildAction="Compile" />
      <TfmSpecificPackageFile Include="@(_File)" PackagePath="%(_File.TargetDir)/%(_File.RecursiveDir)%(_File.FileName)%(_File.Extension)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="RepositoryInfo.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/RepositoryInfo.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!-- Opt-in switch to disable source link (i.e. for local builds). -->
  <PropertyGroup Condition="'$(DisableSourceLink)' == 'true'">
    <EnableSourceLink>false</EnableSourceLink>
    <EnableSourceControlManagerQueries>false</EnableSourceControlManagerQueries>
    <DeterministicSourcePaths>false</DeterministicSourcePaths>
  </PropertyGroup>
  <!--
    Set the SourceRoot to repo root to facilitate deterministic source paths when SCM queries are disabled, unless during design-time build.
    Set the RepositoryUrl to the Build.Repository.Uri Azure DevOps build variable if on CI, otherwise to local repo path.
    Do not set these properties during design-time build to avoid differences between design-time and reuglar builds.
  -->
  <ItemGroup Condition="'$(EnableSourceControlManagerQueries)' != 'true' and '$(DesignTimeBuild)' != 'true'">
    <SourceRoot Include="$(RepoRoot)" />
  </ItemGroup>
  <PropertyGroup Condition="'$(EnableSourceControlManagerQueries)' != 'true' and '$(DesignTimeBuild)' != 'true' and '$(RepositoryUrl)' == ''">
    <RepositoryUrl Condition="'$(BUILD_REPOSITORY_URI)' != '' and '$(DisableSourceLinkUrlTranslation)' != 'true'">$([System.Text.RegularExpressions.Regex]::Replace($(BUILD_REPOSITORY_URI), $(_TranslateUrlPattern), $(_TranslateUrlReplacement)))</RepositoryUrl>
    <RepositoryUrl Condition="'$(BUILD_REPOSITORY_URI)' != '' and '$(DisableSourceLinkUrlTranslation)' == 'true'">$(BUILD_REPOSITORY_URI)</RepositoryUrl>
    <RepositoryUrl Condition="'$(BUILD_REPOSITORY_URI)' == ''">file://$(RepoRoot)</RepositoryUrl>
  </PropertyGroup>
  <PropertyGroup Condition="'$(EnableSourceControlManagerQueries)' != 'true' and '$(DesignTimeBuild)' != 'true' and '$(RepositoryCommit)' == ''">
    <RepositoryCommit Condition="'$(BUILD_SOURCEVERSION)' != ''">$(BUILD_SOURCEVERSION)</RepositoryCommit>
    <RepositoryCommit Condition="'$(BUILD_SOURCEVERSION)' == ''">0000000000000000000000000000000000000000</RepositoryCommit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(EnableSourceControlManagerQueries)' != 'true' and '$(DesignTimeBuild)' != 'true' and '$(RepositoryType)' == ''">
    <RepositoryType>git</RepositoryType>
  </PropertyGroup>
  <!-- 
    The convention for names of Azure DevOps repositories mirrored from GitHub is "{GitHub org name}-{GitHub repository name}"
    In the legacy devdiv.visualstudio instance, it is instead "{GitHub org name}-{GitHub repository name}-Trusted" with no guarantees for casing.
  -->
  <PropertyGroup>
    <!-- There are quite a few git repo forms:
      https://dnceng@dev.azure.com/dnceng/internal/_git/dotnet-arcade-services
      https://dev.azure.com/dnceng/internal/_git/dotnet-arcade-services
      https://dnceng.visualstudio.com/internal/_git/dotnet-arcade-services
      https://devdiv.visualstudio.com/DevDiv/_git/DotNet-msbuild-Trusted
      dnceng@vs-ssh.visualstudio.com:v3/dnceng/internal/dotnet-arcade-services
      git@ssh.dev.azure.com:v3/dnceng/internal/dotnet-arcade-services
    -->
    <!-- Set DisableSourceLinkUrlTranslation to true when building a tool for internal use where sources only come from internal URIs -->
    <DisableSourceLinkUrlTranslation Condition="'$(DisableSourceLinkUrlTranslation)' == ''">false</DisableSourceLinkUrlTranslation>
    <_TranslateUrlPattern>(https://dnceng%40dev\.azure\.com/dnceng/internal/_git|https://dev\.azure\.com/dnceng/internal/_git|https://dnceng\.visualstudio\.com/internal/_git|dnceng%40vs-ssh\.visualstudio\.com:v3/dnceng/internal|git%40ssh\.dev\.azure\.com:v3/dnceng/internal|https://devdiv\.visualstudio\.com/devdiv/_git)/([^/-]+)-(.+)</_TranslateUrlPattern>
    <_TranslateUrlReplacement>https://github.com/$2/$3</_TranslateUrlReplacement>
  </PropertyGroup>
  <Target Name="_TranslateAzureDevOpsUrlToGitHubUrl" Condition="'$(DisableSourceLinkUrlTranslation)' == 'false'" DependsOnTargets="$(SourceControlManagerUrlTranslationTargets)" BeforeTargets="SourceControlManagerPublishTranslatedUrls">
    <PropertyGroup>
      <!-- Repositories mirrored on devdiv.visualstudio will have '-Trusted' added to their name and this needs to be stripped off before translation
           Eventually, all repos should move to dnceng/internal when possible. -->
      <ScmRepositoryUrl Condition=" '$([MSBuild]::ValueOrDefault(`%(SourceRoot.ScmRepositoryUrl)`, ``).Contains(`devdiv.visualstudio`))' == 'true' ">$([MSBuild]::ValueOrDefault(`%(SourceRoot.ScmRepositoryUrl)`, ``).ToLower().Replace(`-trusted`,``))</ScmRepositoryUrl>
      <ScmRepositoryUrl>$([System.Text.RegularExpressions.Regex]::Replace($(ScmRepositoryUrl), $(_TranslateUrlPattern), $(_TranslateUrlReplacement)))</ScmRepositoryUrl>
    </PropertyGroup>
    <ItemGroup>
      <SourceRoot Update="@(SourceRoot)">
        <ScmRepositoryUrl Condition="$([MSBuild]::ValueOrDefault(`%(SourceRoot.ScmRepositoryUrl)`, ``).Contains(`devdiv.visualstudio`))">$([MSBuild]::ValueOrDefault(`%(SourceRoot.ScmRepositoryUrl)`, ``).ToLower().Replace(`-trusted`,``))</ScmRepositoryUrl>
      </SourceRoot>
      <SourceRoot Update="@(SourceRoot)">
        <ScmRepositoryUrl>$([System.Text.RegularExpressions.Regex]::Replace(%(SourceRoot.ScmRepositoryUrl), $(_TranslateUrlPattern), $(_TranslateUrlReplacement)))</ScmRepositoryUrl>
      </SourceRoot>
    </ItemGroup>
  </Target>
  <!--
    Generates and adds {PackageId}.SourceLink.targets file to the build directory of the source package.
  -->
  <UsingTask TaskName="Microsoft.DotNet.Arcade.Sdk.GenerateSourcePackageSourceLinkTargetsFile" AssemblyFile="$(ArcadeSdkBuildTasksAssembly)" />
  <PropertyGroup Condition="'$(IsPackable)' == 'true' and '$(IsSourcePackage)' == 'true' and '$(EnableSourceLink)' == 'true'">
    <BeforePack>$(BeforePack);_AddSourcePackageSourceLinkFile</BeforePack>
  </PropertyGroup>
  <Target Name="_AddSourcePackageSourceLinkFile" DependsOnTargets="_GenerateSourcePackageSourceLinkFile">
    <ItemGroup>
      <!-- Add a packable item if the project builds the package with auto-generated .nuspec file -->
      <None Include="$(_SourcePackageSourceLinkTargetsFilePath)" PackagePath="build" Pack="true" Condition="'$(NuspecFile)' == ''" />
      <!-- Include path in the nuspec properties if the project builds package using custom .nuspec -->
      <NuspecProperty Include="SourceLinkTargetsFilePath=$(_SourcePackageSourceLinkTargetsFilePath)" Condition="'$(NuspecFile)' != ''" />
    </ItemGroup>
  </Target>
  <Target Name="_CalculateGenerateSourcePackageSourceLinkFileOutputs">
    <PropertyGroup>
      <_SourcePackageSourceLinkTargetsFileName>$([MSBuild]::ValueOrDefault($(SourcePackageSourceLinkTargetsFileName), '$(PackageId).targets'))</_SourcePackageSourceLinkTargetsFileName>
      <_SourcePackageSourceLinkTargetsFilePath>$(IntermediateOutputPath)$(_SourcePackageSourceLinkTargetsFileName)</_SourcePackageSourceLinkTargetsFilePath>
    </PropertyGroup>
  </Target>
  <Target Name="_GenerateSourcePackageSourceLinkFile" DependsOnTargets="InitializeSourceControlInformation;$(SourceLinkUrlInitializerTargets);_CalculateGenerateSourcePackageSourceLinkFileOutputs" Inputs="$(MSBuildAllProjects)" Outputs="$(_SourcePackageSourceLinkTargetsFilePath)">
    <Microsoft.DotNet.Arcade.Sdk.GenerateSourcePackageSourceLinkTargetsFile ProjectDirectory="$(MSBuildProjectDirectory)" PackageId="$(PackageId)" SourceRoots="@(SourceRoot)" OutputPath="$(_SourcePackageSourceLinkTargetsFilePath)" />
    <ItemGroup>
      <FileWrites Include="$(_SourcePackageSourceLinkTargetsFilePath)" />
    </ItemGroup>
  </Target>
  <!--
    Validates repository-wide requirements.
    MSBuild only evaluates the target project once per each set of values of global properties and caches the results.
  -->
  <Target Name="_RepositoryValidation" BeforeTargets="Build" Condition="'$(ContinuousIntegrationBuild)' == 'true'">
    <MSBuild Projects="$(MSBuildThisFileDirectory)RepositoryValidation.proj" Targets="Validate" RemoveProperties="TargetFramework;Platform" Properties="RepoRoot=$(RepoRoot);PackageLicenseExpression=$(PackageLicenseExpression);PackageLicenseExpressionInternal=$(PackageLicenseExpressionInternal);SuppressLicenseValidation=$(SuppressLicenseValidation)" UseResultsCache="true" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Version.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Version.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    Specification: https://github.com/dotnet/arcade/blob/master/Documentation/CorePackages/Versioning.md

    Properties:
      SemanticVersioningV1        "true" if the Version needs to respect SemVer 1.0. Default is false, which means format following SemVer 2.0.
  -->
  <UsingTask TaskName="Microsoft.DotNet.Arcade.Sdk.CalculateAssemblyAndFileVersions" AssemblyFile="$(ArcadeSdkBuildTasksAssembly)" />
  <Target Name="_InitializeAssemblyVersion" BeforeTargets="GetAssemblyVersion">
    <Warning Text="AssemblyVersion '$(AssemblyVersion)' overridden by auto-generated version" Condition="'$(AssemblyVersion)' != '' and '$(AutoGenerateAssemblyVersion)' == 'true'" />
    <Microsoft.DotNet.Arcade.Sdk.CalculateAssemblyAndFileVersions VersionPrefix="$(_OriginalVersionPrefix)" BuildNumber="$(_BuildNumber)" PatchNumber="$(_PatchNumber)" AutoGenerateAssemblyVersion="$(AutoGenerateAssemblyVersion)" Condition="'$(VersionSuffixDateStamp)' != ''">
      <Output TaskParameter="AssemblyVersion" PropertyName="AssemblyVersion" Condition="'$(AssemblyVersion)' == '' or '$(AutoGenerateAssemblyVersion)' == 'true'" />
      <Output TaskParameter="FileVersion" PropertyName="FileVersion" />
    </Microsoft.DotNet.Arcade.Sdk.CalculateAssemblyAndFileVersions>
    <PropertyGroup Condition="'$(VersionSuffixDateStamp)' == ''">
      <!--
        Set FileVersion to a distinct version that's greater than any shipping version.
        This makes it possible to install binaries produced by a dev build over product binaries,
        provided that the installer only requires higher version.
      -->
      <FileVersion>42.42.42.42424</FileVersion>
      <!--
        Respect version explicitly set by the project.
        The default .NET Core SDK implementation sets AssemblyVersion from NuGet package version,
        which we want to override in dev builds.
      -->
      <AssemblyVersion Condition="'$(AssemblyVersion)' == ''">42.42.42.42</AssemblyVersion>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <GenerateNativeVersionFileDependsOn>_InitializeAssemblyVersion</GenerateNativeVersionFileDependsOn>
    <GenerateNativeVersionFileDependsOn Condition="'$(DisableSourceLink)' != 'true'">$(GenerateNativeVersionFileDependsOn);
                                                                                     InitializeSourceControlInformationFromSourceControlManager</GenerateNativeVersionFileDependsOn>
  </PropertyGroup>
  <!--
    GenerateNativeVersionFile target is a standalone target intended to be pulled into a build once as
    a pre-step before kicking off a native build. It will generate a _version.h or _version.c depending
    on the OS it is targeting.
  -->
  <Target Name="GenerateNativeVersionFile" DependsOnTargets="$(GenerateNativeVersionFileDependsOn)">
    <!-- To support builds without a source control provider available, allow this property to be unset. -->
    <PropertyGroup Condition="'$(SourceRevisionId)' != ''">
      <_SourceBuildInfo> %40Commit: $(SourceRevisionId)</_SourceBuildInfo>
    </PropertyGroup>
    <PropertyGroup Condition="'$(OS)' == 'Windows_NT'">
      <NativeVersionFile Condition="'$(NativeVersionFile)' == ''">$(IntermediateOutputPath)_version.h</NativeVersionFile>
      <_WindowsFileVersion>$(FileVersion.Replace('.', ','))</_WindowsFileVersion>
      <_Windows_VER_DEBUG>0</_Windows_VER_DEBUG>
      <_Windows_VER_DEBUG Condition="'$(Configuration)'=='Debug'">VS_FF_DEBUG</_Windows_VER_DEBUG>
      <_NativeVersionFileContents><![CDATA[
#ifndef VER_COMPANYNAME_STR
#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#endif
#ifndef VER_FILEDESCRIPTION_STR
#define VER_FILEDESCRIPTION_STR     "$(AssemblyName)"
#endif
#ifndef VER_INTERNALNAME_STR
#define VER_INTERNALNAME_STR        VER_FILEDESCRIPTION_STR
#endif
#ifndef VER_ORIGINALFILENAME_STR
#define VER_ORIGINALFILENAME_STR    VER_FILEDESCRIPTION_STR
#endif
#ifndef VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR         ".NET"
#endif
#undef VER_PRODUCTVERSION
#define VER_PRODUCTVERSION          $(_WindowsFileVersion)
#undef VER_PRODUCTVERSION_STR
#define VER_PRODUCTVERSION_STR      "$(Version)$(_SourceBuildInfo)"
#undef VER_FILEVERSION
#define VER_FILEVERSION             $(_WindowsFileVersion)
#undef VER_FILEVERSION_STR
#define VER_FILEVERSION_STR         "$(_WindowsFileVersion)$(_SourceBuildInfo)"
#ifndef VER_LEGALCOPYRIGHT_STR
#define VER_LEGALCOPYRIGHT_STR      "\xa9 Microsoft Corporation. All rights reserved."
#endif
#ifndef VER_DEBUG
#define VER_DEBUG                   $(_Windows_VER_DEBUG)
#endif
]]></_NativeVersionFileContents>
    </PropertyGroup>
    <!--
      Copy the NativeVersion.rc file next to the version header so that it can be picked
      up and used in the native build along with the version.h file.
    -->
    <Copy SourceFiles="$(MSBuildThisFileDirectory)NativeVersion.rc" DestinationFolder="$([System.IO.Path]::GetDirectoryName($(NativeVersionFile)))" SkipUnchangedFiles="true" Condition="'$(OS)' == 'Windows_NT'" />
    <PropertyGroup Condition="'$(OS)' != 'Windows_NT'">
      <NativeVersionFile Condition="'$(NativeVersionFile)' == ''">$(ArtifactsObjDir)_version.c</NativeVersionFile>
      <!--
        There isn't a defacto standard for including version information in a native binary on unix so we defined a static
        variable which contains the version information we want which can be retrieved by using What(1) or strings+grep.
        See https://github.com/dotnet/coreclr/issues/3133 for further discussion on this approach.
      -->
      <_NativeVersionFileContents><![CDATA[
static char sccsid[] __attribute__((used)) = "@(#)Version $(FileVersion)$(_SourceBuildInfo)";
 ]]></_NativeVersionFileContents>
    </PropertyGroup>
    <MakeDir Directories="$([System.IO.Path]::GetDirectoryName($(NativeVersionFile)))" />
    <WriteLinesToFile File="$(NativeVersionFile)" Lines="$(_NativeVersionFileContents.Replace(';', '%3B'))" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <FileWrites Include="$(NativeVersionFile)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Tests.targets" Condition="'$(DisableArcadeTestFramework)' != 'true'">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Tests.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <PropertyGroup Condition="'$(IsTestProject)' == 'true'">
    <AutoGenerateBindingRedirects Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">true</AutoGenerateBindingRedirects>
    <_GetTestsToRunTarget Condition="'$(TargetFrameworks)' == ''">_InnerGetTestsToRun</_GetTestsToRunTarget>
    <_GetTestsToRunTarget Condition="'$(TargetFrameworks)' != ''">_OuterGetTestsToRun</_GetTestsToRunTarget>
    <!-- The runtime to run tests on: 'Core', 'Mono', 'Full' (desktop FX). -->
    <TestRuntime Condition="'$(TestRuntime)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">Core</TestRuntime>
    <TestRuntime Condition="'$(TestRuntime)' == '' and '$(MSBuildRuntimeType)' == 'Mono'">Mono</TestRuntime>
    <TestRuntime Condition="'$(TestRuntime)' == '' and '$(OS)' == 'Windows_NT'">Full</TestRuntime>
    <TestRunnerName Condition="'$(TestRunnerName)' == ''">XUnit</TestRunnerName>
    <TestRunnerName Condition="'$(UsingToolXUnit)' == 'false'" />
    <!--
      Look for the specified test runner in the building repository first.
      If we can't find it see if the requested test runner provided by the Arcade SDK.
    -->
    <TestRunnerTargets>$(RepositoryEngineeringDir)$(TestRunnerName)\$(TestRunnerName).targets</TestRunnerTargets>
    <TestRunnerTargets Condition="!Exists($(TestRunnerTargets))">$(MSBuildThisFileDirectory)$(TestRunnerName)\$(TestRunnerName).targets</TestRunnerTargets>
  </PropertyGroup>
  <Target Name="ErrorForMissingTestRunner" Condition="'$(IsTestProject)' == 'true' AND '$(TestRunnerName)' != ''">
    <Error Condition="!Exists($(TestRunnerTargets))" Text="Test runner $(TestRunnerName) is invalid." />
  </Target>
  <PropertyGroup Condition="'$(IsTestProject)' == 'true' and '$(TestArchitectures)' == ''">
    <TestArchitectures>$(PlatformTarget)</TestArchitectures>
    <TestArchitectures Condition="'$(PlatformTarget)' == '' or '$(PlatformTarget)' == 'AnyCpu'">x64</TestArchitectures>
  </PropertyGroup>
  <Target Name="Test" DependsOnTargets="ErrorForMissingTestRunner;$(_GetTestsToRunTarget);RunTests" Condition="'$(IsUnitTestProject)' == 'true' or '$(IsPerformanceTestProject)' == 'true'" />
  <Target Name="IntegrationTest" DependsOnTargets="ErrorForMissingTestRunner;$(_GetTestsToRunTarget);RunTests" Condition="'$(IsIntegrationTestProject)' == 'true'" />
  <ItemGroup>
    <_TestArchitectureItems Include="$(TestArchitectures)" />
  </ItemGroup>
  <!-- Using Inputs/Outputs just to loop over test architectures -->
  <Target Name="_InnerGetTestsToRun" Outputs="%(_TestArchitectureItems.Identity)" Returns="@(TestToRun)" DependsOnTargets="ComputeRunArguments" Condition="'$(TestRuntime)' != '' and '$(SkipTests)' != 'true' and&#xD;&#xA;                     ('$(TestTargetFrameworks)' == '' or $([System.String]::new(';$(TestTargetFrameworks);').Contains(';$(TargetFramework);')))">
    <PropertyGroup>
      <_TestArchitecture>%(_TestArchitectureItems.Identity)</_TestArchitecture>
      <_ResultFileNameNoExt>$(MSBuildProjectName)_$(TargetFramework)_$(_TestArchitecture)</_ResultFileNameNoExt>
      <!-- Send the logs into the default location, unless overriden by the consumer -->
      <TestResultsLogDir Condition=" '$(TestResultsLogDir)' == '' ">$(ArtifactsLogDir)</TestResultsLogDir>
    </PropertyGroup>
    <ItemGroup>
      <TestToRun Include="$(TargetPath)">
        <TargetFramework>$(TargetFramework)</TargetFramework>
        <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$(TargetFrameworkVersion)</TargetFrameworkVersion>
        <TestRuntime>$(TestRuntime)</TestRuntime>
        <TestTimeout>$(TestTimeout)</TestTimeout>
        <Architecture>$(_TestArchitecture)</Architecture>
        <EnvironmentDisplay>$(TargetFramework)|$(_TestArchitecture)</EnvironmentDisplay>
        <ResultsFilePathWithoutExtension>$(_ResultFileNameNoExt)</ResultsFilePathWithoutExtension>
        <ResultsXmlPath>$(ArtifactsTestResultsDir)$(_ResultFileNameNoExt).xml</ResultsXmlPath>
        <ResultsTrxPath>$(ArtifactsTestResultsDir)$(_ResultFileNameNoExt).trx</ResultsTrxPath>
        <ResultsHtmlPath>$(ArtifactsTestResultsDir)$(_ResultFileNameNoExt).html</ResultsHtmlPath>
        <ResultsStdOutPath>$(TestResultsLogDir)$(_ResultFileNameNoExt).log</ResultsStdOutPath>
        <TestRunSettingsFile>$(TestRunSettingsFile)</TestRunSettingsFile>
        <TestRunnerAdditionalArguments>$(TestRunnerAdditionalArguments)</TestRunnerAdditionalArguments>
        <RunArguments>$(RunArguments)</RunArguments>
        <RunCommand>$(RunCommand)</RunCommand>
      </TestToRun>
    </ItemGroup>
  </Target>
  <Target Name="_OuterGetTestsToRun" Returns="@(TestToRun)">
    <ItemGroup>
      <_TargetFramework Include="$(TargetFrameworks)" />
    </ItemGroup>
    <MSBuild Projects="$(MSBuildProjectFile)" Condition="'$(TargetFrameworks)' != ''" Targets="_InnerGetTestsToRun" Properties="TargetFramework=%(_TargetFramework.Identity)">
      <Output ItemName="TestToRun" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>
  <!-- Import specialized targets files of supported test runners -->
  <!--<Import Project="$(TestRunnerTargets)" Condition="'$(IsTestProject)' == 'true' and '$(TestRunnerName)' != '' and Exists('$(TestRunnerTargets)')" />-->
  <!-- Allow for repo specific Test targets such as rerunning tests -->
  <!--<Import Project="$(RepositoryEngineeringDir)Tests.targets" Condition="Exists('$(RepositoryEngineeringDir)Tests.targets')" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--<Import Project="Pack.targets" Condition="'$(__ImportPackTargets)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="Performance.targets" Condition="'$(DisableArcadeTestFramework)' != 'true'">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Performance.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!-- The 'PerformanceTest' target is only viable for repos building their own performance-test harness. -->
  <Target Name="PerformanceTest" Condition="'$(IsPerformanceTestProject)' == 'true'">
    <PropertyGroup>
      <PerfIterations Condition="'$(PerfIterations)' == ''">10</PerfIterations>
      <PerfOutputDirectory Condition="'$(PerfOutputDirectory)' == ''">$(ArtifactsTestResultsDir)Performance</PerfOutputDirectory>
      <PerfCollectionType Condition="'$(PerfCollectionType)' == ''">stopwatch</PerfCollectionType>
    </PropertyGroup>
    <MakeDir Directories="$(PerfOutputDirectory)" />
    <Message Text="Running performance tests: $(TargetPath)" Importance="high" />
    <!-- Call the repo built performance-test harness directly with the necessary parameters. -->
    <Exec Command="&quot;$(DotNetTool)&quot; &quot;$(TargetPath)&quot; --perf:iterations $(PerfIterations) --perf:outputdir &quot;$(PerfOutputDirectory)&quot; --perf:collect $(PerfCollectionType)" LogStandardErrorAsError="false" WorkingDirectory="$(OutDir)" IgnoreExitCode="true">
      <Output TaskParameter="ExitCode" PropertyName="_TestErrorCode" />
    </Exec>
    <Error Text="Performance tests failed: ExitCode = $(_TestErrorCode)" Condition="'$(_TestErrorCode)' != '0'" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Localization.targets">

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Localization.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
  <!--
    XliffTasks for localizing .resx files and generating satellite assemblies.
    When not building in CI, automatically sync .xlf files to .resx files on build.
    Otherwise, let the build fail to catch .xlf files that are not up-to-date.
  -->
  <PropertyGroup Condition="'$(UsingToolXliff)' == 'true'">
    <!-- 
      It is only intended to automatically run update during dev cycle. However, it will fail the build on CI if the XLF file is not updated.
      XLF file should be checked in and loc team will update the XLF it with translated version.
    -->
    <UpdateXlfOnBuild Condition="'$(ContinuousIntegrationBuild)' != 'true'">true</UpdateXlfOnBuild>
    <!--
      Use Satellite assembly generation task from Microsoft.NET.Sdk even when building with
      full Framework MSBuild. This will support public signing, is deterministic, and always
      generates them as AnyCPU. 
    -->
    <GenerateSatelliteAssembliesForCore Condition="'$(GenerateSatelliteAssembliesForCore)' == ''">true</GenerateSatelliteAssembliesForCore>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.DotNet.XliffTasks" Version="$(MicrosoftDotNetXliffTasksVersion)" PrivateAssets="all" IsImplicitlyDefined="true" Condition="'$(UsingToolXliff)' == 'true' and '$(IsShippingAssembly)' == 'true'" />
  </ItemGroup>
  <!-- TemplateLocalizer for localizing 'dotnet new' templates -->
  <PropertyGroup Condition="'$(UsingToolTemplateLocalizer)' == 'true' and '$(DotNetBuildSourceOnly)' != 'true'">
    <!-- Run localizer when building on dev machine. -->
    <LocalizeTemplates Condition="'$(ContinuousIntegrationBuild)' != 'true'">true</LocalizeTemplates>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.TemplateEngine.Authoring.Tasks" Version="$(MicrosoftTemplateEngineAuthoringTasksVersion)" PrivateAssets="all" IsImplicitlyDefined="true" Condition="'$(UsingToolTemplateLocalizer)' == 'true' and '$(DotNetBuildSourceOnly)' != 'true'" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/tools/Imports.targets
============================================================================================================================================
-->
  <!--<Import Project="VisualStudio.targets" Condition="'$(UsingToolVSSDK)' == 'true' and ('$(IsVsixProject)' == 'true' or '$(IsSwixProject)' == 'true' or '$(GeneratePkgDefFile)' == 'true') and '$(MSBuildRuntimeType)' != 'Core'" />-->
  <!--<Import Project="OptimizationData.targets" Condition="'$(UsingToolIbcOptimization)' == 'true'" />-->
  <!--<Import Project="SymStore.targets" Condition="'$(ContinuousIntegrationBuild)' == 'true' and '$(OS)' == 'Windows_NT'" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/.nuget/packages/microsoft.dotnet.arcade.sdk/10.0.0-beta.25377.103/sdk/Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="..\tools\Empty.targets" Condition="'$(_SuppressSdkImports)' != 'true' and '$(_SuppressAllTargets)' == 'true'" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.targets
============================================================================================================================================
-->
  <!-- Properties which should be set after the project has been evaluated -->
  <PropertyGroup Label="Versioning settings">
    <!-- The 'human friendly' version to display in installers. In pre-release builds, this might be "2.0.7 Preview 2 Build 12356". In final builds, it should be "2.0.7" -->
    <BrandingVersionSuffix>$(PreReleaseBrandingLabel) Build $(VersionSuffix)</BrandingVersionSuffix>
    <PackageBrandingVersion>$(VersionPrefix)</PackageBrandingVersion>
    <PackageBrandingVersion Condition=" '$(VersionSuffix)' != '' ">$(PackageBrandingVersion) $(BrandingVersionSuffix.Trim())</PackageBrandingVersion>
    <SiteExtensionVersion>$(VersionPrefix)</SiteExtensionVersion>
    <SiteExtensionVersion Condition=" '$(VersionSuffix)' != '' ">$(VersionPrefix)-$(VersionSuffix.Replace('.','-'))</SiteExtensionVersion>
    <PackageVersion Condition=" '$(PackageVersion)' == '' ">$(Version)</PackageVersion>
    <SharedFxVersion>$(PackageVersion)</SharedFxVersion>
    <SharedFxVersion Condition=" '$(StabilizePackageVersion)' == 'true' ">$(VersionPrefix)</SharedFxVersion>
    <SharedFxProductName>$(Product) $(SharedFxVersion) Shared Framework</SharedFxProductName>
    <TargetingPackVersion>$(SharedFxVersion)</TargetingPackVersion>
    <PackageVersion Condition=" '$(NoSemVer20)' == 'true' ">$(SiteExtensionVersion)</PackageVersion>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Analyzers package are special. In general, they should not have dependencies in the nuspec. Analyzer assemblies are not meant to be used for compilation or runtime. -->
    <SuppressDependenciesWhenPacking Condition="'$(SuppressDependenciesWhenPacking)' == '' AND '$(IsAnalyzersProject)' == 'true'">true</SuppressDependenciesWhenPacking>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(MSBuildProjectExtension)' == '.csproj' ">
    <PackageId Condition=" '$(PackageId)' == '' ">$(AssemblyName)</PackageId>
    <IsPackable Condition="'$(IsPackable)' == '' AND ( $(IsTestProject) OR '$(IsTestAssetProject)' == 'true' OR&#xA;         '$(IsBenchmarkProject)' == 'true' OR '$(IsSampleProject)' == 'true' OR '$(IsMicrobenchmarksProject)' == 'true') ">false</IsPackable>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="eng\Baseline.Designer.props">

/home/runner/work/aspnetcore/aspnetcore/eng/Baseline.Designer.props
============================================================================================================================================
-->
  <!-- Auto generated. Do not edit manually, use eng/tools/BaselineGenerator/ to recreate. -->
  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
    <AspNetCoreBaselineVersion>9.0.0</AspNetCoreBaselineVersion>
  </PropertyGroup>
  <!-- Package: AspNetCoreRuntime.9.0.x64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'AspNetCoreRuntime.9.0.x64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: AspNetCoreRuntime.9.0.x86-->
  <PropertyGroup Condition=" '$(PackageId)' == 'AspNetCoreRuntime.9.0.x86' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: dotnet-sql-cache-->
  <PropertyGroup Condition=" '$(PackageId)' == 'dotnet-sql-cache' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Ref-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Ref' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.linux-arm-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.linux-arm' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.linux-arm64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.linux-arm64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.linux-musl-arm-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.linux-musl-arm' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.linux-musl-arm64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.linux-musl-arm64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.linux-musl-x64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.linux-musl-x64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.linux-x64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.linux-x64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.osx-arm64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.osx-arm64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.osx-x64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.osx-x64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.win-arm64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.win-arm64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.win-x64-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.win-x64' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.App.Runtime.win-x86-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.App.Runtime.win-x86' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.Certificate-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.Certificate' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.Certificate' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Memory" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.Facebook-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.Facebook' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.Google-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.Google' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.JwtBearer-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.JwtBearer' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.JwtBearer' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.IdentityModel.Protocols.OpenIdConnect" Version="[8.0.1, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.MicrosoftAccount-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.MicrosoftAccount' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.Negotiate-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.Negotiate' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.Negotiate' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Connections.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Memory" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.DirectoryServices.Protocols" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.OpenIdConnect-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.OpenIdConnect' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.OpenIdConnect' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.IdentityModel.Protocols.OpenIdConnect" Version="[8.0.1, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.Twitter-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.Twitter' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Authentication.WsFederation-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.WsFederation' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authentication.WsFederation' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.IdentityModel.Protocols.WsFederation" Version="[8.0.1, )" />
    <BaselinePackageReference Include="System.IdentityModel.Tokens.Jwt" Version="[8.0.1, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Authorization-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authorization' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authorization' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Metadata" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authorization' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Metadata" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Authorization' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Metadata" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.AzureAppServices.HostingStartup-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.AzureAppServices.HostingStartup' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.AzureAppServices.HostingStartup' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.AzureAppServicesIntegration" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Text.Json" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.AzureAppServices.SiteExtension-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.AzureAppServices.SiteExtension' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.AzureAppServicesIntegration-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.AzureAppServicesIntegration' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.AzureAppServicesIntegration' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.AzureAppServices" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.Analyzers" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Authorization" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.Analyzers-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.Analyzers' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Components.Authorization-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.Authorization' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.Authorization' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Authorization" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.CustomElements-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.CustomElements' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.CustomElements' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.Web" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.Forms-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.Forms' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.Forms' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.QuickGrid-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.QuickGrid' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.QuickGrid' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.Web" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.QuickGrid.EntityFrameworkAdapter' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.QuickGrid" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.EntityFrameworkCore" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.Web-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.Web' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.Web' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.Forms" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.JSInterop" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Primitives" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.WebAssembly-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.WebAssembly' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.WebAssembly' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.JSInterop.WebAssembly" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.Web" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.WebAssembly.Authentication-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.WebAssembly.Authentication' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.WebAssembly.Authentication' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.Authorization" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.Web" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Components.WebAssembly.DevServer-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.WebAssembly.DevServer' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Components.WebAssembly.Server-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.WebAssembly.Server' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Components.WebView-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.WebView' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Components.WebView' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.Web" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Embedded" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Composite" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.ConcurrencyLimiter-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.ConcurrencyLimiter' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.ConcurrencyLimiter' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Threading.RateLimiting" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Connections.Abstractions-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Connections.Abstractions' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Connections.Abstractions' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Features" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.IO.Pipelines" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Connections.Abstractions' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Features" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Connections.Abstractions' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Features" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.IO.Pipelines" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Connections.Abstractions' AND '$(TargetFramework)' == 'netstandard2.1' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Features" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.IO.Pipelines" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Cryptography.Internal-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Cryptography.Internal' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.Cryptography.KeyDerivation-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Cryptography.KeyDerivation' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Cryptography.KeyDerivation' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.Internal" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Cryptography.KeyDerivation' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.Internal" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Cryptography.KeyDerivation' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.Internal" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.DataProtection-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.Internal" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Win32.Registry" Version="[5.0.0, )" />
    <BaselinePackageReference Include="System.Runtime.InteropServices.RuntimeInformation" Version="[4.3.0, )" />
    <BaselinePackageReference Include="System.Security.Cryptography.Xml" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.Internal" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Security.Cryptography.Xml" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.Internal" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Win32.Registry" Version="[5.0.0, )" />
    <BaselinePackageReference Include="System.Security.Cryptography.Xml" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Security.Principal.Windows" Version="[5.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.DataProtection.Abstractions-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.Abstractions' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.DataProtection.EntityFrameworkCore-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.EntityFrameworkCore' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.EntityFrameworkCore' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.EntityFrameworkCore" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.DataProtection.Extensions-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.Extensions' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.Extensions' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.Extensions' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.Extensions' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.DataProtection.StackExchangeRedis-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.StackExchangeRedis' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.StackExchangeRedis' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.StackExchangeRedis' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.DataProtection.StackExchangeRedis' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.DataProtection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Grpc.JsonTranscoding-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Grpc.JsonTranscoding' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Grpc.JsonTranscoding' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Google.Api.CommonProtos" Version="[2.15.0, )" />
    <BaselinePackageReference Include="Google.Protobuf" Version="[3.27.0, )" />
    <BaselinePackageReference Include="Grpc.AspNetCore.Server" Version="[2.64.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.HeaderPropagation-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.HeaderPropagation' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.HeaderPropagation' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Http" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Hosting.WindowsServices-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Hosting.WindowsServices' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Hosting.WindowsServices' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="System.ServiceProcess.ServiceController" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Http.Connections.Client-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Client' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Client' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Http.Connections.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Net.Http" Version="[4.3.4, )" />
    <BaselinePackageReference Include="System.Net.ServerSentEvents" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Runtime.InteropServices.RuntimeInformation" Version="[4.3.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Client' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Http.Connections.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Net.ServerSentEvents" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Client' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Http.Connections.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Net.ServerSentEvents" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Client' AND '$(TargetFramework)' == 'netstandard2.1' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Http.Connections.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Net.ServerSentEvents" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Http.Connections.Common-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Common' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Common' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Connections.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Text.Json" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Common' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Connections.Abstractions" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Http.Connections.Common' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Connections.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Text.Json" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Identity.EntityFrameworkCore-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Identity.EntityFrameworkCore' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Identity.EntityFrameworkCore' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Identity.Stores" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Identity.UI-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Identity.UI' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Identity.UI' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Embedded" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Identity.Stores" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.JsonPatch-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.JsonPatch' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.JsonPatch' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.CSharp" Version="[4.7.0, )" />
    <BaselinePackageReference Include="Newtonsoft.Json" Version="[13.0.3, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.JsonPatch' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.CSharp" Version="[4.7.0, )" />
    <BaselinePackageReference Include="Newtonsoft.Json" Version="[13.0.3, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.JsonPatch' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.CSharp" Version="[4.7.0, )" />
    <BaselinePackageReference Include="Newtonsoft.Json" Version="[13.0.3, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Metadata-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Metadata' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.MiddlewareAnalysis-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.MiddlewareAnalysis' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.MiddlewareAnalysis' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Mvc.NewtonsoftJson-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Mvc.NewtonsoftJson' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Mvc.NewtonsoftJson' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.JsonPatch" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Newtonsoft.Json" Version="[13.0.3, )" />
    <BaselinePackageReference Include="Newtonsoft.Json.Bson" Version="[1.0.2, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Mvc.Razor.Extensions" Version="[6.0.0, )" />
    <BaselinePackageReference Include="Microsoft.CodeAnalysis.Razor" Version="[6.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyModel" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Mvc.Testing-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Mvc.Testing' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Mvc.Testing' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.TestHost" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyModel" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Hosting" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.OpenApi-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.OpenApi' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.OpenApi' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.OpenApi" Version="[1.6.17, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.OutputCaching.StackExchangeRedis-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.OutputCaching.StackExchangeRedis' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.OutputCaching.StackExchangeRedis' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.Owin-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.Owin' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.SignalR.Client-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Client.Core" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Http.Connections.Client" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Client.Core" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Http.Connections.Client" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Client.Core" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.Http.Connections.Client" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.SignalR.Client.Core-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client.Core' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client.Core' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Protocols.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Bcl.TimeProvider" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Threading.Channels" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client.Core' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Protocols.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Threading.Channels" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client.Core' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Protocols.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Bcl.TimeProvider" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Threading.Channels" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Client.Core' AND '$(TargetFramework)' == 'netstandard2.1' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Protocols.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Bcl.TimeProvider" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Threading.Channels" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.SignalR.Common-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Common' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Common' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Connections.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Net.Sockets" Version="[4.3.0, )" />
    <BaselinePackageReference Include="System.Text.Json" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Common' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Connections.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Common' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Connections.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Text.Json" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.SignalR.Protocols.Json-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.Json' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.Json' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.Json' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.Json' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.SignalR.Protocols.MessagePack-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.MessagePack' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.MessagePack' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="MessagePack" Version="[2.5.187, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.MessagePack' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="MessagePack" Version="[2.5.187, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.MessagePack' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="MessagePack" Version="[2.5.187, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Newtonsoft.Json" Version="[13.0.3, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Newtonsoft.Json" Version="[13.0.3, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Newtonsoft.Json" Version="[13.0.3, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.SignalR.Specification.Tests-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Specification.Tests' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.Specification.Tests' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Protocols.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Protocols.MessagePack" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.AspNetCore.SignalR.Common" Version="[9.0.0, )" />
    <BaselinePackageReference Include="xunit.assert" Version="[2.4.2, )" />
    <BaselinePackageReference Include="xunit.extensibility.core" Version="[2.4.2, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.SignalR.StackExchangeRedis-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.StackExchangeRedis' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SignalR.StackExchangeRedis' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="MessagePack" Version="[2.5.187, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.SpaProxy-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SpaProxy' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.SpaServices.Extensions-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SpaServices.Extensions' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.SpaServices.Extensions' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Physical" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.AspNetCore.TestHost-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.TestHost' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.AspNetCore.WebUtilities-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.WebUtilities' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.AspNetCore.WebUtilities' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Net.Http.Headers" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Authentication.WebAssembly.Msal-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Authentication.WebAssembly.Msal' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Authentication.WebAssembly.Msal' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.Authentication" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.dotnet-openapi-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.dotnet-openapi' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.DotNet.Web.Client.ItemTemplates-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.DotNet.Web.Client.ItemTemplates' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.DotNet.Web.ItemTemplates.9.0-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.DotNet.Web.ItemTemplates.9.0' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.DotNet.Web.ProjectTemplates.9.0-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.DotNet.Web.ProjectTemplates.9.0' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.Extensions.ApiDescription.Client-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.ApiDescription.Client' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.Extensions.ApiDescription.Server-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.ApiDescription.Server' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.Extensions.Caching.SqlServer-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.SqlServer' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.SqlServer' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Azure.Identity" Version="[1.11.4, )" />
    <BaselinePackageReference Include="Microsoft.Data.SqlClient" Version="[4.0.5, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.SqlServer' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Azure.Identity" Version="[1.11.4, )" />
    <BaselinePackageReference Include="Microsoft.Data.SqlClient" Version="[4.0.5, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.SqlServer' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Azure.Identity" Version="[1.11.4, )" />
    <BaselinePackageReference Include="Microsoft.Data.SqlClient" Version="[4.0.5, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Caching.StackExchangeRedis-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.StackExchangeRedis' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.StackExchangeRedis' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.StackExchangeRedis' AND '$(TargetFramework)' == 'net8.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.StackExchangeRedis' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Caching.StackExchangeRedis' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="StackExchange.Redis" Version="[2.7.27, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Configuration.KeyPerFile-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Configuration.KeyPerFile' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Configuration.KeyPerFile' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Physical" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Configuration.KeyPerFile' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Physical" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Configuration.KeyPerFile' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Physical" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Diagnostics.HealthChecks-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Diagnostics.HealthChecks' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Diagnostics.HealthChecks' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Diagnostics.HealthChecks' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Diagnostics.HealthChecks' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.EntityFrameworkCore.Relational" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Features-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Features' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.Extensions.FileProviders.Embedded-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.FileProviders.Embedded' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.FileProviders.Embedded' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Abstractions" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.FileProviders.Embedded' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.FileProviders.Abstractions" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Http.Polly-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Http.Polly' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Http.Polly' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Http" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Polly" Version="[7.2.4, )" />
    <BaselinePackageReference Include="Polly.Extensions.Http" Version="[3.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Identity.Core-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Identity.Core' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Identity.Core' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.KeyDerivation" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.ComponentModel.Annotations" Version="[5.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Identity.Core' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.KeyDerivation" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Identity.Core' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.AspNetCore.Cryptography.KeyDerivation" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.ComponentModel.Annotations" Version="[5.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Identity.Stores-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Identity.Stores' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Identity.Stores' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Identity.Core" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Identity.Stores' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Identity.Core" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Identity.Stores' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Identity.Core" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Localization-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Localization' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Localization' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Localization.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Localization' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Localization.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Localization' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Localization.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.Localization.Abstractions-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Localization.Abstractions' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.Extensions.Logging.AzureAppServices-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Logging.AzureAppServices' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Logging.AzureAppServices' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Configuration" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Net.Http" Version="[4.3.4, )" />
    <BaselinePackageReference Include="System.ValueTuple" Version="[4.5.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Logging.AzureAppServices' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Configuration" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.ValueTuple" Version="[4.5.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.Logging.AzureAppServices' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.EnvironmentVariables" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Configuration.Json" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Logging.Configuration" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.ValueTuple" Version="[4.5.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Extensions.ObjectPool-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.ObjectPool' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.Extensions.WebEncoders-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.WebEncoders' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.WebEncoders' AND '$(TargetFramework)' == 'net462' ">
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Text.Encodings.Web" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.WebEncoders' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
  </ItemGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Extensions.WebEncoders' AND '$(TargetFramework)' == 'netstandard2.0' ">
    <BaselinePackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="[9.0.0, )" />
    <BaselinePackageReference Include="Microsoft.Extensions.Options" Version="[9.0.0, )" />
    <BaselinePackageReference Include="System.Text.Encodings.Web" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.JSInterop-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.JSInterop' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <!-- Package: Microsoft.JSInterop.WebAssembly-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.JSInterop.WebAssembly' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.JSInterop.WebAssembly' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.JSInterop" Version="[9.0.0, )" />
  </ItemGroup>
  <!-- Package: Microsoft.Net.Http.Headers-->
  <PropertyGroup Condition=" '$(PackageId)' == 'Microsoft.Net.Http.Headers' ">
    <BaselinePackageVersion>9.0.0</BaselinePackageVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(PackageId)' == 'Microsoft.Net.Http.Headers' AND ('$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' OR '$(TargetFramework)' == 'net9.0') ">
    <BaselinePackageReference Include="Microsoft.Extensions.Primitives" Version="[9.0.0, )" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.targets
============================================================================================================================================
-->
  <PropertyGroup Condition=" '$(IsPackable)' != 'false' AND '$(IsServicingBuild)' == 'true' ">
    <IsPackageInThisPatch Condition="'$(IsPackageInThisPatch)' == ''">true</IsPackageInThisPatch>
    <!-- Used to distinguish between packages building -->
    <IsPackableInNonServicingBuild>true</IsPackableInNonServicingBuild>
    <!-- Suppress creation of .nupkg for servicing builds of non-shipping projects. -->
    <IsPackable Condition=" '$(IsPackageInThisPatch)' != 'true' ">false</IsPackable>
  </PropertyGroup>
  <PropertyGroup>
    <!-- When OnlyPackPlatformSpecificPackages is set, only produce packages for projects which set RuntimeIdentifier. -->
    <!-- Keep this below where we set "IsPackageInThisPatch" -->
    <IsPackable Condition=" '$(OnlyPackPlatformSpecificPackages)' == 'true' AND '$(RuntimeIdentifier)' == '' ">false</IsPackable>
  </PropertyGroup>
  <PropertyGroup>
    <PackageVersionForPackageVersionInfo>$(PackageVersion)</PackageVersionForPackageVersionInfo>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(IsPackageInThisPatch)' != 'true' AND '$(BaselinePackageVersion)' != '' AND '$(IsServicingBuild)' == 'true' ">
    <!-- This keeps assembly and package versions consistent across patches. If a package is not included in a patch, its version should stay at the baseline. -->
    <AssemblyVersion Condition="$(BaselinePackageVersion.Contains('-'))">$(BaselinePackageVersion.Substring(0, $(BaselinePackageVersion.IndexOf('-')))).0</AssemblyVersion>
    <AssemblyVersion Condition="! $(BaselinePackageVersion.Contains('-'))">$(BaselinePackageVersion).0</AssemblyVersion>
    <!--
      Ideally, we would also set the project version to match the baseline in case NuGet turns a ProjectReference into a nuspec depenendency, but
      NuGet does not currently handle conflicts between packages and projects which have the same package id/version.
      See https://github.com/NuGet/Home/issues/6795.

      Because we still use static analysis to scrape versions, only set this during static analysis, which can be detected by checking for both NoBuild and DesignTimeBuild.
    -->
    <Version Condition="'$(NoBuild)' == 'true' AND '$(DesignTimeBuild)' == 'true'">$(BaselinePackageVersion)</Version>
    <PackageVersion Condition="'$(NoBuild)' == 'true' AND '$(DesignTimeBuild)' == 'true'">$(BaselinePackageVersion)</PackageVersion>
    <!-- For servicing builds, we want to resolve baseline versions of project packages that aren't building, always -->
    <PackageVersionForPackageVersionInfo>$(BaselinePackageVersion)</PackageVersionForPackageVersionInfo>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Implementation projects are the projects which produce nuget packages or shipping assemblies. -->
    <IsImplementationProject Condition=" '$(IsImplementationProject)' == '' AND&#xA;        '$(IsAnalyzersProject)' != 'true' AND&#xA;        '$(IsBenchmarkProject)' != 'true' AND&#xA;        '$(IsSampleProject)' != 'true' AND&#xA;        '$(IsSpecificationTestProject)' != 'true' AND&#xA;        '$(IsTestAssetProject)' != 'true' AND&#xA;        !$(IsTestProject) AND&#xA;        '$(IsMicrobenchmarksProject)' != 'true' ">true</IsImplementationProject>
    <!-- This determines whether a project is available as a <Reference> to other projects in this repo. -->
    <IsProjectReferenceProvider Condition=" '$(IsProjectReferenceProvider)' == '' AND&#xA;        ( '$(IsImplementationProject)' == 'true' OR '$(IsSpecificationTestProject)' == 'true' ) ">true</IsProjectReferenceProvider>
    <HasReferenceAssembly Condition=" '$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' AND '$(IsAspNetCoreApp)' == 'true' ">true</HasReferenceAssembly>
    <HasReferenceAssembly Condition="'$(HasReferenceAssembly)' == ''">false</HasReferenceAssembly>
    <ProduceReferenceAssembly>$(HasReferenceAssembly)</ProduceReferenceAssembly>
    <!-- Duplicate setting from Microsoft.Common.CurrentVersion.targets because this is imported after that file. -->
    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and $(ProduceReferenceAssembly) ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
    <IsPackable Condition="'$(IsPackable)' == '' AND ('$(IsImplementationProject)' == 'true' OR '$(IsAnalyzersProject)' == 'true') ">true</IsPackable>
    <IsPackable Condition="'$(IsPackable)' == '' ">false</IsPackable>
    <BuildHelixPayload Condition="'$(BuildHelixPayload)' == '' AND $(IsTestProject) ">true</BuildHelixPayload>
    <SkipTests Condition="'$(SkipTests)' == '' AND '$(SkipHelixReadyTests)' == 'true' AND '$(BuildHelixPayload)' == 'true'">true</SkipTests>
  </PropertyGroup>
  <PropertyGroup>
    <PackageThirdPartyNoticesFile Condition="'$(PackageThirdPartyNoticesFile)' == ''">$(RepoRoot)THIRD-PARTY-NOTICES.TXT</PackageThirdPartyNoticesFile>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsPackable)' == 'true'">
    <None Include="$(PackageThirdPartyNoticesFile)" Pack="true" PackagePath="." />
  </ItemGroup>
  <!--
    If assembly is in shared framework and not net4*, assembly version should remain fixed for an entire
    major.minor release even in servicing.
  -->
  <PropertyGroup Condition=" '$(IsAspNetCoreApp)' == 'true' AND&#xA;      '$(Language)' == 'C#' AND&#xA;      '$(TargetFrameworkIdentifier)' != '.NETFramework' ">
    <AssemblyVersion>$(AspNetCoreMajorMinorVersion).0.0</AssemblyVersion>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Do not update the Microsoft.AspNetCore.App KnownFrameworkReference item unless requested. -->
    <UpdateAspNetCoreKnownFramework>false</UpdateAspNetCoreKnownFramework>
    <UpdateAspNetCoreKnownFramework Condition=" '$(UseAspNetCoreSharedRuntime)' == 'true' AND&#xA;      '$(DoNotApplyWorkaroundsToMicrosoftAspNetCoreApp)' != 'true' ">true</UpdateAspNetCoreKnownFramework>
  </PropertyGroup>
  <ItemGroup>
    <KnownFrameworkReference Condition="'$(UseAspNetCoreSharedRuntime)' != 'true'" Remove="Microsoft.AspNetCore.App" />
    <KnownFrameworkReference Remove="Microsoft.WindowsDesktop.App" />
  </ItemGroup>
  <PropertyGroup Condition=" '$(CopySymbolsToArtifacts)' == 'true' AND '$(TargetFramework)' != '' ">
    <BuildDependsOn>$(BuildDependsOn);_CopySymbolsToArtifacts</BuildDependsOn>
  </PropertyGroup>
  <!-- Properties for Package Validation -->
  <PropertyGroup Condition="'$(ExcludeFromSourceOnlyBuild)' != 'true'">
    <EnablePackageValidation Condition="'$(EnablePackageValidation)' == ''">true</EnablePackageValidation>
    <DisablePackageBaselineValidation Condition="'$(IsServicingBuild)' != 'true'">true</DisablePackageBaselineValidation>
    <GenerateCompatibilitySuppressionFile>true</GenerateCompatibilitySuppressionFile>
  </PropertyGroup>
  <Target Name="_CopySymbolsToArtifacts">
    <Copy SourceFiles="$([System.IO.Path]::ChangeExtension('$(TargetPath)', 'pdb'))" DestinationFolder="$(SymbolsOutputPath)$(TargetFramework)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" />
  </Target>
  <!--
    Remove the implicit package reference for Microsoft.AspNetCore.App.Internal.Assets.
    Projects within the repo will consume framework assets by importing
    Microsoft.AspNetCore.App.Internal.Assets.targets directly
  -->
  <Target Name="_RemoveAspNetCoreAppInternalAssetsReference" AfterTargets="ProcessFrameworkReferences">
    <ItemGroup>
      <PackageReference Remove="Microsoft.AspNetCore.App.Internal.Assets" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  <Import Project="eng\Workarounds.targets">

/home/runner/work/aspnetcore/aspnetcore/eng/Workarounds.targets
============================================================================================================================================
-->
  <!-- Use this file to workaround issues. List the issue tracking the item to fix so we can remove the workaround when the issue is resolved. -->
  <PropertyGroup>
    <DefaultNetCoreTargetFrameworkIdentifier>$([MSBuild]::GetTargetFrameworkIdentifier('$(DefaultNetCoreTargetFramework)'))</DefaultNetCoreTargetFrameworkIdentifier>
    <DefaultNetCoreTargetFrameworkVersion>v$([MSBuild]::GetTargetFrameworkVersion('$(DefaultNetCoreTargetFramework)', 2))</DefaultNetCoreTargetFrameworkVersion>
    <ProjectTargetFrameworkIdentifier>$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)'))</ProjectTargetFrameworkIdentifier>
    <ProjectTargetFrameworkVersion>v$([MSBuild]::GetTargetFrameworkVersion('$(TargetFramework)', 2))</ProjectTargetFrameworkVersion>
  </PropertyGroup>
  <!--
    Workaround https://github.com/dotnet/aspnetcore/issues/4257.
    The web sdk adds an implicit framework reference. This removes it until we can update our build to use framework references.
  -->
  <ItemGroup>
    <FrameworkReference Remove="Microsoft.AspNetCore.App" Condition="'$(DoNotApplyWorkaroundsToMicrosoftAspNetCoreApp)' != 'true'" />
    <!-- Required because the Razor SDK will generate attributes -->
    <Reference Include="Microsoft.AspNetCore.Mvc" Condition="'$(UsingMicrosoftNETSdkWeb)' == 'true' AND&#xA;      '$(TargetFrameworkIdentifier)' == '$(NETCoreAppFrameworkIdentifier)' AND&#xA;      '$(GenerateRazorAssemblyInfo)' == 'true'" />
  </ItemGroup>
  <!-- Workaround for netstandard2.1 projects until we can get a preview 8 SDK containing https://github.com/dotnet/sdk/pull/3463 fix. -->
  <ItemGroup>
    <KnownFrameworkReference Update="NETStandard.Library">
      <RuntimeFrameworkName>NETStandard.Library</RuntimeFrameworkName>
    </KnownFrameworkReference>
  </ItemGroup>
  <!-- Work around https://github.com/dotnet/cli/issues/11378. -->
  <Target Name="_WorkaroundNetStandard" AfterTargets="ResolvePackageAssets">
    <ItemGroup>
      <TransitiveFrameworkReference Remove="NETStandard.Library" />
    </ItemGroup>
  </Target>
  <!-- Work around https://github.com/dotnet/aspnetcore/issues/18393 -->
  <Target Name="_UpdateRazorGenerateAssemblyReferences" AfterTargets="ResolveAssemblyReferenceRazorGenerateInputs" DependsOnTargets="FindReferenceAssembliesForReferences" Condition="'$(CompileUsingReferenceAssemblies)' != 'false'">
    <ItemGroup>
      <RazorReferencePath Remove="@(ReferencePath)" />
      <RazorReferencePath Include="@(ReferencePathWithRefAssemblies)" />
    </ItemGroup>
  </Target>
  <!-- Work around https://github.com/dotnet/aspnetcore/issues/34048 -->
  <Target Name="_RemoveDuplicateLoggingSourceGenerator" AfterTargets="ResolvePackageAssets" Condition="'$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' AND&#xA;      ('$(IsAspNetCoreApp)' == 'true' OR '$(UseAspNetCoreSharedRuntime)' == 'true')">
    <ItemGroup>
      <ResolvedAnalyzers Remove="@(ResolvedAnalyzers)" Condition="'%(ResolvedAnalyzers.NuGetPackageId)' == 'Microsoft.Extensions.Logging.Abstractions'" />
      <ResolvedAnalyzers Remove="@(ResolvedAnalyzers)" Condition="'%(ResolvedAnalyzers.NuGetPackageId)' == 'System.Text.Json'" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="artifacts\bin\GenerateFiles\Directory.Build.targets" Condition=" '$(MSBuildProjectName)' != 'GenerateFiles' ">

/home/runner/work/aspnetcore/aspnetcore/artifacts/bin/GenerateFiles/Directory.Build.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- Workaround while there is no SDK available that understands the TFM; suppress unsupported version errors. -->
    <NETCoreAppMaximumVersion>99.9</NETCoreAppMaximumVersion>
    <UpdateAspNetCoreKnownFramework Condition=" '$(UpdateAspNetCoreKnownFramework)' == '' ">true</UpdateAspNetCoreKnownFramework>
  </PropertyGroup>
  <!-- Workaround when there is no vNext SDK available; copy known apphost/framework reference info from 9.0. -->
  <ItemGroup>
    <KnownAppHostPack Include="@(KnownAppHostPack-&gt;WithMetadataValue('TargetFramework', 'net9.0'))" TargetFramework="net10.0" Condition="'@(KnownAppHostPack-&gt;Count())' != '0' AND&#xA;        !(@(KnownAppHostPack-&gt;AnyHaveMetadataValue('TargetFramework', 'net10.0')))" />
    <KnownRuntimePack Include="@(KnownRuntimePack-&gt;WithMetadataValue('TargetFramework', 'net9.0'))" TargetFramework="net10.0" Condition="'@(KnownRuntimePack-&gt;Count())' != '0' AND&#xA;        !(@(KnownRuntimePack-&gt;AnyHaveMetadataValue('TargetFramework', 'net10.0')))" />
    <KnownFrameworkReference Include="@(KnownFrameworkReference-&gt;WithMetadataValue('TargetFramework', 'net9.0'))" TargetFramework="net10.0" Condition="'@(KnownFrameworkReference-&gt;Count())' != '0' AND&#xA;        !(@(KnownFrameworkReference-&gt;AnyHaveMetadataValue('TargetFramework', 'net10.0')))" />
    <KnownILLinkPack Include="@(KnownILLinkPack-&gt;WithMetadataValue('TargetFramework', 'net9.0'))" TargetFramework="net10.0" Condition="'@(KnownILLinkPack-&gt;Count())' != '0' AND&#xA;        !(@(KnownILLinkPack-&gt;AnyHaveMetadataValue('TargetFramework', 'net10.0')))" />
    <KnownILCompilerPack Include="@(KnownILCompilerPack-&gt;WithMetadataValue('TargetFramework', 'net9.0'))" TargetFramework="net10.0" Condition="'@(KnownILCompilerPack-&gt;Count())' != '0' AND&#xA;        !(@(KnownILCompilerPack-&gt;AnyHaveMetadataValue('TargetFramework', 'net10.0')))" />
    <KnownWebAssemblySdkPack Include="@(KnownWebAssemblySdkPack-&gt;WithMetadataValue('TargetFramework', 'net9.0'))" TargetFramework="net10.0" Condition="'@(KnownWebAssemblySdkPack-&gt;Count())' != '0' AND&#xA;        !(@(KnownWebAssemblySdkPack-&gt;AnyHaveMetadataValue('TargetFramework', 'net10.0')))" />
    <KnownAspNetCorePack Include="@(KnownAspNetCorePack-&gt;WithMetadataValue('TargetFramework', 'net9.0'))" TargetFramework="net10.0" Condition="'@(KnownAspNetCorePack-&gt;Count())' != '0' AND&#xA;        !(@(KnownAspNetCorePack-&gt;AnyHaveMetadataValue('TargetFramework', 'net10.0')))" />
  </ItemGroup>
  <ItemGroup>
    <!--
      Reference base shared framework at incoming dependency flow version, not bundled sdk version.
      Apply this to all projects that target the default tfm (e.g. net9.0) or a rid-based variant of it (e.g. net9.0-windows)
    -->
    <FrameworkReference Update="Microsoft.NETCore.App" Condition=" (('$(ProjectTargetFrameworkIdentifier)' == 'net10.0') AND 'net10.0' == '$(ProjectTargetFrameworkVersion)') AND '$(TargetLatestDotNetRuntime)' != 'false' " RuntimeFrameworkVersion="10.0.0-preview.7.25377.103" TargetingPackVersion="10.0.0-preview.7.25377.103" />
    <PackageReference Include="Microsoft.DotNet.ILCompiler" Condition=" '$(PublishAot)' == 'true' " Version="10.0.0-preview.7.25377.103" />
  </ItemGroup>
  <ItemGroup>
    <!-- Use the same NETCore shared framework as repo built against except when building product code in servicing. -->
    <!-- We cannot use live shims when building tool packs in the .NET product mode as only packages for the current arch are available. -->
    <KnownFrameworkReference Update="Microsoft.NETCore.App" Condition=" '$(DotNetBuild)' != 'true' OR '$(PackAsToolShimRuntimeIdentifiers)' == '' ">
      <LatestRuntimeFrameworkVersion Condition=" '%(TargetFramework)' == 'net10.0' ">10.0.0-preview.7.25377.103</LatestRuntimeFrameworkVersion>
      <TargetingPackVersion Condition=" '%(TargetFramework)' == 'net10.0' and '$(TargetLatestDotNetRuntime)' != 'false' ">10.0.0-preview.7.25377.103</TargetingPackVersion>
      <!--
        Change the default shared framework version only when _not_ servicing. Avoid bumping version used in most
        projects. When servicing, projects (Microsoft.AspNetCore.App.Runtime in particular) can use
        $(TargetLatestRuntimePatch) to explicitly control whether assemblies build against default (false) or
        latest (true). When that property is not set, SDK uses default metadata in most cases but published apps
        e.g. tool projects (again, property not set) use latest.
        On the other hand, $(TargetLatestDotNetRuntime) is specific to this repo and controls only the update below.
      -->
      <DefaultRuntimeFrameworkVersion Condition=" '$(IsServicingBuild)' != 'true' AND&#xA;          '%(TargetFramework)' == 'net10.0' AND&#xA;          '$(TargetLatestDotNetRuntime)' != 'false' ">10.0.0-preview.7.25377.103</DefaultRuntimeFrameworkVersion>
      <RuntimePackRuntimeIdentifiers Condition="'$(DotNetBuild)' == 'true'">%(RuntimePackRuntimeIdentifiers);$(TargetRuntimeIdentifier)</RuntimePackRuntimeIdentifiers>
    </KnownFrameworkReference>
    <!-- We cannot use live shims when building tool packs in .NET product build mode as only packages for the current arch are available. -->
    <KnownAppHostPack Update="Microsoft.NETCore.App" Condition=" '$(DotNetBuild)' != 'true' OR '$(PackAsToolShimRuntimeIdentifiers)' == '' ">
      <AppHostPackVersion Condition=" '%(TargetFramework)' == 'net10.0' ">10.0.0-preview.7.25377.103</AppHostPackVersion>
      <AppHostRuntimeIdentifiers Condition=" '$(DotNetBuildSourceOnly)' == 'true' ">$(TargetRuntimeIdentifier)</AppHostRuntimeIdentifiers>
    </KnownAppHostPack>
    <KnownRuntimePack Update="Microsoft.NETCore.App">
      <LatestRuntimeFrameworkVersion Condition=" '%(TargetFramework)' == 'net10.0' ">10.0.0-preview.7.25377.103</LatestRuntimeFrameworkVersion>
      <AppHostRuntimeIdentifiers Condition=" '$(DotNetBuildSourceOnly)' == 'true' ">$(TargetRuntimeIdentifier)</AppHostRuntimeIdentifiers>
    </KnownRuntimePack>
    <KnownWebAssemblySdkPack Update="Microsoft.NET.Sdk.WebAssembly.Pack">
      <WebAssemblySdkPackVersion Condition=" '%(TargetFramework)' == 'net10.0' ">10.0.0-preview.7.25377.103</WebAssemblySdkPackVersion>
    </KnownWebAssemblySdkPack>
    <KnownAspNetCorePack Update="Microsoft.AspNetCore.App.Internal.Assets">
      <AspNetCorePackVersion Condition=" '%(TargetFramework)' == 'net10.0' ">10.0.0-dev</AspNetCorePackVersion>
    </KnownAspNetCorePack>
    <KnownCrossgen2Pack Update="Microsoft.NETCore.App.Crossgen2">
      <Crossgen2PackVersion Condition=" '%(TargetFramework)' == 'net10.0' ">10.0.0-preview.7.25377.103</Crossgen2PackVersion>
      <Crossgen2RuntimeIdentifiers Condition="'$(DotNetBuild)' == 'true'">%(Crossgen2RuntimeIdentifiers);$(NETCoreSdkRuntimeIdentifier);$(TargetRuntimeIdentifier)</Crossgen2RuntimeIdentifiers>
    </KnownCrossgen2Pack>
    <KnownILLinkPack Update="Microsoft.NET.ILLink.Tasks" Condition=" '$(DotNetBuildSourceOnly)' == 'true' ">
      <ILLinkPackVersion Condition=" '%(TargetFramework)' == 'net10.0' ">10.0.0-preview.7.25377.103</ILLinkPackVersion>
    </KnownILLinkPack>
    <!-- Use the just-built ASP.NET Core shared framework if available except when building product code in servicing. -->
    <KnownFrameworkReference Update="Microsoft.AspNetCore.App" Condition=" $(UpdateAspNetCoreKnownFramework) ">
      <LatestRuntimeFrameworkVersion Condition=" '%(TargetFramework)' == 'net10.0' ">10.0.0-dev</LatestRuntimeFrameworkVersion>
      <RuntimePackRuntimeIdentifiers Condition=" '%(TargetFramework)' == 'net10.0' ">win-x64;win-x86;win-arm;win-arm64;osx-x64;osx-arm64;linux-musl-x64;linux-musl-arm;linux-musl-arm64;linux-x64;linux-arm;linux-arm64;freebsd-x64</RuntimePackRuntimeIdentifiers>
      <!-- Do not update %(TargetingPackVersion) until X.Y.0 versions have been released. -->
      <TargetingPackVersion Condition=" '%(TargetFramework)' == 'net10.0' AND '0' != '1' ">10.0.0-dev</TargetingPackVersion>
      <DefaultRuntimeFrameworkVersion Condition=" '$(IsServicingBuild)' != 'true' AND&#xA;          '%(TargetFramework)' == 'net10.0' ">10.0.0-dev</DefaultRuntimeFrameworkVersion>
    </KnownFrameworkReference>
  </ItemGroup>
  <!-- When building and running locally, manually resolve the just-built frameworks. On Helix, let the SDK resolve the packs itself (they're laid out on top of the .NET SDK in the work items) -->
  <PropertyGroup Condition="'$(UpdateAspNetCoreKnownFramework)' == 'true' AND '$(HELIX_CORRELATION_PAYLOAD)' == ''">
    <!-- Allow additional targeting and runtime packs to be downloaded only if required by a test. -->
    <EnableTargetingPackDownload Condition="'$(TestRequiresTargetingPackDownload)' != 'true'">false</EnableTargetingPackDownload>
    <EnableRuntimePackDownload Condition="'$(TestRequiresRuntimePackDownload)' != 'true'">false</EnableRuntimePackDownload>
    <GenerateErrorForMissingTargetingPacks>false</GenerateErrorForMissingTargetingPacks>
  </PropertyGroup>
  <Target Name="ResolveLiveBuiltAspnetCoreKnownFramework" Condition="'$(UpdateAspNetCoreKnownFramework)' == 'true' AND '$(HELIX_CORRELATION_PAYLOAD)' == ''" AfterTargets="ResolveFrameworkReferences">
    <Error Text="Requested Microsoft.AspNetCore.App v10.0.0-dev ref pack does not exist." Condition="!Exists('$(TargetingPackLayoutRoot)packs\Microsoft.AspNetCore.App.Ref\10.0.0-dev\data\FrameworkList.xml') " />
    <ItemGroup>
      <ResolvedTargetingPack Path="$(TargetingPackLayoutRoot)packs\Microsoft.AspNetCore.App.Ref\10.0.0-dev" NugetPackageVersion="10.0.0-dev" PackageDirectory="$(TargetingPackLayoutRoot)packs\Microsoft.AspNetCore.App.Ref\10.0.0-dev" Condition="'%(ResolvedTargetingPack.RuntimeFrameworkName)' == 'Microsoft.AspNetCore.App'" />
      <ResolvedRuntimePack PackageDirectory="$(SharedFrameworkLayoutRoot)shared\Microsoft.AspNetCore.App\10.0.0-dev" Condition="'%(ResolvedRuntimePack.RuntimeFrameworkName)' == 'Microsoft.AspNetCore.App'" />
      <ResolvedFrameworkReference TargetingPackPath="$(TargetingPackLayoutRoot)packs\Microsoft.AspNetCore.App.Ref\10.0.0-dev" TargetingPackVersion="10.0.0-dev" RuntimePackPath="$(SharedFrameworkLayoutRoot)shared\Microsoft.AspNetCore.App\10.0.0-dev" Condition="'%(Identity)' == 'Microsoft.AspNetCore.App'" />
    </ItemGroup>
  </Target>
  <!--
    Make a netstandard2.1 copy of the .net ILLinkPack to work around a trimming issue.
    See https://github.com/dotnet/linker/issues/3175
  -->
  <Target Name="_FixKnownILLinkPack" BeforeTargets="ProcessFrameworkReferences">
    <ItemGroup>
      <KnownILLinkPack Include="@(KnownILLinkPack)" Condition="'%(TargetFramework)' == 'net7.0'" TargetFramework="netstandard2.1" ILLinkPackVersion="%(KnownILLinkPack.ILLinkPackVersion)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="eng\targets\ResolveIisReferences.targets" Condition=" '$(MSBuildProjectExtension)' != '.vcxproj' ">

/home/runner/work/aspnetcore/aspnetcore/eng/targets/ResolveIisReferences.targets
============================================================================================================================================
-->
  <!--

The targets in this file resolve References to ANCM into ProjectReferences,
with the right MSBuild incantations to get output copied to the right place.

-->
  <!-- IIS native projects only build on Windows with MSBuild.exe -->
  <ItemGroup Condition="'@(NativeProjectReference-&gt;Count())' != '0' AND $(BuildNative) ">
    <!-- TODO: investigate building just one arch at a time. -->
    <ProjectReference Include="@(NativeProjectReference)">
      <!-- Set the arch-->
      <SetPlatform>Platform=%(Platform)</SetPlatform>
      <SetPlatform Condition="'%(Platform)' == 'x86'">Platform=Win32</SetPlatform>
      <!-- The base path for the output. -->
      <LinkBase>%(Platform)\%(HandlerPath)\</LinkBase>
      <!-- This reference assembly doesn't need -->
      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
      <!-- NativeContent is a custom type of item group which is assigned a target path after project references are resolved.  -->
      <OutputItemType>NativeContent</OutputItemType>
      <!-- This instructs the ProjectRef protocol to collect symbols as well as built output -->
      <Targets>Build;BuiltProjectOutputGroup;DebugSymbolsProjectOutputGroup</Targets>
      <!-- Optimization. Native projects don't have a .NET TargetFramework -->
      <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>
      <UndefineProperties>TargetFramework</UndefineProperties>
      <!-- Don't put this reference into generated .nuspec -->
      <PrivateAssets>All</PrivateAssets>
      <!-- Publish assets from this reference -->
      <Publish>true</Publish>
    </ProjectReference>
    <NativeProjectReference Remove="@(NativeProjectReference)" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.targets
============================================================================================================================================
-->
  <!--<Import Project="eng\targets\Cpp.Common.targets" Condition="'$(MSBuildProjectExtension)' == '.vcxproj'" />-->
  <!--
============================================================================================================================================
  <Import Project="eng\targets\CSharp.Common.targets" Condition="'$(MSBuildProjectExtension)' == '.csproj'">

/home/runner/work/aspnetcore/aspnetcore/eng/targets/CSharp.Common.targets
============================================================================================================================================
-->
  <!-- For 'legacy' .csproj files, set map TargetFrameworkVersion back to TargetFramework -->
  <PropertyGroup Condition=" '$(TargetFramework)' == '' AND '$(TargetFrameworks)' == '' ">
    <TargetFramework>net$(TargetFrameworkVersion.TrimStart('vV').Replace('.',''))</TargetFramework>
    <TargetFrameworkIdentifier>.NETFramework</TargetFrameworkIdentifier>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Ensure API changes show up clearly in PRs. -->
    <AddPublicApiAnalyzers Condition=" '$(AddPublicApiAnalyzers)' == '' AND&#xA;        '$(IsImplementationProject)' == 'true' AND&#xA;        ! $(RepoRelativeProjectDir.Contains('Tools')) ">true</AddPublicApiAnalyzers>
    <AddPublicApiAnalyzers Condition=" '$(AddPublicApiAnalyzers)' == '' ">false</AddPublicApiAnalyzers>
    <!-- Public members should not use oblivious types. Not done with all nullable annotations. -->
    <NoWarn>$(NoWarn);RS0041</NoWarn>
    <_IsSrcProject Condition="'$(IsImplementationProject)' == 'true' OR&#xA;        '$(IsAnalyzersProject)' == true OR&#xA;        '$(IsSpecificationTestProject)' == 'true'">true</_IsSrcProject>
    <Nullable Condition=" '$(Nullable)' == '' AND '$(_IsSrcProject)' == 'true'">enable</Nullable>
    <!-- Strip out non-public nullable annotations for src projects. This should help with size reduction -->
    <Features Condition="'$(_IsSrcProject)' == 'true'">$(Features);nullablePublicOnly</Features>
    <!-- Turn off platform compatibility analyzer warnings in test, test assets, and samples. -->
    <NoWarn Condition=" $(IsTestProject) OR&#xA;        '$(IsTestAssetProject)' == 'true' OR&#xA;        '$(ISBenchmarkProject)' == 'true' OR&#xA;        '$(IsSampleProject)' == 'true' OR&#xA;        '$(IsMicrobenchmarksProject)' == 'true'">$(NoWarn);CA1416</NoWarn>
    <!-- Turn off unused usings warning for multi-targeted projects. Fixing them using ifdefs looks worse than ignoring the warnings. -->
    <NoWarn Condition="'$(TargetFrameworks)' != ''">$(NoWarn);IDE0005</NoWarn>
    <!--
      Turn off ConfigureAwait analyzer rule in the projects that are exclusively meant to run in ASP.NET Core or Blazor contexts.
      Since we don't have a good way to detect this, we'll use the presence of ns2.0 as a proxy.
     -->
    <NoWarn Condition="'$(_IsSrcProject)' != 'true' OR !$(TargetFrameworks.Contains('netstandard'))">$(NoWarn);CA2007</NoWarn>
    <!-- Enable .NET code style analysis during build for src projects. -->
    <EnforceCodeStyleInBuild Condition="'$(EnforceCodeStyleInBuild)' == ''">true</EnforceCodeStyleInBuild>
    <!-- Enable trimming annotation validation in DI. See https://github.com/dotnet/runtime/blob/main/docs/workflow/trimming/feature-switches.md -->
    <VerifyDependencyInjectionOpenGenericServiceTrimmability Condition=" $(IsTestProject) ">true</VerifyDependencyInjectionOpenGenericServiceTrimmability>
  </PropertyGroup>
  <!-- Enable implicit usings for projects that target the default TFM -->
  <PropertyGroup Condition="'$(ImplicitUsings)' == '' AND '$(TargetFrameworks)' == '' AND '$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)'">
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
  <ItemGroup Condition="'$(ImplicitUsings)' == 'enable'">
    <!-- We should make it obvious when Linq is being used in shipping code -->
    <Using Remove="System.Linq" Condition="'$(_IsSrcProject)' == 'true'" />
    <!-- System.Net.Http types will frequently conflict with ASP.NET Core types-->
    <Using Remove="System.Net.Http" />
    <Using Include="Xunit" Condition=" $(IsTestProject) " />
  </ItemGroup>
  <ItemGroup Condition=" '$(DotNetBuildSourceOnly)' != 'true' AND $(AddPublicApiAnalyzers) ">
    <Reference Include="Microsoft.CodeAnalysis.PublicApiAnalyzers" ExcludeAssets="Compile" PrivateAssets="All" />
  </ItemGroup>
  <Target Name="_CheckIgnoredPublicApiFiles" BeforeTargets="Build;Restore" Condition=" Exists('$(MSBuildProjectDirectory)\PublicAPI.Shipped.txt') AND ! $(AddPublicApiAnalyzers) ">
    <Warning Text="Public API baseline files ignored." />
  </Target>
  <Target Name="_RemovePublicApiAnalyzer" BeforeTargets="RazorCoreCompile">
    <ItemGroup>
      <_PublicAPIAnalyzers Include="@(Analyzer-&gt;WithMetadataValue('NuGetPackageId','Microsoft.CodeAnalysis.PublicApiAnalyzers'))" />
      <Analyzer Remove="@(_PublicAPIAnalyzers)" />
    </ItemGroup>
  </Target>
  <Target Name="_RestorePublicApiAnalyzer" AfterTargets="RazorCoreCompile">
    <ItemGroup>
      <Analyzer Include="@(_PublicAPIAnalyzers)" />
    </ItemGroup>
  </Target>
  <Target Name="GetCustomAssemblyAttributes" BeforeTargets="GetAssemblyAttributes" DependsOnTargets="InitializeSourceControlInformation">
    <ItemGroup>
      <AssemblyAttribute Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(SourceRevisionId)' != ''">
        <_Parameter1>CommitHash</_Parameter1>
        <_Parameter2>$(SourceRevisionId)</_Parameter2>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyMetadataAttribute" Condition="$(RepositoryUrl.StartsWith('https://github.com'))">
        <_Parameter1>SourceCommitUrl</_Parameter1>
        <_Parameter2>$(RepositoryUrl)/tree/$(SourceRevisionId)</_Parameter2>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(Serviceable)' == 'true'">
        <_Parameter1>Serviceable</_Parameter1>
        <_Parameter2>True</_Parameter2>
      </AssemblyAttribute>
    </ItemGroup>
  </Target>
  <!-- Reference assemblies are shipped only in targeting packs. -->
  <Target Name="_RemoveReferenceAssembly" BeforeTargets="_GetPackageFiles;GenerateNuspec" Condition="$(HasReferenceAssembly)">
    <ItemGroup>
      <_PackageFilesToExclude Include="@(IntermediateRefAssembly);$(TargetRefPath)" />
    </ItemGroup>
  </Target>
  <Choose>
    <!--
        C# 8.0's nullable annotations only work for .NET Core 3.0+ by default. However it can be made to work for other target frameworks
        by compiling the annotations (as internal types).
        The code block that follows sets it up so projects in this repo that target ns2.0 or netfx can compile when Nullable is configured.
        Based on https://github.com/dotnet/runtime/blob/93b6c449d4f31ddd7d573d1d3769e681d5ebceb9/src/libraries/Directory.Build.targets#L215-L222

        SuppressNullableAttributesImport to disable. Used when attributes are already present from another project because of InternalsVisibleTo.
     -->
    <When Condition=" ('$(Nullable)' == 'annotations' OR '$(Nullable)' == 'enable') AND&#xA;        '$(SuppressNullableAttributesImport)' != 'true' AND&#xA;        (('$(TargetFrameworkIdentifier)' == '.NETStandard' AND $([MSBuild]::VersionLessThanOrEquals('$(TargetFrameworkVersion)', '2.1'))) OR '$(TargetFrameworkIdentifier)' == '.NETFramework')">
      <PropertyGroup>
        <DefineConstants>$(DefineConstants),INTERNAL_NULLABLE_ATTRIBUTES</DefineConstants>
        <!-- Repo-specific property to enable nullability warnings for ns2.0 -->
        <NoWarn Condition=" '$(WarnOnNullable)' != 'true' ">$(NoWarn);nullable</NoWarn>
      </PropertyGroup>
      <ItemGroup>
        <Compile Include="$(SharedSourceRoot)Nullable\NullableAttributes.cs" />
      </ItemGroup>
    </When>
  </Choose>
  <Target Name="ValidateBenchmarks" BeforeTargets="Test" Condition="'$(IsMicrobenchmarksProject)' == 'true' AND '$(SkipMicrobenchmarksValidation)' != 'true'">
    <Message Text="%0ARunning benchmark validation for:%0A$(MSBuildProjectName)%0A" Importance="High" />
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="GetTargetPath">
      <Output TaskParameter="TargetOutputs" PropertyName="ExecPath" />
    </MSBuild>
    <Exec Command="dotnet $(ExecPath) -f * --validate-fast" IgnoreStandardErrorWarningFormat="true" StandardOutputImportance="low" />
  </Target>
  <!--
============================================================================================================================================
  <Import Project="Packaging.targets">

/home/runner/work/aspnetcore/aspnetcore/eng/targets/Packaging.targets
============================================================================================================================================
-->
  <Target Name="EnsureBaselineIsUpdated" Condition=" '$(ValidateBaseline)' == 'true' AND&#xA;              '$(IsServicingBuild)' == 'true' AND&#xA;              '$(AspNetCoreBaselineVersion)' != '$(PreviousAspNetCoreReleaseVersion)' AND&#xA;              '$(MSBuildProjectName)' != 'BaselineGenerator' AND&#xA;              '$(MSBuildProjectName)' != 'RepoTasks' " BeforeTargets="BeforeBuild">
    <Error Text="The package baseline ($(AspNetCoreBaselineVersion)) is out of date with the latest release of this repo ($(PreviousAspNetCoreReleaseVersion)).&#xA;                 See $(RepoRoot)eng\tools\BaselineGenerator\README.md for instructions on updating this baseline." />
  </Target>
  <!-- This target is used to get the package versions of projects. A variant also exists in Npm.Common.targets. -->
  <Target Name="_GetPackageVersionInfo" DependsOnTargets="$(GetPackageVersionDependsOn)" Returns="@(_ProjectPathWithVersion)">
    <ItemGroup>
      <_ProjectPathWithVersion Include="$(MSBuildProjectFullPath)">
        <PackageId>$(PackageId)</PackageId>
        <PackageVersion>$(PackageVersionForPackageVersionInfo)</PackageVersion>
        <VersionSuffix>$(VersionSuffix)</VersionSuffix>
        <VersionVariableName>$(PackageId.Replace('.',''))Version</VersionVariableName>
      </_ProjectPathWithVersion>
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <GenerateNuspecDependsOn>$(GenerateNuspecDependsOn);_AppendRepositoryUrlToPackageDescription</GenerateNuspecDependsOn>
  </PropertyGroup>
  <Target Name="_AppendRepositoryUrlToPackageDescription" DependsOnTargets="InitializeSourceControlInformation">
    <PropertyGroup Condition="'$(RepositoryUrl)' != '' AND '$(SourceRevisionId)' != ''">
      <PackageDescription>$(PackageDescription)

This package was built from the source code at $(RepositoryUrl)/tree/$(SourceRevisionId)</PackageDescription>
    </PropertyGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/eng/targets/CSharp.Common.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="ResolveReferences.targets">

/home/runner/work/aspnetcore/aspnetcore/eng/targets/ResolveReferences.targets
============================================================================================================================================
-->
  <!--
  The targets in this file are used to implement custom <Reference> resolution.
  For more details, see /docs/ReferenceResolution.md.

  Properties which can be set by projects. If unset, these will be inferred.

    * UseLatestPackageReferences = resolve `<Reference>` items to the latest version of PackageReferences in eng/Dependencies.props.
    * UseProjectReferences = prefer project references to packages
    * IsProjectReferenceProvider = when true, the assembly in this project should be available as a ProjectReferenceProvider (see below).

  Items used by the resolution strategy:

    * BaselinePackageReference = a list of packages that were referenced in the last release of the project currently building
      - mainly used to ensure references do not change in servicing builds unless $(UseLatestPackageReferences) is not true.
    * LatestPackageReference = a list of the latest versions of packages
    * Reference = a list of the references which are needed for compilation or runtime
    * ProjectReferenceProvider = a list which maps of assembly names to the project file that produces it
-->
  <PropertyGroup>
    <EnableCustomReferenceResolution Condition="'$(EnableCustomReferenceResolution)' == '' AND ('$(DotNetBuildSourceOnly)' != 'true' OR '$(ExcludeFromSourceOnlyBuild)' != 'true')">true</EnableCustomReferenceResolution>
    <ResolveReferencesDependsOn>
      ResolveCustomReferences;
      $(ResolveReferencesDependsOn);
    </ResolveReferencesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <!--
      Projects should use the latest package references when:
        * preparing a new major or minor release i.e. a non-servicing builds
        * when a project is a test or sample project
        * when a package is releasing a new patch (we like to update external dependencies in patches when possible)
      That is, use latest package references unless this is a servicing build, the project is normally packable, and
      the package is not included in this release. The "unless" cases are extremely unlikely because both
      $(IsPackableInNonServicingBuild) and $(IsPackageInThisPatch) are either undefined or true.
    -->
    <UseLatestPackageReferences Condition=" '$(UseLatestPackageReferences)' == '' AND '$(IsServicingBuild)' != 'true' ">true</UseLatestPackageReferences>
    <UseLatestPackageReferences Condition=" '$(UseLatestPackageReferences)' == '' AND '$(IsPackableInNonServicingBuild)' != 'true' ">true</UseLatestPackageReferences>
    <UseLatestPackageReferences Condition=" '$(UseLatestPackageReferences)' == '' AND '$(IsPackageInThisPatch)' == 'true' ">true</UseLatestPackageReferences>
    <UseLatestPackageReferences Condition=" '$(UseLatestPackageReferences)' == '' ">false</UseLatestPackageReferences>
    <!-- Projects should use project references (instead of baseline packages) in almost all cases. -->
    <UseProjectReferences Condition=" '$(UseProjectReferences)' == '' ">true</UseProjectReferences>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <Reference>
      <IsSharedSource />
    </Reference>
  </ItemDefinitionGroup>
  <ItemGroup Condition="'$(EnableCustomReferenceResolution)' == 'true'">
    <Reference Update="@(Reference)">
      <IsSharedSource Condition="'%(IsSharedSource)' == '' AND $([System.String]::new('%(Identity)').EndsWith('.Sources'))">true</IsSharedSource>
    </Reference>
    <!-- Packages which are implicitly defined by the .NET Core SDK. -->
    <_ImplicitPackageReference Include="@(PackageReference-&gt;WithMetadataValue('IsImplicitlyDefined', 'true'))" />
    <!-- Capture a list of references which were set explicitly in the project. -->
    <_AllowedExplicitPackageReference Include="@(PackageReference-&gt;WithMetadataValue('AllowExplicitReference', 'true'))" />
    <_AllowedExplicitPackageReference Include="FSharp.Core" Condition="'$(MSBuildProjectExtension)' == '.fsproj'" />
    <_ExplicitPackageReference Include="@(PackageReference)" Exclude="@(_ImplicitPackageReference);@(_AllowedExplicitPackageReference)" />
    <_CompilationOnlyReference Include="@(Reference-&gt;WithMetadataValue('NuGetPackageId','NETStandard.Library'))" Condition="'$(TargetFramework)' == 'netstandard2.0'" />
    <_InvalidReferenceToNonSharedFxAssembly Condition="'$(IsAspNetCoreApp)' == 'true'" Include="@(Reference)" Exclude="&#xA;          @(AspNetCoreAppReference);&#xA;          @(AspNetCoreAppReferenceAndPackage);&#xA;          @(ExternalAspNetCoreAppReference);&#xA;          @(_CompilationOnlyReference);&#xA;          @(Reference-&gt;WithMetadataValue('IsSharedSource', 'true'));&#xA;          @(Reference-&gt;WithMetadataValue('PrivateAssets', 'All'))" />
    <_OriginalReferences Include="@(Reference)" />
  </ItemGroup>
  <!--
    Turn Reference items into a ProjectReference when UseProjectReferences is true. Order matters; this
    comes before package resolution because projects should be used when possible instead of packages.
    -->
  <ItemGroup Condition=" '$(EnableCustomReferenceResolution)' == 'true' AND '$(UseProjectReferences)' == 'true' ">
    <!--
      For the _CheckForReferenceBoundaries target, mark project reference providers that _should_ be referenced with
      Reference items but weren't. General principle is to use only Reference items when referencing a provider.
      This simplifies project moves and shortens files.
    -->
    <ProjectReferenceProvider Update="@(ProjectReference->'%(Filename)')" DirectUse="1" />
    <!-- Find Reference items satisfied using project reference providers. -->
    <Reference Update="@(ProjectReferenceProvider)" ProjectPath="%(ProjectReferenceProvider.ProjectPath)" />
    <ProjectReference Include="@(Reference-&gt;Distinct()-&gt;'%(ProjectPath)')" />
    <Reference Remove="@(Reference-&gt;HasMetadata('ProjectPath'))" />
  </ItemGroup>
  <!--
    This target helps ensure projects within the shared framework do not unintentionally add new references, and that
    assemblies outside the shared framework reference the framework as a whole instead of using individual assemblies.
    In addition, enforce use of Reference items for projects reference providers.
  -->
  <Target Name="_CheckForReferenceBoundaries" BeforeTargets="CollectPackageReferences;ResolveReferences">
    <!-- Dependency graph checks may include unexpected packages. Ignore this because it's not an error. -->
    <Error Condition=" '$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' AND&#xA;            '$(MSBuildRestoreSessionId)' != '' AND&#xA;            @(_InvalidReferenceToNonSharedFxAssembly-&gt;Count()) != 0 " Text="Cannot reference &quot;%(Identity)&quot;. This dependency is not in the shared framework. See docs/SharedFramework.md for instructions on how to modify what is in the shared framework." />
    <Error Condition=" '$(EnableCustomReferenceResolution)' == 'true' AND '@(ProjectReferenceProvider-&gt;WithMetadataValue('DirectUse', '1')-&gt;Count())' != '0' " Text="Cannot reference &quot;%(Identity)&quot; with a ProjectReference item; use a Reference item." />
  </Target>
  <Target Name="_WarnAboutRedundantRef" AfterTargets="ResolveFrameworkReferences;ProcessFrameworkReferences">
    <Warning Condition="@(FrameworkReference-&gt;WithMetadataValue('Identity', 'Microsoft.AspNetCore.App')-&gt;Count()) &gt; 1" Text="Redundant &lt;FrameworkReference&gt;. If you have an explicit item in the project file, you might be able to remove it. Some SDKs, like Microsoft.NET.Sdk.Web, add this implicitly." />
  </Target>
  <!--
    This target resolves remaining Reference items to Packages, if possible. If not, they are left as Reference
    items for the SDK to resolve. This executes on NuGet restore and during DesignTimeBuild. It should not run in
    outer, cross-targeting build.
   -->
  <Target Name="ResolveCustomReferences" BeforeTargets="CheckForImplicitPackageReferenceOverrides;CollectPackageReferences;ResolvePackageAssets" Condition=" '$(TargetFramework)' != '' AND '$(EnableCustomReferenceResolution)' == 'true' ">
    <ItemGroup>
      <!-- Ensure only content assets are consumed from .Sources packages. -->
      <Reference>
        <IncludeAssets Condition="'%(IsSharedSource)' == 'true'">ContentFiles;Build</IncludeAssets>
        <PrivateAssets Condition="'%(IsSharedSource)' == 'true'">All</PrivateAssets>
      </Reference>
      <!-- Identify if any references were present in the last release of this package, but have been removed. -->
      <UnusedBaselinePackageReference Include="@(BaselinePackageReference)" Exclude="@(Reference);@(PackageReference);@(ProjectReference->'%(Filename)')" />
      <!-- Handle suppressions needed because above Exclude is not aware of references added in .nuspec files. -->
      <UnusedBaselinePackageReference Remove="@(SuppressBaselineReference-&gt;WithMetadataValue('InNuspecFile', 'true'))" Condition=" '$(IsServicingBuild)' == 'true' " />
      <!-- Allow suppressions of any baseline changes in non-servicing builds. -->
      <UnusedBaselinePackageReference Remove="@(SuppressBaselineReference)" Condition=" '$(IsServicingBuild)' != 'true' " />
    </ItemGroup>
    <JoinItems Left="@(Reference)" Right="@(LatestPackageReference)" LeftMetadata="*" RightMetadata="Version" Condition=" '$(UseLatestPackageReferences)' == 'true' ">
      <Output TaskParameter="JoinResult" ItemName="_LatestPackageReferenceWithVersion" />
    </JoinItems>
    <ItemGroup>
      <PackageReference Include="@(_LatestPackageReferenceWithVersion)" IsImplicitlyDefined="true" />
      <!-- Remove reference items that have been resolved to a LatestPackageReference item. -->
      <Reference Remove="@(_LatestPackageReferenceWithVersion)" />
    </ItemGroup>
    <!-- Resolve references from BaselinePackageReference for servicing builds in corner cases. May be unused. -->
    <JoinItems Left="@(Reference)" Right="@(BaselinePackageReference)" LeftMetadata="*" RightMetadata="Version" Condition=" '$(IsServicingBuild)' == 'true' OR '$(UseLatestPackageReferences)' != 'true' ">
      <Output TaskParameter="JoinResult" ItemName="_BaselinePackageReferenceWithVersion" />
    </JoinItems>
    <ItemGroup>
      <PackageReference Include="@(_BaselinePackageReferenceWithVersion)" IsImplicitlyDefined="true" />
      <!-- Remove reference items that have been resolved to a BaselinePackageReference item. -->
      <Reference Remove="@(_BaselinePackageReferenceWithVersion)" />
    </ItemGroup>
    <!-- For PrivateAssets=All references, like .Sources packages, fallback to LatestPackageReferences. -->
    <JoinItems Left="@(Reference-&gt;WithMetadataValue('PrivateAssets', 'All'))" Right="@(LatestPackageReference)" LeftMetadata="*" RightMetadata="Version">
      <Output TaskParameter="JoinResult" ItemName="_PrivatePackageReferenceWithVersion" />
    </JoinItems>
    <ItemGroup>
      <PackageReference Include="@(_PrivatePackageReferenceWithVersion)" IsImplicitlyDefined="true" />
      <!-- Remove reference items that have been resolved to a LatestPackageReference item. -->
      <Reference Remove="@(_PrivatePackageReferenceWithVersion)" />
      <!-- Free up memory for unnecessary items -->
      <_LatestPackageReferenceWithVersion Remove="@(_LatestPackageReferenceWithVersion)" />
      <_BaselinePackageReferenceWithVersion Remove="@(_BaselinePackageReferenceWithVersion)" />
      <_PrivatePackageReferenceWithVersion Remove="@(_PrivatePackageReferenceWithVersion)" />
      <_ImplicitPackageReference Remove="@(_ImplicitPackageReference)" />
    </ItemGroup>
    <Error Condition="'$(DisablePackageReferenceRestrictions)' != 'true' AND '@(_ExplicitPackageReference-&gt;Count())' != '0'" Text="PackageReference items are not allowed. Use &lt;Reference&gt; instead to replace the reference to @(_ExplicitPackageReference, ', '). See docs/ReferenceResolution.md for more details." />
    <ItemGroup>
      <_ExplicitPackageReference Remove="@(_ExplicitPackageReference)" />
    </ItemGroup>
    <Error Condition=" '$(IsServicingBuild)' == 'true' AND '@(UnusedBaselinePackageReference-&gt;Count())' != '0' " Code="BUILD002" Text="Package references changed since the last release. This could be a breaking change and is not allowed in a servicing update. References removed:%0A - @(UnusedBaselinePackageReference, '%0A - ')" />
    <Error Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '%(Reference.Identity)' != '' AND ! Exists('%(Reference.Identity)') AND '$(DisablePackageReferenceRestrictions)' != 'true'" Code="MSB3245" Text="Could not resolve this reference. Could not locate the package or project for &quot;%(Reference.Identity)&quot;. Did you update baselines and dependencies lists? See docs/ReferenceResolution.md for more details." />
    <!--
      At this point, most if not all @(Reference) items have been converted to @(PackageReference) or
      @(ProjectReference) items. (Remaining .NET Framework @(Reference) items may exist but the SDK will hopefully
      resolve them.) Check whether these items use the easily-confused %(Private) or %(PrivateAssets) metadata.
      Because this metadata has different semantics, cannot convert one to the other.
    -->
    <Warning Condition=" '@(PackageReference-&gt;HasMetadata('Private')-&gt;Count())' != '0' " Code="BUILD004" Text="%25(Private) metadata should not be applied to the %(Identity) package reference. Did you mean %25(PrivateAssets)?" />
    <Warning Condition=" '@(Reference-&gt;HasMetadata('PrivateAssets')-&gt;Count())' != '0' " Code="BUILD006" Text="%25(PrivateAssets) metadata should not be applied to the %(Identity) assembly reference. Did you mean %25(Private)?" />
  </Target>
  <PropertyGroup>
    <_CompileTfmUsingReferenceAssemblies>false</_CompileTfmUsingReferenceAssemblies>
    <_CompileTfmUsingReferenceAssemblies Condition=" '$(CompileUsingReferenceAssemblies)' != 'false' AND '$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' ">true</_CompileTfmUsingReferenceAssemblies>
  </PropertyGroup>
  <!--
    If we have a ref/ assembly from dotnet/runtime for an Extension package, use that when compiling but do not reference its assemblies.
  -->
  <ItemGroup Condition=" '$(MSBuildProjectName)' != 'Microsoft.AspNetCore.App.Runtime' AND&#xA;      '$(MSBuildProjectName)' != 'RepoTasks' AND&#xA;      ('$(MSBuildProjectName)' == 'Microsoft.AspNetCore.App.Ref' OR&#xA;      '$(MSBuildProjectName)' == 'Microsoft.AspNetCore.App.Ref.Sfx' OR&#xA;      (('$(IsAspNetCoreApp)' == 'true' OR '$(UseAspNetCoreSharedRuntime)' == 'true') AND&#xA;      $(_CompileTfmUsingReferenceAssemblies))) ">
    <PackageReference Include="Microsoft.Internal.Runtime.AspNetCore.Transport" Version="$(MicrosoftInternalRuntimeAspNetCoreTransportVersion)" IsImplicitlyDefined="true" IncludeAssets="Compile" PrivateAssets="All" GeneratePathProperty="true" />
  </ItemGroup>
  <!--
    Remove compile-time assets for packages that overlap Microsoft.Internal.Runtime.AspNetCore.Transport. Serviced packages
    may otherwise increase the referenced version. Avoid this because change reduces compatible runtime versions.
    That's not a big deal within the shared framework but can cause problems for shipped packages. Leave test
    projects alone because they may transitively reference newer netstandard assemblies and need a
    net5.0 assembly with the same version. (This can happen in implementation projects but is less likely.)
  -->
  <Target Name="RemoveExtensionsCompileAssets" AfterTargets="ResolvePackageAssets" Condition="'$(MSBuildProjectName)' == 'Microsoft.AspNetCore.App.Ref'&#xA;        OR ( '$(PkgMicrosoft_Internal_Runtime_AspNetCore_Transport)' != '' AND&#xA;          '$(IsServicingBuild)' == 'true' AND&#xA;          '$(IsImplementationProject)' == 'true' AND&#xA;          '$(MSBuildProjectName)' != 'Microsoft.AspNetCore.App.Runtime' AND&#xA;          $(_CompileTfmUsingReferenceAssemblies)) ">
    <ItemGroup>
      <ResolvedCompileFileDefinitions Remove="@(ResolvedCompileFileDefinitions)" Condition=" '%(NuGetPackageId)' != 'Microsoft.Internal.Runtime.AspNetCore.Transport' AND&#xA;              EXISTS('$(PkgMicrosoft_Internal_Runtime_AspNetCore_Transport)\ref\$(TargetFramework)\%(Filename).dll') AND&#xA;              $([System.String]::new('%(Directory)').Contains('$(TargetFramework)')) " />
    </ItemGroup>
  </Target>
  <!-- These targets are used to generate the map of assembly name to project files. See also the /t:GenerateProjectList target in build/repo.targets. -->
  <Target Name="GetReferencesProvided" Returns="@(ProvidesReference)">
    <ItemGroup>
      <_TargetFramework Remove="@(_TargetFramework)" />
      <_TargetFramework Include="$(TargetFramework)" Condition="'$(TargetFramework)' != '' " />
      <_TargetFramework Include="$(TargetFrameworks)" Condition="'$(TargetFramework)' == '' " />
    </ItemGroup>
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="_GetReferencesProvided" Properties="TargetFramework=%(_TargetFramework.Identity)">
      <Output TaskParameter="TargetOutputs" ItemName="ProvidesReference" />
    </MSBuild>
  </Target>
  <Target Name="_GetReferencesProvided" Returns="@(ProvidesReference)">
    <Error Condition=" '$(IsAspNetCoreApp)' == 'true' AND '$(IsImplementationProject)' == 'true' AND&#xA;            !$(HasReferenceAssembly) AND '$(TargetFramework)' == '$(DefaultNetCoreTargetFramework)' " Text="All assemblies which have set IsAspNetCoreApp=true should produce a reference assembly for default TFM." />
    <Error Condition=" '$(IsAspNetCoreApp)' == 'true' AND '$(IsImplementationProject)' != 'true' " Text="Only implementation projects should set IsAspNetCoreApp=true." />
    <Error Condition=" '$(IsAspNetCoreApp)' != 'true' AND $(HasReferenceAssembly) " Text="Only projects in the shared framework i.e. IsAspNetCoreApp==true should produce a reference assembly." />
    <Warning Condition=" '$(IsProjectReferenceProvider)' == 'true' AND '$(AssemblyName)' != '$(MSBuildProjectName)' " Text="Project name &quot;$(MSBuildProjectName)&quot; is confusing; assembly is named &quot;$(AssemblyName)&quot;." />
    <ItemGroup Condition=" '$(IsProjectReferenceProvider)' == 'true' OR '$(RequiresDelayedBuild)' == 'true' ">
      <ProvidesReference Include="$(AssemblyName)">
        <IsAspNetCoreApp>$([MSBuild]::ValueOrDefault($(IsAspNetCoreApp),'false'))</IsAspNetCoreApp>
        <IsPackable>$([MSBuild]::ValueOrDefault($(IsPackable),'false'))</IsPackable>
        <ProjectFileRelativePath>$([MSBuild]::MakeRelative($(RepoRoot), $(MSBuildProjectFullPath)))</ProjectFileRelativePath>
        <IsTrimmable>$([MSBuild]::ValueOrDefault($(IsTrimmable),'false'))</IsTrimmable>
        <IsShippingPackage>$([MSBuild]::ValueOrDefault($(IsShippingPackage),'false'))</IsShippingPackage>
        <!-- True if the project may be referenced using a @(Reference) item. -->
        <IsProjectReferenceProvider>$([MSBuild]::ValueOrDefault($(IsProjectReferenceProvider),'false'))</IsProjectReferenceProvider>
        <!-- True if project must be restored etc. after App.Ref and App.Runtime are fully built. -->
        <RequiresDelayedBuild>$([MSBuild]::ValueOrDefault($(RequiresDelayedBuild),'false'))</RequiresDelayedBuild>
      </ProvidesReference>
    </ItemGroup>
  </Target>
  <!-- This is used by the eng/scripts/AddAllProjectRefsToSolution.ps1 script to traverse the ProjectRef graph -->
  <PropertyGroup>
    <_CustomCollectProjectReferenceDependsOn Condition="'$(TargetFramework)' != ''">ResolveProjectReferences</_CustomCollectProjectReferenceDependsOn>
  </PropertyGroup>
  <Target Name="_CustomCollectProjectReference" DependsOnTargets="$(_CustomCollectProjectReferenceDependsOn)" Returns="$(MSBuildProjectFullPath);@(_MSBuildProjectReferenceExistent)">
    <ItemGroup>
      <_TargetFrameworks Include="$(TargetFrameworks)" />
    </ItemGroup>
    <MSBuild Condition="'$(TargetFramework)' == ''" Targets="_CustomCollectProjectReference" BuildInParallel="true" Projects="$(MSBuildProjectFullPath)" Properties="TargetFramework=%(_TargetFrameworks.Identity)" RebaseOutputs="True">
      <Output TaskParameter="TargetOutputs" ItemName="_MSBuildProjectReferenceExistent" />
    </MSBuild>
    <MSBuild Condition="'$(TargetFramework)' != ''" Targets="_CustomCollectProjectReference" BuildInParallel="true" SkipNonexistentTargets="true" Projects="@(_MSBuildProjectReferenceExistent)" RebaseOutputs="True">
      <Output TaskParameter="TargetOutputs" ItemName="_MSBuildProjectReferenceExistent" />
    </MSBuild>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/eng/targets/CSharp.Common.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/Directory.Build.targets
============================================================================================================================================
-->
  <!--<Import Project="eng\targets\FSharp.Common.targets" Condition="'$(MSBuildProjectExtension)' == '.fsproj'" />-->
  <!--<Import Project="eng\targets\Wix.Common.targets" Condition="'$(MSBuildProjectExtension)' == '.wixproj'" />-->
  <!--<Import Project="eng\targets\Node.Common.targets" Condition="'$(MSBuildProjectExtension)' == '.nodeproj'" />-->
  <!--<Import Project="eng\targets\Java.Common.targets" Condition="'$(MSBuildProjectExtension)' == '.javaproj'" />-->
  <!--<Import Project="eng\targets\Sfx.Common.targets" Condition="'$(MSBuildProjectExtension)' == '.sfxproj'" />-->
  <!--<Import Project="eng\testing\linker\trimmingTests.targets" Condition="'$(IsPublishedAppTestProject)' == 'true'" />-->
  <!--<Import Project="eng\targets\Helix.targets" Condition=" $(IsTestProject) " />-->
  <!--<Import Project="eng\targets\FunctionalTestWithAssets.targets" Condition=" $(IsTestProject) AND $(ContainsFunctionalTestAssets) " />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/src/Components/Directory.Build.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Common.targets
============================================================================================================================================
-->
  <!--<Import Project="$(CustomAfterDirectoryBuildTargets)" Condition="'$(CustomAfterDirectoryBuildTargets)' != ''" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.CSharp.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildToolsPath)\Microsoft.ServiceModel.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.ServiceModel.targets')" />-->
  <Target Name="_SetTargetFrameworkMonikerAttribute" BeforeTargets="GenerateTargetFrameworkMonikerAttribute">
    <PropertyGroup>
      <TargetFrameworkMonikerAssemblyAttributeText Condition="'$(TargetFrameworkMoniker)' != '' and '$(TargetingClr2Framework)' != 'true'">
// &lt;autogenerated /&gt;
using System%3b
using System.Reflection%3b
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute("$(TargetFrameworkMoniker)", FrameworkDisplayName = "$(TargetFrameworkMonikerDisplayName)")]
        </TargetFrameworkMonikerAssemblyAttributeText>
    </PropertyGroup>
  </Target>
  <PropertyGroup>
    <Utf8Output Condition="'$(Utf8Output)' == ''">true</Utf8Output>
    <!-- NoCompilerStandardLib maps to the compiler's /nostdlib option. By default we always
           want that switch to be passed to the compiler so that either we or the user
           provides the references
           NoStdLib on the other hand indicates that the user doesn't want standard references
           so only if NoStdLib isn't set to true, will we provide the standard references
      -->
    <NoCompilerStandardLib Condition=" '$(NoCompilerStandardLib)' == '' ">true</NoCompilerStandardLib>
    <ErrorEndLocation Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(ErrorEndLocation)' == ''">true</ErrorEndLocation>
    <!-- When building inside VS, by default use the same language for compiler messages as VS itself does. -->
    <PreferredUILang Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(PreferredUILang)' == ''">$([System.Globalization.CultureInfo]::CurrentUICulture.Name)</PreferredUILang>
  </PropertyGroup>
  <!-- Add any "automatic" compiler references that need to be resolved when NoCompilerStandardLib is set
         but the user hasn't told us to not include standard references -->
  <ItemGroup Condition=" '$(NoCompilerStandardLib)' == 'true' and '$(NoStdLib)' != 'true' ">
    <!-- Note that unlike VB, C# does not automatically locate System.dll as a "standard library"
           instead the reference is always passed from the project. Also, for mscorlib.dll
           we need to provide the explicit location in order to avoid resolving from, e.g.,
           {CandidateAssemblyFiles}.
      -->
    <_ExplicitReference Include="$(FrameworkPathOverride)\mscorlib.dll" />
  </ItemGroup>
  <!--<Import Project="$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\ProjectServices\Microsoft.DesignTime.targets" Condition="'$(MSBuildRuntimeType)' == 'Full' and exists('$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\ProjectServices\Microsoft.DesignTime.targets')" />-->
  <!--<Import Project="$(CustomAfterMicrosoftCSharpTargets)" Condition="'$(CustomAfterMicrosoftCSharpTargets)' != '' and Exists('$(CustomAfterMicrosoftCSharpTargets)')" />-->
  <!--<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')" />-->
  <!--<Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.Managed.After.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

This file defines common build logic for all managed languaged: C#, VisualBasic, F#
It is imported after the common targets have been imported.

Copyright (C) Microsoft Corporation. All rights reserved.
***********************************************************************************************
-->
  <!-- Define crosstargeting for static graph, so it can identify inner and outer build graph nodes -->
  <PropertyGroup>
    <InnerBuildProperty>TargetFramework</InnerBuildProperty>
    <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
    <AddTransitiveProjectReferencesInStaticGraph Condition="'$(AddTransitiveProjectReferencesInStaticGraph)' == '' and '$(UsingMicrosoftNETSdk)' == 'true' and '$(DisableTransitiveProjectReferences)' != 'true'">true</AddTransitiveProjectReferencesInStaticGraph>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
    <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.
        Detect WPF, and exclude the generated project from static graph isolation constraint checking.
        Escape the item to avoid eager evaluation of the wildcards.
    -->
    <GraphIsolationExemptReference Condition="'$(UseWPF)' == 'true' or '@(Page)' != '' or '@(ApplicationDefinition)' != '' or '@(XamlPage)' != '' or '@(XamlAppDef)' != ''" Include="$([MSBuild]::Escape('$(MSBuildProjectDirectory)\$(MSBuildProjectName)*_wpftmp$(MSBuildProjectExtension)'))" />
  </ItemGroup>
  <!--
      Properties for extension of ProjectReferenceTargets.
      Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
  -->
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' != 'true'">
    <!-- Empty case is for builds which do not import the target files that set BuildProjectReferences -->
    <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
    <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
    <!-- Publish has the same logic as Build for the main reference target except it also takes $(NoBuild) into account. -->
    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' == 'true'">GetTargetPath</_MainReferenceTargetForPublish>
    <_MainReferenceTargetForPublish Condition="'$(NoBuild)' != 'true'">$(_MainReferenceTargetForBuild)</_MainReferenceTargetForPublish>
    <ProjectReferenceTargetsForPublish>GetTargetFrameworks;$(_MainReferenceTargetForPublish);GetNativeManifest;GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
    <!-- When DeployOnBuild=true, the Publish target is hooked to the Build target -->
    <ProjectReferenceTargetsForBuild Condition="'$(DeployOnBuild)' == 'true'">$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForBuild>
    <ProjectReferenceTargetsForRebuild Condition="'$(DeployOnBuild)' == 'true'">$(ProjectReferenceTargetsForRebuild);$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForRebuild>
    <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true' and '$(IsCrossTargetingBuild)' == 'true'">
    <ProjectReferenceTargetsForBuild>.default;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
  </PropertyGroup>
  <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
    <!--
     Note: SkipNonexistentTargets="true" on the following three items means that an outer build node's call to its existent GetTargetFrameworks target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks.
     This is necessary since the P2P protocol cannot express the targets called from the outer build to the inner build.
     -->
    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" Condition="'$(IsCrossTargetingBuild)' != 'true'" />
    <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
    <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
    <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.CSharp.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.CrossTargeting.targets" Condition="'$(IsCrossTargetingBuild)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.Sdk.targets" Condition="'$(IsCrossTargetingBuild)' != 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.targets
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.
Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Common.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- This file is imported by both cross-targeting and inner builds. Set properties that need to be available to both here. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MicrosoftNETBuildTasksDirectoryRoot>$(MSBuildThisFileDirectory)..\tools\</MicrosoftNETBuildTasksDirectoryRoot>
    <MicrosoftNETBuildTasksTFM Condition=" '$(MSBuildRuntimeType)' == 'Core'">net10.0</MicrosoftNETBuildTasksTFM>
    <MicrosoftNETBuildTasksTFM Condition=" '$(MicrosoftNETBuildTasksTFM)' == ''">net472</MicrosoftNETBuildTasksTFM>
    <MicrosoftNETBuildTasksDirectory>$(MicrosoftNETBuildTasksDirectoryRoot)$(MicrosoftNETBuildTasksTFM)\</MicrosoftNETBuildTasksDirectory>
    <MicrosoftNETBuildTasksAssembly>$(MicrosoftNETBuildTasksDirectory)Microsoft.NET.Build.Tasks.dll</MicrosoftNETBuildTasksAssembly>
    <!--
          Hardcoded list of known implicit packages that are added to project from default SDK targets implicitly.
          Should be re-visited when multiple TFM support is added to Dependencies logic.
    -->
    <DefaultImplicitPackages>Microsoft.NETCore.App;NETStandard.Library</DefaultImplicitPackages>
  </PropertyGroup>
  <!--
     Some versions of Microsoft.NET.Test.Sdk.targets change the OutputType after we've set _IsExecutable and
     HasRuntimeOutput default in Microsoft.NET.Sdk.BeforeCommon.targets. Refresh these value here for backwards
     compatibilty with that.
   -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsExecutable Condition="'$(OutputType)' == 'Exe' or '$(OutputType)'=='WinExe'">true</_IsExecutable>
    <HasRuntimeOutput Condition="'$(_UsingDefaultForHasRuntimeOutput)' == 'true'">$(_IsExecutable)</HasRuntimeOutput>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DotnetCliToolTargetFramework)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Maximum supported target framework for DotnetCliProjectTools is .NET Core 2.2 -->
    <DotnetCliToolTargetFramework>netcoreapp2.2</DotnetCliToolTargetFramework>
  </PropertyGroup>
  <PropertyGroup Condition="'$(EnablePreviewFeatures)' == 'true' And '$(IsNetCoreAppTargetingLatestTFM)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <LangVersion>Preview</LangVersion>
  </PropertyGroup>
  <UsingTask TaskName="NETSdkError" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NETSdkWarning" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NETSdkInformation" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="ShowPreviewMessage" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup Condition="'$(RoslynCompilerType)' == 'FrameworkPackage' and '$(OS)' == 'Windows_NT' and '$(MSBuildRuntimeType)' == 'Full'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RoslynTargetsPath>$(NuGetPackageRoot)\microsoft.net.sdk.compilers.toolset\$(NETCoreSdkVersion)</RoslynTargetsPath>
    <RoslynTasksAssembly>$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll</RoslynTasksAssembly>
    <_NeedToDownloadMicrosoftNetSdkCompilersToolsetPackage>true</_NeedToDownloadMicrosoftNetSdkCompilersToolsetPackage>
    <_MicrosoftNetSdkCompilersToolsetPackageRootEmpty Condition="'$(NuGetPackageRoot)' == ''">true</_MicrosoftNetSdkCompilersToolsetPackageRootEmpty>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EnableDynamicLoading Condition="'$(EnableDynamicLoading)' == '' and '$(EnableComHosting)' == 'true'">true</EnableDynamicLoading>
  </PropertyGroup>
  <!--<ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolution.targets" Condition="Exists('$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolution.targets') and ('$(Language)' != 'C++' or '$(_EnablePackageReferencesInVCProjects)' == 'true')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.PackageDependencyResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.PackageDependencyResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    *************************************
    1. INPUT PROPERTIES
    - That configure the PackageDependency targets
    *************************************
    -->
  <!-- General Properties -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectAssetsFile Condition="'$(ProjectAssetsFile)' == ''">$(MSBuildProjectExtensionsPath)/project.assets.json</ProjectAssetsFile>
    <ProjectAssetsFile>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(ProjectAssetsFile)))</ProjectAssetsFile>
    <!-- Note that the assets.cache file has contents that are unique to the current TFM and configuration and therefore cannot
         be stored in a shared directory next to the assets.json file -->
    <ProjectAssetsCacheFile Condition="'$(ProjectAssetsCacheFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).assets.cache</ProjectAssetsCacheFile>
    <ProjectAssetsCacheFile>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(ProjectAssetsCacheFile)))</ProjectAssetsCacheFile>
    <!-- Don't copy local for netstandard projects. -->
    <CopyLocalLockFileAssemblies Condition="'$(CopyLocalLockFileAssemblies)' == '' and&#xA;                                            '$(TargetFrameworkIdentifier)' == '.NETStandard'">false</CopyLocalLockFileAssemblies>
    <!-- Don't copy local for netcoreapp projects before 3.0 or non-exe and non-component projects. -->
    <CopyLocalLockFileAssemblies Condition="'$(CopyLocalLockFileAssemblies)' == '' and&#xA;                                            '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                                            ('$(_TargetFrameworkVersionWithoutV)' &lt; '3.0' or&#xA;                                             ('$(HasRuntimeOutput)' != 'true' and '$(EnableDynamicLoading)' != 'true'))">false</CopyLocalLockFileAssemblies>
    <!-- All other project types should copy local. -->
    <CopyLocalLockFileAssemblies Condition="'$(CopyLocalLockFileAssemblies)' == ''">true</CopyLocalLockFileAssemblies>
    <ContentPreprocessorOutputDirectory Condition="'$(ContentPreprocessorOutputDirectory)' == ''">$(IntermediateOutputPath)NuGet\</ContentPreprocessorOutputDirectory>
    <UseTargetPlatformAsNuGetTargetMoniker Condition="'$(UseTargetPlatformAsNuGetTargetMoniker)' == '' AND '$(TargetFrameworkMoniker)' == '.NETCore,Version=v5.0'">true</UseTargetPlatformAsNuGetTargetMoniker>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == '' AND '$(UseTargetPlatformAsNuGetTargetMoniker)' == 'true'">$(TargetPlatformIdentifier),Version=v$([System.Version]::Parse('$(TargetPlatformMinVersion)').ToString(3))</NuGetTargetMoniker>
    <NuGetTargetMoniker Condition="'$(NuGetTargetMoniker)' == '' AND '$(UseTargetPlatformAsNuGetTargetMoniker)' != 'true'">$(TargetFrameworkMoniker)</NuGetTargetMoniker>
    <EmitAssetsLogMessages Condition="'$(EmitAssetsLogMessages)' == ''">true</EmitAssetsLogMessages>
    <!-- Setting this property to true restores pre-16.7 behaviour of ResolvePackageDependencies to produce
         TargetDefinitions, FileDefinitions and FileDependencies items. -->
    <EmitLegacyAssetsFileItems Condition="'$(EmitLegacyAssetsFileItems)' == ''">false</EmitLegacyAssetsFileItems>
    <!-- A flag that NuGet packages containing multi-targeted analyzers can check to see if the NuGet package needs to do
         its own multi-targeting logic, or if the current SDK targets will pick the assets correctly. -->
    <SupportsRoslynComponentVersioning>true</SupportsRoslynComponentVersioning>
  </PropertyGroup>
  <!-- Target Moniker + RID-->
  <PropertyGroup Condition="'$(_NugetTargetMonikerAndRID)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_NugetTargetMonikerAndRID Condition="'$(RuntimeIdentifier)' == ''">$(NuGetTargetMoniker)</_NugetTargetMonikerAndRID>
    <_NugetTargetMonikerAndRID Condition="'$(RuntimeIdentifier)' != ''">$(NuGetTargetMoniker)/$(RuntimeIdentifier)</_NugetTargetMonikerAndRID>
  </PropertyGroup>
  <!-- Embed all project.assets.json files into the binary log when building with /bl -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EmbedInBinlog Include="$(ProjectAssetsFile)" Condition="$(EmbedProjectAssetsFile) != false AND Exists('$(ProjectAssetsFile)')" />
  </ItemGroup>
  <!--
    *************************************
    2. EXTERNAL PROPERTIES and ITEMS
    - Override or add to external targets
    *************************************
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolveAssemblyReferencesDependsOn>
      $(ResolveAssemblyReferencesDependsOn);
      ResolvePackageDependenciesForBuild;
      _HandlePackageFileConflicts;
    </ResolveAssemblyReferencesDependsOn>
    <PrepareResourcesDependsOn>
      ResolvePackageDependenciesForBuild;
      _HandlePackageFileConflicts;
      $(PrepareResourcesDependsOn)
    </PrepareResourcesDependsOn>
  </PropertyGroup>
  <!-- Common tokens used in preprocessed content files -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PreprocessorValue Include="rootnamespace">
      <Value>$(RootNamespace)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="assemblyname">
      <Value>$(AssemblyName)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="fullpath">
      <Value>$(MSBuildProjectDirectory)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="outputfilename">
      <Value>$(TargetFileName)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="filename">
      <Value>$(MSBuildProjectFile)</Value>
    </PreprocessorValue>
    <PreprocessorValue Include="@(NuGetPreprocessorValue)" Exclude="@(PreprocessorValue)" />
  </ItemGroup>
  <!--
    This will prevent RAR from spending time locating dependencies and related files for assemblies
    that came from packages. PackageReference should already be promoted to a closure of Reference
    items and we are responsible for adding package relates files to CopyLocal items, not RAR. This
    is only configurable as a compat opt-out in case skipping the slow RAR code breaks something.
  -->
  <PropertyGroup Condition="'$(MarkPackageReferencesAsExternallyResolved)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MarkPackageReferencesAsExternallyResolved>true</MarkPackageReferencesAsExternallyResolved>
  </PropertyGroup>
  <!--
    *************************************
    3. BUILD TARGETS
    - Override the Depends-On properties, or the individual targets
    *************************************
    -->
  <!--
    ============================================================
                     ResolvePackageDependenciesForBuild

    Populate items for build. This is triggered before target
    "AssignProjectConfiguration" to ensure ProjectReference items
    are populated before ResolveProjectReferences is run.
    ============================================================
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolvePackageDependenciesForBuildDependsOn>
      ResolveLockFileReferences;
      ResolveLockFileAnalyzers;
      ResolveLockFileCopyLocalFiles;
      ResolveRuntimePackAssets;
      RunProduceContentAssets;
      IncludeTransitiveProjectReferences
    </ResolvePackageDependenciesForBuildDependsOn>
  </PropertyGroup>
  <Target Name="ResolvePackageDependenciesForBuild" Condition=" ('$(DesignTimeBuild)' != 'true' and '$(_CleaningWithoutRebuilding)' != 'true')&#xA;                      Or Exists('$(ProjectAssetsFile)')" BeforeTargets="AssignProjectConfiguration" DependsOnTargets="$(ResolvePackageDependenciesForBuildDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    *************************************
    4. Package Dependency TASK and TARGETS
    - Raise the lock file to MSBuild Items and create derived items
    *************************************
    -->
  <!--
    ============================================================
                     RunResolvePackageDependencies

    Generate Definitions and Dependencies based on ResolvePackageDependencies task
    ============================================================
    -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.ResolvePackageDependencies" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.CheckForTargetInAssetsFile" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.JoinItems" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.ResolvePackageAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!-- The condition on this target causes it to be skipped during design-time builds if
        the restore operation hasn't run yet.  This is to avoid displaying an error in
        the Visual Studio error list when a project is created before NuGet restore has
        run and created the assets file. -->
  <Target Name="RunResolvePackageDependencies" Condition=" '$(DesignTimeBuild)' != 'true' Or Exists('$(ProjectAssetsFile)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Verify that the assets file has a target for the right framework.  Otherwise, if we restored for the
         wrong framework, we'd end up finding no references to pass to the compiler, and we'd get a ton of
         compile errors. -->
    <CheckForTargetInAssetsFile AssetsFilePath="$(ProjectAssetsFile)" TargetFramework="$(TargetFramework)" RuntimeIdentifier="$(RuntimeIdentifier)" Condition=" '$(DesignTimeBuild)' != 'true'" />
    <!-- Included for backwards compatibility when the EmitLegacyAssetsFileItems property is true. -->
    <ResolvePackageDependencies ProjectPath="$(MSBuildProjectFullPath)" ProjectAssetsFile="$(ProjectAssetsFile)" ProjectLanguage="$(Language)" TargetFramework="$(TargetFramework)" ContinueOnError="ErrorAndContinue" Condition="'$(EmitLegacyAssetsFileItems)' == 'true'">
      <Output TaskParameter="PackageDefinitions" ItemName="PackageDefinitions" />
      <Output TaskParameter="PackageDependencies" ItemName="PackageDependencies" />
      <Output TaskParameter="TargetDefinitions" ItemName="TargetDefinitions" />
      <Output TaskParameter="FileDefinitions" ItemName="FileDefinitions" />
      <Output TaskParameter="FileDependencies" ItemName="FileDependencies" />
    </ResolvePackageDependencies>
  </Target>
  <!-- Reads the version of the compiler APIs that are currently being used in order to pick the correct Roslyn components. -->
  <Target Name="_ResolveCompilerVersion" Condition="'$(CompilerApiVersion)' == '' And&#xA;                     ('$(Language)' == 'C#' Or '$(Language)' == 'VB') And&#xA;                     Exists('$(RoslynTasksAssembly)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetAssemblyIdentity AssemblyFiles="$(RoslynTasksAssembly)">
      <Output TaskParameter="Assemblies" ItemName="_CodeAnalysisIdentity" />
    </GetAssemblyIdentity>
    <PropertyGroup>
      <_RoslynApiVersion>$([System.Version]::Parse(%(_CodeAnalysisIdentity.Version)).Major).$([System.Version]::Parse(%(_CodeAnalysisIdentity.Version)).Minor)</_RoslynApiVersion>
      <CompilerApiVersion>roslyn$(_RoslynApiVersion)</CompilerApiVersion>
    </PropertyGroup>
  </Target>
  <Target Name="ResolvePackageAssets" Condition="('$(DesignTimeBuild)' != 'true' Or Exists('$(ProjectAssetsFile)')) And '$(SkipResolvePackageAssets)' != 'true'" DependsOnTargets="ProcessFrameworkReferences;_DefaultMicrosoftNETPlatformLibrary;_ComputePackageReferencePublish;_ResolveCompilerVersion" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                          and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'&#xA;                          and '$(UseAppHostFromAssetsFile)' == ''">
      <!-- For .NET Core 3.0 and higher, we'll get the apphost from an apphost pack (via ProcessFrameworkReferences) -->
      <UseAppHostFromAssetsFile>false</UseAppHostFromAssetsFile>
    </PropertyGroup>
    <PropertyGroup Condition="'$(UseAppHostFromAssetsFile)' == ''">
      <UseAppHostFromAssetsFile>true</UseAppHostFromAssetsFile>
    </PropertyGroup>
    <PropertyGroup Condition="'$(EnsureRuntimePackageDependencies)' == ''&#xA;                          and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                          and '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'&#xA;                          and '$(EnsureNETCoreAppRuntime)' != 'false'">
      <EnsureRuntimePackageDependencies>true</EnsureRuntimePackageDependencies>
    </PropertyGroup>
    <!-- Only copy local runtime target assets if targeting netcoreapp -->
    <PropertyGroup Condition="'$(CopyLocalRuntimeTargetAssets)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">
      <CopyLocalRuntimeTargetAssets>true</CopyLocalRuntimeTargetAssets>
    </PropertyGroup>
    <ItemGroup>
      <_PackAsToolShimRuntimeIdentifiers Condition="@(_PackAsToolShimRuntimeIdentifiers) ==''" Include="$(PackAsToolShimRuntimeIdentifiers)" />
      <!-- Pass these packages into the ResolvePackageAssets task to verify that the restored versions of the packages
           match the expected version -->
      <ExpectedPlatformPackages Include="@(PackageReference)" Condition="'%(Identity)' == 'Microsoft.NETCore.App'" />
      <ExpectedPlatformPackages Include="@(PackageReference)" Condition="'%(Identity)' == 'Microsoft.AspNetCore.App'" />
      <ExpectedPlatformPackages Include="@(PackageReference)" Condition="'%(Identity)' == 'Microsoft.AspNetCore.All'" />
    </ItemGroup>
    <ResolvePackageAssets ProjectAssetsFile="$(ProjectAssetsFile)" ProjectAssetsCacheFile="$(ProjectAssetsCacheFile)" ProjectPath="$(MSBuildProjectFullPath)" ProjectLanguage="$(Language)" CompilerApiVersion="$(CompilerApiVersion)" EmitAssetsLogMessages="$(EmitAssetsLogMessages)" TargetFramework="$(TargetFramework)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" IsSelfContained="$(SelfContained)" MarkPackageReferencesAsExternallyResolved="$(MarkPackageReferencesAsExternallyResolved)" DisablePackageAssetsCache="$(DisablePackageAssetsCache)" DisableFrameworkAssemblies="$(DisableLockFileFrameworks)" CopyLocalRuntimeTargetAssets="$(CopyLocalRuntimeTargetAssets)" DisableTransitiveProjectReferences="$(DisableTransitiveProjectReferences)" DisableTransitiveFrameworkReferences="$(DisableTransitiveFrameworkReferences)" DotNetAppHostExecutableNameWithoutExtension="$(_DotNetAppHostExecutableNameWithoutExtension)" ShimRuntimeIdentifiers="@(_PackAsToolShimRuntimeIdentifiers)" EnsureRuntimePackageDependencies="$(EnsureRuntimePackageDependencies)" VerifyMatchingImplicitPackageVersion="$(VerifyMatchingImplicitPackageVersion)" ExpectedPlatformPackages="@(ExpectedPlatformPackages)" SatelliteResourceLanguages="$(SatelliteResourceLanguages)" DesignTimeBuild="$(DesignTimeBuild)" ContinueOnError="$(ContinueOnError)" PackageReferences="@(PackageReference)" DefaultImplicitPackages="$(DefaultImplicitPackages)">
      <!-- NOTE: items names here are inconsistent because they match prior implementation
          (that was spread across different tasks/targets) for backwards compatibility.  -->
      <Output TaskParameter="Analyzers" ItemName="ResolvedAnalyzers" />
      <Output TaskParameter="ApphostsForShimRuntimeIdentifiers" ItemName="_ApphostsForShimRuntimeIdentifiersResolvePackageAssets" />
      <Output TaskParameter="ContentFilesToPreprocess" ItemName="_ContentFilesToPreprocess" />
      <Output TaskParameter="DebugSymbolsFiles" ItemName="_DebugSymbolsFiles" />
      <Output TaskParameter="ReferenceDocumentationFiles" ItemName="_ReferenceDocumentationFiles" />
      <Output TaskParameter="FrameworkAssemblies" ItemName="ResolvedFrameworkAssemblies" />
      <Output TaskParameter="FrameworkReferences" ItemName="TransitiveFrameworkReference" />
      <Output TaskParameter="NativeLibraries" ItemName="NativeCopyLocalItems" />
      <Output TaskParameter="ResourceAssemblies" ItemName="ResourceCopyLocalItems" />
      <Output TaskParameter="RuntimeAssemblies" ItemName="RuntimeCopyLocalItems" />
      <Output TaskParameter="RuntimeTargets" ItemName="RuntimeTargetsCopyLocalItems" />
      <Output TaskParameter="CompileTimeAssemblies" ItemName="ResolvedCompileFileDefinitions" />
      <Output TaskParameter="TransitiveProjectReferences" ItemName="_TransitiveProjectReferences" />
      <Output TaskParameter="PackageFolders" ItemName="AssetsFilePackageFolder" />
      <Output TaskParameter="PackageDependencies" ItemName="PackageDependencies" />
      <Output TaskParameter="PackageDependenciesDesignTime" ItemName="_PackageDependenciesDesignTime" />
    </ResolvePackageAssets>
    <ItemGroup Condition="'$(CopyDebugSymbolFilesFromPackages)' == 'true'">
      <ReferenceCopyLocalPaths Include="@(_DebugSymbolsFiles)" />
    </ItemGroup>
    <ItemGroup Condition="'$(CopyDocumentationFilesFromPackages)' == 'true'">
      <ReferenceCopyLocalPaths Include="@(_ReferenceDocumentationFiles)" />
    </ItemGroup>
    <ItemGroup Condition="'$(UseAppHostFromAssetsFile)' == 'true'">
      <_NativeRestoredAppHostNETCore Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetAppHostExecutableName)'" />
    </ItemGroup>
    <ItemGroup Condition="'@(_ApphostsForShimRuntimeIdentifiers)' == ''">
      <_ApphostsForShimRuntimeIdentifiers Include="@(_ApphostsForShimRuntimeIdentifiersResolvePackageAssets)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                     ResolvePackageDependenciesDesignTime

    Aggregate the dependencies produced by ResolvePackageDependencies to a form
    that's consumable by an IDE to display package dependencies.
    ============================================================
    -->
  <Target Name="ResolvePackageDependenciesDesignTime" Returns="@(_PackageDependenciesDesignTime)" DependsOnTargets="ResolvePackageAssets;RunResolvePackageDependencies;ResolveAssemblyReferencesDesignTime" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                     CollectSDKReferencesDesignTime

    Aggregates the sdk specified as project items and implicit
    packages references.
    ============================================================
    -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.CollectSDKReferencesDesignTime" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="CollectSDKReferencesDesignTime" Returns="@(_SDKReference)" DependsOnTargets="CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CollectSDKReferencesDesignTime SdkReferences="@(SdkReference)" PackageReferences="@(PackageReference)" DefaultImplicitPackages="$(DefaultImplicitPackages)">
      <Output TaskParameter="SDKReferencesDesignTime" ItemName="_SDKReference" />
    </CollectSDKReferencesDesignTime>
  </Target>
  <!--
    ============================================================
                     CollectResolvedSDKReferencesDesignTime

    Aggregates the sdk specified as project items and implicit
    packages produced by ResolvePackageDependencies.
    ============================================================
    -->
  <Target Name="CollectResolvedSDKReferencesDesignTime" Returns="@(_ResolvedSDKReference)" DependsOnTargets="ResolveSDKReferencesDesignTime;CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CollectSDKReferencesDesignTime SdkReferences="@(ResolvedSdkReference)" PackageReferences="@(PackageReference)" DefaultImplicitPackages="$(DefaultImplicitPackages)">
      <Output TaskParameter="SDKReferencesDesignTime" ItemName="_ResolvedSDKReference" />
    </CollectSDKReferencesDesignTime>
  </Target>
  <!--
    ============================================================
                     RunProduceContentAssets

    Process content assets by handling preprocessing tokens where necessary, and
    produce copy local items, content items grouped by "build action" and file writes
    ============================================================
    -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.ProduceContentAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="RunProduceContentAssets" DependsOnTargets="ResolvePackageAssets" Condition="'@(_ContentFilesToPreprocess)' != '' and '$(_CleaningWithoutRebuilding)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProduceContentAssets ContentFileDependencies="@(_ContentFilesToPreprocess)" ContentPreprocessorValues="@(PreprocessorValue)" ContentPreprocessorOutputDirectory="$(ContentPreprocessorOutputDirectory)" ProduceOnlyPreprocessorFiles="true" ProjectLanguage="$(Language)">
      <Output TaskParameter="CopyLocalItems" ItemName="_ContentCopyLocalItems" />
      <Output TaskParameter="ProcessedContentItems" ItemName="_ProcessedContentItems" />
      <Output TaskParameter="ProcessedContentItems" ItemName="FileWrites" />
    </ProduceContentAssets>
    <!-- The items in _ProcessedContentItems need to go into the appropriately-named item group,
         but the names depend upon the items themselves. Split it apart. -->
    <CreateItem Include="@(_ProcessedContentItems)" Condition="'@(_ProcessedContentItems)' != ''">
      <Output TaskParameter="Include" ItemName="%(_ProcessedContentItems.ProcessedItemType)" />
    </CreateItem>
  </Target>
  <!--
    ============================================================
    Reference Targets: For populating References based on lock file
    - ResolveLockFileReferences
    ============================================================
    -->
  <Target Name="ResolveLockFileReferences" DependsOnTargets="ResolvePackageAssets" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(MarkPackageReferencesAsExternallyResolved)' == 'true'">
      <!--
        Update Reference items with NuGetPackageId metadata to set ExternallyResolved appropriately.
        NetStandard.Library adds its assets in targets this way and not in the standard way that
        would get ExternallyResolved set in ResolvePackageAssets.
       -->
      <Reference Condition="'%(Reference.NuGetPackageId)' != ''">
        <ExternallyResolved>true</ExternallyResolved>
      </Reference>
      <!-- Add framework references from NuGet packages here, so that if there is also a matching reference from a NuGet package,
           it will be treated the same as a reference from the project file.  If there is already an explicit Reference from the
           project, use that, in order to preserve metadata (such as aliases). -->
      <Reference Include="@(ResolvedFrameworkAssemblies)" Exclude="@(Reference)" />
    </ItemGroup>
    <!-- If there are any references from a NuGet package that match a simple reference which
         would resolve to a framework assembly, then update the NuGet references to use the
         simple name as the ItemSpec.  This will prevent the VS project system from marking
         a reference with a warning.  See https://github.com/dotnet/sdk/issues/1499 -->
    <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="FileName" LeftMetadata="*" Right="@(Reference)" RightKey="" RightMetadata="*">
      <Output TaskParameter="JoinResult" ItemName="_JoinedResolvedCompileFileDefinitions" />
    </JoinItems>
    <ItemGroup>
      <Reference Remove="@(_JoinedResolvedCompileFileDefinitions)" />
      <Reference Include="@(_JoinedResolvedCompileFileDefinitions)" />
    </ItemGroup>
    <ItemGroup>
      <ResolvedCompileFileDefinitionsToAdd Include="@(ResolvedCompileFileDefinitions)" />
      <ResolvedCompileFileDefinitionsToAdd Remove="%(_JoinedResolvedCompileFileDefinitions.HintPath)" />
      <!-- Add the references we computed -->
      <Reference Include="@(ResolvedCompileFileDefinitionsToAdd)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    ProjectReference Targets: Include transitive project references before
                              ResolveProjectReferences is called
    - IncludeTransitiveProjectReferences
    ============================================================
    -->
  <Target Name="IncludeTransitiveProjectReferences" DependsOnTargets="ResolvePackageAssets" Condition="'$(DisableTransitiveProjectReferences)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <ProjectReference Include="@(_TransitiveProjectReferences)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Analyzer Targets: For populating Analyzers based on lock file
    - ResolveLockFileAnalyzers
    ============================================================
    -->
  <Target Name="ResolveLockFileAnalyzers" DependsOnTargets="ResolvePackageAssets" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <Analyzer Include="@(ResolvedAnalyzers)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    ResolveLockFileCopyLocalFiles
    Resolves the files from the assets file to copy for build and publish.
    ============================================================
  -->
  <Target Name="ResolveLockFileCopyLocalFiles" DependsOnTargets="ResolvePackageAssets;RunProduceContentAssets" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ResolvedCopyLocalBuildAssets Include="@(RuntimeCopyLocalItems)" Condition="'%(RuntimeCopyLocalItems.CopyLocal)' == 'true'" />
      <_ResolvedCopyLocalBuildAssets Include="@(ResourceCopyLocalItems)" Condition="'%(ResourceCopyLocalItems.CopyLocal)' == 'true'" />
      <!-- Always exclude the apphost executable from copy local assets; we will copy the generated apphost instead. -->
      <_ResolvedCopyLocalBuildAssets Include="@(NativeCopyLocalItems)" Exclude="@(_NativeRestoredAppHostNETCore)" Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
      <_ResolvedCopyLocalBuildAssets Include="@(RuntimeTargetsCopyLocalItems)" Condition="'%(RuntimeTargetsCopyLocalItems.CopyLocal)' == 'true'" />
      <ReferenceCopyLocalPaths Include="@(_ContentCopyLocalItems)" />
      <ReferenceCopyLocalPaths Include="@(_ResolvedCopyLocalBuildAssets)" Condition="'$(CopyLocalLockFileAssemblies)' == 'true'" />
    </ItemGroup>
  </Target>
  <!-- Override EnsureNETCoreAppRuntime target which is included in Microsoft.NETCore.App NuGet package for
       .NET Core 2.x.  It no longer works with the .NET 5.0.100 SDK, as the ParentTarget metadata has changed format
       but the targets in the NuGet package still expect the old format.

       So here we just override that target.  We have logic in the SDK that covers this scenario and generates
       NETSDK1056. -->
  <Target Name="EnsureNETCoreAppRuntime" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolutionStubs.targets" Condition="Exists('$(MSBuildThisFileDirectory)Microsoft.PackageDependencyResolutionStubs.targets') and ('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')" />-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.DefaultItems.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.DefaultItems.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Don't get the default item globs by default when the flag is not set. -->
  <PropertyGroup Condition="'$(UsingNETSdkDefaults)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EnableDefaultItems Condition=" '$(EnableDefaultItems)' == '' ">true</EnableDefaultItems>
    <EnableDefaultCompileItems Condition=" '$(EnableDefaultCompileItems)' == '' ">true</EnableDefaultCompileItems>
    <EnableDefaultEmbeddedResourceItems Condition=" '$(EnableDefaultEmbeddedResourceItems)' == '' ">true</EnableDefaultEmbeddedResourceItems>
    <EnableDefaultNoneItems Condition=" '$(EnableDefaultNoneItems)' == '' ">true</EnableDefaultNoneItems>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set DefaultItemExcludes property for items that should be excluded from the default Compile, etc items.
         This is in the .targets because it needs to come after the final BaseOutputPath has been evaluated. -->
    <!-- bin folder, by default -->
    <DefaultItemExcludes>$(DefaultItemExcludes);$(BaseOutputPath)/**</DefaultItemExcludes>
    <!-- obj folder, by default -->
    <DefaultItemExcludes>$(DefaultItemExcludes);$(BaseIntermediateOutputPath)/**</DefaultItemExcludes>
    <!-- Various files that should generally always be ignored -->
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.user</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.*proj</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.sln</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.slnx</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/*.vssscc</DefaultItemExcludes>
    <DefaultItemExcludes>$(DefaultItemExcludes);**/.DS_Store</DefaultItemExcludes>
    <!-- WARNING: This pattern is there to ignore folders such as .git and .vs, but it will also match items included with a
         relative path outside the project folder (for example "..\Shared\Shared.cs").  So be sure only to apply it to items
         that are in the project folder. Support both DefaultItemExcludesInProjectFolder and DefaultExcludesInProjectFolder
         properties because of a naming mistake. -->
    <DefaultExcludesInProjectFolder>$(DefaultExcludesInProjectFolder);$(DefaultItemExcludesInProjectFolder);**/.*/**</DefaultExcludesInProjectFolder>
  </PropertyGroup>
  <!-- Set the default versions of the NETStandard.Library or Microsoft.NETCore.App packages to reference.
       The implicit package references themselves are defined in Microsoft.NET.Sdk.props, so that they can be overridden
       in the project file. -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' And '$(_TargetFrameworkVersionWithoutV)' &lt; '2.1'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- If targeting .NET Standard 1.x, use version 1.6.1 of the package.  This is so that when projects are packed, the dependency on the package produced won't change when
         updating to the 2.0 or higher SDK.  When targeting .NET Standard 2.0 or higher, the NETStandard.Library reference won't show up as a dependency of the package
         produced, so we will roll forward to the latest version. -->
    <NETStandardImplicitPackageVersion Condition="'$(NETStandardImplicitPackageVersion)' =='' And '$(_TargetFrameworkVersionWithoutV)' &lt; '2.0'">1.6.1</NETStandardImplicitPackageVersion>
    <!-- Default to use the latest stable 2.0.x release. -->
    <NETStandardImplicitPackageVersion Condition="'$(NETStandardImplicitPackageVersion)' ==''">2.0.3</NETStandardImplicitPackageVersion>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.DefaultItems.Shared.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.Shared.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.DefaultItems.Shared.targets:  Properties and targets pulled from Microsoft.NET.Sdk.DefaultItems.targets
                                                to be shared by the WAP project system


WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Determine the version (including patch) of .NET Core to target.

    When targeting .NET Core, the TargetFramework is used to specify the major and minor version of the runtime to use.  By default,
    the patch version is inferred.  The general logic is that self-contained apps will target the latest patch that the SDK
    knows about, while framework-dependent apps will target the ".0" patch (and roll forward to the latest patch installed at
    runtime).

    When targeting .NET Core 1.0 and 1.1, framework-dependent apps use 1.0.5 and 1.1.2, respectively.  This is done for compatibility
    with previous releases that bumped the self-contained and framework-dependent versions together.

    The TargetLatestRuntimePatch property can be set to true or false to explicitly opt in or out of the logic to roll forward
    to the latest patch, regardless of whether the app is self-contained or framework-dependent.

    The RuntimeFrameworkVersion is where the actual version of the .NET Core runtime to target can be set.  If set, it will be
    used in the implicit PackageReference to Microsoft.NETCore.App.

    The framework version that is written to the runtimeconfig.json file is based on the actual resolved package version
    of Microsoft.NETCore.App.  This is to allow floating the verion number (ie the RuntimeFrameworkVersion could be set to
    "2.0-*".

  -->
  <PropertyGroup Condition="'$(TargetLatestRuntimePatch)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetLatestRuntimePatch Condition="'$(SelfContained)' == 'true' ">true</TargetLatestRuntimePatch>
    <TargetLatestRuntimePatch Condition="'$(SelfContained)' != 'true' ">false</TargetLatestRuntimePatch>
    <_TargetLatestRuntimePatchIsDefault>true</_TargetLatestRuntimePatchIsDefault>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(DisableImplicitFrameworkReferences)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <VerifyMatchingImplicitPackageVersion Condition="'$(VerifyMatchingImplicitPackageVersion)' == ''">true</VerifyMatchingImplicitPackageVersion>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set implicit metadata on ASP.NET package references -->
    <PackageReference Update="Microsoft.AspNetCore.App">
      <PrivateAssets Condition="'%(PackageReference.Version)' == ''">all</PrivateAssets>
      <Publish Condition="'%(PackageReference.Version)' == ''">true</Publish>
    </PackageReference>
    <PackageReference Update="Microsoft.AspNetCore.All">
      <PrivateAssets Condition="'%(PackageReference.Version)' == ''">all</PrivateAssets>
      <Publish Condition="'%(PackageReference.Version)' == ''">true</Publish>
    </PackageReference>
    <!-- Allow RuntimeFrameworkVersion to be used to explicitly specify the version of Microsoft.NETCore.App -->
    <PackageReference Update="Microsoft.NETCore.App" Version="$(RuntimeFrameworkVersion)" Condition="'$(RuntimeFrameworkVersion)' != ''" AllowExplicitVersion="true" />
    <!-- If implicit PackageReferences are disabled, then don't warn about explicit versions at all -->
    <PackageReference Update="@(PackageReference)" Condition="'$(DisableImplicitFrameworkReferences)' == 'true'" AllowExplicitVersion="true" />
  </ItemGroup>
  <UsingTask TaskName="ApplyImplicitVersions" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="CheckIfPackageReferenceShouldBeFrameworkReference" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="UpdateAspNetToFrameworkReference" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CheckIfPackageReferenceShouldBeFrameworkReference PackageReferences="@(PackageReference)" FrameworkReferences="@(FrameworkReference)" PackageReferenceToReplace="Microsoft.AspNetCore.All" FrameworkReferenceToUse="Microsoft.AspNetCore.App">
      <Output TaskParameter="ShouldRemovePackageReference" PropertyName="_ShouldRemoveAspNetCoreAll" />
    </CheckIfPackageReferenceShouldBeFrameworkReference>
    <!-- NETSDK1079: The Microsoft.AspNetCore.All package is not supported when targeting .NET Core 3.0 or higher.
         A FrameworkReference to Microsoft.AspNetCore.App should be used instead, and will be implicitly included by Microsoft.NET.Sdk.Web. -->
    <NETSdkError Condition="'$(_ShouldRemoveAspNetCoreAll)' == 'true'" ResourceName="AspNetCoreAllNotSupported" />
    <CheckIfPackageReferenceShouldBeFrameworkReference PackageReferences="@(PackageReference)" FrameworkReferences="@(FrameworkReference)" PackageReferenceToReplace="Microsoft.AspNetCore.App" FrameworkReferenceToUse="Microsoft.AspNetCore.App">
      <Output TaskParameter="ShouldRemovePackageReference" PropertyName="_ShouldRemoveAspNetCoreApp" />
      <Output TaskParameter="ShouldAddFrameworkReference" PropertyName="_ShouldAddAspNetCoreAppFrameworkReference" />
    </CheckIfPackageReferenceShouldBeFrameworkReference>
    <ItemGroup>
      <PackageReference Remove="Microsoft.AspNetCore.App" Condition="'$(_ShouldRemoveAspNetCoreApp)' == 'true'" />
      <FrameworkReference Include="Microsoft.AspNetCore.App" Condition="'$(_ShouldAddAspNetCoreAppFrameworkReference)' == 'true'" />
    </ItemGroup>
    <!-- NETSDK1080: A PackageReference to Microsoft.AspNetCore.App is not necessary when targeting .NET Core 3.0 or higher.
         If Microsoft.NET.Sdk.Web is used, the shared framework will be referenced automatically. Otherwise, the PackageReference
         should be replaced with a FrameworkReference. -->
    <NETSdkWarning Condition="'$(_ShouldRemoveAspNetCoreApp)' == 'true'" ResourceName="AspNetCoreUsesFrameworkReference" />
  </Target>
  <Target Name="ApplyImplicitVersions" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences;ProcessFrameworkReferences" DependsOnTargets="UpdateAspNetToFrameworkReference;CheckForImplicitPackageReferenceOverrides" Condition="'@(PackageReference)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ApplyImplicitVersions TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" TargetLatestRuntimePatch="$(TargetLatestRuntimePatch)" PackageReferences="@(PackageReference)" ImplicitPackageReferenceVersions="@(ImplicitPackageReferenceVersion)">
      <Output TaskParameter="PackageReferencesToUpdate" ItemName="PackageReferenceToUpdate" />
      <Output TaskParameter="SdkBuildWarnings" ItemName="SdkBuildWarning" />
    </ApplyImplicitVersions>
    <ItemGroup>
      <PackageReference Remove="@(PackageReferenceToUpdate)" />
      <PackageReference Include="@(PackageReferenceToUpdate)" />
    </ItemGroup>
    <ItemGroup>
      <!-- Support using a patch version in the TargetFramework, ie netcoreapp1.1.1
           Note that this isn't officially supported, but it worked in the past so
           this should prevent breaking it. -->
      <PackageReference Condition="'%(PackageReference.Identity)' == 'Microsoft.NETCore.App'">
        <Version Condition="'%(PackageReference.Version)' == ''">$(_TargetFrameworkVersionWithoutV)</Version>
      </PackageReference>
    </ItemGroup>
  </Target>
  <UsingTask TaskName="CheckForImplicitPackageReferenceOverrides" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!-- Remove package references with metadata IsImplicitlyDefined = true, if there are other PackageReference items with the same identity -->
  <Target Name="CheckForImplicitPackageReferenceOverrides" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <ImplicitPackageReferenceInformationLink>https://aka.ms/sdkimplicitrefs</ImplicitPackageReferenceInformationLink>
    </PropertyGroup>
    <CheckForImplicitPackageReferenceOverrides PackageReferenceItems="@(PackageReference)" MoreInformationLink="$(ImplicitPackageReferenceInformationLink)">
      <Output TaskParameter="ItemsToRemove" ItemName="_PackageReferenceToRemove" />
      <Output TaskParameter="ItemsToAdd" ItemName="_PackageReferenceToAdd" />
    </CheckForImplicitPackageReferenceOverrides>
    <ItemGroup>
      <!-- Remove and add the PackageReference items according to the output from the task -->
      <PackageReference Remove="@(_PackageReferenceToRemove)" />
      <PackageReference Include="@(_PackageReferenceToAdd)" />
      <!-- Clear items for other targets to use -->
      <_PackageReferenceToAdd Remove="@(_PackageReferenceToAdd)" />
    </ItemGroup>
    <!-- If any implicit package references were overridden, then don't check that RuntimeFrameworkVersion matches the package version -->
    <PropertyGroup Condition="'@(_PackageReferenceToRemove)' != ''">
      <VerifyMatchingImplicitPackageVersion>false</VerifyMatchingImplicitPackageVersion>
    </PropertyGroup>
  </Target>
  <UsingTask TaskName="CheckForDuplicateItems" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="CheckForDuplicateItems" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <DefaultItemsMoreInformationLink>https://aka.ms/sdkimplicititems</DefaultItemsMoreInformationLink>
    </PropertyGroup>
    <!-- NOTE for design-time builds we continue on errors and remove the duplicate items.
         This is because otherwise there won't be any references to pass to the compiler, leading to design-time
         compilation errors for every API that is used in the project.  Amidst all the compile errors, it would
         be easy to miss the duplicate items error which is the real source of the problem. -->
    <CheckForDuplicateItems Items="@(Compile)" ItemName="Compile" DefaultItemsEnabled="$(EnableDefaultItems)" DefaultItemsOfThisTypeEnabled="$(EnableDefaultCompileItems)" PropertyNameToDisableDefaultItems="EnableDefaultCompileItems" MoreInformationLink="$(DefaultItemsMoreInformationLink)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedCompileItems" />
    </CheckForDuplicateItems>
    <CheckForDuplicateItems Items="@(EmbeddedResource)" ItemName="EmbeddedResource" DefaultItemsEnabled="$(EnableDefaultItems)" DefaultItemsOfThisTypeEnabled="$(EnableDefaultEmbeddedResourceItems)" PropertyNameToDisableDefaultItems="EnableDefaultEmbeddedResourceItems" MoreInformationLink="$(DefaultItemsMoreInformationLink)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedEmbeddedResourceItems" />
    </CheckForDuplicateItems>
    <!-- Default content items are enabled by the Web SDK, not the .NET SDK, but we check it here for simplicity -->
    <CheckForDuplicateItems Items="@(Content)" ItemName="Content" DefaultItemsEnabled="$(EnableDefaultItems)" DefaultItemsOfThisTypeEnabled="$(EnableDefaultContentItems)" PropertyNameToDisableDefaultItems="EnableDefaultContentItems" MoreInformationLink="$(DefaultItemsMoreInformationLink)" ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="DeduplicatedItems" ItemName="DeduplicatedContentItems" />
    </CheckForDuplicateItems>
    <ItemGroup Condition="'$(DesignTimeBuild)' == 'true' And '@(DeduplicatedCompileItems)' != ''">
      <Compile Remove="@(Compile)" />
      <Compile Include="@(DeduplicatedCompileItems)" />
    </ItemGroup>
    <ItemGroup Condition="'$(DesignTimeBuild)' == 'true' And '@(DeduplicatedEmbeddedResourceItems)' != ''">
      <EmbeddedResource Remove="@(EmbeddedResource)" />
      <EmbeddedResource Include="@(DeduplicatedEmbeddedResourceItems)" />
    </ItemGroup>
    <ItemGroup Condition="'$(DesignTimeBuild)' == 'true' And '@(DeduplicatedContentItems)' != ''">
      <Content Remove="@(Content)" />
      <Content Include="@(DeduplicatedContentItems)" />
    </ItemGroup>
  </Target>
  <Target Name="_CheckForTransitiveWindowsDesktopDependencies" AfterTargets="ResolvePackageAssets" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0')) and '$(TargetPlatformIdentifier)' != 'Windows' and '@(TransitiveFrameworkReference)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_WindowsDesktopTransitiveFrameworkReference Include="@(TransitiveFrameworkReference)" Condition="'%(Identity)' == 'Microsoft.WindowsDesktop.App' Or&#xA;                                                              '%(Identity)' == 'Microsoft.WindowsDesktop.App.WPF' Or&#xA;                                                              '%(Identity)' == 'Microsoft.WindowsDesktop.App.WindowsForms'" />
    </ItemGroup>
    <NetSdkError Condition="'@(_WindowsDesktopTransitiveFrameworkReference)' != ''" ResourceName="WindowsDesktopTargetPlatformMustBeWindows" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.DefaultItems.targets
============================================================================================================================================
-->
  <!-- This target runs before build but not before restore, to avoid duplicating these warnings
       if building with an implicit restore. -->
  <Target Name="WarnForExplicitVersions" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" DependsOnTargets="ApplyImplicitVersions" Condition="'@(SdkBuildWarning)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NetSdkWarning FormattedText="%(SdkBuildWarning.Identity)" />
  </Target>
  <!--
    Automatically add Link metadata to items of specific types if they are outside of the project folder and don't already have the Link metadata set.
    This will cause them to be shown in the Solution Explorer.  If an item has LinkBase metadata, the automatic Link will start with that value, and
    the items will appear in the Solution Explorer under the folder specified by LinkBase.
    -->
  <ItemGroup Condition="'$(SetLinkMetadataAutomatically)' != 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Compile Update="@(Compile)">
      <!-- First, add a trailing slash to the LinkBase metadata if necessary.  This allows us to use the same value
           for the Link metadata whether or not LinkBase metadata is set: %(LinkBase)%(RecursiveDir)%(Filename)%(Extension)

           Note that RecursiveDir already includes the trailing slash.
      -->
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <!-- Set the Link metadata if it's not already set, if the item wasn't defined in a shared project,  and the item is outside of the project directory.
           Check whether the item was defined in a shared project by checking whether the extension of the defining project was .projitems.
           Check whether an item is inside the project directory by seeing if the FullPath starts with EnsureTrailingSlash(MSBuildProjectDirectory)
           The FullPath and the MSBuildProjectDirectory will both already be normalized full paths.
           The call to [MSBuild]::ValueOrDefault() is there in order to allow calling StartsWith on the FullPath value, since it's
           not possible to call a string method on a metadata item directly.  The intrinsic ValueOrDefault() will be more
           performant than calling String.Copy(), which has been used for this in other contexts, but actually makes a copy
           of the string data.
      -->
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Compile>
    <AdditionalFiles Update="@(AdditionalFiles)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </AdditionalFiles>
    <None Update="@(None)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </None>
    <Content Update="@(Content)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Content>
    <EmbeddedResource Update="@(EmbeddedResource)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </EmbeddedResource>
    <Page Update="@(Page)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Page>
    <Resource Update="@(Resource)">
      <LinkBase Condition="'%(LinkBase)' != ''">$([MSBuild]::EnsureTrailingSlash(%(LinkBase)))</LinkBase>
      <Link Condition="'%(Link)' == '' And '%(DefiningProjectExtension)' != '.projitems' And !$([MSBuild]::ValueOrDefault('%(FullPath)', '').StartsWith($([MSBuild]::EnsureTrailingSlash($(MSBuildProjectDirectory)))))">%(LinkBase)%(RecursiveDir)%(Filename)%(Extension)</Link>
    </Resource>
  </ItemGroup>
  <Target Name="_CheckForFailedSDKResolution" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(SdkResolverHonoredGlobalJson)' == 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NetSdkError ResourceName="GlobalJsonSDKResolutionFailed" FormatArguments="$(SdkResolverGlobalJsonPath)" />
  </Target>
  <Target Name="_WarnWhenUsingNET9AndVSPriorTo1712" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="$([MSBuild]::VersionLessThan($(MSBuildVersion), '17.12.0')) and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '9.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NetSdkWarning ResourceName="Net9NotCompatibleWithDev1711" />
  </Target>
  <Target Name="_CheckForInvalidWindowsDesktopTargetingConfiguration" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0')) and ('$(UseWindowsForms)' == 'true' or '$(UseWPF)' == 'true')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(TargetPlatformIdentifier)' != 'Windows'" ResourceName="WindowsDesktopTargetPlatformMustBeWindows" />
  </Target>
  <Target Name="_CheckForUnnecessaryWindowsDesktopSDK" BeforeTargets="_CheckForInvalidConfigurationAndPlatform" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0')) and '$(_MicrosoftWindowsDesktopSdkImported)' == 'true' and '$(TargetFrameworks)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning ResourceName="UnnecessaryWindowsDesktopSDK" />
  </Target>
  <!-- Default the value of PublishRelease for 8.0+ TFMs. Note that this is pre-evaluated by the CLI in an evaluation before evaluation (see ReleasePropertyProjectLocator.cs).-->
  <PropertyGroup Condition="'$(PublishRelease)' == '' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '8.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishRelease>true</PublishRelease>
  </PropertyGroup>
  <!-- This verifies that the configuration between projects in a solution set by PackRelease agree.
  PackRelease only affects the CLI since VS has its own Configuration UI and it's not possible to detect like this in MSBuild.
  _IsPacking will only be set if packing in the CLI, so that's fine here. The pack targets are all outside of the SDK, which is why this is here.-->
  <Target Name="_VerifyPackReleaseConfigurations" BeforeTargets="PrepareForBuild" Condition="'$(_IsPacking)' == 'true' and '$(DOTNET_CLI_DISABLE_PUBLISH_AND_PACK_RELEASE)' != 'true' and '$(DOTNET_CLI_LAZY_PUBLISH_AND_PACK_RELEASE_FOR_SOLUTIONS)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(SolutionExt)' == '.sln' and&#xA;                            '$(_SolutionLevelPackRelease)' != '$(PackRelease)'" ResourceName="SolutionProjectConfigurationsConflict" FormatArguments="PackRelease;$(ProjectName)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.FrameworkReferenceResolution.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.FrameworkReferenceResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.FrameworkReferenceResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <ResolveAssemblyReferencesDependsOn>
      $(ResolveAssemblyReferencesDependsOn);
      ResolveTargetingPackAssets;
    </ResolveAssemblyReferencesDependsOn>
  </PropertyGroup>
  <UsingTask TaskName="CreateWindowsSdkKnownFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="GetPackagesToPrune" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="CheckForDuplicateFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ProcessFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveAppHosts" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!-- Don't add Windows SDK framework reference for C++ by default, as C++ doesn't use it and it would be an unnecessary download for possible
       transitive framework references. -->
  <Target Name="AddWindowsSdkKnownFrameworkReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(TargetPlatformIdentifier)' == 'Windows'&#xA;                     And ('$(Language)' != 'C++' Or '$(IncludeWindowsSDKRefFrameworkReferences)' == 'true')">
    <!-- Remove Windows SDK KnownFrameworkReference items from BundledVersions.props (they will eventually be removed, but that is in a different repo so
         we can't do the change atomically). -->
    <ItemGroup>
      <KnownFrameworkReference Remove="Microsoft.Windows.SDK.NET.Ref" />
    </ItemGroup>
    <!-- Generate KnownFrameworkReference items for the Windows SDK pack -->
    <CreateWindowsSdkKnownFrameworkReferences UseWindowsSDKPreview="$(UseWindowsSDKPreview)" WindowsSdkPackageVersion="$(WindowsSdkPackageVersion)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" WindowsSdkSupportedTargetPlatformVersions="@(WindowsSdkSupportedTargetPlatformVersion)">
      <Output TaskParameter="KnownFrameworkReferences" ItemName="KnownFrameworkReference" />
    </CreateWindowsSdkKnownFrameworkReferences>
  </Target>
  <Target Name="AddPrunePackageReferences" BeforeTargets="CollectPrunePackageReferences" DependsOnTargets="ProcessFrameworkReferences" Condition="'$(RestoreEnablePackagePruning)' == 'true'">
    <PropertyGroup>
      <PrunePackageDataRoot Condition="'$(PrunePackageDataRoot)' == ''">$(NetCoreRoot)\sdk\$(NETCoreSdkVersion)\PrunePackageData\</PrunePackageDataRoot>
      <PrunePackageTargetingPackRoots Condition="'$(PrunePackageTargetingPackRoots)' == ''">$(NetCoreTargetingPackRoot)</PrunePackageTargetingPackRoots>
      <AllowMissingPrunePackageData Condition="'$(AllowMissingPrunePackageData)' == ''">false</AllowMissingPrunePackageData>
    </PropertyGroup>
    <GetPackagesToPrune TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" FrameworkReferences="@(FrameworkReference)" TargetingPacks="@(TargetingPack)" TargetingPackRoots="$(PrunePackageTargetingPackRoots)" PrunePackageDataRoot="$(PrunePackageDataRoot)" AllowMissingPrunePackageData="$(AllowMissingPrunePackageData)">
      <Output TaskParameter="PackagesToPrune" ItemName="PrunePackageReference" />
    </GetPackagesToPrune>
  </Target>
  <!--
    ============================================================
                                        ProcessFrameworkReferences

    Matches FrameworkReference items with KnownFrameworkReference items to determine the corresponding
    targeting pack and if necessary the runtime pack.  If the packs aren't available in the NetCoreTargetingPackRoot
    folder, then generate PackageDownload items in order to download the packs during restore.

    Also resolves app host packs in a similar fashion, and checks for duplicate FrameworkReference items.
    ============================================================
    -->
  <Target Name="ProcessFrameworkReferences" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences;CollectPackageDownloads" DependsOnTargets="AddWindowsSdkKnownFrameworkReferences" Condition="'@(FrameworkReference)' != '' Or '$(_RequiresILLinkPack)' == 'true'">
    <CheckForDuplicateFrameworkReferences FrameworkReferences="@(FrameworkReference)" MoreInformationLink="https://aka.ms/sdkimplicitrefs">
      <Output TaskParameter="ItemsToRemove" ItemName="_FrameworkReferenceToRemove" />
      <Output TaskParameter="ItemsToAdd" ItemName="_FrameworkReferenceToAdd" />
    </CheckForDuplicateFrameworkReferences>
    <ItemGroup>
      <FrameworkReference Remove="@(_FrameworkReferenceToRemove)" />
      <FrameworkReference Include="@(_FrameworkReferenceToAdd)" />
    </ItemGroup>
    <PropertyGroup>
      <EnableTargetingPackDownload Condition="'$(EnableTargetingPackDownload)' == ''">true</EnableTargetingPackDownload>
      <EnableRuntimePackDownload Condition="'$(EnableRuntimePackDownload)' == ''">true</EnableRuntimePackDownload>
      <RequiresAspNetWebAssets Condition="'$(RequiresAspNetWebAssets)' == ''">false</RequiresAspNetWebAssets>
    </PropertyGroup>
    <PropertyGroup>
      <_NuGetRestoreSupported Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')">false</_NuGetRestoreSupported>
    </PropertyGroup>
    <ItemGroup>
      <_PackAsToolShimRuntimeIdentifiers Condition="@(_PackAsToolShimRuntimeIdentifiers) ==''" Include="$(PackAsToolShimRuntimeIdentifiers)" />
    </ItemGroup>
    <ProcessFrameworkReferences FrameworkReferences="@(FrameworkReference)" KnownFrameworkReferences="@(KnownFrameworkReference)" KnownRuntimePacks="@(KnownRuntimePack)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetingPackRoot="$(NetCoreTargetingPackRoot)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" SelfContained="$(SelfContained)" ReadyToRunEnabled="$(PublishReadyToRun)" ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)" PublishAot="$(PublishAot)" RequiresILLinkPack="$(_RequiresILLinkPack)" IsAotCompatible="$(IsAotCompatible)" SilenceIsAotCompatibleUnsupportedWarning="$(_SilenceIsAotCompatibleUnsupportedWarning)" MinNonEolTargetFrameworkForAot="$(_MinNonEolTargetFrameworkForAot)" EnableAotAnalyzer="$(EnableAotAnalyzer)" FirstTargetFrameworkVersionToSupportAotAnalyzer="$(_FirstTargetFrameworkVersionToSupportAotAnalyzer)" PublishTrimmed="$(PublishTrimmed)" IsTrimmable="$(IsTrimmable)" FirstTargetFrameworkVersionToSupportTrimAnalyzer="$(_FirstTargetFrameworkVersionToSupportTrimAnalyzer)" SilenceIsTrimmableUnsupportedWarning="$(_SilenceIsTrimmableUnsupportedWarning)" MinNonEolTargetFrameworkForTrimming="$(_MinNonEolTargetFrameworkForTrimming)" EnableTrimAnalyzer="$(EnableTrimAnalyzer)" EnableSingleFileAnalyzer="$(EnableSingleFileAnalyzer)" FirstTargetFrameworkVersionToSupportSingleFileAnalyzer="$(_FirstTargetFrameworkVersionToSupportSingleFileAnalyzer)" SilenceEnableSingleFileAnalyzerUnsupportedWarning="$(_SilenceEnableSingleFileAnalyzerUnsupportedWarning)" MinNonEolTargetFrameworkForSingleFile="$(_MinNonEolTargetFrameworkForSingleFile)" AotUseKnownRuntimePackForTarget="$(PublishAotUsingRuntimePack)" RuntimeIdentifier="$(RuntimeIdentifier)" RuntimeIdentifiers="$(RuntimeIdentifiers)" RuntimeFrameworkVersion="$(RuntimeFrameworkVersion)" TargetLatestRuntimePatch="$(TargetLatestRuntimePatch)" TargetLatestRuntimePatchIsDefault="$(_TargetLatestRuntimePatchIsDefault)" EnableTargetingPackDownload="$(EnableTargetingPackDownload)" EnableRuntimePackDownload="$(EnableRuntimePackDownload)" EnableWindowsTargeting="$(EnableWindowsTargeting)" DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)" KnownCrossgen2Packs="@(KnownCrossgen2Pack)" KnownILCompilerPacks="@(KnownILCompilerPack)" KnownILLinkPacks="@(KnownILLinkPack)" KnownWebAssemblySdkPacks="@(KnownWebAssemblySdkPack)" KnownAspNetCorePacks="@(KnownAspNetCorePack)" UsingMicrosoftNETSdkWebAssembly="$(UsingMicrosoftNETSdkWebAssembly)" RequiresAspNetWebAssets="$(RequiresAspNetWebAssets)" NETCoreSdkRuntimeIdentifier="$(NETCoreSdkRuntimeIdentifier)" NETCoreSdkPortableRuntimeIdentifier="$(NETCoreSdkPortableRuntimeIdentifier)" NetCoreRoot="$(NetCoreRoot)" NETCoreSdkVersion="$(NETCoreSdkVersion)">
      <Output TaskParameter="PackagesToDownload" ItemName="_PackageToDownload" />
      <Output TaskParameter="RuntimeFrameworks" ItemName="RuntimeFramework" />
      <Output TaskParameter="TargetingPacks" ItemName="TargetingPack" />
      <Output TaskParameter="RuntimePacks" ItemName="RuntimePack" />
      <Output TaskParameter="Crossgen2Packs" ItemName="Crossgen2Pack" />
      <Output TaskParameter="HostILCompilerPacks" ItemName="HostILCompilerPack" />
      <Output TaskParameter="TargetILCompilerPacks" ItemName="TargetILCompilerPack" />
      <Output TaskParameter="UnavailableRuntimePacks" ItemName="UnavailableRuntimePack" />
      <Output TaskParameter="ImplicitPackageReferences" ItemName="_ImplicitPackageReference" />
      <Output TaskParameter="KnownRuntimeIdentifierPlatforms" ItemName="_KnownRuntimeIdentifierPlatformsForTargetFramework" />
    </ProcessFrameworkReferences>
    <PropertyGroup Condition="'$(AppHostRuntimeIdentifier)' == '' And&#xA;                              ('$(UseAppHost)' == 'true' Or '$(EnableComHosting)' == 'true' Or '$(UseIJWHost)' == 'true')">
      <AppHostRuntimeIdentifier>$(RuntimeIdentifier)</AppHostRuntimeIdentifier>
      <AppHostRuntimeIdentifier Condition="'$(AppHostRuntimeIdentifier)' == ''">$(DefaultAppHostRuntimeIdentifier)</AppHostRuntimeIdentifier>
    </PropertyGroup>
    <ResolveAppHosts TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" TargetingPackRoot="$(NetCoreTargetingPackRoot)" AppHostRuntimeIdentifier="$(AppHostRuntimeIdentifier)" OtherRuntimeIdentifiers="$(RuntimeIdentifiers)" RuntimeFrameworkVersion="$(RuntimeFrameworkVersion)" PackAsToolShimRuntimeIdentifiers="@(_PackAsToolShimRuntimeIdentifiers)" DotNetAppHostExecutableNameWithoutExtension="$(_DotNetAppHostExecutableNameWithoutExtension)" DotNetSingleFileHostExecutableNameWithoutExtension="$(_DotNetSingleFileHostExecutableNameWithoutExtension)" DotNetComHostLibraryNameWithoutExtension="$(_DotNetComHostLibraryNameWithoutExtension)" DotNetIjwHostLibraryNameWithoutExtension="$(_DotNetIjwHostLibraryNameWithoutExtension)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" KnownAppHostPacks="@(KnownAppHostPack)" NuGetRestoreSupported="$(_NuGetRestoreSupported)" EnableAppHostPackDownload="$(EnableAppHostPackDownload)" NetCoreTargetingPackRoot="$(NetCoreTargetingPackRoot)">
      <Output TaskParameter="PackagesToDownload" ItemName="_PackageToDownload" />
      <Output TaskParameter="AppHost" ItemName="AppHostPack" />
      <Output TaskParameter="SingleFileHost" ItemName="SingleFileHostPack" />
      <Output TaskParameter="ComHost" ItemName="ComHostPack" />
      <Output TaskParameter="IjwHost" ItemName="IjwHostPack" />
      <Output TaskParameter="PackAsToolShimAppHostPacks" ItemName="PackAsToolShimAppHostPack" />
    </ResolveAppHosts>
    <PropertyGroup Condition="'$(UsePackageDownload)' == ''">
      <UsePackageDownload Condition="'$(MSBuildRuntimeType)' == 'Core'">true</UsePackageDownload>
      <UsePackageDownload Condition="'$(PackageDownloadSupported)' == 'true'">true</UsePackageDownload>
      <UsePackageDownload Condition="'$(UsePackageDownload)' == ''">false</UsePackageDownload>
    </PropertyGroup>
    <ItemGroup Condition="'$(UsePackageDownload)' == 'true'">
      <PackageDownload Include="@(_PackageToDownload)">
        <Version>[%(_PackageToDownload.Version)]</Version>
      </PackageDownload>
    </ItemGroup>
    <ItemGroup Condition="'$(UsePackageDownload)' != 'true'">
      <PackageReference Include="@(_PackageToDownload)" IsImplicitlyDefined="true" PrivateAssets="all" ExcludeAssets="all" />
    </ItemGroup>
    <!-- Add implicit package references that don't already exist in PackageReference. -->
    <ItemGroup>
      <_ImplicitPackageReference Remove="@(PackageReference)" />
      <PackageReference Include="@(_ImplicitPackageReference)" IsImplicitlyDefined="true" PrivateAssets="all" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        AddTransitiveFrameworkReferences

    Adds FrameworkReference items for shared frameworks which weren't directly referenced,
    but were referenced transitively via a project or package reference.  NuGet writes these
    to the assets file, and the ResolvePackageAssets target adds them to the TransitiveFrameworkReference
    item.  Here, we add them to FrameworkReference if they aren't already referenced.
    We add a transitive attribute to the FrameworkReferences so NuGet can filter them out from CollectFrameworkReferences.
    ============================================================
    -->
  <Target Name="AddTransitiveFrameworkReferences" AfterTargets="ResolvePackageAssets" Condition="'@(TransitiveFrameworkReference)' != ''">
    <ItemGroup>
      <FrameworkReference Include="@(TransitiveFrameworkReference)" Exclude="@(FrameworkReference)" IsTransitiveFrameworkReference="true" />
    </ItemGroup>
  </Target>
  <UsingTask TaskName="ResolveFrameworkReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!--
    ============================================================
                                        ResolveFrameworkReferences

    Resolves paths to various FrameworkReference-related items (targeting packs, runtime packs,
    app host packs).  Some of these may already have had the path set if they were in the
    NetCoreTargetingPackRoot folder.  Others which were downloaded as NuGet packages will
    need to have the path set here.
    ============================================================
    -->
  <Target Name="ResolveFrameworkReferences" DependsOnTargets="ProcessFrameworkReferences;ResolvePackageAssets" Condition="'@(FrameworkReference)' != ''" Returns="@(ResolvedFrameworkReference)">
    <GetPackageDirectory Items="@(TargetingPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedTargetingPack" />
    </GetPackageDirectory>
    <ItemGroup>
      <ResolvedTargetingPack Condition="'%(ResolvedTargetingPack.Path)' == '' and '%(ResolvedTargetingPack.PackageDirectory)' != ''">
        <Path>%(ResolvedTargetingPack.PackageDirectory)</Path>
      </ResolvedTargetingPack>
    </ItemGroup>
    <GetPackageDirectory Items="@(AppHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedAppHostPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(SingleFileHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedSingleFileHostPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(Crossgen2Pack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedCrossgen2Pack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(HostILCompilerPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedILCompilerPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(TargetILCompilerPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedTargetILCompilerPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(PackAsToolShimAppHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="_ApphostsForShimRuntimeIdentifiersGetPackageDirectory" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(ComHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedComHostPack" />
    </GetPackageDirectory>
    <GetPackageDirectory Items="@(IjwHostPack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedIjwHostPack" />
    </GetPackageDirectory>
    <ItemGroup>
      <_ApphostsForShimRuntimeIdentifiers Include="%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.PackageDirectory)\%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.PathInPackage)">
        <RuntimeIdentifier>%(_ApphostsForShimRuntimeIdentifiersGetPackageDirectory.RuntimeIdentifier)</RuntimeIdentifier>
      </_ApphostsForShimRuntimeIdentifiers>
    </ItemGroup>
    <ItemGroup>
      <ResolvedAppHostPack Condition="'%(ResolvedAppHostPack.Path)' == '' and '%(ResolvedAppHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedAppHostPack.PackageDirectory)\%(ResolvedAppHostPack.PathInPackage)</Path>
      </ResolvedAppHostPack>
    </ItemGroup>
    <PropertyGroup Condition="'@(ResolvedAppHostPack)' != '' And '$(AppHostSourcePath)' == ''">
      <AppHostSourcePath>@(ResolvedAppHostPack->'%(Path)')</AppHostSourcePath>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedSingleFileHostPack Condition="'%(ResolvedSingleFileHostPack.Path)' == '' and '%(ResolvedSingleFileHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedSingleFileHostPack.PackageDirectory)\%(ResolvedSingleFileHostPack.PathInPackage)</Path>
      </ResolvedSingleFileHostPack>
    </ItemGroup>
    <PropertyGroup Condition="'@(ResolvedSingleFileHostPack)' != '' And '$(SingleFileHostSourcePath)' == ''">
      <SingleFileHostSourcePath>@(ResolvedSingleFileHostPack->'%(Path)')</SingleFileHostSourcePath>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedComHostPack Condition="'%(ResolvedComHostPack.Path)' == '' and '%(ResolvedComHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedComHostPack.PackageDirectory)\%(ResolvedComHostPack.PathInPackage)</Path>
      </ResolvedComHostPack>
    </ItemGroup>
    <PropertyGroup Condition="'@(ResolvedComHostPack)' != '' And '$(ComHostSourcePath)' == ''">
      <ComHostSourcePath>@(ResolvedComHostPack->'%(Path)')</ComHostSourcePath>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedIjwHostPack Condition="'%(ResolvedIjwHostPack.Path)' == '' and '%(ResolvedIjwHostPack.PackageDirectory)' != ''">
        <Path>%(ResolvedIjwHostPack.PackageDirectory)\%(ResolvedIjwHostPack.PathInPackage)</Path>
      </ResolvedIjwHostPack>
    </ItemGroup>
    <PropertyGroup Condition="'@(ResolvedIjwHostPack)' != '' And '$(IjwHostSourcePath)' == ''">
      <IjwHostSourcePath>@(ResolvedIjwHostPack->'%(Path)')</IjwHostSourcePath>
    </PropertyGroup>
    <GetPackageDirectory Items="@(RuntimePack)" PackageFolders="@(AssetsFilePackageFolder)">
      <Output TaskParameter="Output" ItemName="ResolvedRuntimePack" />
    </GetPackageDirectory>
    <ResolveFrameworkReferences FrameworkReferences="@(FrameworkReference)" ResolvedTargetingPacks="@(ResolvedTargetingPack)" ResolvedRuntimePacks="@(ResolvedRuntimePack)">
      <Output TaskParameter="ResolvedFrameworkReferences" ItemName="ResolvedFrameworkReference" />
    </ResolveFrameworkReferences>
  </Target>
  <UsingTask TaskName="GetPackageDirectory" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <UsingTask TaskName="ResolveTargetingPackAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!--
    ============================================================
                                        ResolveTargetingPackAssets

    Resolve assets (primarily references) from targeting packs.
    ============================================================
    -->
  <Target Name="ResolveTargetingPackAssets" DependsOnTargets="ResolveFrameworkReferences" Condition="'@(FrameworkReference)' != ''">
    <!-- For design-time builds, don't generate an error if a targeting pack isn't available (ie because it hasn't been restored yet) -->
    <PropertyGroup Condition="'$(GenerateErrorForMissingTargetingPacks)' == ''">
      <GenerateErrorForMissingTargetingPacks>true</GenerateErrorForMissingTargetingPacks>
      <GenerateErrorForMissingTargetingPacks Condition="'$(DesignTimeBuild)' == 'true'">false</GenerateErrorForMissingTargetingPacks>
    </PropertyGroup>
    <ResolveTargetingPackAssets FrameworkReferences="@(FrameworkReference)" ProjectLanguage="$(Language)" ResolvedTargetingPacks="@(ResolvedTargetingPack)" RuntimeFrameworks="@(RuntimeFramework)" GenerateErrorForMissingTargetingPacks="$(GenerateErrorForMissingTargetingPacks)" NuGetRestoreSupported="$(_NuGetRestoreSupported)" DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)" NetCoreTargetingPackRoot="$(NetCoreTargetingPackRoot)">
      <Output TaskParameter="ReferencesToAdd" ItemName="Reference" />
      <Output TaskParameter="AnalyzersToAdd" ItemName="Analyzer" />
      <Output TaskParameter="PlatformManifests" ItemName="PlatformManifestsFromTargetingPacks" />
      <Output TaskParameter="PackageConflictPreferredPackages" PropertyName="PackageConflictPreferredPackages" />
      <Output TaskParameter="PackageConflictOverrides" ItemName="PackageConflictOverrides" />
      <Output TaskParameter="UsedRuntimeFrameworks" ItemName="_UsedRuntimeFramework" />
    </ResolveTargetingPackAssets>
    <PropertyGroup>
      <!-- Unescape this semicolon-delimited ordered list so that it's passed as a list to targets
           that consume it. -->
      <PackageConflictPreferredPackages>$([MSBuild]::Unescape($(PackageConflictPreferredPackages)))</PackageConflictPreferredPackages>
    </PropertyGroup>
    <ItemGroup Condition="'$(RuntimeIdentifier)' == '' or '$(SelfContained)' != 'true'">
      <PackageConflictPlatformManifests Include="@(PlatformManifestsFromTargetingPacks)" />
    </ItemGroup>
    <ItemGroup>
      <RuntimeFramework Remove="@(RuntimeFramework)" />
      <RuntimeFramework Include="@(_UsedRuntimeFramework)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveOffByDefaultAnalyzers" AfterTargets="ResolveTargetingPackAssets" Condition="'@(FrameworkReference)' != ''">
    <ItemGroup>
      <OffByDefaultAnalyzer Include="Microsoft.AspNetCore.Http.RequestDelegateGenerator.dll" IsEnabled="$(EnableRequestDelegateGenerator)" />
      <OffByDefaultAnalyzer Include="Microsoft.Extensions.Configuration.Binder.SourceGeneration.dll" IsEnabled="$(EnableConfigurationBindingGenerator)" />
    </ItemGroup>
    <ItemGroup>
      <Analyzer Remove="@(OffByDefaultAnalyzer)" Condition="'%(OffByDefaultAnalyzer.IsEnabled)' != 'true'" MatchOnMetadata="FileName" />
    </ItemGroup>
  </Target>
  <UsingTask TaskName="ResolveRuntimePackAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <!--
    ============================================================
                                        IncludeTargetingPackReference

    Add package reference for required targeting pack if necessary
    ============================================================
    -->
  <Target Name="IncludeTargetingPackReference" BeforeTargets="_CheckForInvalidConfigurationAndPlatform;CollectPackageReferences;CheckForImplicitPackageReferenceOverrides" Condition="'$(TargetFrameworkMoniker)' != '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(AutomaticallyUseReferenceAssemblyPackages)' == 'true'">
    <GetReferenceAssemblyPaths TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RootPath="$(TargetFrameworkRootPath)" TargetFrameworkFallbackSearchPaths="$(TargetFrameworkFallbackSearchPaths)" BypassFrameworkInstallChecks="true" SuppressNotFoundError="true">
      <Output TaskParameter="FullFrameworkReferenceAssemblyPaths" PropertyName="_FullFrameworkReferenceAssemblyPaths" />
    </GetReferenceAssemblyPaths>
    <ItemGroup>
      <_ExistingReferenceAssembliesPackageReference Include="@(PackageReference)" Condition="'%(PackageReference.Identity)' == 'Microsoft.NETFramework.ReferenceAssemblies'" />
      <PackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="$(MicrosoftNETFrameworkReferenceAssembliesLatestPackageVersion)" IsImplicitlyDefined="true" PrivateAssets="All" Condition="('$(_FullFrameworkReferenceAssemblyPaths)' == '' or $(_FullFrameworkReferenceAssemblyPaths.Contains('microsoft.netframework.referenceassemblies'))) and '@(_ExistingReferenceAssembliesPackageReference)' == ''" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ResolveRuntimePackAssets

    Resolve assets from runtime packs.
    ============================================================
    -->
  <Target Name="ResolveRuntimePackAssets" DependsOnTargets="ResolveFrameworkReferences" Condition="'@(RuntimePack)' != ''">
    <ResolveRuntimePackAssets FrameworkReferences="@(FrameworkReference)" RuntimeFrameworks="@(RuntimeFramework)" ResolvedRuntimePacks="@(ResolvedRuntimePack)" UnavailableRuntimePacks="@(UnavailableRuntimePack)" SatelliteResourceLanguages="$(SatelliteResourceLanguages)" DesignTimeBuild="$(DesignTimeBuild)" DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)">
      <Output TaskParameter="RuntimePackAssets" ItemName="RuntimePackAsset" />
    </ResolveRuntimePackAssets>
    <ItemGroup>
      <ReferenceCopyLocalPaths Include="@(RuntimePackAsset)" Condition="'$(CopyLocalLockFileAssemblies)' == 'true' and ('$(SelfContained)' == 'true' or '%(RuntimePackAsset.RuntimePackAlwaysCopyLocal)' == 'true') and '%(RuntimePackAsset.AssetType)' != 'pgodata'" />
    </ItemGroup>
  </Target>
  <!--
    Adds metadata so the SDK will generate the UserSecretsIdAttribute.

    This is associated with ASP.NET Core, but may be used in projects that don't use the Web SDK (especially test projects).
    So it is in the base .NET SDK.  (It used to be in the Microsoft.AspNetCore.App package, but now that that's a targeting
    pack we don't support importing build logic from it directly).

    If GeneratedUserSecretsAttributeFile is set, that means Microsoft.Extensions.Configuration.UserSecrets 2.1
    or earlier was referenced as a package. This didn't use the AssemblyAttribute item group, so we cannot
    avoid duplicate AssemblyAttribute items without skipping this target altogether..
  -->
  <Target Name="_GetUserSecretsAssemblyAttribute" BeforeTargets="GetAssemblyAttributes" Condition=" '$(UserSecretsId)' != '' AND '$(GenerateUserSecretsAttribute)' != 'false' AND '$(GeneratedUserSecretsAttributeFile)' == '' ">
    <!--
      If the Microsoft.Extensions.Configuration.UserSecrets package 2.2 or higher is referenced directly,
      it will also add an AssemblyAttribute item. Since this attribute only allows one per assembly, do not
      duplicate the item.

      Also don't add the attribute if there is neither a Microsoft.AspNetCore.App FrameworkReference nor a
      Microsoft.Extensions.Configuration.UserSecrets PackageReference, in order to preserve 2.x SDK behavior
      where projects would successfully build if they define the UserSecretsId property but don't reference
      the corresponding API.

    -->
    <ItemGroup Condition=" @(AssemblyAttribute-&gt;WithMetadataValue('Identity', 'Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute')-&gt;Count()) == 0 And&#xA;                            (@(FrameworkReference-&gt;WithMetadataValue('Identity', 'Microsoft.AspNetCore.App')-&gt;Count()) != 0 Or&#xA;                            @(PackageReference-&gt;WithMetadataValue('Identity', 'Microsoft.Extensions.Configuration.UserSecrets')-&gt;Count()) != 0)">
      <AssemblyAttribute Include="Microsoft.Extensions.Configuration.UserSecrets.UserSecretsIdAttribute">
        <_Parameter1>$(UserSecretsId.Trim())</_Parameter1>
      </AssemblyAttribute>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <UsingTask TaskName="GenerateDepsFile" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="GenerateRuntimeConfigurationFiles" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="GetAssemblyVersion" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="GenerateSatelliteAssemblies" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DisableStandardFrameworkResolution Condition="'$(DisableStandardFrameworkResolution)' == ''">$(_IsNETCoreOrNETStandard)</DisableStandardFrameworkResolution>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateRuntimeConfigurationFiles Condition=" '$(GenerateRuntimeConfigurationFiles)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and ('$(HasRuntimeOutput)' == 'true' or '$(EnableComHosting)' == 'true' or '$(EnableDynamicLoading)' == 'true') ">true</GenerateRuntimeConfigurationFiles>
    <AlwaysIncludeCoreFrameworkInRuntimeConfig Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionLessThan('$(TargetFrameworkVersion)', '6.0'))">false</AlwaysIncludeCoreFrameworkInRuntimeConfig>
    <AlwaysIncludeCoreFrameworkInRuntimeConfig Condition="'$(AlwaysIncludeCoreFrameworkInRuntimeConfig)' == ''">true</AlwaysIncludeCoreFrameworkInRuntimeConfig>
    <UserRuntimeConfig Condition=" '$(UserRuntimeConfig)' == '' ">$(MSBuildProjectDirectory)/runtimeconfig.template.json</UserRuntimeConfig>
    <GenerateSatelliteAssembliesForCore Condition=" '$(GenerateSatelliteAssembliesForCore)' == '' and '$(MSBuildRuntimeType)' == 'Core' ">true</GenerateSatelliteAssembliesForCore>
    <ComputeNETCoreBuildOutputFiles Condition=" '$(ComputeNETCoreBuildOutputFiles)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</ComputeNETCoreBuildOutputFiles>
    <_GenerateRuntimeConfigurationPropertyInputsCache Condition="'$(_GenerateRuntimeConfigurationPropertyInputsCache)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).genruntimeconfig.cache</_GenerateRuntimeConfigurationPropertyInputsCache>
    <_GenerateRuntimeConfigurationPropertyInputsCache>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(_GenerateRuntimeConfigurationPropertyInputsCache)))</_GenerateRuntimeConfigurationPropertyInputsCache>
    <_GeneratePublishDependencyFilePropertyInputsCache Condition="'$(_GeneratePublishDependencyFilePropertyInputsCache)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).genpublishdeps.cache</_GeneratePublishDependencyFilePropertyInputsCache>
    <_GeneratePublishDependencyFilePropertyInputsCache>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(_GeneratePublishDependencyFilePropertyInputsCache)))</_GeneratePublishDependencyFilePropertyInputsCache>
    <_GenerateSingleFileBundlePropertyInputsCache Condition="'$(_GenerateSingleFileBundlePropertyInputsCache)' == ''">$(IntermediateOutputPath)$(MSBuildProjectName).genbundle.cache</_GenerateSingleFileBundlePropertyInputsCache>
    <_GenerateSingleFileBundlePropertyInputsCache>$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(_GenerateSingleFileBundlePropertyInputsCache)))</_GenerateSingleFileBundlePropertyInputsCache>
  </PropertyGroup>
  <!-- For .NET 8 and higher, we will by default use a simplified "portable" RID graph -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UseRidGraphWasSpecified Condition="'$(UseRidGraph)' != ''">true</_UseRidGraphWasSpecified>
  </PropertyGroup>
  <PropertyGroup Condition="'$(UseRidGraph)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <UseRidGraph Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0'))">false</UseRidGraph>
    <UseRidGraph Condition="'$(UseRidGraph)' == ''">true</UseRidGraph>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifierGraphPath)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RuntimeIdentifierGraphPath Condition="'$(UseRidGraph)' == 'true'">$(BundledRuntimeIdentifierGraphFile)</RuntimeIdentifierGraphPath>
    <!-- The portable RID graph should be in the same directory as the full RID graph -->
    <RuntimeIdentifierGraphPath Condition="'$(UseRidGraph)' != 'true'">$([System.IO.Path]::GetDirectoryName($(BundledRuntimeIdentifierGraphFile)))/PortableRuntimeIdentifierGraph.json</RuntimeIdentifierGraphPath>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateRuntimeConfigurationFilesInputs Include="$(ProjectAssetsFile)" />
    <GenerateRuntimeConfigurationFilesInputs Include="$(ProjectAssetsCacheFile)" />
    <GenerateRuntimeConfigurationFilesInputs Include="$(UserRuntimeConfig)" Condition=" Exists($(UserRuntimeConfig)) " />
  </ItemGroup>
  <ItemGroup Condition="'$(TargetFrameworks)' != '' And '$(TargetFramework)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectConfigurationDescription Include="TargetFramework=$(TargetFramework)" />
  </ItemGroup>
  <PropertyGroup Condition="'$(GenerateRuntimeConfigDevFile)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateRuntimeConfigDevFile>true</GenerateRuntimeConfigDevFile>
    <!-- Post-net6.0, stop generating *.runtimeconfig.dev.json files to reduce probing paths. -->
    <!-- https://github.com/dotnet/sdk/issues/16818 -->
    <GenerateRuntimeConfigDevFile Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0'))">false</GenerateRuntimeConfigDevFile>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectDepsFileName Condition="'$(ProjectDepsFileName)' == ''">$(AssemblyName).deps.json</ProjectDepsFileName>
    <ProjectDepsFilePath Condition="'$(ProjectDepsFilePath)' == ''">$(TargetDir)$(ProjectDepsFileName)</ProjectDepsFilePath>
    <ProjectRuntimeConfigFileName Condition="'$(ProjectRuntimeConfigFileName)' == ''">$(AssemblyName).runtimeconfig.json</ProjectRuntimeConfigFileName>
    <ProjectRuntimeConfigFilePath Condition="'$(ProjectRuntimeConfigFilePath)' == ''">$(TargetDir)$(ProjectRuntimeConfigFileName)</ProjectRuntimeConfigFilePath>
    <ProjectRuntimeConfigDevFilePath Condition="'$(ProjectRuntimeConfigDevFilePath)' == '' and $(GenerateRuntimeConfigDevFile) == 'true'">$(TargetDir)$(AssemblyName).runtimeconfig.dev.json</ProjectRuntimeConfigDevFilePath>
    <IncludeMainProjectInDepsFile Condition=" '$(IncludeMainProjectInDepsFile)' == '' ">true</IncludeMainProjectInDepsFile>
    <TrimDepsJsonLibrariesWithoutAssets Condition=" '$(TrimDepsJsonLibrariesWithoutAssets)' == '' ">true</TrimDepsJsonLibrariesWithoutAssets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Shared.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.Shared.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Shared.targets:  The properties and targets shared by the WAP project system.

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(UsingNETSdkDefaults)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Skip import of Microsoft.NuGet.props and Microsoft.NuGet.targets -->
    <SkipImportNuGetProps>true</SkipImportNuGetProps>
    <SkipImportNuGetBuildTargets>true</SkipImportNuGetBuildTargets>
  </PropertyGroup>
  <!-- Workaround: https://github.com/Microsoft/msbuild/issues/1293 -->
  <PropertyGroup Condition="'$(MSBuildRuntimeType)' == 'Core' Or '$(TargetFrameworkIdentifier)' != '.NETFramework'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateResourceMSBuildArchitecture Condition=" '$(GenerateResourceMSBuildArchitecture)' == '' ">CurrentArchitecture</GenerateResourceMSBuildArchitecture>
    <GenerateResourceMSBuildRuntime Condition=" '$(GenerateResourceMSBuildRuntime)' == '' ">CurrentRuntime</GenerateResourceMSBuildRuntime>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_NativeLibraryPrefix Condition="'$(_NativeLibraryPrefix)' == '' and !$(RuntimeIdentifier.StartsWith('win'))">lib</_NativeLibraryPrefix>
    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == '' and $(RuntimeIdentifier.StartsWith('win'))">.dll</_NativeLibraryExtension>
    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == '' and $(RuntimeIdentifier.StartsWith('osx'))">.dylib</_NativeLibraryExtension>
    <_NativeLibraryExtension Condition="'$(_NativeLibraryExtension)' == ''">.so</_NativeLibraryExtension>
    <_NativeExecutableExtension Condition="'$(_NativeExecutableExtension)' == '' and ($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win')))">.exe</_NativeExecutableExtension>
    <_ComHostLibraryExtension Condition="'$(_ComHostLibraryExtension)' == '' and ($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win')))">.dll</_ComHostLibraryExtension>
    <_IjwHostLibraryExtension Condition="'$(_IjwHostLibraryExtension)' == '' and ($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win')))">.dll</_IjwHostLibraryExtension>
    <_DotNetHostExecutableName>dotnet$(_NativeExecutableExtension)</_DotNetHostExecutableName>
    <_DotNetAppHostExecutableNameWithoutExtension>apphost</_DotNetAppHostExecutableNameWithoutExtension>
    <_DotNetAppHostExecutableName>$(_DotNetAppHostExecutableNameWithoutExtension)$(_NativeExecutableExtension)</_DotNetAppHostExecutableName>
    <_DotNetSingleFileHostExecutableNameWithoutExtension>singlefilehost</_DotNetSingleFileHostExecutableNameWithoutExtension>
    <_DotNetComHostLibraryNameWithoutExtension>comhost</_DotNetComHostLibraryNameWithoutExtension>
    <_DotNetComHostLibraryName>$(_DotNetComHostLibraryNameWithoutExtension)$(_ComHostLibraryExtension)</_DotNetComHostLibraryName>
    <_DotNetIjwHostLibraryNameWithoutExtension>Ijwhost</_DotNetIjwHostLibraryNameWithoutExtension>
    <_DotNetIjwHostLibraryName>$(_DotNetIjwHostLibraryNameWithoutExtension)$(_IjwHostLibraryExtension)</_DotNetIjwHostLibraryName>
    <_DotNetHostPolicyLibraryName>$(_NativeLibraryPrefix)hostpolicy$(_NativeLibraryExtension)</_DotNetHostPolicyLibraryName>
    <_DotNetHostFxrLibraryName>$(_NativeLibraryPrefix)hostfxr$(_NativeLibraryExtension)</_DotNetHostFxrLibraryName>
  </PropertyGroup>
  <Target Name="_ComputePackageReferencePublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- PrivateAssets="All" means exclude from publish, unless Publish metadata is specified separately -->
      <PackageReference Publish="false" Condition="('%(PackageReference.PrivateAssets)' == 'All') And ('%(PackageReference.Publish)' == '')" />
      <_ExcludeFromPublishPackageReference Include="@(PackageReference)" Condition="('%(PackageReference.Publish)' == 'false')" />
    </ItemGroup>
  </Target>
  <!--
  ============================================================
                           _DefaultMicrosoftNETPlatformLibrary

  .NET Core apps can have shared frameworks that are pre-installed on the target machine, thus the app is "portable"
  to any machine that already has the shared framework installed. For .NET Core 1.x and 2.x, a "platform" library
  is declared. The platform library and its dependencies will be excluded from the publish output.

  For .NET Core 3 and up, targeting packs and runtime packs are used for shared framework assets instead of PackageReference
  ============================================================
  -->
  <Target Name="_DefaultMicrosoftNETPlatformLibrary" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(MicrosoftNETPlatformLibrary)' == ''">
      <MicrosoftNETPlatformLibrary Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And '$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'">Microsoft.NETCore.App</MicrosoftNETPlatformLibrary>
    </PropertyGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_DefaultUserProfileRuntimeStorePath>$(HOME)</_DefaultUserProfileRuntimeStorePath>
    <_DefaultUserProfileRuntimeStorePath Condition="$([MSBuild]::IsOSPlatform(`Windows`))">$(USERPROFILE)</_DefaultUserProfileRuntimeStorePath>
    <_DefaultUserProfileRuntimeStorePath>$([System.IO.Path]::Combine($(_DefaultUserProfileRuntimeStorePath), '.dotnet', 'store'))</_DefaultUserProfileRuntimeStorePath>
    <UserProfileRuntimeStorePath Condition="'$(UserProfileRuntimeStorePath)' == ''">$(_DefaultUserProfileRuntimeStorePath)</UserProfileRuntimeStorePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PredefinedCulturesOnly Condition="'$(PredefinedCulturesOnly)' == '' and '$(InvariantGlobalization)' == 'true'">true</PredefinedCulturesOnly>
  </PropertyGroup>
  <PropertyGroup Condition="'$(GenerateResourceWarnOnBinaryFormatterUse)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionEquals($(TargetFrameworkVersion), '8.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateResourceWarnOnBinaryFormatterUse>true</GenerateResourceWarnOnBinaryFormatterUse>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RespectAlreadyAssignedItemCulture)' == '' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '9.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RespectAlreadyAssignedItemCulture>true</RespectAlreadyAssignedItemCulture>
  </PropertyGroup>
  <!-- Set the IsRidAgnostic property if this project should NOT accept global RuntimeIdentifier and SelfContained
       property values from referencing projects. -->
  <PropertyGroup Condition="'$(IsRidAgnostic)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IsRidAgnostic Condition="('$(_IsExecutable)' == 'true' And '$(IsTestProject)' != 'true') Or&#xA;                              '$(RuntimeIdentifier)' != '' Or&#xA;                              '$(RuntimeIdentifiers)' != ''">false</IsRidAgnostic>
    <IsRidAgnostic Condition="'$(IsRidAgnostic)' == ''">true</IsRidAgnostic>
  </PropertyGroup>
  <!-- Opt into .NET Core resource-serialization strategy by default when targeting frameworks
       that support it by default.
       -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateResourceUsePreserializedResources Condition="'$(GenerateResourceUsePreserializedResources)' == '' and&#xA;                 ('$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0')">true</GenerateResourceUsePreserializedResources>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EmbeddedResourceUseDependentUponConvention Condition="'$(EmbeddedResourceUseDependentUponConvention)' == '' and&#xA;                 (('$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0') or&#xA;                  ('$(TargetFrameworkIdentifier)' == '.NETStandard' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '2.1'))">true</EmbeddedResourceUseDependentUponConvention>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '2.1'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AvailablePlatforms>$(AvailablePlatforms),ARM32</AvailablePlatforms>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '3.1'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AvailablePlatforms>$(AvailablePlatforms),ARM64</AvailablePlatforms>
  </PropertyGroup>
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '4.8.1'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AvailablePlatforms>$(AvailablePlatforms),ARM64</AvailablePlatforms>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Turn off support for metadata updates in non-Debug builds by default. -->
    <MetadataUpdaterSupport Condition="'$(MetadataUpdaterSupport)' == '' and '$(Configuration)' != 'Debug'">false</MetadataUpdaterSupport>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Turn on IncludeProjectsNotInAssetsFileInDepsFile by default. -->
    <IncludeProjectsNotInAssetsFileInDepsFile Condition="'$(IncludeProjectsNotInAssetsFileInDepsFile)' == ''">true</IncludeProjectsNotInAssetsFileInDepsFile>
  </PropertyGroup>
  <!--
    BinaryFormatter Disabling
    ===========================

    The EnableUnsafeBinaryFormatterSerialization setting controls both runtime and compile-time behavior.
    The behavior is slightly different depending on the project type and target runtime.

    If the property is explicitly set to TRUE:
      - The APIs are obsolete as warning, and calls to the APIs will succeed at runtime.

    If the property is explicitly set to FALSE:
      - On .NET 5 & 6, the APIs are obsolete as warning, and calls to the APIs will fail at runtime.
      - On .NET 7+, the APIs are obsolete as error, and calls to the APIs will fail at runtime.

    If the property is not explicitly TRUE or FALSE:
      - On .NET 5 & 6, the APIs are obsolete as warning, and calls to the APIs will succeed at runtime.
      - On .NET 7, the APIs are obsolete as error, but calls to the APIs will succeed at runtime.
      - On .NET 8+, the APIs are obsolete as error, and calls to the APIs will fail at runtime
        unless the SDK has opted in to keeping legacy BinaryFormatter behavior around.

    n.b. The APIs are already marked obsolete (as warning) in .NET 5, so we don't need to special-case
    them unless we want to upgrade them to warn-as-error.
  -->
  <PropertyGroup Condition="'$(EnableUnsafeBinaryFormatterSerialization)' != 'true' AND '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '7.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Certain project types need to re-enable BinaryFormatter by default; it will still be warn-as-error but will work at runtime.
      WinForms: enabled through 8.0 (but not after)
      WPF: enabled through 8.0 (but not after)
    -->
    <_ProjectTypeRequiresBinaryFormatter Condition="'$(UseWindowsForms)' == 'true' AND $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), '8.0'))">true</_ProjectTypeRequiresBinaryFormatter>
    <_ProjectTypeRequiresBinaryFormatter Condition="'$(UseWPF)' == 'true' AND $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), '8.0'))">true</_ProjectTypeRequiresBinaryFormatter>
    <!-- controls warn as error -->
    <_BinaryFormatterObsoleteAsError>true</_BinaryFormatterObsoleteAsError>
    <!-- controls runtime behavior (AppContext & trimming) -->
    <EnableUnsafeBinaryFormatterSerialization Condition="'$(EnableUnsafeBinaryFormatterSerialization)' == '' AND '$(_ProjectTypeRequiresBinaryFormatter)' == 'true'">true</EnableUnsafeBinaryFormatterSerialization>
    <EnableUnsafeBinaryFormatterSerialization Condition="$([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '8.0')) AND '$(_ProjectTypeRequiresBinaryFormatter)' != 'true'">false</EnableUnsafeBinaryFormatterSerialization>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CoreBuildDependsOn>
      _CheckForBuildWithNoBuild;
      $(CoreBuildDependsOn);
      GenerateBuildDependencyFile;
      GenerateBuildRuntimeConfigurationFiles
    </CoreBuildDependsOn>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CoreCleanDependsOn>
      _SdkBeforeClean;
      $(CoreCleanDependsOn)
    </CoreCleanDependsOn>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RebuildDependsOn>
      _SdkBeforeRebuild;
      $(RebuildDependsOn)
    </RebuildDependsOn>
  </PropertyGroup>
  <!-- NOTE: Keep in sync with https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.tasks -->
  <!-- `Condition="Exists('$(RoslynTargetsPath)')` is needed because the package might not be yet downloaded during restore in VS
        and we do not want to fail the restore phase because of that. -->
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly" AssemblyFile="$(RoslynTasksAssembly)" Condition="Exists('$(RoslynTasksAssembly)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc" AssemblyFile="$(RoslynTasksAssembly)" Condition="Exists('$(RoslynTasksAssembly)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc" AssemblyFile="$(RoslynTasksAssembly)" Condition="Exists('$(RoslynTasksAssembly)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <ItemGroup Condition="'$(_NeedToDownloadMicrosoftNetSdkCompilersToolsetPackage)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageDownload Include="Microsoft.Net.Sdk.Compilers.Toolset" Version="[$(NETCoreSdkVersion)]" />
  </ItemGroup>
  <Target Name="_CheckMicrosoftNetCompilersToolsetFrameworkPackageReference" Condition="'$(MSBuildRuntimeType)' == 'Full'" BeforeTargets="CollectPackageReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Users should not be setting Microsoft.Net.Compilers.Toolset.Framework directly.
         If they do, and BuildWithNetFrameworkHostedCompiler is also set, the former will override the latter.
         This makes it more explicit that that is not supported. -->
    <NETSdkWarning ResourceName="CannotDirectlyReferenceMicrosoftNetCompilersToolsetFramework" Condition="'@(PackageReference-&gt;AnyHaveMetadataValue('Identity', 'Microsoft.Net.Compilers.Toolset.Framework'))' == 'true'" />
  </Target>
  <Target Name="_CheckMicrosoftNetSdkCompilersToolsetPackageExists" Condition="'$(_NeedToDownloadMicrosoftNetSdkCompilersToolsetPackage)' == 'true' and '$(DesignTimeBuild)' != 'true'" BeforeTargets="CoreCompile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- If users did not run restore or it failed to download the Microsoft.Net.Sdk.Compilers.Toolset package
         (but they proceeded to build, e.g., in Visual Studio), display an error with suggestions how to fix the problem. -->
    <NETSdkError ResourceName="MicrosoftNetSdkCompilersToolsetNotFound" Condition="'$(_MicrosoftNetSdkCompilersToolsetPackageRootEmpty)' != 'true' and !Exists('$(RoslynTargetsPath)')" FormatArguments="$(NETCoreSdkVersion)" />
    <!-- Warn if $(NuGetPackageRoot) is empty. See https://github.com/dotnet/sdk/issues/43016.
         WPF temp projects are ignored (it's known their NuGetPackageRoot is empty and user cannot fix that anyway). -->
    <NETSdkWarning ResourceName="MicrosoftNetSdkCompilersToolsetRootEmpty" Condition="'$(_MicrosoftNetSdkCompilersToolsetPackageRootEmpty)' == 'true' and !($(MSBuildProjectFile.EndsWith('_wpftmp.csproj')) or $(MSBuildProjectFile.EndsWith('_wpftmp.vbproj')))" />
  </Target>
  <Target Name="_CheckForBuildWithNoBuild" Condition="'$(NoBuild)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError ResourceName="NoBuildRequested" />
  </Target>
  <!--
    ============================================================
                                        GenerateBuildDependencyFile
    Generates the $(project).deps.json file during Build
    ============================================================
    -->
  <Target Name="GenerateBuildDependencyFile" DependsOnTargets="_DefaultMicrosoftNETPlatformLibrary;&#xA;                            _HandlePackageFileConflicts;&#xA;                            _ComputeReferenceAssemblies;&#xA;                            _ComputeUserRuntimeAssemblies;&#xA;                            ResolveRuntimePackAssets;&#xA;                            _ComputePackageReferencePublish" BeforeTargets="CopyFilesToOutputDirectory" Condition="'$(GenerateDependencyFile)' == 'true'" Inputs="$(ProjectAssetsFile);$(ProjectAssetsCacheFile);$(MSBuildAllProjects)" Outputs="$(ProjectDepsFilePath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set a dummy Version if it hasn't been set by DefaultAssemblyInfo.targets -->
    <PropertyGroup Condition="'$(UsingNETSdkDefaults)' != 'true'">
      <Version Condition="'$(Version)' == ''">1.0.0</Version>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedCompileFileDefinitions Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' == 'Reference'" />
      <NativeCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <ResourceCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimeCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimeTargetsCopyLocalItems Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimePackAsset Remove="@(_ConflictPackageFiles)" Condition="'%(_ConflictPackageFiles.ConflictItemType)' != 'Reference'" />
    </ItemGroup>
    <!-- Set valid RID platforms for runtime assets if targeting .NET 8+ and using the RID graph is not enabled. -->
    <ItemGroup Condition="$([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '8.0'))&#xA;        and @(RuntimeHostConfigurationOption-&gt;WithMetadataValue('Identity', 'System.Runtime.Loader.UseRidGraph')-&gt;WithMetadataValue('Value', 'true')-&gt;Count()) == 0&#xA;        and '@(_KnownRuntimeIdentifierPlatformsForTargetFramework)' != ''">
      <!-- Known RID platforms for all target frameworks comes from BundledVersions -->
      <_ValidRuntimeIdentifierPlatformsForAssets Include="@(_KnownRuntimeIdentiferPlatforms)" />
      <!-- Known RID platforms for current target framework comes from ProcessFrameworkReferences output -->
      <_ValidRuntimeIdentifierPlatformsForAssets Include="@(_KnownRuntimeIdentifierPlatformsForTargetFramework)" Exclude="@(_ExcludedKnownRuntimeIdentiferPlatforms)" />
    </ItemGroup>
    <GenerateDepsFile ProjectPath="$(MSBuildProjectFullPath)" AssetsFilePath="$(ProjectAssetsFile)" DepsFilePath="$(ProjectDepsFilePath)" TargetFramework="$(TargetFramework)" AssemblyName="$(AssemblyName)" AssemblyExtension="$(TargetExt)" AssemblyVersion="$(Version)" AssemblySatelliteAssemblies="@(IntermediateSatelliteAssembliesWithTargetPath)" ReferencePaths="@(ReferencePath)" ReferenceDependencyPaths="@(ReferenceDependencyPaths)" ReferenceSatellitePaths="@(ReferenceSatellitePaths)" ReferenceAssemblies="@(_ReferenceAssemblies)" RuntimePackAssets="@(RuntimePackAsset)" IncludeMainProject="$(IncludeMainProjectInDepsFile)" TrimDepsJsonLibrariesWithoutAssets="$(TrimDepsJsonLibrariesWithoutAssets)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" CompilerOptions="@(DependencyFileCompilerOptions)" CompileReferences="@(ResolvedCompileFileDefinitions)" ResolvedNuGetFiles="@(NativeCopyLocalItems);@(ResourceCopyLocalItems);@(RuntimeCopyLocalItems)" UserRuntimeAssemblies="@(UserRuntimeAssembly)" ResolvedRuntimeTargetsFiles="@(RuntimeTargetsCopyLocalItems)" IsSelfContained="$(SelfContained)" IncludeRuntimeFileVersions="$(IncludeFileVersionsInDependencyFile)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" IncludeProjectsNotInAssetsFile="$(IncludeProjectsNotInAssetsFileInDepsFile)" ValidRuntimeIdentifierPlatformsForAssets="@(_ValidRuntimeIdentifierPlatformsForAssets)" />
    <ItemGroup>
      <!-- Do this in an ItemGroup instead of as an output parameter of the GenerateDepsFile task so that it still gets added to the item set
           during incremental builds when the task is skipped -->
      <FileWrites Include="$(ProjectDepsFilePath)" Condition="Exists('$(ProjectDepsFilePath)')" />
    </ItemGroup>
  </Target>
  <!-- To achieve incremental build with property change. When any property changes, WriteOnlyWhenDifferent will be triggered to write cache file.
  And the cache file's timestamp will be later, and it then triggers the incremental build.-->
  <Target Name="_GenerateRuntimeConfigurationFilesInputCache" DependsOnTargets="_DefaultMicrosoftNETPlatformLibrary" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <GenerateRuntimeConfigurationFilesInputs Include="$(_GenerateRuntimeConfigurationPropertyInputsCache)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="@(AdditionalProbingPath->'%(Identity)')" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(EnableDynamicLoading)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(RollForward)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="@(RuntimeHostConfigurationOption->'%(Identity)%(Value)')" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(RuntimeIdentifier)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(SelfContained)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(TargetFramework)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(UserRuntimeConfig)" />
      <_GenerateRuntimeConfigurationPropertyInputsCacheToHash Include="$(_WriteIncludedFrameworks)" />
    </ItemGroup>
    <Hash ItemsToHash="@(_GenerateRuntimeConfigurationPropertyInputsCacheToHash)">
      <Output TaskParameter="HashResult" PropertyName="_GenerateRuntimeConfigurationPropertyInputsCacheHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_GenerateRuntimeConfigurationPropertyInputsCacheHash)" File="$(_GenerateRuntimeConfigurationPropertyInputsCache)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(_GenerateRuntimeConfigurationPropertyInputsCache)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateBuildRuntimeConfigurationFiles
    Generates the $(project).runtimeconfig.json and $(project).runtimeconfig.dev.json files during Build
    ============================================================
    -->
  <Target Name="GenerateBuildRuntimeConfigurationFiles" DependsOnTargets="_GenerateRuntimeConfigurationFilesInputCache" BeforeTargets="CopyFilesToOutputDirectory" Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'" Inputs="@(GenerateRuntimeConfigurationFilesInputs)" Outputs="$(ProjectRuntimeConfigFilePath);$(ProjectRuntimeConfigDevFilePath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_IsRollForwardSupported Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'">true</_IsRollForwardSupported>
      <RollForward Condition="'$(RollForward)' == '' and '$(EnableDynamicLoading)' == 'true' and '$(_IsRollForwardSupported)' == 'true'">LatestMinor</RollForward>
    </PropertyGroup>
    <!-- RollForward is only supported since .NET Core 3.0, but we should allow limited usage when the app is targeting even lower versions
         This is to let 2.* apps specify that they are OK to run on 3.0 and above. So explicitly allow just Major and LatestMajor
         other values should still keep failing as they won't have any effect when run on 2.*. -->
    <NETSdkError Condition="'$(RollForward)' != '' and '$(RollForward)' != 'Major' and '$(RollForward)' != 'LatestMajor' and '$(_IsRollForwardSupported)' != 'true'" ResourceName="RollForwardRequiresVersion30" />
    <PropertyGroup>
      <_WriteIncludedFrameworks Condition="'$(SelfContained)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.1'">true</_WriteIncludedFrameworks>
    </PropertyGroup>
    <GenerateRuntimeConfigurationFiles AssetsFilePath="$(ProjectAssetsFile)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" RuntimeConfigPath="$(ProjectRuntimeConfigFilePath)" RuntimeConfigDevPath="$(ProjectRuntimeConfigDevFilePath)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" RollForward="$(RollForward)" UserRuntimeConfig="$(UserRuntimeConfig)" HostConfigurationOptions="@(RuntimeHostConfigurationOption)" AdditionalProbingPaths="@(AdditionalProbingPath)" IsSelfContained="$(SelfContained)" WriteIncludedFrameworks="$(_WriteIncludedFrameworks)" GenerateRuntimeConfigDevFile="$(GenerateRuntimeConfigDevFile)" AlwaysIncludeCoreFramework="$(AlwaysIncludeCoreFrameworkInRuntimeConfig)" />
    <ItemGroup>
      <!-- Do this in an ItemGroup instead of as an output parameter of the GenerateDepsFile task so that it still gets added to the item set
          during incremental builds when the task is skipped -->
      <FileWrites Include="$(ProjectRuntimeConfigFilePath)" Condition="Exists('$(ProjectRuntimeConfigFilePath)')" />
      <FileWrites Include="$(ProjectRuntimeConfigDevFilePath)" Condition="Exists('$(ProjectRuntimeConfigDevFilePath)')" />
    </ItemGroup>
  </Target>
  <!-- Add runtimeconfig.json file to BuiltProjectOutputGroupOutput, so that it will get included in the NuGet package by the Pack target -->
  <Target Name="AddRuntimeConfigFileToBuiltProjectOutputGroupOutput" Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'" BeforeTargets="BuiltProjectOutputGroup" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <BuiltProjectOutputGroupOutput Include="$(ProjectRuntimeConfigFilePath)" TargetPath="$(ProjectRuntimeConfigFileName)" FinalOutputPath="$(ProjectRuntimeConfigFilePath)" />
    </ItemGroup>
  </Target>
  <Target Name="AddDepsJsonAndRuntimeConfigToCopyItemsForReferencingProjects" BeforeTargets="GetCopyToOutputDirectoryItems;_GetCopyToOutputDirectoryItemsFromThisProject" Condition="'$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(GenerateDependencyFile)' == 'true'">
      <AllItemsFullPathWithTargetPath Include="$(ProjectDepsFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectDepsFilePath)))" CopyToOutputDirectory="PreserveNewest" />
    </ItemGroup>
    <ItemGroup Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'">
      <AllItemsFullPathWithTargetPath Include="$(ProjectRuntimeConfigFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectRuntimeConfigFilePath)))" CopyToOutputDirectory="PreserveNewest" />
      <AllItemsFullPathWithTargetPath Include="$(ProjectRuntimeConfigDevFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectRuntimeConfigDevFilePath)))" CopyToOutputDirectory="PreserveNewest" />
    </ItemGroup>
  </Target>
  <Target Name="AddDepsJsonAndRuntimeConfigToPublishItemsForReferencingProjects" DependsOnTargets="_ComputeUseBuildDependencyFile" BeforeTargets="GetCopyToPublishDirectoryItems" Condition="'$(HasRuntimeOutput)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(GenerateDependencyFile)' == 'true'">
      <AllPublishItemsFullPathWithTargetPath Include="$(ProjectDepsFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectDepsFilePath)))" CopyToPublishDirectory="PreserveNewest" Condition="'$(_UseBuildDependencyFile)' == 'true'" />
      <AllPublishItemsFullPathWithTargetPath Include="$(PublishDepsFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(PublishDepsFilePath)))" CopyToPublishDirectory="PreserveNewest" Condition="'$(PublishDepsFilePath)' != '' and '$(_UseBuildDependencyFile)' != 'true'" />
    </ItemGroup>
    <ItemGroup Condition=" '$(GenerateRuntimeConfigurationFiles)' == 'true'">
      <AllPublishItemsFullPathWithTargetPath Include="$(ProjectRuntimeConfigFilePath)" TargetPath="$([System.IO.Path]::GetFileName($(ProjectRuntimeConfigFilePath)))" CopyToPublishDirectory="PreserveNewest" />
    </ItemGroup>
  </Target>
  <Target Name="_SdkBeforeClean" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(_CleaningWithoutRebuilding)' == ''">
      <_CleaningWithoutRebuilding>true</_CleaningWithoutRebuilding>
      <EmitAssetsLogMessages>false</EmitAssetsLogMessages>
    </PropertyGroup>
  </Target>
  <Target Name="_SdkBeforeRebuild" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_CleaningWithoutRebuilding>false</_CleaningWithoutRebuilding>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        DefaultRuntimeHostConfigurationOptions
    Defaults @(RuntimeHostConfigurationOption) items based on MSBuild properties.
    ============================================================
    -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RuntimeHostConfigurationOption Include="Microsoft.Extensions.DependencyInjection.VerifyOpenGenericServiceTrimmability" Condition="'$(VerifyDependencyInjectionOpenGenericServiceTrimmability)' != ''" Value="$(VerifyDependencyInjectionOpenGenericServiceTrimmability)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.AggressiveAttributeTrimming" Condition="'$(_AggressiveAttributeTrimming)' != ''" Value="$(_AggressiveAttributeTrimming)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.ComponentModel.DefaultValueAttribute.IsSupported" Condition="'$(_DefaultValueAttributeSupport)' != ''" Value="$(_DefaultValueAttributeSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.ComponentModel.Design.IDesignerHost.IsSupported" Condition="'$(_DesignerHostSupport)' != ''" Value="$(_DesignerHostSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.ComponentModel.TypeConverter.EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization" Condition="'$(EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization)' != ''" Value="$(EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.ComponentModel.TypeDescriptor.IsComObjectDescriptorSupported" Condition="'$(_ComObjectDescriptorSupport)' != ''" Value="$(_ComObjectDescriptorSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Data.DataSet.XmlSerializationIsSupported" Condition="'$(_DataSetXmlSerializationSupport)' != ''" Value="$(_DataSetXmlSerializationSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Diagnostics.Debugger.IsSupported" Condition="'$(DebuggerSupport)' != ''" Value="$(DebuggerSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Diagnostics.Metrics.Meter.IsSupported" Condition="'$(MetricsSupport)' != ''" Value="$(MetricsSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Diagnostics.StackTrace.IsSupported" Condition="'$(StackTraceSupport)' != ''" Value="$(StackTraceSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Diagnostics.Tracing.EventSource.IsSupported" Condition="'$(EventSourceSupport)' != ''" Value="$(EventSourceSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Drawing.Design.UITypeEditor.IsSupported" Condition="'$(_WinFormsUITypeEditorSupport)' != ''" Value="$(_WinFormsUITypeEditorSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.GC.Concurrent" Condition="'$(ConcurrentGarbageCollection)' != ''" Value="$(ConcurrentGarbageCollection)" />
    <RuntimeHostConfigurationOption Include="System.GC.Server" Condition="'$(ServerGarbageCollection)' != ''" Value="$(ServerGarbageCollection)" />
    <RuntimeHostConfigurationOption Include="System.GC.DynamicAdaptationMode" Condition="'$(GarbageCollectionAdaptationMode)' != ''" Value="$(GarbageCollectionAdaptationMode)" />
    <RuntimeHostConfigurationOption Include="System.GC.RetainVM" Condition="'$(RetainVMGarbageCollection)' != ''" Value="$(RetainVMGarbageCollection)" />
    <RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Condition="'$(InvariantGlobalization)' != ''" Value="$(InvariantGlobalization)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.TimeZoneInfo.Invariant" Condition="'$(InvariantTimezone)' != ''" Value="$(InvariantTimezone)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Globalization.Hybrid" Condition="'$(HybridGlobalization)' != ''" Value="$(HybridGlobalization)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Globalization.PredefinedCulturesOnly" Condition="'$(PredefinedCulturesOnly)' != ''" Value="$(PredefinedCulturesOnly)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Linq.Enumerable.IsSizeOptimized" Condition="'$(UseSizeOptimizedLinq)' != ''" Value="$(UseSizeOptimizedLinq)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Net.Http.EnableActivityPropagation" Condition="'$(HttpActivityPropagationSupport)' != ''" Value="$(HttpActivityPropagationSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Net.Http.UseNativeHttpHandler" Condition="'$(UseNativeHttpHandler)' != ''" Value="$(UseNativeHttpHandler)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Net.Security.UseManagedNtlm" Condition="'$(_UseManagedNtlm)' != ''" Value="$(_UseManagedNtlm)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Reflection.Metadata.MetadataUpdater.IsSupported" Condition="'$(MetadataUpdaterSupport)' != ''" Value="$(MetadataUpdaterSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Reflection.NullabilityInfoContext.IsSupported" Condition="'$(NullabilityInfoContextSupport)' != ''" Value="$(NullabilityInfoContextSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Resources.ResourceManager.AllowCustomResourceTypes" Condition="'$(CustomResourceTypesSupport)' != ''" Value="$(CustomResourceTypesSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Resources.UseSystemResourceKeys" Condition="'$(UseSystemResourceKeys)' != ''" Value="$(UseSystemResourceKeys)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.CompilerServices.RuntimeFeature.IsDynamicCodeSupported" Condition="'$(DynamicCodeSupport)' != ''" Value="$(DynamicCodeSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.InteropServices.BuiltInComInterop.IsSupported" Condition="'$(BuiltInComInteropSupport)' != ''" Value="$(BuiltInComInteropSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.InteropServices.EnableConsumingManagedCodeFromNativeHosting" Condition="'$(_EnableConsumingManagedCodeFromNativeHosting)' != ''" Value="$(_EnableConsumingManagedCodeFromNativeHosting)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.InteropServices.EnableCppCLIHostActivation" Condition="'$(EnableCppCLIHostActivation)' != ''" Value="$(EnableCppCLIHostActivation)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.InteropServices.Marshalling.EnableGeneratedComInterfaceComImportInterop" Condition="'$(EnableGeneratedComInterfaceComImportInterop)' != ''" Value="$(EnableGeneratedComInterfaceComImportInterop)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization" Condition="'$(EnableUnsafeBinaryFormatterSerialization)' != ''" Value="$(EnableUnsafeBinaryFormatterSerialization)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Runtime.TieredCompilation" Condition="'$(TieredCompilation)' != ''" Value="$(TieredCompilation)" />
    <RuntimeHostConfigurationOption Include="System.Runtime.TieredCompilation.QuickJit" Condition="'$(TieredCompilationQuickJit)' != ''" Value="$(TieredCompilationQuickJit)" />
    <RuntimeHostConfigurationOption Include="System.Runtime.TieredCompilation.QuickJitForLoops" Condition="'$(TieredCompilationQuickJitForLoops)' != ''" Value="$(TieredCompilationQuickJitForLoops)" />
    <RuntimeHostConfigurationOption Include="System.Runtime.TieredPGO" Condition="'$(TieredPGO)' != ''" Value="$(TieredPGO)" />
    <RuntimeHostConfigurationOption Include="System.Runtime.Loader.UseRidGraph" Condition="'$(_UseRidGraphWasSpecified)' == 'true'" Value="$(UseRidGraph)" />
    <RuntimeHostConfigurationOption Include="System.StartupHookProvider.IsSupported" Condition="'$(StartupHookSupport)' != ''" Value="$(StartupHookSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Text.Encoding.EnableUnsafeUTF7Encoding" Condition="'$(EnableUnsafeUTF7Encoding)' != ''" Value="$(EnableUnsafeUTF7Encoding)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Text.Json.JsonSerializer.IsReflectionEnabledByDefault" Condition="'$(JsonSerializerIsReflectionEnabledByDefault)' != ''" Value="$(JsonSerializerIsReflectionEnabledByDefault)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Threading.Thread.EnableAutoreleasePool" Condition="'$(AutoreleasePoolSupport)' != ''" Value="$(AutoreleasePoolSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.MinThreads" Condition="'$(ThreadPoolMinThreads)' != ''" Value="$(ThreadPoolMinThreads)" />
    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.MaxThreads" Condition="'$(ThreadPoolMaxThreads)' != ''" Value="$(ThreadPoolMaxThreads)" />
    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.UnfairSemaphoreSpinLimit" Condition="'$(ThreadPoolSpinCount)' != ''" Value="$(ThreadPoolSpinCount)" />
    <RuntimeHostConfigurationOption Include="System.Threading.ThreadPool.UseWindowsThreadPool" Condition="'$(UseWindowsThreadPool)' != ''" Value="$(UseWindowsThreadPool)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.ActiveXImpl.IsSupported" Condition="'$(_ActiveXImplSupport)' != ''" Value="$(_ActiveXImplSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.Binding.IsSupported" Condition="'$(_WinFormsBindingSupport)' != ''" Value="$(_WinFormsBindingSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.Control.AreDesignTimeFeaturesSupported" Condition="'$(_WinFormsDesignTimeFeaturesSupport)' != ''" Value="$(_WinFormsDesignTimeFeaturesSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.Control.UseComponentModelRegisteredTypes" Condition="'$(_UseComponentModelRegisteredTypes)' != ''" Value="$(_UseComponentModelRegisteredTypes)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.ImageIndexConverter.IsSupported" Condition="'$(_WinFormsImageIndexConverterSupport)' != ''" Value="$(_WinFormsImageIndexConverterSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.MdiWindowDialog.IsSupported" Condition="'$(_MdiWindowDialogSupport)' != ''" Value="$(_MdiWindowDialogSupport)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Windows.Forms.Primitives.TypeConverterHelper.UseComponentModelRegisteredTypes" Condition="'$(_UseComponentModelRegisteredTypes)' != ''" Value="$(_UseComponentModelRegisteredTypes)" Trim="true" />
    <RuntimeHostConfigurationOption Include="System.Xml.XmlResolver.IsNetworkingEnabledByDefault" Condition="'$(XmlResolverIsNetworkingEnabledByDefault)' != ''" Value="$(XmlResolverIsNetworkingEnabledByDefault)" Trim="true" />
  </ItemGroup>
  <!--
    ============================================================
                                        DefaultAdditionalProbingPaths
    Adds the default @(AdditionalProbingPath) items.
    ============================================================
    -->
  <ItemGroup Condition="'$(GenerateRuntimeConfigurationFiles)' == 'true' and '$(SkipDefaultAdditionalProbingPaths)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Note: can't use Path.Combine here since `|` is an illegal path character -->
    <AdditionalProbingPath Include="$(UserProfileRuntimeStorePath)$([System.IO.Path]::DirectorySeparatorChar)|arch|$([System.IO.Path]::DirectorySeparatorChar)|tfm|" />
  </ItemGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CompileDependsOn>
      $(CompileDependsOn);
      _CreateAppHost;
      _CreateComHost;
      _GetIjwHostPaths;
    </CompileDependsOn>
  </PropertyGroup>
  <!--
    ============================================================
                _GetAppHostCreationConfiguration
    Computes the properties for configuration of apphost creation
    during either build or publish
    ============================================================
     -->
  <Target Name="_GetAppHostCreationConfiguration" Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_UseWindowsGraphicalUserInterface Condition="($(RuntimeIdentifier.StartsWith('win')) or $(DefaultAppHostRuntimeIdentifier.StartsWith('win'))) and '$(OutputType)'=='WinExe'">true</_UseWindowsGraphicalUserInterface>
      <_EnableMacOSCodeSign Condition="'$(_EnableMacOSCodeSign)' == '' and&#xA;                                      ($(RuntimeIdentifier.StartsWith('osx')) or $(AppHostRuntimeIdentifier.StartsWith('osx')))">true</_EnableMacOSCodeSign>
      <_UseSingleFileHostForPublish Condition="'$(PublishSingleFile)' == 'true' and&#xA;                                               '$(SelfContained)' == 'true' and&#xA;                                               '$(SingleFileHostSourcePath)' != '' and&#xA;                                               '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                                               $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0))">true</_UseSingleFileHostForPublish>
      <_DisableCetCompat Condition="'$(CetCompat)' == 'false'">true</_DisableCetCompat>
      <!-- Default to AppHostDotNetSearch=AppRelative if AppHostRelativeDotNet is set -->
      <AppHostDotNetSearch Condition="'$(AppHostRelativeDotNet)' != '' and '$(AppHostDotNetSearch)' == ''">AppRelative</AppHostDotNetSearch>
      <_UpdateAppHostForPublish Condition="'$(_UseSingleFileHostForPublish)' != 'true' and&#xA;                                          ('$(AppHostRelativeDotNet)' != '' or '$(AppHostDotNetSearch)' != '')">true</_UpdateAppHostForPublish>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _CreateAppHost
    If we found a restored apphost, create the modified destination apphost
    with options from the project.
    ============================================================
     -->
  <UsingTask TaskName="CreateAppHost" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_CreateAppHost" Inputs="@(IntermediateAssembly);$(AppHostSourcePath)" Outputs="$(AppHostIntermediatePath)" DependsOnTargets="_GetAppHostPaths;_GetAppHostCreationConfiguration;CoreCompile" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and&#xA;                     '$(AppHostSourcePath)' != '' and&#xA;                     Exists('@(IntermediateAssembly)') and&#xA;                     Exists('$(AppHostSourcePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateAppHost AppHostSourcePath="$(AppHostSourcePath)" AppHostDestinationPath="$(AppHostIntermediatePath)" AppBinaryName="$(AssemblyName)$(TargetExt)" IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')" WindowsGraphicalUserInterface="$(_UseWindowsGraphicalUserInterface)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" EnableMacOSCodeSign="$(_EnableMacOSCodeSign)" DisableCetCompat="$(_DisableCetCompat)" />
  </Target>
  <!--
    ============================================================
                                        _GetAppHostPaths
    Gets the path to apphost (restored via packages or in an apphost pack),
    and computes the path for the destination apphost.
    ============================================================
     -->
  <Target Name="_GetAppHostPaths" DependsOnTargets="ResolvePackageAssets;ResolveFrameworkReferences" Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'@(_NativeRestoredAppHostNETCore-&gt;Count())' &gt; 1" ResourceName="MultipleFilesResolved" FormatArguments="$(_DotNetAppHostExecutableName)" />
    <PropertyGroup>
      <!-- AppHostSourcePath will be set from ProcessFrameworkReferences if not using the apphost from the assets file -->
      <AppHostSourcePath Condition="'$(UseAppHostFromAssetsFile)' == 'true'">@(_NativeRestoredAppHostNETCore)</AppHostSourcePath>
    </PropertyGroup>
    <PropertyGroup Condition="'$(UseAppHostFromAssetsFile)' == 'false' Or '@(_NativeRestoredAppHostNETCore)' != ''">
      <AppHostIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)apphost$(_NativeExecutableExtension)'))</AppHostIntermediatePath>
      <AppHostForPublishIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)apphost_publish$(_NativeExecutableExtension)'))</AppHostForPublishIntermediatePath>
      <SingleFileHostIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)singlefilehost$(_NativeExecutableExtension)'))</SingleFileHostIntermediatePath>
    </PropertyGroup>
  </Target>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ClsidMap Include="$(IntermediateOutputPath)$(AssemblyName).clsidmap" />
    <RegFreeComManifest Include="$(IntermediateOutputPath)$(AssemblyName).X.manifest" />
  </ItemGroup>
  <!--
      ============================================================
                                        _GenerateClsidMap
    Generates a *.clsidmap file from the built assembly.
    ============================================================
  -->
  <UsingTask TaskName="GenerateClsidMap" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_GenerateClsidMap" Inputs="@(IntermediateAssembly)" Outputs="@(ClsidMap)" DependsOnTargets="CoreCompile" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and&#xA;                     '$(EnableComHosting)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateClsidMap IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')" CLsidMapDestinationPath="@(ClsidMap->'%(FullPath)')" />
  </Target>
  <UsingTask TaskName="CreateComHost" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _CreateComHost
    If we found a restored comhost, create the modified destination apphost
    with options from the project.
    ============================================================
     -->
  <Target Name="_CreateComHost" Inputs="@(IntermediateAssembly);$(ComHostSourcePath)" Outputs="$(ComHostIntermediatePath)" DependsOnTargets="_GetComHostPaths;CoreCompile;_GenerateClsidMap;_GenerateRegFreeComManifest" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and&#xA;                     '$(ComHostIntermediatePath)' != '' and&#xA;                     Exists('@(IntermediateAssembly)') and&#xA;                     Exists('$(ComHostSourcePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateComHost ComHostSourcePath="$(ComHostSourcePath)" ComHostDestinationPath="$(ComHostIntermediatePath)" ClsidMapPath="@(ClsidMap)" TypeLibraries="@(ComHostTypeLibrary)" />
  </Target>
  <UsingTask TaskName="GenerateRegFreeComManifest" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _GenerateRegFreeComManifest
    Gets the path to the restored comhost, and if the restored comhost
    was present, computes the path for the destination comhost.
    ============================================================
  -->
  <Target Name="_GenerateRegFreeComManifest" DependsOnTargets="_GenerateClsidMap;_GetComHostPaths" Inputs="@(ClsidMap);@(IntermediateAssembly)" Outputs="@(RegFreeComManifest)" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true' and&#xA;                     '$(EnableComHosting)' == 'true' and&#xA;                     '$(EnableRegFreeCom)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateRegFreeComManifest IntermediateAssembly="@(IntermediateAssembly)" ComHostName="$(ComHostFileName)" ClsidMapPath="@(ClsidMap)" TypeLibraries="@(ComHostTypeLibrary)" ComManifestPath="@(RegFreeComManifest)" />
  </Target>
  <!--
    ============================================================
                                        _GetComHostPaths
    Gets the path to the restored comhost, and if the restored comhost
    was present, computes the path for the destination comhost.
    ============================================================
     -->
  <Target Name="_GetComHostPaths" DependsOnTargets="ResolvePackageAssets;ResolveFrameworkReferences" Condition="'$(EnableComHosting)' == 'true' and '$(_IsExecutable)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <ComHostFileName>$(AssemblyName).comhost$(_ComHostLibraryExtension)</ComHostFileName>
      <ComHostIntermediatePath>$([System.IO.Path]::GetFullPath('$(IntermediateOutputPath)$(ComHostFileName)'))</ComHostIntermediatePath>
    </PropertyGroup>
    <NETSdkError Condition="'$(ComHostSourcePath)' == '' or !Exists('$(ComHostSourcePath)')" ResourceName="CannotFindComhost" />
  </Target>
  <!--
    ============================================================
                                        _GetIjwHostPaths
    Gets the path to the restored Ijwhost, and if the restored Ijwhost
    was present, Computes the path for the destination Ijwhost.
    ============================================================
     -->
  <Target Name="_GetIjwHostPaths" DependsOnTargets="ResolvePackageAssets;ResolveFrameworkReferences" Condition="'$(UseIJWHost)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(IjwHostSourcePath)' == '' or !Exists('$(IjwHostSourcePath)')" ResourceName="CannotFindIjwhost" />
  </Target>
  <!--
    ============================================================
                                        _ComputeNETCoreBuildOutputFiles
    Computes any files that need to be copied to the build output folder for .NET Core.
    ============================================================
    -->
  <Target Name="_ComputeNETCoreBuildOutputFiles" DependsOnTargets="_GetAppHostPaths;_GetAppHostCreationConfiguration;_GetComHostPaths;_GetIjwHostPaths" BeforeTargets="AssignTargetPaths" Condition="'$(ComputeNETCoreBuildOutputFiles)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Fallback to renaming the dotnet host if there is no apphost for self-contained builds. -->
    <PropertyGroup Condition="'$(AppHostIntermediatePath)' == '' and '$(SelfContained)' == 'true'">
      <_CopyAndRenameDotnetHost Condition="'$(_CopyAndRenameDotnetHost)' == ''">true</_CopyAndRenameDotnetHost>
    </PropertyGroup>
    <ItemGroup Condition="'$(_CopyAndRenameDotnetHost)' == 'true'">
      <None Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostExecutableName)'">
        <Link>$(AssemblyName)$(_NativeExecutableExtension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(AppHostIntermediatePath)' != '' or '$(_CopyAndRenameDotnetHost)' == 'true'">
      <!--
        If not copying local lock file assemblies, copy the host policy and host fxr libraries for self-contained builds.
        This is required to allow the host to activate in self-contained mode.
      -->
      <None Include="@(NativeCopyLocalItems)" Condition="'$(SelfContained)' == 'true' and&#xA;                       '$(CopyLocalLockFileAssemblies)' != 'true' and&#xA;                       ('%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostPolicyLibraryName)' or&#xA;                        '%(NativeCopyLocalItems.FileName)%(NativeCopyLocalItems.Extension)' == '$(_DotNetHostFxrLibraryName)')">
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>Never</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(AppHostIntermediatePath)' != ''">
      <None Include="$(AppHostIntermediatePath)">
        <Link>$(AssemblyName)$(_NativeExecutableExtension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <!-- Always copy the AppHost because the contents of the apphost binary can change during the publish step (due to single-file bundling).
             Always copying the apphost ensures that that the sequence
                 dotnet publish /p:PublishSingleFile=true
                 dotnet publish /p:PublishSingleFile=false
             places the correct unbundled apphost in the publish directory. -->
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(ComHostIntermediatePath)' != ''">
      <None Include="$(ComHostIntermediatePath)">
        <Link>$(AssemblyName).$(_DotNetComHostLibraryName)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
      <None Include="@(RegFreeComManifest)" Condition="'$(EnableRegFreeCom)' == 'true'">
        <Link>%(FileName)%(Extension)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
    </ItemGroup>
    <ItemGroup Condition="'$(IjwHostSourcePath)' != '' and '$(UseIJWHost)' == 'true'">
      <None Include="$(IjwHostSourcePath)">
        <Link>$(_DotNetIjwHostLibraryName)</Link>
        <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </None>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _ComputeReferenceAssemblies
    Computes references that are only used at compile-time.
    ============================================================
    -->
  <Target Name="_ComputeReferenceAssemblies" DependsOnTargets="ResolveAssemblyReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_FrameworkReferenceAssemblies Include="@(ReferencePath)" Condition="(%(ReferencePath.FrameworkFile) == 'true' or&#xA;                                                %(ReferencePath.ResolvedFrom) == 'ImplicitlyExpandDesignTimeFacades')&#xA;                                            and ('%(ReferencePath.NuGetSourceType)' == ''  or&#xA;                                                 '%(ReferencePath.NuGetIsFrameworkReference)' == 'true')" />
      <!--
      "ReferenceOnly" assemblies are assemblies that are only used at compile-time, and they can't be resolved
      by the normal compile-assembly resolvers at runtime:
      1. App local
      2. NuGet/Package layout
      3. ProgramFiles\Reference Assemblies
      These assemblies need to be copied to the 'refs' folder for both build and publish.
      -->
      <_ReferenceOnlyAssemblies Include="@(ReferencePath)" Exclude="@(_FrameworkReferenceAssemblies)" Condition="%(ReferencePath.CopyLocal) != 'true' and&#xA;                                           %(ReferencePath.NuGetSourceType) == ''" />
      <_ReferenceAssemblies Include="@(_FrameworkReferenceAssemblies)" />
      <_ReferenceAssemblies Include="@(_ReferenceOnlyAssemblies)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _ComputeUserRuntimeAssemblies
    Computes references or reference dependencies that are copy local.
     NOTE: NuGet and framework references are never copy local so those are not included here.
           These will be project references and direct references and their copy local dependencies.
    ============================================================
    -->
  <Target Name="_ComputeUserRuntimeAssemblies" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- IncludeRuntimeDependency=true metadata is escape hatch to include a non-copy local reference in deps file as a runtime dependency -->
      <ReferencePath>
        <IncludeRuntimeDependency Condition="'%(ReferencePath.IncludeRuntimeDependency)' == '' and '%(ReferencePath.CopyLocal)' == 'true'">true</IncludeRuntimeDependency>
      </ReferencePath>
      <ReferenceDependencyPaths>
        <IncludeRuntimeDependency Condition="'%(ReferenceDependencyPaths.IncludeRuntimeDependency)' == '' and '%(ReferenceDependencyPaths.CopyLocal)' == 'true'">true</IncludeRuntimeDependency>
      </ReferenceDependencyPaths>
      <UserRuntimeAssembly Include="@(ReferencePath-&gt;WithMetadataValue('IncludeRuntimeDependency', 'true'))" />
      <UserRuntimeAssembly Include="@(ReferenceDependencyPaths-&gt;WithMetadataValue('IncludeRuntimeDependency', 'true'))" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                    CoreGenerateSatelliteAssemblies
    ============================================================
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateSatelliteAssembliesDependsOn>
      $(CreateSatelliteAssembliesDependsOn);
      CoreGenerateSatelliteAssemblies
    </CreateSatelliteAssembliesDependsOn>
  </PropertyGroup>
  <UsingTask TaskName="GetAssemblyAttributes" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="CoreGenerateSatelliteAssemblies" DependsOnTargets="ResolveAssemblyReferences;_GetAssemblyInfoFromTemplateFile" Inputs="$(MSBuildAllProjects);@(_SatelliteAssemblyResourceInputs);$(IntermediateOutputPath)$(TargetName)$(TargetExt)" Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll" Condition="'@(_SatelliteAssemblyResourceInputs)' != ''  and '$(GenerateSatelliteAssembliesForCore)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MakeDir Directories="@(_SatelliteAssemblyResourceInputs->'$(IntermediateOutputPath)%(Culture)')" />
    <PropertyGroup>
      <_AssemblyInfoFile>$(IntermediateOutputPath)%(_SatelliteAssemblyResourceInputs.Culture)\$(TargetName).resources.cs</_AssemblyInfoFile>
      <_OutputAssembly>$(IntermediateOutputPath)%(_SatelliteAssemblyResourceInputs.Culture)\$(TargetName).resources.dll</_OutputAssembly>
    </PropertyGroup>
    <ItemGroup>
      <SatelliteAssemblyAttribute Include="System.Reflection.AssemblyCultureAttribute" Condition="'%(_SatelliteAssemblyResourceInputs.Culture)' != ''">
        <_Parameter1>%(_SatelliteAssemblyResourceInputs.Culture)</_Parameter1>
      </SatelliteAssemblyAttribute>
    </ItemGroup>
    <WriteCodeFragment AssemblyAttributes="@(SatelliteAssemblyAttribute)" Language="C#" OutputFile="$(_AssemblyInfoFile)">
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
    <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
      <UseSharedCompilation>true</UseSharedCompilation>
    </PropertyGroup>
    <ItemGroup>
      <_SatelliteAssemblyReferences Remove="@(_SatelliteAssemblyReferences)" />
      <_SatelliteAssemblyReferences Include="@(ReferencePath)" Condition="'%(Filename)' == 'mscorlib' or '%(Filename)' == 'netstandard' or '%(Filename)' == 'System.Runtime' " />
    </ItemGroup>
    <Csc Resources="@(_SatelliteAssemblyResourceInputs)" Sources="$(_AssemblyInfoFile)" OutputAssembly="$(_OutputAssembly)" References="@(_SatelliteAssemblyReferences)" KeyContainer="$(KeyContainerName)" KeyFile="$(KeyOriginatorFile)" NoConfig="true" NoLogo="$(NoLogo)" NoStandardLib="$(NoCompilerStandardLib)" Optimize="$(Optimize)" PublicSign="$(PublicSign)" PathMap="$(PathMap)" Features="$(Features)" DelaySign="$(DelaySign)" Deterministic="$(Deterministic)" DisabledWarnings="$(DisabledWarnings)" WarningLevel="$(WarningLevel)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" TargetType="Library" ToolExe="$(CscToolExe)" ToolPath="$(CscToolPath)" UseSharedCompilation="$(UseSharedCompilation)">
      <Output TaskParameter="OutputAssembly" ItemName="FileWrites" />
    </Csc>
  </Target>
  <Target Name="_GetAssemblyInfoFromTemplateFile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetAssemblyAttributes PathToTemplateFile="$(IntermediateOutputPath)$(TargetName)$(TargetExt)">
      <Output TaskParameter="AssemblyAttributes" ItemName="_AssemblyAttributesFromTemplateFile" />
    </GetAssemblyAttributes>
    <ItemGroup>
      <SatelliteAssemblyAttribute Include="@(_AssemblyAttributesFromTemplateFile)" />
    </ItemGroup>
  </Target>
  <!--
  ============================================================
                                      GetAllRuntimeIdentifiers
  ============================================================
  -->
  <Target Name="GetAllRuntimeIdentifiers" Returns="$(RuntimeIdentifiers);$(RuntimeIdentifier)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
  ============================================================
               _BlockWinMDsOnUnsupportedTFMs
  Block referencing or producing
  Windows Metadata files (.winmd) for target frameworks
  that do not support loading winmds directly
  into the runtime as assemblies
  ============================================================
  -->
  <UsingTask TaskName="CheckForUnsupportedWinMDReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_BlockWinMDsOnUnsupportedTFMs" AfterTargets="PreBuildEvent" DependsOnTargets="ResolveReferences" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '5.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CheckForUnsupportedWinMDReferences TargetFrameworkMoniker="$(TargetFrameworkMoniker)" ReferencePaths="@(ReferencePath)" />
    <NETSdkError Condition="'$(OutputType)' == 'winmdobj'" ResourceName="WinMDObjNotSupportedOnTargetFramework" FormatArguments="$(TargetFrameworkMoniker)" />
  </Target>
  <!--
  ============================================================
                                      InjectTargetPathMetadata
  Update TargetPathWithTargetPlatformMoniker with target framework
  identifier and version metadata.  This is so that the
  ImplicitlyExpandNETStandardFacades target can determine if a
  referenced project needs the .NET Standard facades even if
  the project hasn't been compiled to disk yet.
  See https://github.com/dotnet/sdk/issues/1403 for more context
  ============================================================
  -->
  <ItemDefinitionGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetPathWithTargetPlatformMoniker>
      <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
      <TargetFrameworkVersion>$(_TargetFrameworkVersionWithoutV)</TargetFrameworkVersion>
    </TargetPathWithTargetPlatformMoniker>
  </ItemDefinitionGroup>
  <!--
    ============================================================
                            GenerateSupportedTargetFrameworkAlias
    Generate a list of valid TargetFramework aliases for the project
    system to consume for the target framework properties page drop down
    ============================================================
  -->
  <UsingTask TaskName="GenerateSupportedTargetFrameworkAlias" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GenerateSupportedTargetFrameworkAlias" Returns="@(SupportedTargetFrameworkAlias)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateSupportedTargetFrameworkAlias SupportedTargetFramework="@(SupportedTargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetPlatformMoniker="$(TargetPlatformMoniker)" UseWpf="$(UseWpf)" UseWindowsForms="$(UseWindowsForms)">
      <Output TaskParameter="SupportedTargetFrameworkAlias" ItemName="SupportedTargetFrameworkAlias" />
    </GenerateSupportedTargetFrameworkAlias>
  </Target>
  <!--
  ============================================================
  ValidateExecutableReferences
  ============================================================
  -->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AdditionalTargetFrameworkInfoProperty Include="SelfContained" />
    <AdditionalTargetFrameworkInfoProperty Include="_IsExecutable" />
    <AdditionalTargetFrameworkInfoProperty Include="IsRidAgnostic" />
    <AdditionalTargetFrameworkInfoProperty Include="ShouldBeValidatedAsExecutableReference" />
    <AdditionalTargetFrameworkInfoProperty Include="_SelfContainedWasSpecified" />
  </ItemGroup>
  <PropertyGroup Condition="'$(RuntimeIdentifier)' == 'browser-wasm'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Don't generate a NETSDK1151 error if a non self-contained Exe references a Blazor wasm Exe -->
    <ShouldBeValidatedAsExecutableReference>false</ShouldBeValidatedAsExecutableReference>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsTestProject)' == 'true' And '$(ValidateExecutableReferencesMatchSelfContained)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Don't generate an error if a test project references a self-contained Exe.  Test projects
         use an OutputType of Exe but will usually call APIs in a referenced Exe rather than try
         to run it. -->
    <ValidateExecutableReferencesMatchSelfContained>false</ValidateExecutableReferencesMatchSelfContained>
  </PropertyGroup>
  <PropertyGroup Condition="'$(IsTestProject)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Don't generate an error if an Exe project references a test project. -->
    <ShouldBeValidatedAsExecutableReference>false</ShouldBeValidatedAsExecutableReference>
  </PropertyGroup>
  <UsingTask TaskName="ValidateExecutableReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="$([MSBuild]::VersionGreaterThanOrEquals($(MSBuildVersion), '17.0'))">true</_UseAttributeForTargetFrameworkInfoPropertyNames>
  </PropertyGroup>
  <Target Name="ValidateExecutableReferences" AfterTargets="_GetProjectReferenceTargetFrameworkProperties" Condition="'$(ValidateExecutableReferencesMatchSelfContained)' != 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ValidateExecutableReferences SelfContained="$(SelfContained)" IsExecutable="$(_IsExecutable)" ReferencedProjects="@(_MSBuildProjectReferenceExistent)" UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)" />
  </Target>
  <!--
  ============================================================
  Command Line Configuration Validation
  ============================================================
  -->
  <Target Name="ValidateCommandLineProperties" AfterTargets="_CheckForInvalidConfigurationAndPlatform" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Currently a no-op, but we could put things here in the future, so keeping it. -->
  </Target>
  <!--
  ============================================================
                                         Project Capabilities
  ============================================================
  -->
  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_IsExecutable)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="CrossPlatformExecutable" />
  </ItemGroup>
  <!-- Native AOT compilation -->
  <!-- Native AOT properties should be shown by default for projects targeting .NET 8 or higher, except for WPF and WinForms projects -->
  <ItemGroup Condition="'$(UseWPF)' != 'true'&#xA;             and '$(UseWindowsForms)' != 'true'&#xA;             and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;             and $([MSBuild]::VersionGreaterThanOrEquals('$(_TargetFrameworkVersionWithoutV)', '8.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="NativeAOT" />
  </ItemGroup>
  <!-- Reference Manager capabilities -->
  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Remove="ReferenceManagerAssemblies" />
  </ItemGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.SourceLink.targets" Condition="'$(SuppressImplicitGitSourceLink)' != 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.SourceLink.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- C++ projects currently do not import Microsoft.NET.Sdk.props. -->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.SourceLink.props" Condition="'$(_SourceLinkPropsImported)' != 'true'" />-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Workaround for https://github.com/Microsoft/msbuild/issues/3294. -->
    <_SourceLinkSdkSubDir>build</_SourceLinkSdkSubDir>
    <_SourceLinkSdkSubDir Condition="'$(IsCrossTargetingBuild)' == 'true'">buildMultiTargeting</_SourceLinkSdkSubDir>
    <!-- Workaround for https://github.com/dotnet/sdk/issues/36585 (Desktop XAML targets do not produce correct #line directives) -->
    <EmbedUntrackedSources Condition="'$(EmbedUntrackedSources)' == '' and '$(ImportFrameworkWinFXTargets)' != 'true'">true</EmbedUntrackedSources>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.Build.Tasks.Git\build\Microsoft.Build.Tasks.Git.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.Build.Tasks.Git/build/Microsoft.Build.Tasks.Git.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <UsingTask TaskName="Microsoft.Build.Tasks.Git.LocateRepository" AssemblyFile="$(MicrosoftBuildTasksGitAssemblyFile)" />
  <UsingTask TaskName="Microsoft.Build.Tasks.Git.GetUntrackedFiles" AssemblyFile="$(MicrosoftBuildTasksGitAssemblyFile)" />
  <PropertyGroup>
    <!--
      Sets the scope of git repository configuration. By default (no scope specified) configuration is read from environment variables
      and system and global user git/ssh configuration files. 
      
      If "local" is specified the configuration is only read from the configuration files local to the repository (or work tree).
      In addition, any use of home relative paths in these configuration files (paths that start with '~/') is disallowed.
      
      By default, the scope is restricted to "local" when building in CI (ContinuousIntegrationBuild is true) to avoid introducing 
      dependencies on CI machine state into the build.
    -->
    <GitRepositoryConfigurationScope Condition="'$(GitRepositoryConfigurationScope)' == '' and '$(ContinuousIntegrationBuild)' == 'true'">local</GitRepositoryConfigurationScope>
  </PropertyGroup>
  <Target Name="InitializeSourceControlInformationFromSourceControlManager">
    <!--
      Reports a warning if the given project doesn't belong to a repository under source control,
      unless the targets were implicily imported from an SDK without a package reference.
    -->
    <Microsoft.Build.Tasks.Git.LocateRepository Path="$(MSBuildProjectDirectory)" RemoteName="$(GitRepositoryRemoteName)" ConfigurationScope="$(GitRepositoryConfigurationScope)" NoWarnOnMissingInfo="$(PkgMicrosoft_Build_Tasks_Git.Equals(''))">
      <Output TaskParameter="RepositoryId" PropertyName="_GitRepositoryId" />
      <Output TaskParameter="Url" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="Roots" ItemName="SourceRoot" />
      <Output TaskParameter="RevisionId" PropertyName="SourceRevisionId" Condition="'$(SourceRevisionId)' == ''" />
      <Output TaskParameter="BranchName" PropertyName="SourceBranchName" />
    </Microsoft.Build.Tasks.Git.LocateRepository>
    <PropertyGroup>
      <RepositoryType Condition="'$(RepositoryType)' == ''">git</RepositoryType>
    </PropertyGroup>
  </Target>
  <!--
    Embed files to the PDB that either do not belong to any of the SourceRoot directories
    or belong to the source repository, but are explicitly ignored (excluded) from source control.
  -->
  <Target Name="SetEmbeddedFilesFromSourceControlManagerUntrackedFiles" DependsOnTargets="InitializeSourceControlInformationFromSourceControlManager">
    <Microsoft.Build.Tasks.Git.GetUntrackedFiles RepositoryId="$(_GitRepositoryId)" ConfigurationScope="$(GitRepositoryConfigurationScope)" ProjectDirectory="$(MSBuildProjectDirectory)" Files="@(Compile)" Condition="'$(_GitRepositoryId)' != ''">
      <Output TaskParameter="UntrackedFiles" ItemName="EmbeddedFiles" />
    </Microsoft.Build.Tasks.Git.GetUntrackedFiles>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.Common\$(_SourceLinkSdkSubDir)\Microsoft.SourceLink.Common.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.Common/build/Microsoft.SourceLink.Common.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <!--
============================================================================================================================================
  <Import Project="InitializeSourceControlInformation.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.Common/build/InitializeSourceControlInformation.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <UsingTask TaskName="Microsoft.SourceLink.Common.SourceLinkHasSingleProvider" AssemblyFile="$(_MicrosoftSourceLinkCommonAssemblyFile)" />
  <Target Name="_SourceLinkHasSingleProvider">
    <!--
      If there is a single SourceLink provider we can use Repository URL to infer repository host.
      If the project references multiple SourceLink providers the user needs to specify hosts explicitly (ImplicitHost will be empty)
      as we do not know which providers should be used to produce SourceLink URL for the repository.
      
      Reports an error if there is no SourceLinkUrlInitializerTargets is empty (no SourceLink provider is referenced).
    -->
    <Microsoft.SourceLink.Common.SourceLinkHasSingleProvider ProviderTargets="$(SourceLinkUrlInitializerTargets)">
      <Output TaskParameter="HasSingleProvider" PropertyName="SourceLinkHasSingleProvider" />
    </Microsoft.SourceLink.Common.SourceLinkHasSingleProvider>
  </Target>
  <!--
    Triggers InitializeSourceControlInformationFromSourceControlManager target defined by a source control package Microsoft.Build.Tasks.{Git|Tfvc|...}.
    
    Notes: No error is reported if InitializeSourceControlInformation is not defined.
  -->
  <Target Name="_InitializeSourceControlInformationFromSourceControlManager" DependsOnTargets="InitializeSourceControlInformationFromSourceControlManager;_SourceLinkHasSingleProvider;$(SourceControlManagerUrlTranslationTargets);SourceControlManagerPublishTranslatedUrls" BeforeTargets="InitializeSourceControlInformation" Condition="'$(EnableSourceControlManagerQueries)' == 'true'" />
  <Target Name="SourceControlManagerPublishTranslatedUrls">
    <PropertyGroup>
      <!--
        If the project already sets RepositoryUrl use it. Such URL is considered final and translations are not applied.
      -->
      <PrivateRepositoryUrl Condition="'$(PrivateRepositoryUrl)' == ''">$(RepositoryUrl)</PrivateRepositoryUrl>
      <PrivateRepositoryUrl Condition="'$(PrivateRepositoryUrl)' == ''">$(ScmRepositoryUrl)</PrivateRepositoryUrl>
    </PropertyGroup>
    <ItemGroup>
      <SourceRoot Update="@(SourceRoot)">
        <RepositoryUrl Condition="'%(SourceRoot.RepositoryUrl)' == ''">%(SourceRoot.ScmRepositoryUrl)</RepositoryUrl>
      </SourceRoot>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.Common/build/Microsoft.SourceLink.Common.targets
============================================================================================================================================
-->
  <UsingTask TaskName="Microsoft.SourceLink.Common.GenerateSourceLinkFile" AssemblyFile="$(_MicrosoftSourceLinkCommonAssemblyFile)" />
  <Target Name="_SetSourceLinkFilePath">
    <PropertyGroup>
      <_SourceLinkFilePath>$(IntermediateOutputPath)$(MSBuildProjectName).sourcelink.json</_SourceLinkFilePath>
    </PropertyGroup>
  </Target>
  <!--
    Triggers SetEmbeddedFilesFromSourceControlManagerUntrackedFiles target defined by a source control package Microsoft.Build.Tasks.{Git|Tfvc|...}.
    Assumes that all targets that generate source files and add them to Compile items run before BeforeCompile target.
    This is a convention established by common targets.
    
    Disabled for design-time build since calculating untracked files is non-trivial operation
    and embedding them only affects the content of the generated PDB, which has no impact on design-time build.
  -->
  <Target Name="_SetEmbeddedFilesFromSourceControlManagerUntrackedFiles" DependsOnTargets="BeforeCompile;SetEmbeddedFilesFromSourceControlManagerUntrackedFiles" BeforeTargets="CoreCompile" Condition="'$(EmbedUntrackedSources)' == 'true' and '$(EmbedAllSources)' != 'true' and '$(DebugType)' != 'none' and '$(EnableSourceControlManagerQueries)' == 'true' and '$(DesignTimeBuild)' != 'true'" />
  <!--
    If defined populates MappedPath metadata of SourceRoot items.
  -->
  <Target Name="_InitializeSourceRootMappedPathsOpt" DependsOnTargets="InitializeSourceRootMappedPaths" Condition="'$(SourceRootMappedPathsFeatureSupported)' == 'true'" />
  <!-- 
    Add compiler targets: C++ generates PDB with SourceLink in Link phase.
  -->
  <PropertyGroup Condition="'$(Language)' == 'C++'">
    <_GenerateSourceLinkFileBeforeTargets>Link</_GenerateSourceLinkFileBeforeTargets>
    <_GenerateSourceLinkFileDependsOnTargets>ComputeLinkSwitches</_GenerateSourceLinkFileDependsOnTargets>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Language)' != 'C++'">
    <_GenerateSourceLinkFileBeforeTargets>CoreCompile</_GenerateSourceLinkFileBeforeTargets>
    <_GenerateSourceLinkFileDependsOnTargets />
  </PropertyGroup>
  <!--
    Each source control provider package adds its SourceLinkUrl initialization target to SourceLinkUrlInitializerTargets.
    This target shall initialize SourceLinkUrl of all items that don't have it initialized yet and belong to the source control provider.
  -->
  <Target Name="_GenerateSourceLinkFile" DependsOnTargets="_SetSourceLinkFilePath;$(_GenerateSourceLinkFileDependsOnTargets);_InitializeSourceRootMappedPathsOpt;$(SourceLinkUrlInitializerTargets)" Condition="'$(EnableSourceLink)' == 'true' and '$(DebugType)' != 'none'" Outputs="$(_SourceLinkFilePath)">
    <!--- Suppress warning if targets are imported from an SDK without a package reference. -->
    <Microsoft.SourceLink.Common.GenerateSourceLinkFile SourceRoots="@(SourceRoot)" NoWarnOnMissingSourceControlInformation="$(PkgMicrosoft_SourceLink_Common.Equals(''))" OutputFile="$(_SourceLinkFilePath)">
      <!-- Set SourceLink property passed to compilers -->
      <Output TaskParameter="SourceLink" PropertyName="SourceLink" />
    </Microsoft.SourceLink.Common.GenerateSourceLinkFile>
    <!--
      Include the output file whenever it exists, even if it hasn't been written to (it was up-to-date).
      This is needed so that incremental clean doesn't delete the file.
    -->
    <ItemGroup Condition="'$(SourceLink)' != ''">
      <FileWrites Include="$(SourceLink)" />
    </ItemGroup>
    <!-- C++ Link task currently doesn't recognize SourceLink property -->
    <ItemGroup Condition="'$(Language)' == 'C++' and '$(SourceLink)' != ''">
      <Link Update="@(Link)">
        <AdditionalOptions>%(Link.AdditionalOptions) /sourcelink:"$(SourceLink)"</AdditionalOptions>
      </Link>
    </ItemGroup>
  </Target>
  <Target Name="GenerateSourceLinkFile" DependsOnTargets="InitializeSourceControlInformation;_GenerateSourceLinkFile" Condition="'$(SourceControlInformationFeatureSupported)' == 'true'" BeforeTargets="$(_GenerateSourceLinkFileBeforeTargets)" />
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.GitHub\build\Microsoft.SourceLink.GitHub.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.GitHub/build/Microsoft.SourceLink.GitHub.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_SourceLinkGitHubAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.GitHub.dll</_SourceLinkGitHubAssemblyFile>
    <_SourceLinkGitHubAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.GitHub.dll</_SourceLinkGitHubAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.SourceLink.GitHub.GetSourceLinkUrl" AssemblyFile="$(_SourceLinkGitHubAssemblyFile)" />
  <UsingTask TaskName="Microsoft.SourceLink.GitHub.TranslateRepositoryUrls" AssemblyFile="$(_SourceLinkGitHubAssemblyFile)" />
  <PropertyGroup>
    <SourceLinkUrlInitializerTargets>$(SourceLinkUrlInitializerTargets);_InitializeGitHubSourceLinkUrl</SourceLinkUrlInitializerTargets>
    <SourceControlManagerUrlTranslationTargets>$(SourceControlManagerUrlTranslationTargets);TranslateGitHubUrlsInSourceControlInformation</SourceControlManagerUrlTranslationTargets>
  </PropertyGroup>
  <Target Name="_InitializeGitHubSourceLinkUrl" Outputs="%(SourceRoot.Identity)">
    <!--
      The task calculates SourceLink URL for a given SourceRoot.

      If the SourceRoot is associated with a git repository with a recognized domain the <see cref="SourceLinkUrl"/>
      output property is set to the content URL corresponding to the domain, otherwise it is set to string "N/A".

      Recognized domains are specified via Hosts (initialized from SourceLinkGitHubHost item group).
      In addition, if SourceLinkHasSingleProvider is true an implicit host is parsed from RepositoryUrl.

      Example of SourceLinkGitHubHost items:

      <ItemGroup>
        <SourceLinkGitHubHost Include="github.com" ContentUrl="https://raw.githubusercontent.com"/>
        <SourceLinkGitHubHost Include="mygithub1.com" />           ContentUrl defaults to https://mygithub1.com/raw
        <SourceLinkGitHubHost Include="mygithub2.com:8080" />      ContentUrl defaults to https://mygithub2.com:8080/raw
      </ItemGroup>

      ContentUrl is optional. If not specified it defaults to "https://{domain}/raw".
    -->
    <Microsoft.SourceLink.GitHub.GetSourceLinkUrl RepositoryUrl="$(PrivateRepositoryUrl)" SourceRoot="@(SourceRoot)" Hosts="@(SourceLinkGitHubHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="SourceLinkUrl" PropertyName="_SourceLinkUrlToUpdate" />
    </Microsoft.SourceLink.GitHub.GetSourceLinkUrl>
    <ItemGroup>
      <!-- Only update the SourceLinkUrl metadata if the SourceRoot belongs to this source control -->
      <SourceRoot Update="%(Identity)" SourceLinkUrl="$(_SourceLinkUrlToUpdate)" Condition="'$(_SourceLinkUrlToUpdate)' != 'N/A'" />
    </ItemGroup>
  </Target>
  <!-- 
    We need to translate ssh URLs to https.
  -->
  <Target Name="TranslateGitHubUrlsInSourceControlInformation">
    <ItemGroup>
      <_TranslatedSourceRoot Remove="@(_TranslatedSourceRoot)" />
    </ItemGroup>
    <Microsoft.SourceLink.GitHub.TranslateRepositoryUrls RepositoryUrl="$(ScmRepositoryUrl)" SourceRoots="@(SourceRoot)" Hosts="@(SourceLinkGitHubHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="TranslatedRepositoryUrl" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="TranslatedSourceRoots" ItemName="_TranslatedSourceRoot" />
    </Microsoft.SourceLink.GitHub.TranslateRepositoryUrls>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_TranslatedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.GitLab\build\Microsoft.SourceLink.GitLab.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.GitLab/build/Microsoft.SourceLink.GitLab.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_SourceLinkGitLabAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.GitLab.dll</_SourceLinkGitLabAssemblyFile>
    <_SourceLinkGitLabAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.GitLab.dll</_SourceLinkGitLabAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.SourceLink.GitLab.GetSourceLinkUrl" AssemblyFile="$(_SourceLinkGitLabAssemblyFile)" />
  <UsingTask TaskName="Microsoft.SourceLink.GitLab.TranslateRepositoryUrls" AssemblyFile="$(_SourceLinkGitLabAssemblyFile)" />
  <PropertyGroup>
    <SourceLinkUrlInitializerTargets>$(SourceLinkUrlInitializerTargets);_InitializeGitLabSourceLinkUrl</SourceLinkUrlInitializerTargets>
    <SourceControlManagerUrlTranslationTargets>$(SourceControlManagerUrlTranslationTargets);TranslateGitLabUrlsInSourceControlInformation</SourceControlManagerUrlTranslationTargets>
  </PropertyGroup>
  <Target Name="_InitializeGitLabSourceLinkUrl" Outputs="%(SourceRoot.Identity)">
    <!--
      The task calculates SourceLink URL for a given SourceRoot.

      If the SourceRoot is associated with a git repository with a recognized domain the <see cref="SourceLinkUrl"/>
      output property is set to the content URL corresponding to the domain, otherwise it is set to string "N/A".

      Recognized domains are specified via Hosts (initialized from SourceLinkGitLabHost item group).
      In addition, if SourceLinkHasSingleProvider is true an implicit host is parsed from RepositoryUrl.

      Example of SourceLinkGitLabHost items:

      <ItemGroup>
        <SourceLinkGitLabHost Include="mygitlab1.com" ContentUrl="http://mygitlab1.com"/>
        <SourceLinkGitLabHost Include="mygitlab2.com" />           ContentUrl defaults to https://mygitlab2.com
        <SourceLinkGitLabHost Include="mygitlab3.com:8080" />      ContentUrl defaults to https://mygitlab3.com:8080
      </ItemGroup>

      ContentUrl is optional. If not specified it defaults to "https://{domain}" or "http://{domain}", based on the scheme of SourceRoot.RepositoryUrl.
    -->
    <Microsoft.SourceLink.GitLab.GetSourceLinkUrl RepositoryUrl="$(PrivateRepositoryUrl)" SourceRoot="@(SourceRoot)" Hosts="@(SourceLinkGitLabHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="SourceLinkUrl" PropertyName="_SourceLinkUrlToUpdate" />
    </Microsoft.SourceLink.GitLab.GetSourceLinkUrl>
    <ItemGroup>
      <!-- Only update the SourceLinkUrl metadata if the SourceRoot belongs to this source control -->
      <SourceRoot Update="%(Identity)" SourceLinkUrl="$(_SourceLinkUrlToUpdate)" Condition="'$(_SourceLinkUrlToUpdate)' != 'N/A'" />
    </ItemGroup>
  </Target>
  <!-- 
    We need to translate ssh URLs to https.
  -->
  <Target Name="TranslateGitLabUrlsInSourceControlInformation">
    <ItemGroup>
      <_TranslatedSourceRoot Remove="@(_TranslatedSourceRoot)" />
    </ItemGroup>
    <Microsoft.SourceLink.GitLab.TranslateRepositoryUrls RepositoryUrl="$(ScmRepositoryUrl)" SourceRoots="@(SourceRoot)" Hosts="@(SourceLinkGitLabHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="TranslatedRepositoryUrl" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="TranslatedSourceRoots" ItemName="_TranslatedSourceRoot" />
    </Microsoft.SourceLink.GitLab.TranslateRepositoryUrls>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_TranslatedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.AzureRepos.Git\build\Microsoft.SourceLink.AzureRepos.Git.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.AzureRepos.Git/build/Microsoft.SourceLink.AzureRepos.Git.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_SourceLinkAzureReposGitAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.AzureRepos.Git.dll</_SourceLinkAzureReposGitAssemblyFile>
    <_SourceLinkAzureReposGitAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.AzureRepos.Git.dll</_SourceLinkAzureReposGitAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.SourceLink.AzureRepos.Git.GetSourceLinkUrl" AssemblyFile="$(_SourceLinkAzureReposGitAssemblyFile)" />
  <UsingTask TaskName="Microsoft.SourceLink.AzureRepos.Git.TranslateRepositoryUrls" AssemblyFile="$(_SourceLinkAzureReposGitAssemblyFile)" />
  <PropertyGroup>
    <SourceLinkUrlInitializerTargets>$(SourceLinkUrlInitializerTargets);_InitializeAzureReposGitSourceLinkUrl</SourceLinkUrlInitializerTargets>
    <SourceControlManagerUrlTranslationTargets>$(SourceControlManagerUrlTranslationTargets);TranslateAzureReposGitUrlsInSourceControlInformation</SourceControlManagerUrlTranslationTargets>
  </PropertyGroup>
  <Target Name="_InitializeAzureReposGitSourceLinkUrl" Outputs="%(SourceRoot.Identity)">
    <!--
      The task calculates SourceLink URL for a given SourceRoot.

      If the SourceRoot is associated with a git repository with a recognized domain the <see cref="SourceLinkUrl"/>
      output property is set to the content URL corresponding to the domain, otherwise it is set to string "N/A".

      Recognized domains are specified via Hosts (initialized from SourceLinkAzureReposGitHost item group).
      In addition, if SourceLinkHasSingleProvider is true an implicit host is parsed from RepositoryUrl.

      ContentUrl is optional. If not specified it defaults to "https://{domain}" or "http://{domain}", based on the scheme of SourceRoot.RepositoryUrl.
    -->
    <Microsoft.SourceLink.AzureRepos.Git.GetSourceLinkUrl RepositoryUrl="$(PrivateRepositoryUrl)" SourceRoot="@(SourceRoot)" Hosts="@(SourceLinkAzureReposGitHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="SourceLinkUrl" PropertyName="_SourceLinkUrlToUpdate" />
    </Microsoft.SourceLink.AzureRepos.Git.GetSourceLinkUrl>
    <ItemGroup>
      <!-- Only update the SourceLinkUrl metadata if the SourceRoot belongs to this source control -->
      <SourceRoot Update="%(Identity)" SourceLinkUrl="$(_SourceLinkUrlToUpdate)" Condition="'$(_SourceLinkUrlToUpdate)' != 'N/A'" />
    </ItemGroup>
  </Target>
  <!-- 
    We need to translate ssh URLs to https.
  -->
  <Target Name="TranslateAzureReposGitUrlsInSourceControlInformation">
    <ItemGroup>
      <_TranslatedSourceRoot Remove="@(_TranslatedSourceRoot)" />
    </ItemGroup>
    <Microsoft.SourceLink.AzureRepos.Git.TranslateRepositoryUrls RepositoryUrl="$(ScmRepositoryUrl)" SourceRoots="@(SourceRoot)" Hosts="@(SourceLinkAzureReposGitHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="TranslatedRepositoryUrl" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="TranslatedSourceRoots" ItemName="_TranslatedSourceRoot" />
    </Microsoft.SourceLink.AzureRepos.Git.TranslateRepositoryUrls>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_TranslatedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\Microsoft.SourceLink.Bitbucket.Git\build\Microsoft.SourceLink.Bitbucket.Git.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.SourceLink.Bitbucket.Git/build/Microsoft.SourceLink.Bitbucket.Git.targets
============================================================================================================================================
-->
  <!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the License.txt file in the project root for more information. -->
  <PropertyGroup>
    <_SourceLinkBitbucketAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\netframework\Microsoft.SourceLink.Bitbucket.Git.dll</_SourceLinkBitbucketAssemblyFile>
    <_SourceLinkBitbucketAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net\Microsoft.SourceLink.Bitbucket.Git.dll</_SourceLinkBitbucketAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.SourceLink.Bitbucket.Git.GetSourceLinkUrl" AssemblyFile="$(_SourceLinkBitbucketAssemblyFile)" />
  <UsingTask TaskName="Microsoft.SourceLink.Bitbucket.Git.TranslateRepositoryUrls" AssemblyFile="$(_SourceLinkBitbucketAssemblyFile)" />
  <PropertyGroup>
    <SourceLinkUrlInitializerTargets>$(SourceLinkUrlInitializerTargets);_InitializeBitbucketGitSourceLinkUrl</SourceLinkUrlInitializerTargets>
    <SourceControlManagerUrlTranslationTargets>$(SourceControlManagerUrlTranslationTargets);TranslateBitbucketGitUrlsInSourceControlInformation</SourceControlManagerUrlTranslationTargets>
  </PropertyGroup>
  <Target Name="_InitializeBitbucketGitSourceLinkUrl" Outputs="%(SourceRoot.Identity)">
    <!--
      The task calculates SourceLink URL for a given SourceRoot.

      If the SourceRoot is associated with a git repository with a recognized domain the <see cref="SourceLinkUrl"/>
      output property is set to the content URL corresponding to the domain, otherwise it is set to string "N/A".

      Recognized domains are specified via Hosts (initialized from SourceLinkBitbucketGitHost item group).
      In addition, if SourceLinkHasSingleProvider is true an implicit host is parsed from RepositoryUrl.

      Example of SourceLinkBitbucketGitHost items:

      <ItemGroup>
        <SourceLinkBitbucketGitHost Include="bitbucket1.com" ContentUrl="http://bitbucket1.com"/>
        <SourceLinkBitbucketGitHost Include="bitbucket2.com" />           ContentUrl defaults to https://bitbucket2.com
        <SourceLinkBitbucketGitHost Include="bitbucket3.com:8080" />      ContentUrl defaults to https://bitbucket3.com:8080
      </ItemGroup>

      ContentUrl is optional. If not specified it defaults to "https://{domain}" or "http://{domain}", based on the scheme of SourceRoot.RepositoryUrl.
    -->
    <Microsoft.SourceLink.Bitbucket.Git.GetSourceLinkUrl RepositoryUrl="$(PrivateRepositoryUrl)" SourceRoot="@(SourceRoot)" Hosts="@(SourceLinkBitbucketGitHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="SourceLinkUrl" PropertyName="_SourceLinkUrlToUpdate" />
    </Microsoft.SourceLink.Bitbucket.Git.GetSourceLinkUrl>
    <ItemGroup>
      <!-- Only update the SourceLinkUrl metadata if the SourceRoot belongs to this source control -->
      <SourceRoot Update="%(Identity)" SourceLinkUrl="$(_SourceLinkUrlToUpdate)" Condition="'$(_SourceLinkUrlToUpdate)' != 'N/A'" />
    </ItemGroup>
  </Target>
  <!-- 
    We need to translate ssh URLs to https.
  -->
  <Target Name="TranslateBitbucketGitUrlsInSourceControlInformation">
    <ItemGroup>
      <_TranslatedSourceRoot Remove="@(_TranslatedSourceRoot)" />
    </ItemGroup>
    <Microsoft.SourceLink.Bitbucket.Git.TranslateRepositoryUrls RepositoryUrl="$(ScmRepositoryUrl)" SourceRoots="@(SourceRoot)" Hosts="@(SourceLinkBitbucketGitHost)" IsSingleProvider="$(SourceLinkHasSingleProvider)">
      <Output TaskParameter="TranslatedRepositoryUrl" PropertyName="ScmRepositoryUrl" />
      <Output TaskParameter="TranslatedSourceRoots" ItemName="_TranslatedSourceRoot" />
    </Microsoft.SourceLink.Bitbucket.Git.TranslateRepositoryUrls>
    <ItemGroup>
      <SourceRoot Remove="@(SourceRoot)" />
      <SourceRoot Include="@(_TranslatedSourceRoot)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.SourceLink.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DisableStandardFrameworkResolution.targets" Condition="'$(DisableStandardFrameworkResolution)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DisableStandardFrameworkResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DisableStandardFrameworkResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <Target Name="GetReferenceAssemblyPaths" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GetFrameworkPaths" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <TargetFrameworkMonikerDisplayName Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 1.0)) and $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), 2.1))">.NET Standard $(_TargetFrameworkVersionWithoutV)</TargetFrameworkMonikerDisplayName>
    <TargetFrameworkMonikerDisplayName Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 1.0)) and $([MSBuild]::VersionLessThanOrEquals($(TargetFrameworkVersion), 3.1))">.NET Core $(_TargetFrameworkVersionWithoutV)</TargetFrameworkMonikerDisplayName>
    <TargetFrameworkMonikerDisplayName Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), 5.0))">.NET $(_TargetFrameworkVersionWithoutV)</TargetFrameworkMonikerDisplayName>
    <_TargetFrameworkDirectories />
    <FrameworkPathOverride />
    <TargetFrameworkDirectory />
    <!-- all references (even the StdLib) come from packages -->
    <NoStdLib>true</NoStdLib>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.DesignerSupport.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DesignerSupport.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DesignerSupport.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(DesignerRuntimeImplementationProjectOutputGroupDependsOn)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DesignerRuntimeImplementationProjectOutputGroupDependsOn>
      $(CommonOutputGroupsDependsOn);
    </DesignerRuntimeImplementationProjectOutputGroupDependsOn>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DesignerRuntimeImplementationProjectOutputGroupDependsOn>
      $(DesignerRuntimeImplementationProjectOutputGroupDependsOn);
      _GenerateDesignerDepsFile;
      _GenerateDesignerRuntimeConfigFile;
      GetCopyToOutputDirectoryItems;
      _GatherDesignerShadowCopyFiles;
    </DesignerRuntimeImplementationProjectOutputGroupDependsOn>
    <_DesignerDepsFileName>$(AssemblyName).designer.deps.json</_DesignerDepsFileName>
    <_DesignerRuntimeConfigFileName>$(AssemblyName).designer.runtimeconfig.json</_DesignerRuntimeConfigFileName>
    <_DesignerDepsFilePath>$(IntermediateOutputPath)$(_DesignerDepsFileName)</_DesignerDepsFilePath>
    <_DesignerRuntimeConfigFilePath>$(IntermediateOutputPath)$(_DesignerRuntimeConfigFileName)</_DesignerRuntimeConfigFilePath>
  </PropertyGroup>
  <Target Name="DesignerRuntimeImplementationProjectOutputGroup" DependsOnTargets="$(DesignerRuntimeImplementationProjectOutputGroupDependsOn)" Returns="@(DesignerRuntimeImplementationProjectOutputGroupOutput)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_GenerateDesignerDepsFile" Inputs="$(MSBuildAllProjects);$(ProjectAssetsFile)" Outputs="$(_DesignerDepsFilePath)" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      NOTE: We do not include the main assembly info or non-NuGet dependencies
      in designer deps file as these files may not be built yet at design time.
      Instead, we rely on SetAppPaths in runtimeconfig to allow loading of
      non-NuGet assets from shadow copied app base directory. This further
      allows loading of designer dll(s) that are not seen by the build.
    -->
    <GenerateDepsFile AssemblyName="_" AssemblyExtension="_" AssemblyVersion="_" AssetsFilePath="$(ProjectAssetsFile)" DepsFilePath="$(_DesignerDepsFilePath)" IncludeMainProject="false" TrimDepsJsonLibrariesWithoutAssets="$(TrimDepsJsonLibrariesWithoutAssets)" IncludeRuntimeFileVersions="$(IncludeFileVersionsInDependencyFile)" IsSelfContained="false" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" ProjectPath="$(MSBuildProjectFullPath)" RuntimeFrameworks="@(RuntimeFramework)" CompileReferences="@(ResolvedCompileFileDefinitions)" ResolvedNuGetFiles="@(NativeCopyLocalItems);@(ResourceCopyLocalItems);@(RuntimeCopyLocalItems)" ResolvedRuntimeTargetsFiles="@(RuntimeTargetsCopyLocalItems)" TargetFramework="$(TargetFramework)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" IncludeProjectsNotInAssetsFile="$(IncludeProjectsNotInAssetsFileInDepsFile)" />
    <ItemGroup>
      <!-- Designer will rename to <surface process name>.deps.json -->
      <DesignerRuntimeImplementationProjectOutputGroupOutput Include="$([MSBuild]::NormalizePath($(_DesignerDepsFilePath)))" TargetPath="$(_DesignerDepsFileName)" />
      <FileWrites Include="$(_DesignerDepsFilePath)" />
    </ItemGroup>
  </Target>
  <Target Name="_GenerateDesignerRuntimeConfigFile" Inputs="$(MSBuildAllProjects);$(ProjectAssetsFile)" Outputs="$(_DesignerRuntimeConfigFilePath)" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_DesignerHostConfigurationOption Include="Microsoft.NETCore.DotNetHostPolicy.SetAppPaths" Value="true" />
    </ItemGroup>
    <GenerateRuntimeConfigurationFiles AdditionalProbingPaths="@(AdditionalProbingPath)" AssetsFilePath="$(ProjectAssetsFile)" HostConfigurationOptions="@(RuntimeHostConfigurationOption);@(_DesignerHostConfigurationOption)" IsSelfContained="false" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeConfigPath="$(_DesignerRuntimeConfigFilePath)" RuntimeFrameworks="@(RuntimeFramework)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" UserRuntimeConfig="$(UserRuntimeConfig)" WriteAdditionalProbingPathsToMainConfig="true" AlwaysIncludeCoreFramework="$(AlwaysIncludeCoreFrameworkInRuntimeConfig)" />
    <ItemGroup>
      <!-- Designer will rename to <surface process name>.runtimeconfig.json -->
      <DesignerRuntimeImplementationProjectOutputGroupOutput Include="$([MSBuild]::NormalizePath($(_DesignerRuntimeConfigFilePath)))" TargetPath="$(_DesignerRuntimeConfigFileName)" />
      <FileWrites Include="$(_DesignerRuntimeConfigFilePath)" />
    </ItemGroup>
  </Target>
  <Target Name="_GatherDesignerShadowCopyFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_DesignerShadowCopy Include="@(ReferenceCopyLocalPaths)" />
      <!-- For .NET Core, we do not include NuGet package assets, as the designer will load these from the NuGet cache. -->
      <_DesignerShadowCopy Remove="@(_ResolvedCopyLocalBuildAssets)" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'" />
      <!-- For .NET Core runtime pack assets, we do not include them regardless of whether the app is
              self-contained, as they will be loaded from the shared framework.  However, for runtime pack
              assets where RuntimePackAlwaysCopyLocal is true, there is no shared framework, so we still
              include those.  -->
      <_DesignerShadowCopy Remove="@(RuntimePackAsset)" Condition="'%(RuntimePackAsset.RuntimePackAlwaysCopyLocal)' != 'true'" />
      <DesignerRuntimeImplementationProjectOutputGroupOutput Include="@(_DesignerShadowCopy->'%(FullPath)')" TargetPath="%(_DesignerShadowCopy.DestinationSubDirectory)%(_DesignerShadowCopy.Filename)%(_DesignerShadowCopy.Extension)" />
      <!-- Include ijwhost.dll for projects that use it -->
      <DesignerRuntimeImplementationProjectOutputGroupOutput Include="@(AllItemsFullPathWithTargetPath-&gt;WithMetadataValue('Filename', '$(_DotNetIjwHostLibraryNameWithoutExtension)')-&gt;WithMetadataValue('Extension', '$(_IjwHostLibraryExtension)'))" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.GenerateAssemblyInfo.targets" Condition="'$(UsingNETSdkDefaults)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.GenerateAssemblyInfo.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.GenerateAssemblyInfo.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    ============================================================
                                     GenerateAssemblyInfo

    Generates assembly info source to intermediate directory
    ============================================================
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GeneratedAssemblyInfoFile Condition="'$(GeneratedAssemblyInfoFile)' ==''">$(IntermediateOutputPath)$(MSBuildProjectName).AssemblyInfo$(DefaultLanguageSourceExtension)</GeneratedAssemblyInfoFile>
    <GenerateAssemblyInfo Condition="'$(GenerateAssemblyInfo)' == ''">true</GenerateAssemblyInfo>
  </PropertyGroup>
  <PropertyGroup Condition="'$(GenerateAssemblyInfo)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateAssemblyCompanyAttribute Condition="'$(GenerateAssemblyCompanyAttribute)' == ''">true</GenerateAssemblyCompanyAttribute>
    <GenerateAssemblyConfigurationAttribute Condition="'$(GenerateAssemblyConfigurationAttribute)' == ''">true</GenerateAssemblyConfigurationAttribute>
    <GenerateAssemblyCopyrightAttribute Condition="'$(GenerateAssemblyCopyrightAttribute)' == ''">true</GenerateAssemblyCopyrightAttribute>
    <GenerateAssemblyDescriptionAttribute Condition="'$(GenerateAssemblyDescriptionAttribute)' == ''">true</GenerateAssemblyDescriptionAttribute>
    <GenerateAssemblyFileVersionAttribute Condition="'$(GenerateAssemblyFileVersionAttribute)' == ''">true</GenerateAssemblyFileVersionAttribute>
    <GenerateAssemblyInformationalVersionAttribute Condition="'$(GenerateAssemblyInformationalVersionAttribute)' == ''">true</GenerateAssemblyInformationalVersionAttribute>
    <GenerateAssemblyTrademarkAttribute Condition="'$(GenerateAssemblyTrademarkAttribute)' == ''">true</GenerateAssemblyTrademarkAttribute>
    <GenerateAssemblyProductAttribute Condition="'$(GenerateAssemblyProductAttribute)' == ''">true</GenerateAssemblyProductAttribute>
    <GenerateAssemblyTitleAttribute Condition="'$(GenerateAssemblyTitleAttribute)' == ''">true</GenerateAssemblyTitleAttribute>
    <GenerateAssemblyVersionAttribute Condition="'$(GenerateAssemblyVersionAttribute)' == ''">true</GenerateAssemblyVersionAttribute>
    <GenerateRepositoryUrlAttribute Condition="'$(GenerateRepositoryUrlAttribute)' == '' and !('$(TargetFrameworkIdentifier)' == '.NETFramework' and $([MSBuild]::VersionLessThan($(TargetFrameworkVersion), 4.5)))">true</GenerateRepositoryUrlAttribute>
    <GenerateNeutralResourcesLanguageAttribute Condition="'$(GenerateNeutralResourcesLanguageAttribute)' == ''">true</GenerateNeutralResourcesLanguageAttribute>
    <GenerateAssemblyMetadataAttributes Condition="'$(GenerateAssemblyMetadataAttributes)' == ''">true</GenerateAssemblyMetadataAttributes>
    <IncludeSourceRevisionInInformationalVersion Condition="'$(IncludeSourceRevisionInInformationalVersion)' == ''">true</IncludeSourceRevisionInInformationalVersion>
    <GenerateInternalsVisibleToAttributes Condition="'$(GenerateInternalsVisibleToAttributes)' == ''">true</GenerateInternalsVisibleToAttributes>
    <GenerateRequiresPreviewFeaturesAttribute Condition="'$(GenerateRequiresPreviewFeaturesAttribute)' == '' and '$(IsNetCoreAppTargetingLatestTFM)' == 'true'">true</GenerateRequiresPreviewFeaturesAttribute>
    <GenerateTargetPlatformAttribute Condition="'$(GenerateTargetPlatformAttribute)' == ''">true</GenerateTargetPlatformAttribute>
    <GenerateSupportedOSPlatformAttribute Condition="'$(GenerateSupportedOSPlatformAttribute)' == ''">true</GenerateSupportedOSPlatformAttribute>
    <GenerateDisableRuntimeMarshallingAttribute Condition="'$(GenerateDisableRuntimeMarshallingAttribute)' == ''">true</GenerateDisableRuntimeMarshallingAttribute>
  </PropertyGroup>
  <!--
    Note that this must run before every invocation of CoreCompile to ensure that all compiler
    runs see the generated assembly info. There is at least one scenario involving Xaml
    where CoreCompile is invoked without other potential hooks such as Compile or CoreBuild,
    etc., so we hook directly on to CoreCompile. Furthermore, we  must run *after*
    PrepareForBuild to ensure that the intermediate directory has been created.

    Targets that generate Compile items are also expected to run before
    BeforeCompile targets (common targets convention).
   -->
  <Target Name="GenerateAssemblyInfo" BeforeTargets="BeforeCompile;CoreCompile" DependsOnTargets="PrepareForBuild;CoreGenerateAssemblyInfo" Condition="'$(GenerateAssemblyInfo)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="AddSourceRevisionToInformationalVersion" DependsOnTargets="GetAssemblyVersion;InitializeSourceControlInformation" Condition="'$(SourceControlInformationFeatureSupported)' == 'true' and '$(IncludeSourceRevisionInInformationalVersion)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="'$(SourceRevisionId)' != ''">
      <!-- Follow SemVer 2.0 rules -->
      <_InformationalVersionContainsPlus>false</_InformationalVersionContainsPlus>
      <_InformationalVersionContainsPlus Condition="$(InformationalVersion.Contains('+'))">true</_InformationalVersionContainsPlus>
      <InformationalVersion Condition="!$(_InformationalVersionContainsPlus)">$(InformationalVersion)+$(SourceRevisionId)</InformationalVersion>
      <InformationalVersion Condition="$(_InformationalVersionContainsPlus)">$(InformationalVersion).$(SourceRevisionId)</InformationalVersion>
    </PropertyGroup>
  </Target>
  <Target Name="GetAssemblyAttributes" DependsOnTargets="GetAssemblyVersion;InitializeSourceControlInformation;AddSourceRevisionToInformationalVersion" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <AssemblyAttribute Include="System.Reflection.AssemblyCompanyAttribute" Condition="'$(Company)' != '' and '$(GenerateAssemblyCompanyAttribute)' == 'true'">
        <_Parameter1>$(Company)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyConfigurationAttribute" Condition="'$(Configuration)' != '' and '$(GenerateAssemblyConfigurationAttribute)' == 'true'">
        <_Parameter1>$(Configuration)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyCopyrightAttribute" Condition="'$(Copyright)' != '' and '$(GenerateAssemblyCopyrightAttribute)' == 'true'">
        <_Parameter1>$(Copyright)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyDescriptionAttribute" Condition="'$(Description)' != '' and '$(GenerateAssemblyDescriptionAttribute)' == 'true'">
        <_Parameter1>$(Description)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyFileVersionAttribute" Condition="'$(FileVersion)' != '' and '$(GenerateAssemblyFileVersionAttribute)' == 'true'">
        <_Parameter1>$(FileVersion)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyInformationalVersionAttribute" Condition="'$(InformationalVersion)' != '' and '$(GenerateAssemblyInformationalVersionAttribute)' == 'true'">
        <_Parameter1>$(InformationalVersion)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyProductAttribute" Condition="'$(Product)' != '' and '$(GenerateAssemblyProductAttribute)' == 'true'">
        <_Parameter1>$(Product)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyTrademarkAttribute" Condition="'$(Trademark)' != '' and '$(GenerateAssemblyTrademarkAttribute)' == 'true'">
        <_Parameter1>$(Trademark)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyTitleAttribute" Condition="'$(AssemblyTitle)' != '' and '$(GenerateAssemblyTitleAttribute)' == 'true'">
        <_Parameter1>$(AssemblyTitle)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyVersionAttribute" Condition="'$(AssemblyVersion)' != '' and '$(GenerateAssemblyVersionAttribute)' == 'true'">
        <_Parameter1>$(AssemblyVersion)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(GenerateRepositoryUrlAttribute)' == 'true' and ('$(RepositoryUrl)' != '' or '$(PublishRepositoryUrl)' == 'true')">
        <_Parameter1>RepositoryUrl</_Parameter1>
        <_Parameter2 Condition="'$(RepositoryUrl)' != ''">$(RepositoryUrl)</_Parameter2>
        <_Parameter2 Condition="'$(RepositoryUrl)' == ''">$(PrivateRepositoryUrl)</_Parameter2>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Resources.NeutralResourcesLanguageAttribute" Condition="'$(NeutralLanguage)' != '' and '$(GenerateNeutralResourcesLanguageAttribute)' == 'true'">
        <_Parameter1>$(NeutralLanguage)</_Parameter1>
      </AssemblyAttribute>
      <InternalsVisibleTo Condition="'%(InternalsVisibleTo.PublicKey)' != ''">
        <Key>%(InternalsVisibleTo.PublicKey)</Key>
      </InternalsVisibleTo>
      <AssemblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleTo" Condition="%(InternalsVisibleTo.Identity) != '' and '$(GenerateInternalsVisibleToAttributes)' == 'true'">
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' != ''">%(InternalsVisibleTo.Identity), PublicKey=%(InternalsVisibleTo.Key)</_Parameter1>
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' == '' and '$(PublicKey)' != ''">%(InternalsVisibleTo.Identity), PublicKey=$(PublicKey)</_Parameter1>
        <_Parameter1 Condition="'%(InternalsVisibleTo.Key)' == '' and '$(PublicKey)' == ''">%(InternalsVisibleTo.Identity)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Reflection.AssemblyMetadata" Condition="%(AssemblyMetadata.Identity) != '' and '$(GenerateAssemblyMetadataAttributes)' == 'true'">
        <_Parameter1>%(AssemblyMetadata.Identity)</_Parameter1>
        <_Parameter2>%(AssemblyMetadata.Value)</_Parameter2>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Runtime.Versioning.RequiresPreviewFeaturesAttribute" Condition="'$(EnablePreviewFeatures)' == 'true' and '$(GenerateRequiresPreviewFeaturesAttribute)' == 'true'" />
    </ItemGroup>
    <ItemGroup Condition="'$(GenerateTargetPlatformAttribute)' == 'true'&#xA;                         and '$(TargetPlatformIdentifier)' != ''&#xA;                         and '$(TargetPlatformVersion)' != ''&#xA;                         and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                         and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0'))">
      <AssemblyAttribute Include="System.Runtime.Versioning.TargetPlatformAttribute">
        <_Parameter1>$(TargetPlatformIdentifier)$(TargetPlatformVersion)</_Parameter1>
      </AssemblyAttribute>
    </ItemGroup>
    <ItemGroup Condition="'$(GenerateSupportedOSPlatformAttribute)' == 'true'&#xA;                         and '$(TargetPlatformIdentifier)' != ''&#xA;                         and '$(SupportedOSPlatformVersion)' != ''&#xA;                         and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                         and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0'))">
      <AssemblyAttribute Include="System.Runtime.Versioning.SupportedOSPlatformAttribute" Condition="!$([MSBuild]::VersionEquals($(SupportedOSPlatformVersion), '0.0'))">
        <_Parameter1>$(TargetPlatformIdentifier)$(SupportedOSPlatformVersion)</_Parameter1>
      </AssemblyAttribute>
      <AssemblyAttribute Include="System.Runtime.Versioning.SupportedOSPlatformAttribute" Condition="$([MSBuild]::VersionEquals($(SupportedOSPlatformVersion), '0.0'))">
        <_Parameter1>$(TargetPlatformIdentifier)</_Parameter1>
      </AssemblyAttribute>
    </ItemGroup>
    <ItemGroup Condition="'$(GenerateDisableRuntimeMarshallingAttribute)' == 'true'&#xA;                         and '$(DisableRuntimeMarshalling)' == 'true'&#xA;                         and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                         and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '7.0'))">
      <AssemblyAttribute Include="System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute" />
    </ItemGroup>
  </Target>
  <!--
    To allow version changes to be respected on incremental builds (e.g. through CLI parameters),
    create a hash of all assembly attributes so that the cache file will change with the calculated
    assembly attribute values and msbuild will then execute CoreGenerateAssembly to generate a new file.
  -->
  <Target Name="CreateGeneratedAssemblyInfoInputsCacheFile" DependsOnTargets="GetAssemblyAttributes" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <GeneratedAssemblyInfoInputsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectName).AssemblyInfoInputs.cache</GeneratedAssemblyInfoInputsCacheFile>
    </PropertyGroup>
    <!-- We only use up to _Parameter1 for most attributes, but other targets may add additional assembly attributes with multiple parameters. -->
    <Hash ItemsToHash="@(AssemblyAttribute->'%(Identity)%(_Parameter1)%(_Parameter2)%(_Parameter3)%(_Parameter4)%(_Parameter5)%(_Parameter6)%(_Parameter7)%(_Parameter8)')">
      <Output TaskParameter="HashResult" PropertyName="_AssemblyAttributesHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_AssemblyAttributesHash)" File="$(GeneratedAssemblyInfoInputsCacheFile)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(GeneratedAssemblyInfoInputsCacheFile)" />
    </ItemGroup>
  </Target>
  <Target Name="CoreGenerateAssemblyInfo" Condition="'$(Language)'=='VB' or '$(Language)'=='C#'" DependsOnTargets="CreateGeneratedAssemblyInfoInputsCacheFile" Inputs="$(GeneratedAssemblyInfoInputsCacheFile)" Outputs="$(GeneratedAssemblyInfoFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Ensure the generated assemblyinfo file is not already part of the Compile sources, as a workaround for https://github.com/dotnet/sdk/issues/114 -->
      <Compile Remove="$(GeneratedAssemblyInfoFile)" />
    </ItemGroup>
    <WriteCodeFragment AssemblyAttributes="@(AssemblyAttribute)" Language="$(Language)" OutputFile="$(GeneratedAssemblyInfoFile)">
      <Output TaskParameter="OutputFile" ItemName="Compile" />
      <Output TaskParameter="OutputFile" ItemName="FileWrites" />
    </WriteCodeFragment>
  </Target>
  <!--
    ==================================================================
                                            GetAssemblyVersion

    Parses the nuget package version set in $(Version) and returns
    the implied $(AssemblyVersion) and $(FileVersion).

    e.g.:
        <Version>1.2.3-beta.4</Version>

    implies:
        <AssemblyVersion>1.2.3</AssemblyVersion>
        <FileVersion>1.2.3</FileVersion>

    Note that if $(AssemblyVersion) or $(FileVersion) are are already set, it
    is considered an override of the default inference from $(Version) and they
    are left unchanged by this target.
    ==================================================================
  -->
  <Target Name="GetAssemblyVersion" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetAssemblyVersion Condition="'$(AssemblyVersion)' == ''" NuGetVersion="$(Version)">
      <Output TaskParameter="AssemblyVersion" PropertyName="AssemblyVersion" />
    </GetAssemblyVersion>
    <PropertyGroup>
      <FileVersion Condition="'$(FileVersion)' == ''">$(AssemblyVersion)</FileVersion>
      <InformationalVersion Condition="'$(InformationalVersion)' == ''">$(Version)</InformationalVersion>
    </PropertyGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.GenerateGlobalUsings.targets" Condition="'$(Language)' == 'C#'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.GenerateGlobalUsings.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.GenerateGlobalUsings.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    ============================================================
                                     GenerateGlobalUsings

    Generates implicit namespace imports source to intermediate directory for C# projects
    ============================================================
    -->
  <UsingTask TaskName="GenerateGlobalUsings" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GeneratedGlobalUsingsFile Condition="'$(GeneratedGlobalUsingsFile)' ==''">$(IntermediateOutputPath)$(MSBuildProjectName).GlobalUsings.g$(DefaultLanguageSourceExtension)</GeneratedGlobalUsingsFile>
  </PropertyGroup>
  <!--
    Note that this must run before every invocation of CoreCompile to ensure that all compiler
    runs see the generated global usings. There is at least one scenario involving Xaml
    where CoreCompile is invoked without other potential hooks such as Compile or CoreBuild,
    etc., so we hook directly on to CoreCompile. Furthermore, we  must run *after*
    PrepareForBuild to ensure that the intermediate directory has been created.

    Targets that generate Compile items are also expected to run before
    BeforeCompile targets (common targets convention).
   -->
  <Target Name="GenerateGlobalUsings" BeforeTargets="BeforeCompile;CoreCompile" AfterTargets="PrepareForBuild" Condition="@(Using-&gt;Count()) != 0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateGlobalUsings Usings="@(Using)">
      <Output TaskParameter="Lines" ItemName="_GlobalUsingLines" />
    </GenerateGlobalUsings>
    <WriteLinesToFile File="$(GeneratedGlobalUsingsFile)" Lines="@(_GlobalUsingLines)" Overwrite="true" WriteOnlyWhenDifferent="true" />
    <ItemGroup>
      <Compile Include="$(GeneratedGlobalUsingsFile)" />
      <!-- Performing a clean and waiting without a build results in build warnings in VS due to all the missing namespaces, so we'll avoid recording it in FileWrites -->
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.GenerateSupportedRuntime.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.GenerateSupportedRuntime.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.GenerateSupportedRuntime.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="WriteAppConfigWithSupportedRuntime" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="SetGeneratedAppConfigMetadata" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_GenerateSupportedRuntimeIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).withSupportedRuntime.config</_GenerateSupportedRuntimeIntermediateAppConfig>
  </PropertyGroup>
  <Target Name="GenerateSupportedRuntime" Condition="'$(GenerateSupportedRuntime)' != 'false' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(HasRuntimeOutput)' == 'true'" DependsOnTargets="_WriteAppConfigWithSupportedRuntime" BeforeTargets="GenerateBindingRedirects" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SetGeneratedAppConfigMetadata AppConfigFile="@(AppConfigWithTargetPath)" TargetName="$(TargetFileName).config" GeneratedAppConfigFile="$(_GenerateSupportedRuntimeIntermediateAppConfig)">
      <Output TaskParameter="OutputAppConfigFileWithMetadata" ItemName="_GenerateSupportedRuntimeAppConfigWithTargetPath" />
    </SetGeneratedAppConfigMetadata>
    <!--Override the AppConfigWithTargetPath for downstream target-->
    <ItemGroup>
      <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
      <AppConfigWithTargetPath Include="@(_GenerateSupportedRuntimeAppConfigWithTargetPath)" />
    </ItemGroup>
  </Target>
  <Target Name="_WriteAppConfigWithSupportedRuntime" Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath)" Outputs="$(_GenerateSupportedRuntimeIntermediateAppConfig)" DependsOnTargets="PrepareForBuild" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <WriteAppConfigWithSupportedRuntime AppConfigFile="@(AppConfigWithTargetPath)" TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)" TargetFrameworkVersion="$(TargetFrameworkVersion)" TargetFrameworkProfile="$(TargetFrameworkProfile)" OutputAppConfigFile="$(_GenerateSupportedRuntimeIntermediateAppConfig)" />
    <ItemGroup>
      <FileWrites Include="@(_GenerateSupportedRuntimeAppConfigWithTargetPath)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ComposeStore.targets" Condition="'$(UsingNETSdkDefaults)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ComposeStore.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ComposeStore.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    ============================================================
                                        ComposeStore

    The main store entry point.
    ============================================================
    -->
  <Target Name="ComposeStore" DependsOnTargets="PrepareForComposeStore;&#xA;                            PrepOptimizer;&#xA;                            StoreWorkerMain;&#xA;                            _CopyResolvedUnOptimizedFiles;&#xA;                            StoreFinalizer;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        StoreWorkerMain

   Processes the store project files
    ============================================================
    -->
  <Target Name="StoreWorkerMain" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_AllProjects Include="$(AdditionalProjects.Split('%3B'))" />
      <_AllProjects Include="$(MSBuildProjectFullPath)" />
    </ItemGroup>
    <MSBuild Projects="%(_AllProjects.Identity)" Targets="StoreWorkerMapper" BuildinParallel="$(BuildinParallel)" Properties="ComposeWorkingDir=$(ComposeWorkingDir);&#xA;                             PublishDir=$(PublishDir);&#xA;                             StoreStagingDir=$(StoreStagingDir);&#xA;                             TargetFramework=$(_TFM);&#xA;                             JitPath=$(JitPath);&#xA;                             Crossgen=$(Crossgen);&#xA;                             DisableImplicitFrameworkReferences=true;&#xA;                             SkipUnchangedFiles=$(SkipUnchangedFiles);&#xA;                             PreserveStoreLayout=$(PreserveStoreLayout);&#xA;                             CreateProfilingSymbols=$(CreateProfilingSymbols);&#xA;                             StoreSymbolsStagingDir=$(StoreSymbolsStagingDir)">
      <Output ItemName="AllResolvedPackagesPublished" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>
  <!--
    ============================================================
                                        StoreWorkerMapper

   Processes each package specified in a store project file
    ============================================================
    -->
  <Target Name="StoreWorkerMapper" Returns="@(ResolvedPackagesFromMapper)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <PackageReferencesToStore Include="$(MSBuildProjectFullPath)">
        <PackageName>%(PackageReference.Identity)</PackageName>
        <PackageVersion>%(PackageReference.Version)</PackageVersion>
        <AdditionalProperties>
          StorePackageName=%(PackageReference.Identity);
          StorePackageVersion=%(PackageReference.Version);
          ComposeWorkingDir=$(ComposeWorkingDir);
          PublishDir=$(PublishDir);
          StoreStagingDir=$(StoreStagingDir);
          TargetFramework=$(TargetFramework);
          RuntimeIdentifier=$(RuntimeIdentifier);
          JitPath=$(JitPath);
          Crossgen=$(Crossgen);
          SkipUnchangedFiles=$(SkipUnchangedFiles);
          PreserveStoreLayout=$(PreserveStoreLayout);
          CreateProfilingSymbols=$(CreateProfilingSymbols);
          StoreSymbolsStagingDir=$(StoreSymbolsStagingDir);
          DisableImplicitFrameworkReferences=false;
        </AdditionalProperties>
      </PackageReferencesToStore>
    </ItemGroup>
    <!-- Restore phase -->
    <MSBuild Projects="@(PackageReferencesToStore)" Targets="RestoreForComposeStore" BuildInParallel="$(BuildInParallel)" />
    <!-- Resolve phase-->
    <MSBuild Projects="@(PackageReferencesToStore)" Targets="StoreResolver" Properties="SelfContained=false;UseAppHost=false;MSBuildProjectExtensionsPath=$(ComposeWorkingDir)\%(PackageReferencesToStore.PackageName)_$([System.String]::Copy('%(PackageReferencesToStore.PackageVersion)').Replace('*','-'))\;" BuildInParallel="$(BuildInParallel)">
      <Output ItemName="ResolvedPackagesFromMapper" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>
  <Target Name="StoreResolver" Returns="@(ResolvedPackagesPublished)" DependsOnTargets="PrepforRestoreForComposeStore;&#xA;                            StoreWorkerPerformWork" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="StoreWorkerPerformWork" DependsOnTargets="ComputeAndCopyFilesToStoreDirectory;" Condition="Exists($(StoreWorkerWorkingDir))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        StoreFinalizer

   Cleans up and produces artifacts after completion of store
    ============================================================
    -->
  <UsingTask TaskName="RemoveDuplicatePackageReferences" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="StoreFinalizer" DependsOnTargets="StoreWorkerMain;&#xA;                            _CopyResolvedOptimizedFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RemoveDuplicatePackageReferences InputPackageReferences="@(AllResolvedPackagesPublished)">
      <Output TaskParameter="UniquePackageReferences" ItemName="AllResolvedPackagesPublishedAfterFilter" />
    </RemoveDuplicatePackageReferences>
    <ItemGroup>
      <ListOfPackageReference Include="@(AllResolvedPackagesPublishedAfterFilter -> '%20%20&lt;Package Id=&quot;%(Identity)&quot; Version=&quot;%(Version)&quot; /&gt;')" />
    </ItemGroup>
    <PropertyGroup>
      <_StoreArtifactContent><![CDATA[
<StoreArtifacts>
@(ListOfPackageReference)
</StoreArtifacts>
]]></_StoreArtifactContent>
    </PropertyGroup>
    <WriteLinesToFile File="$(StoreArtifactXml)" Lines="$(_StoreArtifactContent)" Overwrite="true" />
    <Message Text="Files were composed in $(PublishDir)" Importance="high" />
    <Message Text="The list of packages stored is in $(StoreArtifactXml) " Importance="high" />
    <RemoveDir Condition="'$(PreserveComposeWorkingDir)' != 'true'" Directories="$(ComposeWorkingDir)" />
  </Target>
  <!--
    ============================================================
                                        _CopyResolvedUnOptimizedFiles

    Copy OptimizedResolvedFileToPublish items to the publish directory.
    ============================================================
    -->
  <Target Name="_CopyResolvedOptimizedFiles" DependsOnTargets="StoreWorkerMain;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_OptimizedResolvedFileToPublish Include="$(StoreStagingDir)\**\*.*" />
      <_OptimizedSymbolFileToPublish Include="$(StoreSymbolsStagingDir)\**\*.*" />
    </ItemGroup>
    <Copy SourceFiles="@(_OptimizedResolvedFileToPublish)" DestinationFolder="$(PublishDir)%(_OptimizedResolvedFileToPublish.RecursiveDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" Condition="'@(_OptimizedResolvedFileToPublish)' != ''" SkipUnchangedFiles="$(SkipUnchangedFiles)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <Copy SourceFiles="@(_OptimizedSymbolFileToPublish)" DestinationFolder="$(ProfilingSymbolsDir)%(_OptimizedSymbolFileToPublish.RecursiveDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" Condition="'@(_OptimizedSymbolFileToPublish)' != ''" SkipUnchangedFiles="$(SkipUnchangedFiles)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        PrepareForComposeStore

    Prepare the prerequisites for ComposeStore.
    ============================================================
    -->
  <Target Name="PrepareForComposeStore" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <PreserveStoreLayout Condition="'$(PreserveStoreLayout)' == ''">true</PreserveStoreLayout>
      <SkipOptimization Condition="'$(RuntimeIdentifier)' == ''">true</SkipOptimization>
      <_TFM Condition="'$(_TFM)' == ''">$(TargetFramework)</_TFM>
      <SkipUnchangedFiles Condition="'$(SkipUnchangedFiles)' == ''">true</SkipUnchangedFiles>
    </PropertyGroup>
    <NETSdkError Condition="'2.0' &gt; '$(_TargetFrameworkVersionWithoutV)'" ResourceName="UnuspportedFramework" FormatArguments="$(TargetFrameworkMoniker)" />
    <NETSdkError Condition="'$(RuntimeIdentifier)' =='' and '$(_PureManagedAssets)' == ''" ResourceName="RuntimeIdentifierWasNotSpecified" />
    <NETSdkError Condition="'$(_TFM)' ==''" ResourceName="AtLeastOneTargetFrameworkMustBeSpecified" />
    <PropertyGroup>
      <DefaultComposeDir>$(UserProfileRuntimeStorePath)</DefaultComposeDir>
      <_ProfilingSymbolsDirectoryName>symbols</_ProfilingSymbolsDirectoryName>
      <DefaultProfilingSymbolsDir>$([System.IO.Path]::Combine($(DefaultComposeDir), $(_ProfilingSymbolsDirectoryName)))</DefaultProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="'$(ProfilingSymbolsDir)' == '' and '$(ComposeDir)' != ''">$([System.IO.Path]::Combine($(ComposeDir), $(_ProfilingSymbolsDirectoryName)))</ProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="'$(ProfilingSymbolsDir)' != '' and '$(DoNotDecorateComposeDir)' != 'true'">$([System.IO.Path]::Combine($(ProfilingSymbolsDir), $(PlatformTarget)))</ProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="'$(ProfilingSymbolsDir)' == ''">$(DefaultProfilingSymbolsDir)</ProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="'$(DoNotDecorateComposeDir)' != 'true'">$([System.IO.Path]::Combine($(ProfilingSymbolsDir), $(_TFM)))</ProfilingSymbolsDir>
      <ProfilingSymbolsDir Condition="!HasTrailingSlash('$(ProfilingSymbolsDir)')">$(ProfilingSymbolsDir)\</ProfilingSymbolsDir>
      <ComposeDir Condition="'$(ComposeDir)' == ''">$(DefaultComposeDir)</ComposeDir>
      <ComposeDir Condition="'$(DoNotDecorateComposeDir)' != 'true'">$([System.IO.Path]::Combine($(ComposeDir), $(PlatformTarget)))</ComposeDir>
      <ComposeDir Condition="'$(DoNotDecorateComposeDir)' != 'true'">$([System.IO.Path]::Combine($(ComposeDir), $(_TFM)))</ComposeDir>
      <StoreArtifactXml>$([System.IO.Path]::Combine($(ComposeDir),"artifact.xml"))</StoreArtifactXml>
      <PublishDir>$([System.IO.Path]::GetFullPath($(ComposeDir)))</PublishDir>
      <_RandomFileName>$([System.IO.Path]::GetRandomFileName())</_RandomFileName>
      <TEMP Condition="'$(TEMP)' == ''">$([System.IO.Path]::GetTempPath())</TEMP>
      <ComposeWorkingDir Condition="'$(ComposeWorkingDir)' == ''">$([System.IO.Path]::Combine($(TEMP), $(_RandomFileName)))</ComposeWorkingDir>
      <ComposeWorkingDir>$([System.IO.Path]::GetFullPath($(ComposeWorkingDir)))</ComposeWorkingDir>
      <StoreStagingDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"StagingDir"))</StoreStagingDir>
      <!-- Will contain optimized managed assemblies in nuget cache layout -->
      <StoreSymbolsStagingDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"SymbolsStagingDir"))</StoreSymbolsStagingDir>
      <!-- Ensure any PublishDir has a trailing slash, so it can be concatenated -->
      <PublishDir Condition="!HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
    </PropertyGroup>
    <PropertyGroup Condition="'$(CreateProfilingSymbols)' == ''">
      <!-- There is no support for profiling symbols on OSX -->
      <CreateProfilingSymbols Condition="$(RuntimeIdentifier.StartsWith('osx'))">false</CreateProfilingSymbols>
      <CreateProfilingSymbols Condition="'$(CreateProfilingSymbols)' == ''">true</CreateProfilingSymbols>
    </PropertyGroup>
    <NETSdkError Condition="Exists($(ComposeWorkingDir))" ResourceName="FolderAlreadyExists" FormatArguments="$(ComposeWorkingDir)" />
    <MakeDir Directories="$(PublishDir)" />
    <MakeDir Directories="$(StoreStagingDir)" />
  </Target>
  <Target Name="PrepforRestoreForComposeStore" DependsOnTargets="_DefaultMicrosoftNETPlatformLibrary" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <StorePackageVersionForFolderName>$(StorePackageVersion.Replace('*','-'))</StorePackageVersionForFolderName>
      <StoreWorkerWorkingDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"$(StorePackageName)_$(StorePackageVersionForFolderName)"))</StoreWorkerWorkingDir>
      <_PackageProjFile>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "Restore.csproj"))</_PackageProjFile>
      <BaseIntermediateOutputPath>$(StoreWorkerWorkingDir)\</BaseIntermediateOutputPath>
      <ProjectAssetsFile>$(BaseIntermediateOutputPath)\project.assets.json</ProjectAssetsFile>
    </PropertyGroup>
    <PropertyGroup>
      <PackagesToPrune>$(MicrosoftNETPlatformLibrary)</PackagesToPrune>
      <SelfContained Condition="'$(SelfContained)' == ''">true</SelfContained>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        RestoreForComposeStore

    Restores the package
    ============================================================
    -->
  <Target Name="RestoreForComposeStore" DependsOnTargets="PrepforRestoreForComposeStore;" Condition="!Exists($(StoreWorkerWorkingDir))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <MakeDir Directories="$(StoreWorkerWorkingDir)" />
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Restore" Properties="RestoreGraphProjectInput=$(MSBuildProjectFullPath);&#xA;                             RestoreOutputPath=$(BaseIntermediateOutputPath);&#xA;                             StorePackageName=$(StorePackageName);&#xA;                             StorePackageVersion=$(StorePackageVersion);&#xA;                             RuntimeIdentifier=$(RuntimeIdentifier);&#xA;                             TargetFramework=$(TargetFramework);" />
  </Target>
  <!--
    ============================================================
                                        ComputeAndCopyFilesToStoreDirectory

    Computes the list of all files to copy to the publish directory and then publishes them.
    ============================================================
    -->
  <Target Name="ComputeAndCopyFilesToStoreDirectory" DependsOnTargets="ComputeFilesToStore;&#xA;                            CopyFilesToStoreDirectory" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        CopyFilesToStoreDirectory

    Copy all build outputs, satellites and other necessary files to the publish directory.
    ============================================================
    -->
  <Target Name="CopyFilesToStoreDirectory" DependsOnTargets="_CopyResolvedUnOptimizedFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _CopyResolvedUnOptimizedFiles

    Copy _UnOptimizedResolvedFileToPublish items to the publish directory.
    ============================================================
    -->
  <Target Name="_CopyResolvedUnOptimizedFiles" DependsOnTargets="_ComputeResolvedFilesToStoreTypes;&#xA;                            _RunOptimizer" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Copy SourceFiles="@(_UnOptimizedResolvedFileToPublish)" DestinationFiles="$(PublishDir)%(_UnOptimizedResolvedFileToPublish.DestinationSubPath)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" SkipUnchangedFiles="$(SkipUnchangedFiles)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _ComputeResolvedFilesToStoreTypes
    ============================================================
    -->
  <Target Name="_ComputeResolvedFilesToStoreTypes" DependsOnTargets="_GetResolvedFilesToStore;_SplitResolvedFiles;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _SplitResolvedFiles

    Splits ResolvedFileToPublish items into 'managed' and 'unmanaged' buckets.
    ============================================================
    -->
  <Target Name="_SplitResolvedFiles" Condition="$(SkipOptimization) !='true' " DependsOnTargets="_GetResolvedFilesToStore" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ManagedResolvedFileToPublishCandidates Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.AssetType)'=='runtime'" />
      <_UnOptimizedResolvedFileToPublish Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.AssetType)'!='runtime'" />
    </ItemGroup>
    <PropertyGroup>
      <SkipOptimization Condition="'@(_ManagedResolvedFileToPublishCandidates)'==''">true</SkipOptimization>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _GetResolvedFilesToStore
    ============================================================
    -->
  <Target Name="_GetResolvedFilesToStore" Condition="$(SkipOptimization) == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_UnOptimizedResolvedFileToPublish Include="@(ResolvedFileToPublish)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ComputeFilesToStore

    Gathers all the files that need to be copied to the publish directory.
    ============================================================
    -->
  <UsingTask TaskName="FilterResolvedFiles" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ComputeFilesToStore" DependsOnTargets="_ComputeResolvedCopyLocalPublishAssets;&#xA;                            _ComputeCopyToPublishDirectoryItems" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <CopyBuildOutputToPublishDirectory Condition="'$(CopyBuildOutputToPublishDirectory)'==''">true</CopyBuildOutputToPublishDirectory>
      <CopyOutputSymbolsToPublishDirectory Condition="'$(CopyOutputSymbolsToPublishDirectory)'==''">true</CopyOutputSymbolsToPublishDirectory>
    </PropertyGroup>
    <FilterResolvedFiles AssetsFilePath="$(ProjectAssetsFile)" ResolvedFiles="@(_ResolvedCopyLocalPublishAssets)" PackagesToPrune="$(PackagesToPrune)" TargetFramework="$(TargetFramework)" RuntimeIdentifier="$(RuntimeIdentifier)" IsSelfContained="$(SelfContained)">
      <Output TaskParameter="AssembliesToPublish" ItemName="ResolvedFileToPublish" />
      <Output TaskParameter="PublishedPackages" ItemName="PackagesThatWereResolved" />
    </FilterResolvedFiles>
    <ItemGroup>
      <ResolvedPackagesPublished Include="@(PackagesThatWereResolved)" Condition="$(DoNotTrackPackageAsResolved) !='true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                       PrepRestoreForStoreProjects

    Removes specified PackageReference for store and inserts the specified StorePackageName
    ============================================================
    -->
  <Target Name="PrepRestoreForStoreProjects" BeforeTargets="_GenerateProjectRestoreGraphPerFramework;" Condition="'$(StorePackageName)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <PackageReference Remove="@(PackageReference)" Condition="'%(PackageReference.IsImplicitlyDefined)' != 'true'" />
      <PackageReference Include="$(StorePackageName)" Version="$(StorePackageVersion)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.CrossGen.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.CrossGen.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.CrossGen.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    For ReadyToRun compilation, default to Crossgen for .NET Core 3.x and .NET 5. If PublishReadyToRunUseCrossgen2
    is set to true in the project or on the command line, use Crossgen2 and default to composite mode. For .NET 6
    and higher, always use Crossgen2 and default to non-composite mode.
  -->
  <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishReadyToRunUseCrossgen2 Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '6.0'">true</PublishReadyToRunUseCrossgen2>
    <PublishReadyToRunComposite Condition="'$(PublishReadyToRunComposite)' == '' and '$(PublishSingleFile)' == 'true'  and '$(PublishReadyToRun)' == 'true' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '7.0'">true</PublishReadyToRunComposite>
    <PublishReadyToRunComposite Condition="'$(PublishReadyToRunComposite)' == '' and '$(_TargetFrameworkVersionWithoutV)' &gt;= '6.0'">false</PublishReadyToRunComposite>
    <PublishReadyToRunComposite Condition="'$(PublishReadyToRunComposite)' == ''">true</PublishReadyToRunComposite>
    <PublishReadyToRunComposite Condition="'$(PublishReadyToRunUseCrossgen2)' != 'true' or '$(SelfContained)' != 'true'">false</PublishReadyToRunComposite>
    <PublishReadyToRunUseRuntimePackOptimizationData Condition="'$(PublishReadyToRunUseRuntimePackOptimizationData)' == ''">true</PublishReadyToRunUseRuntimePackOptimizationData>
    <PublishReadyToRunPerfmapFormatVersion Condition="'$(PublishReadyToRunPerfmapFormatVersion)' == ''">1</PublishReadyToRunPerfmapFormatVersion>
  </PropertyGroup>
  <!--
    ============================================================
                                        PrepOptimizer

    Sets up the common infrastructure for the optimization phase
    Outputs:
        JitPath
        Crossgen
    ============================================================
    -->
  <Target Name="PrepOptimizer" DependsOnTargets="_RestoreCrossgen;" Condition="$(SkipOptimization) != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Get the coreclr path -->
    <ItemGroup>
      <_CoreclrResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)" Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='coreclr'" />
      <_CoreclrResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)" Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='libcoreclr'" />
      <_JitResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)" Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='clrjit'" />
      <_JitResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)" Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='libclrjit'" />
    </ItemGroup>
    <NETSdkError Condition="'@(_CoreclrResolvedPath-&gt;Count())' &gt; 1" ResourceName="MultipleFilesResolved" FormatArguments="coreclr" />
    <NETSdkError Condition="'@(_CoreclrResolvedPath)'== ''" ResourceName="UnableToFindResolvedPath" FormatArguments="coreclr" />
    <NETSdkError Condition="'@(_JitResolvedPath-&gt;Count())' &gt; 1" ResourceName="MultipleFilesResolved" FormatArguments="jit" />
    <NETSdkError Condition="'@(_JitResolvedPath)'== ''" ResourceName="UnableToFindResolvedPath" FormatArguments="jit" />
    <!-- Get the crossgen and jit path-->
    <PropertyGroup>
      <_CoreclrPath>@(_CoreclrResolvedPath)</_CoreclrPath>
      <JitPath>@(_JitResolvedPath)</JitPath>
      <_CoreclrDir>$([System.IO.Path]::GetDirectoryName($(_CoreclrPath)))</_CoreclrDir>
      <_CoreclrPkgDir>$([System.IO.Path]::Combine($(_CoreclrDir),"..\..\..\"))</_CoreclrPkgDir>
      <CrossgenDir>$([System.IO.Path]::Combine($(_CoreclrPkgDir),"tools"))</CrossgenDir>
      <!-- TODO override with rid specific tools path for x-arch -->
      <Crossgen>$([System.IO.Path]::Combine($(CrossgenDir),"crossgen"))</Crossgen>
      <Crossgen Condition="$([MSBuild]::IsOSPlatform(`Windows`))">$([System.IO.Path]::Combine($(CrossgenDir),"crossgen.exe"))</Crossgen>
    </PropertyGroup>
    <NETSdkError Condition="!Exists($(Crossgen))" ResourceName="UnableToFindResolvedPath" FormatArguments="$(Crossgen)" />
    <!-- Copy crossgen into the netcoreapp folder to ensure it can load Microsoft.DiaSymReader.Native when creating PDBs -->
    <Copy SourceFiles="$(Crossgen)" DestinationFolder="$(_NetCoreRefDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <PropertyGroup>
      <Crossgen>$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine($(_NetCoreRefDir), $([System.IO.Path]::GetFileName($(Crossgen)))))))</Crossgen>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _RunOptimizer

    Start the optimization phase
    ============================================================
    -->
  <Target Name="_RunOptimizer" DependsOnTargets="_InitializeBasicProps;&#xA;                            _ComputeResolvedFilesToStoreTypes;&#xA;                            _SetupStageForCrossgen" Condition="$(SkipOptimization) != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <AssembliestoCrossgen Include="$(MSBuildProjectFullPath)">
        <Properties>
          CrossgenExe=$(Crossgen);
          CrossgenJit=$(JitPath);
          CrossgenInputAssembly=%(_ManagedResolvedFilesToOptimize.Fullpath);
          CrossgenOutputAssembly=$(_RuntimeOptimizedDir)$(DirectorySeparatorChar)%(_ManagedResolvedFilesToOptimize.FileName)%(_ManagedResolvedFilesToOptimize.Extension);
          CrossgenSubOutputPath=%(_ManagedResolvedFilesToOptimize.DestinationSubPath);
          _RuntimeOptimizedDir=$(_RuntimeOptimizedDir);
          PublishDir=$(StoreStagingDir);
          CrossgenPlatformAssembliesPath=$(_RuntimeRefDir)$(PathSeparator)$(_NetCoreRefDir);
          CreateProfilingSymbols=$(CreateProfilingSymbols);
          StoreSymbolsStagingDir=$(StoreSymbolsStagingDir);
          _RuntimeSymbolsDir=$(_RuntimeSymbolsDir)
        </Properties>
      </AssembliestoCrossgen>
    </ItemGroup>
    <!-- CrossGen the assemblies  -->
    <MSBuild Projects="@(AssembliestoCrossgen)" Targets="RunCrossGen" BuildInParallel="$(BuildInParallel)" Condition="'@(_ManagedResolvedFilesToOptimize)' != ''" />
  </Target>
  <!--
    ============================================================
                                        RunCrossGen
    Target Encapsulating the crossgen command
    ============================================================
    -->
  <Target Name="RunCrossGen" DependsOnTargets="_InitializeBasicProps;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <CrossgenProfilingSymbolsOutputDirectory>$([System.IO.Path]::GetDirectoryName($(_RuntimeSymbolsDir)\$(CrossgenSubOutputPath)))</CrossgenProfilingSymbolsOutputDirectory>
      <CrossgenSymbolsStagingDirectory>$([System.IO.Path]::GetDirectoryName($(StoreSymbolsStagingDir)\$(CrossgenSubOutputPath)))</CrossgenSymbolsStagingDirectory>
      <CrossgenCommandline>$(CrossgenExe) -nologo -readytorun -in "$(CrossgenInputAssembly)" -out "$(CrossgenOutputAssembly)" -jitpath "$(CrossgenJit)" -platform_assemblies_paths "$(CrossgenPlatformAssembliesPath)"</CrossgenCommandline>
      <CreateProfilingSymbolsOptionName Condition="$([MSBuild]::IsOSPlatform(`Windows`))">CreatePDB</CreateProfilingSymbolsOptionName>
      <CreateProfilingSymbolsOptionName Condition="'$(CreateProfilingSymbolsOptionName)' == ''">CreatePerfMap</CreateProfilingSymbolsOptionName>
    </PropertyGroup>
    <Message Text="CrossgenCommandline: $(CrossgenCommandline)" />
    <!--Optimization skip if the assembly is already present in the final output directory-->
    <Exec Command="$(CrossgenCommandline)" Condition="!Exists($([System.IO.Path]::Combine($(PublishDir),$(CrossgenSubOutputPath))))" IgnoreStandardErrorWarningFormat="true" />
    <Copy SourceFiles="$(CrossgenOutputAssembly)" DestinationFiles="$(PublishDir)\$(CrossgenSubOutputPath)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" Condition="!Exists($([System.IO.Path]::Combine($(PublishDir),$(CrossgenSubOutputPath))))">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
    <!-- Create profiling symbols if requested -->
    <MakeDir Directories="$(CrossgenProfilingSymbolsOutputDirectory)" Condition="'$(CreateProfilingSymbols)' == 'true' and Exists($(CrossgenOutputAssembly))" />
    <Exec Command="$(CrossgenExe) -nologo -readytorun -platform_assemblies_paths $(CrossgenPlatformAssembliesPath) -$(CreateProfilingSymbolsOptionName) $(CrossgenProfilingSymbolsOutputDirectory) $(CrossgenOutputAssembly)" Condition="'$(CreateProfilingSymbols)' == 'true' and Exists($(CrossgenOutputAssembly))" IgnoreStandardErrorWarningFormat="true" />
    <ItemGroup>
      <_ProfilingSymbols Include="$(CrossgenProfilingSymbolsOutputDirectory)\*" Condition="'$(CreateProfilingSymbols)' == 'true'" />
    </ItemGroup>
    <Copy SourceFiles="@(_ProfilingSymbols)" DestinationFolder="$(CrossgenSymbolsStagingDirectory)" Condition="'$(CreateProfilingSymbols)' == 'true'" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <Target Name="_InitializeBasicProps" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <PathSeparator>$([System.IO.Path]::PathSeparator)</PathSeparator>
      <DirectorySeparatorChar>$([System.IO.Path]::DirectorySeparatorChar)</DirectorySeparatorChar>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                       _GetCrossgenProps
    Generates props used by Crossgen
    ============================================================
    -->
  <Target Name="_GetCrossgenProps" Condition="$(SkipOptimization) != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_CrossProjFileDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"Optimize"))</_CrossProjFileDir>
      <_NetCoreRefDir>$([System.IO.Path]::Combine($(_CrossProjFileDir), "netcoreapp"))</_NetCoreRefDir>
      <!-- flat netcore app assemblies-->
    </PropertyGroup>
    <MakeDir Directories="$(_CrossProjFileDir)" />
    <PropertyGroup>
      <_CrossProjAssetsFile>$([System.IO.Path]::Combine($(_CrossProjFileDir),  project.assets.json))</_CrossProjAssetsFile>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        _SetupStageForCrossgen
    ============================================================
    -->
  <Target Name="_SetupStageForCrossgen" DependsOnTargets="_GetCrossgenProps;" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_RuntimeRefDir>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "runtimeref"))</_RuntimeRefDir>
      <!-- flat app managed assemblies -->
      <_RuntimeOptimizedDir>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "runtimopt"))</_RuntimeOptimizedDir>
      <!-- optimized app managed assemblies in nuget cache layout -->
      <_RuntimeSymbolsDir>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "runtimesymbols"))</_RuntimeSymbolsDir>
    </PropertyGroup>
    <ItemGroup>
      <_ManagedResolvedFilesToOptimize Include="@(_ManagedResolvedFileToPublishCandidates)" />
    </ItemGroup>
    <MakeDir Directories="$(_RuntimeOptimizedDir)" />
    <MakeDir Directories="$(_RuntimeSymbolsDir)" Condition="'$(CreateProfilingSymbols)' == 'true'" />
    <!-- Copy managed files to  a flat temp directory for passing it as ref -->
    <Copy SourceFiles="@(_ManagedResolvedFilesToOptimize)" DestinationFolder="$(_RuntimeRefDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _RestoreCrossgen
    Restores netcoreapp and publishes it to a temp directory
    ============================================================
    -->
  <Target Name="_RestoreCrossgen" DependsOnTargets="PrepforRestoreForComposeStore;&#xA;                           _SetupStageForCrossgen;&#xA;                           ProcessFrameworkReferences;&#xA;                           ApplyImplicitVersions;&#xA;                           _ComputePackageReferencePublish" Condition="$(SkipOptimization) != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Filter package references to the one for the platform library, in order to find the right version -->
      <PackageReferenceForCrossGen Include="@(PackageReference)" Condition="'%(Identity)' == '$(MicrosoftNETPlatformLibrary)'" />
    </ItemGroup>
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Restore" Properties="RuntimeIdentifiers=$(RuntimeIdentifier);&#xA;                             RestoreGraphProjectInput=$(MSBuildProjectFullPath);&#xA;                             RestoreOutputPath=$(_CrossProjFileDir);&#xA;                             StorePackageName=$(MicrosoftNETPlatformLibrary);&#xA;                             StorePackageVersion=%(PackageReferenceForCrossGen.Version);" />
    <!-- For future: Use ResolvePackageAssets instead of ResolveCopyLocalAssets, delete ResolveCopyLocalAssets task -->
    <ResolveCopyLocalAssets Condition="'$(_TargetFrameworkVersionWithoutV)' &lt; '3.0'" AssetsFilePath="$(_CrossProjAssetsFile)" TargetFramework="$(_TFM)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" ExcludedPackageReferences="@(_ExcludeFromPublishPackageReference)" IsSelfContained="$(SelfContained)" PreserveStoreLayout="false">
      <Output TaskParameter="ResolvedAssets" ItemName="CrossgenResolvedAssembliesToPublish" />
    </ResolveCopyLocalAssets>
    <GetPackageDirectory Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'" Items="@(RuntimePack)" AssetsFileWithAdditionalPackageFolders="$(_CrossProjAssetsFile)">
      <Output TaskParameter="Output" ItemName="_CrossgenRuntimePack" />
    </GetPackageDirectory>
    <ResolveRuntimePackAssets Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0'" FrameworkReferences="@(FrameworkReference)" ResolvedRuntimePacks="@(_CrossgenRuntimePack)" DisableTransitiveFrameworkReferenceDownloads="$(DisableTransitiveFrameworkReferenceDownloads)">
      <Output TaskParameter="RuntimePackAssets" ItemName="CrossgenResolvedAssembliesToPublish" />
    </ResolveRuntimePackAssets>
    <!-- Copy managed files to  a flat temp directory for passing it as ref for crossgen -->
    <Copy SourceFiles="@(CrossgenResolvedAssembliesToPublish)" DestinationFolder="$(_NetCoreRefDir)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        CreateReadyToRunImages

    Create ReadyToRun images for managed assemblies in _ResolvedFileToPublishAlways and _ResolvedFileToPublishPreserveNewest.
    ============================================================
    -->
  <Target Name="CreateReadyToRunImages" Condition="'$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0' And '$(PublishReadyToRun)' == 'true' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" DependsOnTargets="_PrepareForReadyToRunCompilation;&#xA;                            _CreateR2RImages;&#xA;                            _CreateR2RSymbols" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <R2RTelemetry Include="PublishReadyToRunUseCrossgen2" Value="$(PublishReadyToRunUseCrossgen2)" />
      <R2RTelemetry Include="Crossgen2PackVersion" Value="%(ResolvedCrossgen2Pack.NuGetPackageVersion)" />
      <R2RTelemetry Include="CompileListCount" Value="@(_ReadyToRunCompileList-&gt;Count())" />
      <R2RTelemetry Include="FailedCount" Value="@(_ReadyToRunCompilationFailures-&gt;Count())" />
    </ItemGroup>
    <AllowEmptyTelemetry EventName="ReadyToRun" EventData="@(R2RTelemetry)" />
    <NETSdkError Condition="'@(_ReadyToRunCompilationFailures)' != ''" ResourceName="ReadyToRunCompilationFailed" />
    <NETSdkInformation Condition="'$(_ReadyToRunCompilerHasWarnings)' != ''" ResourceName="ReadyToRunCompilationHasWarnings_Info" />
    <ItemGroup>
      <!--
      Note: we only remove the entries for the IL images and replace them with the entries for the R2R images.
      We do not do the same for PDBs, because the native PDBs created by the R2R compiler complement the IL PDBs
      and do not replace them. IL PDBs are still required for debugging. Native PDBs emitted by the R2R compiler are
      only used for profiling purposes.
      -->
      <ResolvedFileToPublish Remove="@(_ReadyToRunCompositeBuildInput)" />
      <ResolvedFileToPublish Remove="@(_ReadyToRunCompileList)" />
      <ResolvedFileToPublish Include="@(_ReadyToRunFilesToPublish)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _PrepareForReadyToRunCompilation

    Prepare build for ReadyToRun compilations. Builds list of assemblies to compile, and computes paths to ReadyToRun compiler bits
    ============================================================
    -->
  <UsingTask Condition="'$(Crossgen2TasksOverriden)' != 'true'" TaskName="PrepareForReadyToRunCompilation" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_PrepareForReadyToRunCompilation" DependsOnTargets="ResolveReadyToRunCompilers;_ComputeManagedRuntimePackAssemblies;_ComputeAssembliesToPostprocessOnPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_ReadyToRunOutputPath>$(IntermediateOutputPath)R2R</_ReadyToRunOutputPath>
    </PropertyGroup>
    <MakeDir Directories="$(_ReadyToRunOutputPath)" />
    <ItemGroup>
      <_ReadyToRunImplementationAssemblies Include="@(ResolvedFileToPublish-&gt;WithMetadataValue('PostprocessAssembly', 'true'))" />
    </ItemGroup>
    <!-- Even if app is not self-contained, crossgen requires closure of implementation assemblies. Resolve conflicts
         of the runtime pack assets as though we were copying them locally, and add them to the R2R implementation
         assembly list. -->
    <ItemGroup Condition="'$(SelfContained)' != 'true'">
      <_ReadyToRunImplementationAssemblies Include="@(_ManagedRuntimePackAssembly)" ReferenceOnly="true" />
    </ItemGroup>
    <ResolvePackageFileConflicts Condition="'$(SelfContained)' != 'true'" ReferenceCopyLocalPaths="@(_ReadyToRunImplementationAssemblies)">
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ReadyToRunImplementationAssembliesWithoutConflicts" />
    </ResolvePackageFileConflicts>
    <ItemGroup Condition="'$(SelfContained)' != 'true'">
      <_ReadyToRunImplementationAssemblies Remove="@(_ReadyToRunImplementationAssemblies)" />
      <_ReadyToRunImplementationAssemblies Include="@(_ReadyToRunImplementationAssembliesWithoutConflicts)" />
    </ItemGroup>
    <ItemGroup>
      <_ReadyToRunPgoFiles Include="@(PublishReadyToRunPgoFiles)" />
      <_ReadyToRunPgoFiles Include="@(RuntimePackAsset)" Condition="'%(RuntimePackAsset.AssetType)' == 'pgodata' and '%(RuntimePackAsset.Extension)' == '.mibc' and '$(PublishReadyToRunUseRuntimePackOptimizationData)' == 'true'" />
    </ItemGroup>
    <PrepareForReadyToRunCompilation CrossgenTool="@(CrossgenTool)" Crossgen2Tool="@(Crossgen2Tool)" OutputPath="$(_ReadyToRunOutputPath)" MainAssembly="@(IntermediateAssembly)" Assemblies="@(_ReadyToRunImplementationAssemblies)" ExcludeList="@(PublishReadyToRunExclude)" EmitSymbols="$(PublishReadyToRunEmitSymbols)" IncludeSymbolsInSingleFile="$(IncludeSymbolsInSingleFile)" ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)" Crossgen2Composite="$(PublishReadyToRunComposite)" PublishReadyToRunCompositeExclusions="@(PublishReadyToRunCompositeExclusions)" PublishReadyToRunCompositeRoots="@(PublishReadyToRunCompositeRoots)">
      <Output TaskParameter="ReadyToRunCompileList" ItemName="_ReadyToRunCompileList" />
      <Output TaskParameter="ReadyToRunSymbolsCompileList" ItemName="_ReadyToRunSymbolsCompileList" />
      <Output TaskParameter="ReadyToRunFilesToPublish" ItemName="_ReadyToRunFilesToPublish" />
      <Output TaskParameter="ReadyToRunAssembliesToReference" ItemName="_ReadyToRunAssembliesToReference" />
      <Output TaskParameter="ReadyToRunCompositeBuildReferences" ItemName="_ReadyToRunCompositeBuildReferences" />
      <Output TaskParameter="ReadyToRunCompositeBuildInput" ItemName="_ReadyToRunCompositeBuildInput" />
      <Output TaskParameter="ReadyToRunCompositeUnrootedBuildInput" ItemName="_ReadyToRunCompositeUnrootedBuildInput" />
    </PrepareForReadyToRunCompilation>
  </Target>
  <UsingTask Condition="'$(Crossgen2TasksOverriden)' != 'true'" TaskName="ResolveReadyToRunCompilers" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ResolveReadyToRunCompilers" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolveReadyToRunCompilers RuntimePacks="@(ResolvedRuntimePack)" Crossgen2Packs="@(ResolvedCrossgen2Pack)" TargetingPacks="@(ResolvedTargetingPack)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" NETCoreSdkRuntimeIdentifier="$(NETCoreSdkRuntimeIdentifier)" EmitSymbols="$(PublishReadyToRunEmitSymbols)" ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)" PerfmapFormatVersion="$(PublishReadyToRunPerfmapFormatVersion)">
      <Output TaskParameter="CrossgenTool" ItemName="CrossgenTool" />
      <Output TaskParameter="Crossgen2Tool" ItemName="Crossgen2Tool" />
    </ResolveReadyToRunCompilers>
  </Target>
  <!--
    ============================================================
                                        _CreateR2RImages

    Compiles assemblies in the _ReadyToRunCompileList list into ReadyToRun images
    ============================================================
    -->
  <UsingTask Condition="'$(Crossgen2TasksOverriden)' != 'true'" TaskName="RunReadyToRunCompiler" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_CreateR2RImages" Inputs="$(MSBuildAllProjects);@(_ReadyToRunCompileList);@(_ReadyToRunCompositeBuildInput);@(_ReadyToRunPgoFiles)" Outputs="%(_ReadyToRunCompileList.OutputR2RImage);%(_ReadyToRunCompileList.OutputPDBImage)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RunReadyToRunCompiler CrossgenTool="@(CrossgenTool)" Crossgen2Tool="@(Crossgen2Tool)" UseCrossgen2="$(PublishReadyToRunUseCrossgen2)" Crossgen2PgoFiles="@(_ReadyToRunPgoFiles)" Crossgen2ExtraCommandLineArgs="$(PublishReadyToRunCrossgen2ExtraArgs)" ImplementationAssemblyReferences="@(_ReadyToRunAssembliesToReference)" ShowCompilerWarnings="$(PublishReadyToRunShowWarnings)" CompilationEntry="@(_ReadyToRunCompileList)" ContinueOnError="ErrorAndContinue" ReadyToRunCompositeBuildReferences="@(_ReadyToRunCompositeBuildReferences)" ReadyToRunCompositeBuildInput="@(_ReadyToRunCompositeBuildInput)" ReadyToRunCompositeUnrootedBuildInput="@(_ReadyToRunCompositeUnrootedBuildInput)">
      <Output TaskParameter="ExitCode" PropertyName="_ReadyToRunCompilerExitCode" />
      <Output TaskParameter="WarningsDetected" PropertyName="_ReadyToRunWarningsDetected" />
    </RunReadyToRunCompiler>
    <PropertyGroup>
      <!-- Use distinct property here as any of the invocations can set it -->
      <_ReadyToRunCompilerHasWarnings Condition="'$(_ReadyToRunWarningsDetected)' == 'true'">true</_ReadyToRunCompilerHasWarnings>
    </PropertyGroup>
    <ItemGroup>
      <_ReadyToRunCompilationFailures Condition="'$(_ReadyToRunCompilerExitCode)' != '' And $(_ReadyToRunCompilerExitCode) != 0" Include="@(_ReadyToRunCompileList)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CreateR2RSymbols

    Emit native symbols for ReadyToRun images in the _ReadyToRunSymbolsCompileList list
    ============================================================
    -->
  <Target Name="_CreateR2RSymbols" Inputs="$(MSBuildAllProjects);@(_ReadyToRunSymbolsCompileList)" Outputs="%(_ReadyToRunSymbolsCompileList.OutputPDBImage)" Condition="'$(PublishReadyToRunUseCrossgen2)' != 'true' or '@(Crossgen2Tool -> '%(IsVersion5)')' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RunReadyToRunCompiler CrossgenTool="@(CrossgenTool)" Crossgen2Tool="@(Crossgen2Tool)" UseCrossgen2="$(PublishReadyToRunUseCrossgen2)" Crossgen2ExtraCommandLineArgs="$(PublishReadyToRunCrossgen2ExtraArgs)" ImplementationAssemblyReferences="@(_ReadyToRunAssembliesToReference)" ShowCompilerWarnings="$(PublishReadyToRunShowWarnings)" CompilationEntry="@(_ReadyToRunSymbolsCompileList)" ContinueOnError="ErrorAndContinue">
      <Output TaskParameter="ExitCode" PropertyName="_ReadyToRunCompilerExitCode" />
      <Output TaskParameter="WarningsDetected" PropertyName="_ReadyToRunWarningsDetected" />
    </RunReadyToRunCompiler>
    <PropertyGroup>
      <!-- Use distinct property here as any of the invocations can set it -->
      <_ReadyToRunCompilerHasWarnings Condition="'$(_ReadyToRunWarningsDetected)' == 'true'">true</_ReadyToRunCompilerHasWarnings>
    </PropertyGroup>
    <ItemGroup>
      <_ReadyToRunCompilationFailures Condition="'$(_ReadyToRunCompilerExitCode)' != '' And $(_ReadyToRunCompilerExitCode) != 0" Include="@(_ReadyToRunSymbolsCompileList)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ObsoleteReferences.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ObsoleteReferences.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ObsoleteReferences.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(NETCoreSdkBundledCliToolsProps)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETCoreSdkBundledCliToolsProps>$(MSBuildThisFileDirectory)..\..\..\Microsoft.NETCoreSdk.BundledCliTools.props</NETCoreSdkBundledCliToolsProps>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NETCoreSdkBundledCliToolsProps)" Condition="Exists('$(NETCoreSdkBundledCliToolsProps)')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Microsoft.NETCoreSdk.BundledCliTools.props
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NETCoreSdk.BundledCliTools.props

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup />
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ObsoleteReferences.targets
============================================================================================================================================
-->
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_ReferenceToObsoleteDotNetCliTool Include="@(DotNetCliToolReference)" />
    <DotNetCliToolReference Remove="@(BundledDotNetCliToolReference)" />
    <_ReferenceToObsoleteDotNetCliTool Remove="@(DotNetCliToolReference)" />
  </ItemGroup>
  <Target Name="_CheckForObsoleteDotNetCliToolReferences" BeforeTargets="CollectPackageReferences" Condition=" '$(SuppressObsoleteDotNetCliToolWarning)' != 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkWarning Condition=" '%(_ReferenceToObsoleteDotNetCliTool.Identity)' != '' " ResourceName="ProjectContainsObsoleteDotNetCliTool" FormatArguments="%(_ReferenceToObsoleteDotNetCliTool.Identity)" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Publish.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Publish.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Publish.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefaultCopyToPublishDirectoryMetadata Condition="'$(DefaultCopyToPublishDirectoryMetadata)' == ''">true</DefaultCopyToPublishDirectoryMetadata>
    <_GetChildProjectCopyToPublishDirectoryItems Condition="'$(_GetChildProjectCopyToPublishDirectoryItems)' == ''">true</_GetChildProjectCopyToPublishDirectoryItems>
    <IsPublishable Condition="'$(IsPublishable)' == ''">true</IsPublishable>
  </PropertyGroup>
  <!-- Trimming/AOT/publish* property configuration -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- PublishAot depends on PublishTrimmed. This must be set early enough for the KnownILLinkPack to be restored. -->
    <PublishTrimmed Condition="'$(PublishTrimmed)' == '' And '$(PublishAot)' == 'true'">true</PublishTrimmed>
    <IsTrimmable Condition="'$(IsTrimmable)' == '' and '$(IsAotCompatible)' == 'true'">true</IsTrimmable>
    <_FirstTargetFrameworkToSupportTrimming>net6.0</_FirstTargetFrameworkToSupportTrimming>
    <_FirstTargetFrameworkToSupportAot>net7.0</_FirstTargetFrameworkToSupportAot>
    <_FirstTargetFrameworkToSupportSingleFile>net6.0</_FirstTargetFrameworkToSupportSingleFile>
    <_FirstTargetFrameworkVersionToSupportTrimAnalyzer>$([MSBuild]::GetTargetFrameworkVersion('$(_FirstTargetFrameworkToSupportTrimming)'))</_FirstTargetFrameworkVersionToSupportTrimAnalyzer>
    <_FirstTargetFrameworkVersionToSupportAotAnalyzer>$([MSBuild]::GetTargetFrameworkVersion('$(_FirstTargetFrameworkToSupportAot)'))</_FirstTargetFrameworkVersionToSupportAotAnalyzer>
    <_FirstTargetFrameworkVersionToSupportSingleFileAnalyzer>$([MSBuild]::GetTargetFrameworkVersion('$(_FirstTargetFrameworkToSupportSingleFile)'))</_FirstTargetFrameworkVersionToSupportSingleFileAnalyzer>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Condition="'$(IsAotCompatible)' == 'true'" Include="IsAotCompatible" />
    <ProjectCapability Condition="'$(IsTrimmable)' == 'true'" Include="IsTrimmable" />
    <ProjectCapability Condition="'$(PublishAot)' == 'true'" Include="PublishAot" />
    <ProjectCapability Condition="'$(PublishReadyToRun)' == 'true'" Include="PublishReadyToRun" />
    <ProjectCapability Condition="'$(PublishSingleFile)' == 'true'" Include="PublishSingleFile" />
    <ProjectCapability Condition="'$(PublishTrimmed)' == 'true'" Include="PublishTrimmed" />
  </ItemGroup>
  <ItemDefinitionGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolvedFileToPublish>
      <CopyToPublishDirectory>Always</CopyToPublishDirectory>
    </ResolvedFileToPublish>
  </ItemDefinitionGroup>
  <Target Name="_ComputeToolPackInputsToProcessFrameworkReferences" BeforeTargets="ProcessFrameworkReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Keep this in sync with the warnings produced for RequiresILLinkPack in ProcessFrameworkReferences.cs.
         Must be set late enough to see the inferred value of EnableSingleFileAnalyzer. -->
    <PropertyGroup>
      <_RequiresILLinkPack Condition="'$(_RequiresILLinkPack)' == '' And (&#xA;          '$(PublishAot)' == 'true' Or&#xA;          '$(IsAotCompatible)' == 'true' Or '$(EnableAotAnalyzer)' == 'true' Or&#xA;          '$(PublishTrimmed)' == 'true' Or&#xA;          '$(IsTrimmable)' == 'true' Or '$(EnableTrimAnalyzer)' == 'true' Or&#xA;          '$(EnableSingleFileAnalyzer)' == 'true')">true</_RequiresILLinkPack>
      <_RequiresILLinkPack Condition="'$(_RequiresILLinkPack)' == ''">false</_RequiresILLinkPack>
    </PropertyGroup>
    <!-- ProcessFrameworkReferences warns when the project settings introduce a dependency on a
         tool pack that's not available for the target framework. For trimming, AOT, and single-file, the recommendation
         is to multitarget the project to include a more recent TargetFramework. For correctly multitargeted
         projects, the warning is usually just noise, so we silence it.

         Correctly multitargeted projects include a TargetFramework that is compatible with the requested
         functionality (trimming/AOT/single-file), and doesn't leave a "gap" where the incompatible TargetFramework's
         assembly could be consumed from an app that uses the functionality. In other words, correctly multitargeted
         projects should include at least one TFM that:
         - supports the given functionality, and
         - is no larger than the minimum non-EOL TargetFramework that supports this functionality.

         The following logic determines whether the project is correctly multi-targeted based on its TargetFrameworks,
         and silences the warning if it is. -->
    <PropertyGroup>
      <!-- The min non-EOL TFM has already caught up with the first TFM to support trimming/singlefile. No need to compare against it. -->
      <_MinNonEolTargetFrameworkForTrimming>$(_MinimumNonEolSupportedNetCoreTargetFramework)</_MinNonEolTargetFrameworkForTrimming>
      <_MinNonEolTargetFrameworkForSingleFile>$(_MinimumNonEolSupportedNetCoreTargetFramework)</_MinNonEolTargetFrameworkForSingleFile>
      <!-- Get the min non-EOL TFM that supports AOT. -->
      <_MinNonEolTargetFrameworkForAot>$(_MinimumNonEolSupportedNetCoreTargetFramework)</_MinNonEolTargetFrameworkForAot>
      <_MinNonEolTargetFrameworkForAot Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(_FirstTargetFrameworkToSupportAot)', '$(_MinimumNonEolSupportedNetCoreTargetFramework)'))">$(_FirstTargetFrameworkToSupportAot)</_MinNonEolTargetFrameworkForAot>
    </PropertyGroup>
    <ItemGroup>
      <_TargetFramework Include="$(TargetFrameworks)" />
      <_DecomposedTargetFramework Include="@(_TargetFramework)">
        <SupportsTrimming>$([MSBuild]::IsTargetFrameworkCompatible('%(Identity)', '$(_FirstTargetFrameworkToSupportTrimming)'))</SupportsTrimming>
        <SupportedByMinNonEolTargetFrameworkForTrimming>$([MSBuild]::IsTargetFrameworkCompatible('$(_MinNonEolTargetFrameworkForTrimming)', '%(Identity)'))</SupportedByMinNonEolTargetFrameworkForTrimming>
        <SupportsAot>$([MSBuild]::IsTargetFrameworkCompatible('%(Identity)', '$(_FirstTargetFrameworkToSupportAot)'))</SupportsAot>
        <SupportedByMinNonEolTargetFrameworkForAot>$([MSBuild]::IsTargetFrameworkCompatible('$(_MinNonEolTargetFrameworkForAot)', '%(Identity)'))</SupportedByMinNonEolTargetFrameworkForAot>
        <SupportsSingleFile>$([MSBuild]::IsTargetFrameworkCompatible('%(Identity)', '$(_FirstTargetFrameworkToSupportSingleFile)'))</SupportsSingleFile>
        <SupportedByMinNonEolTargetFrameworkForSingleFile>$([MSBuild]::IsTargetFrameworkCompatible('$(_MinNonEolTargetFrameworkForSingleFile)', '%(Identity)'))</SupportedByMinNonEolTargetFrameworkForSingleFile>
      </_DecomposedTargetFramework>
      <_TargetFrameworkToSilenceIsTrimmableUnsupportedWarning Include="@(_DecomposedTargetFramework)" Condition="'%(SupportsTrimming)' == 'true' And '%(SupportedByMinNonEolTargetFrameworkForTrimming)' == 'true'" />
      <_TargetFrameworkToSilenceIsAotCompatibleUnsupportedWarning Include="@(_DecomposedTargetFramework->'%(Identity)')" Condition="'%(SupportsAot)' == 'true' And '%(SupportedByMinNonEolTargetFrameworkForAot)' == 'true'" />
      <_TargetFrameworkToSilenceEnableSingleFileAnalyzerUnsupportedWarning Include="@(_DecomposedTargetFramework)" Condition="'%(SupportsSingleFile)' == 'true' And '%(SupportedByMinNonEolTargetFrameworkForSingleFile)' == 'true'" />
    </ItemGroup>
    <PropertyGroup>
      <!-- Don't warn if the library multitargets and includes TFM that's supported by trimming/AOT and is supported by the min non-EOL TFM that supports trimming/AOT. -->
      <_SilenceIsTrimmableUnsupportedWarning Condition="'$(_SilenceIsTrimmableUnsupportedWarning)' == '' And&#xA;                                                        @(_TargetFrameworkToSilenceIsTrimmableUnsupportedWarning-&gt;Count()) &gt; 0">true</_SilenceIsTrimmableUnsupportedWarning>
      <_SilenceIsAotCompatibleUnsupportedWarning Condition="'$(_SilenceIsAotCompatibleUnsupportedWarning)' == '' And&#xA;                                                            @(_TargetFrameworkToSilenceIsAotCompatibleUnsupportedWarning-&gt;Count()) &gt; 0">true</_SilenceIsAotCompatibleUnsupportedWarning>
      <_SilenceEnableSingleFileAnalyzerUnsupportedWarning Condition="'$(_SilenceEnableSingleFileAnalyzerUnsupportedWarning)' == '' And&#xA;                                                          @(_TargetFrameworkToSilenceEnableSingleFileAnalyzerUnsupportedWarning-&gt;Count()) &gt; 0">true</_SilenceEnableSingleFileAnalyzerUnsupportedWarning>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        Publish

    The main publish entry point.
    ============================================================
    -->
  <!--<Import Project="Microsoft.NET.ClickOnce.targets" Condition="'$(PublishProtocol)' == 'ClickOnce'" />-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- We still need to resolve references even if we are not building during publish. -->
    <!-- BuildOnlySettings are required for RAR to find satellites and dependencies -->
    <_BeforePublishNoBuildTargets>
      BuildOnlySettings;
      _PreventProjectReferencesFromBuilding;
      ResolveReferences;
      PrepareResourceNames;
      ComputeIntermediateSatelliteAssemblies;
      ComputeEmbeddedApphostPaths;
    </_BeforePublishNoBuildTargets>
    <_CorePublishTargets>
      PrepareForPublish;
      ComputeAndCopyFilesToPublishDirectory;
      $(PublishProtocolProviderTargets);
      PublishItemsOutputGroup;
    </_CorePublishTargets>
    <_PublishNoBuildAlternativeDependsOn>$(_BeforePublishNoBuildTargets);$(_CorePublishTargets)</_PublishNoBuildAlternativeDependsOn>
  </PropertyGroup>
  <Target Name="_PublishBuildAlternative" Condition="'$(NoBuild)' != 'true'" DependsOnTargets="Build;$(_CorePublishTargets)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_PublishNoBuildAlternative" Condition="'$(NoBuild)' == 'true'" DependsOnTargets="$(_PublishNoBuildAlternativeDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="Publish" Condition="$(IsPublishable) == 'true'" DependsOnTargets="_PublishBuildAlternative;_PublishNoBuildAlternative" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Ensure there is minimal verbosity output pointing to the publish directory and not just the
         build step's minimal output. Otherwise there is no indication at minimal verbosity of where
         the published assets were copied. -->
    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([System.IO.Path]::GetFullPath('$(PublishDir)'))" />
    <ItemGroup>
      <PublishTelemetry Include="PublishReadyToRun" Value="$(PublishReadyToRun)" />
      <PublishTelemetry Include="PublishTrimmed" Value="$(PublishTrimmed)" />
      <PublishTelemetry Include="PublishSingleFile" Value="$(PublishSingleFile)" />
      <PublishTelemetry Include="PublishAot" Value="$(PublishAot)" />
      <PublishTelemetry Include="PublishProtocol" Value="$(PublishProtocol)" />
    </ItemGroup>
    <AllowEmptyTelemetry EventName="PublishProperties" EventData="@(PublishTelemetry)" />
  </Target>
  <!-- Don't let project reference resolution build project references in NoBuild case. -->
  <Target Name="_PreventProjectReferencesFromBuilding" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <BuildProjectReferences>false</BuildProjectReferences>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        PrepareForPublish

    Prepare the prerequisites for publishing.
    ============================================================
    -->
  <Target Name="PrepareForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And '$(_IsExecutable)' != 'true'" ResourceName="CannotHaveSingleFileWithoutExecutable" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And '$(_IsExecutable)' == 'true' And '$(TargetFrameworkIdentifier)' != '.NETCoreApp'" ResourceName="CanOnlyHaveSingleFileWithNetCoreApp" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And&#xA;                            '$(IncludeSymbolsInSingleFile)' == 'true' And&#xA;                            '$(_TargetFrameworkVersionWithoutV)' &gt;= '5.0' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" ResourceName="CannotIncludeSymbolsInSingleFile" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' and '$(RuntimeIdentifier)' == ''" ResourceName="CannotHaveSingleFileWithoutRuntimeIdentifier" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' and '$(UseAppHost)' != 'true' and '$(PublishAot)' != 'true'" ResourceName="CannotHaveSingleFileWithoutAppHost" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And&#xA;                            '$(EnableCompressionInSingleFile)' == 'true' And&#xA;                            '$(_TargetFrameworkVersionWithoutV)' &lt; '6.0'" ResourceName="CompressionInSingleFileRequires60" />
    <NETSdkError Condition="'$(PublishSingleFile)' == 'true' And&#xA;                            '$(EnableCompressionInSingleFile)' == 'true' And&#xA;                            '$(SelfContained)' != 'true'" ResourceName="CompressionInSingleFileRequiresSelfContained" />
    <NETSdkWarning Condition="'$(PublishProfileImported)' != 'true' and '$(PublishProfile)' != ''" ResourceName="PublishProfileNotPresent" FormatArguments="$(PublishProfile)" />
    <!-- Projects in a solution cannot have conflicting configurations. This checks if PublishRelease conflicted at runtime to avoid extra project evaluations.
    SolutionExt is used to check if we are publishing a solution. Will be undefined if not.-->
    <NETSdkError Condition="'$(_IsPublishing)' == 'true' and&#xA;                            '$(DOTNET_CLI_DISABLE_PUBLISH_AND_PACK_RELEASE)' != 'true' and&#xA;                            '$(DOTNET_CLI_LAZY_PUBLISH_AND_PACK_RELEASE_FOR_SOLUTIONS)' == 'true' and&#xA;                            '$(SolutionExt)' == '.sln' and&#xA;                            '$(_SolutionLevelPublishRelease)' != '$(PublishRelease)'" ResourceName="SolutionProjectConfigurationsConflict" FormatArguments="PublishRelease;$(ProjectName)" />
    <NETSdkError Condition="'$(PublishAot)' == 'true' and&#xA;                            '$(_IsPublishing)' != 'true' and&#xA;                            '$(PublishAotUsingRuntimePack)' == 'true' and&#xA;                            '$(NativeCompilationDuringPublish)' != 'false' and&#xA;                            '$(_TargetFrameworkVersionWithoutV)' &gt;= '10.0'" ResourceName="NativeCompilationRequiresPublishing" />
    <PropertyGroup>
      <!-- Ensure any PublishDir has a trailing slash, so it can be concatenated -->
      <PublishDir Condition="!HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
    </PropertyGroup>
    <MakeDir Directories="$(PublishDir)" />
  </Target>
  <!--
    ============================================================
                                        ComputeAndCopyFilesToPublishDirectory

    Computes the list of all files to copy to the publish directory and then publishes them.
    ============================================================
    -->
  <Target Name="ComputeAndCopyFilesToPublishDirectory" DependsOnTargets="ComputeFilesToPublish;&#xA;                            CopyFilesToPublishDirectory" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        CopyFilesToPublishDirectory

    Copy all build outputs, satellites and other necessary files to the publish directory.
    When publishing to a single file, only those files that are not bundled are copied.
    The remaining files are directly written to the bundle file.
    ============================================================
    -->
  <Target Name="CopyFilesToPublishDirectory" DependsOnTargets="_IncrementalCleanPublishDirectory;&#xA;                            _CopyResolvedFilesToPublishPreserveNewest;&#xA;                            _CopyResolvedFilesToPublishAlways;&#xA;                            _HandleFileConflictsForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        _IncrementalCleanPublishDirectory

    Remove files that were produced in a prior publish but weren't produced in the current publish.
    ============================================================
    -->
  <Target Name="_IncrementalCleanPublishDirectory" DependsOnTargets="_GetCurrentAndPriorPublishFileWrites" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Subtract list of files produced in the prior publish from list of files produced in this publish. -->
    <ItemGroup>
      <_OrphanPublishFileWrites Include="@(_PriorPublishFileWrites)" Exclude="@(_CurrentPublishFileWrites)" />
    </ItemGroup>
    <!-- Delete the orphaned files. -->
    <Delete Files="@(_OrphanPublishFileWrites)" TreatErrorsAsWarnings="true">
      <Output TaskParameter="DeletedFiles" ItemName="_OrphanFilesDeleted" />
    </Delete>
    <!-- Write new list of current files back to clean file. -->
    <WriteLinesToFile File="$(IntermediateOutputPath)$(_PublishCleanFile)" Lines="@(_CurrentPublishFileWrites)" Overwrite="true" />
  </Target>
  <!--
    ============================================================
                                        _GetCurrentAndPriorPublishFileWrites
    Get the list of files written in the previous publish and the list of files to be written in this publish.
    ============================================================
    -->
  <Target Name="_GetCurrentAndPriorPublishFileWrites" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_NormalizedPublishDir>$([MSBuild]::NormalizeDirectory($(PublishDir)))</_NormalizedPublishDir>
    </PropertyGroup>
    <Hash ItemstoHash="$(_NormalizedPublishDir)">
      <Output TaskParameter="HashResult" PropertyName="_NormalizedPublishDirHash" />
    </Hash>
    <PropertyGroup>
      <_PublishCleanFile Condition="'$(PublishCleanFile)'==''">PublishOutputs.$(_NormalizedPublishDirHash.Substring(0, 10)).txt</_PublishCleanFile>
    </PropertyGroup>
    <!-- Read in writes made by prior publish. -->
    <ReadLinesFromFile File="$(IntermediateOutputPath)$(_PublishCleanFile)">
      <Output TaskParameter="Lines" ItemName="_UnfilteredPriorPublishFileWrites" />
    </ReadLinesFromFile>
    <ConvertToAbsolutePath Paths="@(_UnfilteredPriorPublishFileWrites)">
      <Output TaskParameter="AbsolutePaths" ItemName="_UnfilteredAbsolutePriorPublishFileWrites" />
    </ConvertToAbsolutePath>
    <!-- Find all files in the final output directory. -->
    <FindUnderPath Path="$(_NormalizedPublishDir)" Files="@(_UnfilteredAbsolutePriorPublishFileWrites)" UpdateToAbsolutePaths="true">
      <Output TaskParameter="InPath" ItemName="_PriorPublishFileWritesInOutput" />
    </FindUnderPath>
    <!-- Remove duplicates from files produced in the previous publish. -->
    <RemoveDuplicates Inputs="@(_PriorPublishFileWritesInOutput)">
      <Output TaskParameter="Filtered" ItemName="_PriorPublishFileWrites" />
    </RemoveDuplicates>
    <ItemGroup>
      <_CurrentPublishFileWritesUnfiltered Include="@(ResolvedFileToPublish->'$(_NormalizedPublishDir)%(RelativePath)')" />
      <_CurrentPublishFileWritesUnfiltered Include="$(_NormalizedPublishDir)$(AssemblyName)$(_NativeExecutableExtension)" Condition="'$(UseAppHost)' == 'true'" />
    </ItemGroup>
    <ConvertToAbsolutePath Paths="@(_CurrentPublishFileWritesUnfiltered)">
      <Output TaskParameter="AbsolutePaths" ItemName="_CurrentAbsolutePublishFileWritesUnfiltered" />
    </ConvertToAbsolutePath>
    <!-- Remove duplicates from the files produced in this publish-->
    <RemoveDuplicates Inputs="@(_CurrentAbsolutePublishFileWritesUnfiltered)">
      <Output TaskParameter="Filtered" ItemName="_CurrentPublishFileWrites" />
    </RemoveDuplicates>
  </Target>
  <!--
    ============================================================
                                        _CopyResolvedFilesToPublishPreserveNewest

    Copy _ResolvedFileToPublishPreserveNewest items to the publish directory
    ============================================================
    -->
  <Target Name="_CopyResolvedFilesToPublishPreserveNewest" DependsOnTargets="_ComputeResolvedFilesToPublishTypes" Inputs="@(_ResolvedFileToPublishPreserveNewest)" Outputs="@(_ResolvedFileToPublishPreserveNewest->'$(PublishDir)%(RelativePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      PreserveNewest means that we will only copy the source to the destination if the source is newer.
      SkipUnchangedFiles is not used for that purpose because it will copy if the source and destination
      differ by size too.  Instead, this target uses inputs and outputs to only copy when the source is newer.
      -->
    <Copy SourceFiles="@(_ResolvedFileToPublishPreserveNewest)" DestinationFiles="@(_ResolvedFileToPublishPreserveNewest->'$(PublishDir)%(RelativePath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
    ============================================================
                                        _CopyResolvedFilesToPublishAlways

    Copy _ResolvedFileToPublishAlways items to the publish directory
    ============================================================
    -->
  <Target Name="_CopyResolvedFilesToPublishAlways" DependsOnTargets="_ComputeResolvedFilesToPublishTypes" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Use SkipUnchangedFiles to prevent unnecessary file copies. The copy will occur if the
      destination doesn't exist, the source is newer than the destination, or if the source and
      destination differ by file size.
      -->
    <Copy SourceFiles="@(_ResolvedFileToPublishAlways)" DestinationFiles="@(_ResolvedFileToPublishAlways->'$(PublishDir)%(RelativePath)')" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <UsingTask TaskName="ResolveReadyToRunCompilers" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ResolveReadyToRunCompilers" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolveReadyToRunCompilers RuntimePacks="@(ResolvedRuntimePack)" Crossgen2Packs="@(ResolvedCrossgen2Pack)" TargetingPacks="@(ResolvedTargetingPack)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" NETCoreSdkRuntimeIdentifier="$(NETCoreSdkRuntimeIdentifier)" EmitSymbols="$(PublishReadyToRunEmitSymbols)" ReadyToRunUseCrossgen2="$(PublishReadyToRunUseCrossgen2)" PerfmapFormatVersion="$(PublishReadyToRunPerfmapFormatVersion)">
      <Output TaskParameter="CrossgenTool" ItemName="CrossgenTool" />
      <Output TaskParameter="Crossgen2Tool" ItemName="Crossgen2Tool" />
    </ResolveReadyToRunCompilers>
  </Target>
  <!--
    ============================================================
                                        _ComputeResolvedFilesToPublishTypes

    Splits ResolvedFileToPublish items into 'PreserveNewest' and 'Always' buckets.
    Then further splits those into 'Unbundled' buckets based on the single file setting.
    ============================================================
    -->
  <Target Name="_ComputeResolvedFilesToPublishTypes" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ResolvedFileToPublishPreserveNewest Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.CopyToPublishDirectory)'=='PreserveNewest'" />
      <_ResolvedFileToPublishAlways Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.CopyToPublishDirectory)'=='Always'" />
    </ItemGroup>
    <ItemGroup>
      <_ResolvedUnbundledFileToPublishPreserveNewest Include="@(_ResolvedFileToPublishPreserveNewest)" Condition="'$(PublishSingleFile)' != 'true' or&#xA;                               '%(_ResolvedFileToPublishPreserveNewest.ExcludeFromSingleFile)'=='true'" />
      <_ResolvedUnbundledFileToPublishAlways Include="@(_ResolvedFileToPublishAlways)" Condition="'$(PublishSingleFile)' != 'true' or&#xA;                         '%(_ResolvedFileToPublishAlways.ExcludeFromSingleFile)'=='true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ComputeFilesToPublish

    Gathers all the files that need to be copied to the publish directory, including R2R and ILLinker transformations
    ============================================================
    -->
  <Target Name="ComputeFilesToPublish" DependsOnTargets="PrepareForPublish;&#xA;                            ComputeResolvedFilesToPublishList;&#xA;                            ILLink;&#xA;                            CreateReadyToRunImages;&#xA;                            GeneratePublishDependencyFile;&#xA;                            GenerateSingleFileBundle" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        ILLink

    Initially an empty placeholder target. When trimming, this
    will be redefined to invoke ILLink to perform IL trimming.
    The placeholder exists to allow other targets to depend on it for ordering purposes.
    ============================================================
    -->
  <Target Name="ILLink" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CopyBuildOutputToPublishDirectory Condition="'$(CopyBuildOutputToPublishDirectory)'==''">true</CopyBuildOutputToPublishDirectory>
    <CopyOutputSymbolsToPublishDirectory Condition="'$(CopyOutputSymbolsToPublishDirectory)'==''">true</CopyOutputSymbolsToPublishDirectory>
    <IncludeSymbolsInSingleFile Condition="'$(IncludeSymbolsInSingleFile)' == ''">false</IncludeSymbolsInSingleFile>
  </PropertyGroup>
  <UsingTask TaskName="ResolveOverlappingItemGroupConflicts" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
                                        ComputeResolvedFilesToPublishList

    Gathers all the files that need to be copied to the publish directory.
    ============================================================
    -->
  <Target Name="ComputeResolvedFilesToPublishList" DependsOnTargets="_ComputeResolvedCopyLocalPublishAssets;&#xA;                            _ComputeCopyToPublishDirectoryItems;&#xA;                            ComputeRefAssembliesToPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Copy the build product (.dll or .exe). -->
      <ResolvedFileToPublish Include="@(IntermediateAssembly)" Condition="'$(CopyBuildOutputToPublishDirectory)' == 'true'">
        <RelativePath>@(IntermediateAssembly->'%(Filename)%(Extension)')</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the deps file if using the build deps file. -->
      <ResolvedFileToPublish Include="$(ProjectDepsFilePath)" Condition="'$(GenerateDependencyFile)' == 'true' and '$(_UseBuildDependencyFile)' == 'true'">
        <RelativePath>$(ProjectDepsFileName)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the runtime config file. -->
      <ResolvedFileToPublish Include="$(ProjectRuntimeConfigFilePath)" Condition="'$(GenerateRuntimeConfigurationFiles)' == 'true'  and '$(PublishAot)' != 'true'">
        <RelativePath>$(ProjectRuntimeConfigFileName)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the app.config (if any) -->
      <ResolvedFileToPublish Include="@(AppConfigWithTargetPath)" Condition="'$(CopyBuildOutputToPublishDirectory)' == 'true'">
        <RelativePath>@(AppConfigWithTargetPath->'%(TargetPath)')</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the debug information file (.pdb), if any -->
      <ResolvedFileToPublish Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true' and '$(CopyOutputSymbolsToPublishDirectory)'=='true'">
        <RelativePath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
        <ExcludeFromSingleFile Condition="'$(IncludeSymbolsInSingleFile)'!='true'">true</ExcludeFromSingleFile>
      </ResolvedFileToPublish>
      <!-- Copy satellite assemblies. -->
      <ResolvedFileToPublish Include="@(IntermediateSatelliteAssembliesWithTargetPath)">
        <RelativePath>%(IntermediateSatelliteAssembliesWithTargetPath.Culture)\%(Filename)%(Extension)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy generated COM References. -->
      <ResolvedFileToPublish Include="@(ReferenceComWrappersToCopyLocal)">
        <RelativePath>%(Filename)%(Extension)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
    </ItemGroup>
    <!-- Remove conflicting items that appear in both _ResolvedCopyLocalPublishAssets and ResolvedFileToPublish
         to ensure that we don't get duplicate files in the publish output. -->
    <ResolveOverlappingItemGroupConflicts ItemGroup1="@(_ResolvedCopyLocalPublishAssets-&gt;Distinct())" ItemGroup2="@(ResolvedFileToPublish-&gt;Distinct())" PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="RemovedItemGroup1" ItemName="_ResolvedCopyLocalPublishAssetsRemoved" />
      <Output TaskParameter="RemovedItemGroup2" ItemName="ResolvedFileToPublishRemoved" />
    </ResolveOverlappingItemGroupConflicts>
    <ItemGroup>
      <_ResolvedCopyLocalPublishAssets Remove="@(_ResolvedCopyLocalPublishAssetsRemoved)" />
      <ResolvedFileToPublish Remove="@(ResolvedFileToPublishRemoved)" />
      <!-- Copy the resolved copy local publish assets. -->
      <ResolvedFileToPublish Include="@(_ResolvedCopyLocalPublishAssets)">
        <RelativePath>%(_ResolvedCopyLocalPublishAssets.DestinationSubDirectory)%(Filename)%(Extension)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy the xml documentation (if enabled) -->
      <ResolvedFileToPublish Include="@(FinalDocFile)" Condition="'$(PublishDocumentationFile)' == 'true'">
        <RelativePath>@(FinalDocFile->'%(Filename)%(Extension)')</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Copy all PackAsTool shims (if any) -->
      <ResolvedFileToPublish Include="@(_EmbeddedApphostPaths-&gt;Distinct())">
        <RelativePath>shims/%(_EmbeddedApphostPaths.ShimRuntimeIdentifier)/%(_EmbeddedApphostPaths.Filename)%(_EmbeddedApphostPaths.Extension)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ResolvedFileToPublish>
      <!-- Filter files for PublishSingleFiles scenario -->
      <_FilesToDrop Include="@(ResolvedFileToPublish)" Condition="'$(PublishSingleFile)' == 'true' and&#xA;                               '%(ResolvedFileToPublish.DropFromSingleFile)' == 'true'" />
      <ResolvedFileToPublish Remove="@(_FilesToDrop)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _ResolveCopyLocalAssetsForPublish
    Resolves the assets from packages to copy locally for publish.
    We can just use the build's copy local assets if we can reuse the build deps file.
    ============================================================
  -->
  <UsingTask TaskName="ResolveCopyLocalAssets" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_ResolveCopyLocalAssetsForPublish" DependsOnTargets="ResolveLockFileCopyLocalFiles;&#xA;                            _ComputeUseBuildDependencyFile;&#xA;                            _DefaultMicrosoftNETPlatformLibrary;&#xA;                            ResolveRuntimePackAssets;&#xA;                            _ComputePackageReferencePublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- For future: Delete ResolveCopyLocalAssets task.  Need to figure out how to get correct DestinationSubPath for
           PreserveStoreLayout without this task, and how to handle RuntimeStorePackages. -->
    <ResolveCopyLocalAssets AssetsFilePath="$(ProjectAssetsFile)" TargetFramework="$(TargetFramework)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" ExcludedPackageReferences="@(_ExcludeFromPublishPackageReference)" RuntimeStorePackages="@(RuntimeStorePackages)" PreserveStoreLayout="$(PreserveStoreLayout)" ResolveRuntimeTargets="$(CopyLocalRuntimeTargetAssets)" IsSelfContained="$(SelfContained)" Condition="'$(PreserveStoreLayout)' == 'true' Or '@(RuntimeStorePackages)' != ''">
      <Output TaskParameter="ResolvedAssets" ItemName="_ResolvedCopyLocalPublishAssets" />
    </ResolveCopyLocalAssets>
    <ItemGroup>
      <_ResolvedCopyLocalPublishAssets Include="@(RuntimePackAsset)" Condition="('$(SelfContained)' == 'true' Or '%(RuntimePackAsset.RuntimePackAlwaysCopyLocal)' == 'true') and '%(RuntimePackAsset.AssetType)' != 'pgodata'" />
    </ItemGroup>
    <ItemGroup Condition="'$(_UseBuildDependencyFile)' != 'true'">
      <!-- Remove the apphost executable from publish copy local assets; we will copy the generated apphost instead -->
      <_ResolvedCopyLocalPublishAssets Remove="@(_NativeRestoredAppHostNETCore)" />
    </ItemGroup>
    <ItemGroup Condition="'$(PreserveStoreLayout)' != 'true' And '@(RuntimeStorePackages)' == ''">
      <_ResolvedCopyLocalPublishAssets Include="@(_ResolvedCopyLocalBuildAssets)" Condition="'%(_ResolvedCopyLocalBuildAssets.CopyToPublishDirectory)' != 'false' " />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _ParseTargetManifestFiles
    Parses the $(TargetManifestFiles) which contains a list of files into @(RuntimeStorePackages) items
    which describes which packages should be excluded from publish since they are contained in the runtime store.
    ============================================================
    -->
  <UsingTask TaskName="ParseTargetManifests" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_ParseTargetManifestFiles" Condition="'$(TargetManifestFiles)' != ''" Returns="@(RuntimeStorePackages)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ParseTargetManifests TargetManifestFiles="$(TargetManifestFiles)">
      <Output TaskParameter="RuntimeStorePackages" ItemName="RuntimeStorePackages" />
    </ParseTargetManifests>
  </Target>
  <!--
    ============================================================
    _FilterSatelliteResourcesForPublish
    Filters the resolved resource assets for build to the given resource languages.
    ============================================================
  -->
  <Target Name="_FilterSatelliteResourcesForPublish" Condition="'$(SatelliteResourceLanguages)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_PublishSatelliteResources Include="@(_ResolvedCopyLocalPublishAssets)" Condition="'%(_ResolvedCopyLocalPublishAssets.AssetType)' == 'resources'" />
    </ItemGroup>
    <JoinItems Left="@(_PublishSatelliteResources)" LeftKey="Culture" LeftMetadata="*" Right="$(SatelliteResourceLanguages)" RightKey="" RightMetadata="" ItemSpecToUse="Left">
      <Output TaskParameter="JoinResult" ItemName="_FilteredPublishSatelliteResources" />
    </JoinItems>
    <ItemGroup Condition="'@(_PublishSatelliteResources)' != ''">
      <_ResolvedCopyLocalPublishAssets Remove="@(_PublishSatelliteResources)" />
      <_ResolvedCopyLocalPublishAssets Include="@(_FilteredPublishSatelliteResources)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _ComputeResolvedCopyLocalPublishAssets
    Computes the files from both project and package references.
    ============================================================
  -->
  <Target Name="_ComputeResolvedCopyLocalPublishAssets" DependsOnTargets="_ResolveCopyLocalAssetsForPublish;&#xA;                            _FilterSatelliteResourcesForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ResolvedCopyLocalPublishAssets Include="@(ReferenceCopyLocalPaths)" Exclude="@(_ResolvedCopyLocalBuildAssets);@(RuntimePackAsset)" Condition="('$(PublishReferencesDocumentationFiles)' == 'true' or '%(ReferenceCopyLocalPaths.Extension)' != '.xml') and '%(ReferenceCopyLocalPaths.Private)' != 'false'">
        <DestinationSubPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</DestinationSubPath>
      </_ResolvedCopyLocalPublishAssets>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CreateSingleFileHost
      Create the single-file host for the publish scenario if app is being published as a self-contained single-file .net5+ app
    ============================================================
     -->
  <Target Name="_CreateSingleFileHost" Inputs="@(IntermediateAssembly);$(SingleFileHostSourcePath)" Outputs="$(SingleFileHostIntermediatePath)" DependsOnTargets="_GetAppHostPaths;_GetAppHostCreationConfiguration" Condition="'$(_UseSingleFileHostForPublish)' == 'true' and&#xA;                     Exists('@(IntermediateAssembly)') and&#xA;                     Exists('$(SingleFileHostSourcePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateAppHost AppHostSourcePath="$(SingleFileHostSourcePath)" AppHostDestinationPath="$(SingleFileHostIntermediatePath)" AppBinaryName="$(AssemblyName)$(TargetExt)" IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')" WindowsGraphicalUserInterface="$(_UseWindowsGraphicalUserInterface)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" EnableMacOSCodeSign="$(_EnableMacOSCodeSign)" DisableCetCompat="$(_DisableCetCompat)" />
  </Target>
  <!--
    ============================================================
    _CreateAppHostForPublish
    Create the apphost for the publish scenario if app is configuring .NET install search behaviour
    Because there is no SDK support yet for output with a layout conforming to the configuration,
    only do this on publish, such that the inner dev loop is unaffected.
    ============================================================
     -->
  <Target Name="_CreateAppHostForPublish" Inputs="@(IntermediateAssembly);$(AppHostSourcePath)" Outputs="$(AppHostForPublishIntermediatePath)" DependsOnTargets="_GetAppHostPaths;_GetAppHostCreationConfiguration" Condition="'$(_UpdateAppHostForPublish)' == 'true' and&#xA;                     Exists('@(IntermediateAssembly)') and&#xA;                     Exists('$(AppHostSourcePath)')" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CreateAppHost AppHostSourcePath="$(AppHostSourcePath)" AppHostDestinationPath="$(AppHostForPublishIntermediatePath)" AppBinaryName="$(AssemblyName)$(TargetExt)" IntermediateAssembly="@(IntermediateAssembly->'%(FullPath)')" WindowsGraphicalUserInterface="$(_UseWindowsGraphicalUserInterface)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" EnableMacOSCodeSign="$(_EnableMacOSCodeSign)" DisableCetCompat="$(_DisableCetCompat)" DotNetSearchLocations="$(AppHostDotNetSearch)" AppRelativeDotNet="$(AppHostRelativeDotNet)" />
  </Target>
  <!--
    ============================================================
                                        _ComputeCopyToPublishDirectoryItems
    ============================================================
    -->
  <Target Name="_ComputeCopyToPublishDirectoryItems" DependsOnTargets="GetCopyToPublishDirectoryItems" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <ResolvedFileToPublish Include="@(_SourceItemsToCopyToPublishDirectoryAlways)">
        <RelativePath>%(_SourceItemsToCopyToPublishDirectoryAlways.TargetPath)</RelativePath>
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
        <IsKeyOutput Condition="'%(_SourceItemsToCopyToPublishDirectoryAlways.FullPath)' == '$(AppHostIntermediatePath)'">True</IsKeyOutput>
      </ResolvedFileToPublish>
      <ResolvedFileToPublish Include="@(_SourceItemsToCopyToPublishDirectory)">
        <RelativePath>%(_SourceItemsToCopyToPublishDirectory.TargetPath)</RelativePath>
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
        <IsKeyOutput Condition="'%(_SourceItemsToCopyToPublishDirectory.FullPath)' == '$(AppHostIntermediatePath)'">True</IsKeyOutput>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        GetCopyToPublishDirectoryItems

    Get all project items that may need to be transferred to the publish directory.
    This includes baggage items from transitively referenced projects. It would appear
    that this target computes full transitive closure of content items for all referenced
    projects; however that is not the case. It only collects the content items from its
    immediate children and not children of children.

    See comment on GetCopyToOutputDirectoryItems, from which this logic was taken.
    ============================================================
    -->
  <Target Name="GetCopyToPublishDirectoryItems" Returns="@(AllPublishItemsFullPathWithTargetPath)" KeepDuplicateOutputs=" '$(MSBuildDisableGetCopyToPublishDirectoryItemsOptimization)' == '' " DependsOnTargets="AssignTargetPaths;&#xA;                            DefaultCopyToPublishDirectoryMetadata;&#xA;                            _CreateSingleFileHost;&#xA;                            _CreateAppHostForPublish;&#xA;                            _SplitProjectReferencesByFileExistence;&#xA;                            _GetProjectReferenceTargetFrameworkProperties" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- In the general case, clients need very little of the metadata which is generated by invoking this target on this project and its children.  For those
         cases, we can immediately discard the unwanted metadata, reducing memory usage, particularly in very large and interconnected systems of projects.
         However, if some client does require the original functionality, it is sufficient to set MSBuildDisableGetCopyToPublishDirectoryItemsOptimization to
         a non-empty value and the original behavior will be restored. -->
    <PropertyGroup Condition=" '$(MSBuildDisableGetCopyToPublishDirectoryItemsOptimization)' == '' ">
      <_GCTPDIKeepDuplicates>false</_GCTPDIKeepDuplicates>
      <_GCTPDIKeepMetadata>CopyToPublishDirectory;ExcludeFromSingleFile;TargetPath</_GCTPDIKeepMetadata>
    </PropertyGroup>
    <!-- Get items from child projects first. -->
    <MSBuild Projects="@(_MSBuildProjectReferenceExistent)" Targets="GetCopyToPublishDirectoryItems" BuildInParallel="$(BuildInParallel)" Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)" Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToPublishDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false'" ContinueOnError="$(ContinueOnError)" RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
      <Output TaskParameter="TargetOutputs" ItemName="_AllChildProjectPublishItemsWithTargetPath" />
    </MSBuild>
    <!-- Target outputs must be full paths because they will be consumed by a different project. -->
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepDuplicates=" '$(_GCTPDIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_AllChildProjectPublishItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectPublishItemsWithTargetPath.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepDuplicates=" '$(_GCTPDIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_AllChildProjectPublishItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectPublishItemsWithTargetPath.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
    <ItemGroup>
      <_AllChildProjectPublishItemsWithTargetPath Remove="@(_AllChildProjectPublishItemsWithTargetPath)" />
    </ItemGroup>
    <!-- Get items from this project last so that they will be copied last. -->
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_CompileItemsToPublish Include="@(Compile->'%(FullPath)')" Condition="'%(Compile.CopyToPublishDirectory)'=='Always' or '%(Compile.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <AssignTargetPath Files="@(_CompileItemsToPublish)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="_CompileItemsToPublishWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_CompileItemsToPublishWithTargetPath)" Condition="'%(_CompileItemsToPublishWithTargetPath.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_CompileItemsToPublishWithTargetPath)" Condition="'%(_CompileItemsToPublishWithTargetPath.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup>
      <_SourceItemsToCopyToPublishDirectoryAlways KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToPublishDirectory)'=='Always'" />
      <_SourceItemsToCopyToPublishDirectory KeepMetadata="$(_GCTPDIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToPublishDirectory)'=='PreserveNewest'" />
    </ItemGroup>
    <ItemGroup Condition="'$(_UseSingleFileHostForPublish)' == 'true' and Exists('$(SingleFileHostIntermediatePath)')">
      <!-- Remove non-single-file apphost from items to publish -->
      <_SourceItemsToCopyToPublishDirectoryAlways Remove="$(AppHostIntermediatePath)" />
      <_SourceItemsToCopyToPublishDirectory Remove="$(AppHostIntermediatePath)" />
      <!-- Add the single-file host created as part of publish -->
      <_SourceItemsToCopyToPublishDirectoryAlways Include="$(SingleFileHostIntermediatePath)" CopyToOutputDirectory="Always" TargetPath="$(AssemblyName)$(_NativeExecutableExtension)" />
    </ItemGroup>
    <ItemGroup Condition="'$(_UpdateAppHostForPublish)' == 'true' and Exists('$(AppHostForPublishIntermediatePath)')">
      <!-- Remove apphost from build from items to publish -->
      <_SourceItemsToCopyToPublishDirectoryAlways Remove="$(AppHostIntermediatePath)" />
      <_SourceItemsToCopyToPublishDirectory Remove="$(AppHostIntermediatePath)" />
      <!-- Add the apphost created as part of publish -->
      <_SourceItemsToCopyToPublishDirectoryAlways Include="$(AppHostForPublishIntermediatePath)" CopyToOutputDirectory="Always" TargetPath="$(AssemblyName)$(_NativeExecutableExtension)" />
    </ItemGroup>
    <ItemGroup>
      <AllPublishItemsFullPathWithTargetPath Include="@(_SourceItemsToCopyToPublishDirectoryAlways->'%(FullPath)');@(_SourceItemsToCopyToPublishDirectory->'%(FullPath)')" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        DefaultCopyToPublishDirectoryMetadata

    If CopyToPublishDirectory isn't set on these items, the value should be taken from CopyToOutputDirectory.
    This way, projects can just set "CopyToOutputDirectory = Always/PreserveNewest" and by default the item will be copied
    to both the build output and publish directories.
    ============================================================
    -->
  <Target Name="DefaultCopyToPublishDirectoryMetadata" DependsOnTargets="AssignTargetPaths" Condition=" '$(DefaultCopyToPublishDirectoryMetadata)' == 'true' " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <ContentWithTargetPath Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' and '%(ContentWithTargetPath.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </ContentWithTargetPath>
      <ContentWithTargetPath Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' and '%(ContentWithTargetPath.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </ContentWithTargetPath>
      <EmbeddedResource Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' and '%(EmbeddedResource.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </EmbeddedResource>
      <EmbeddedResource Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' and '%(EmbeddedResource.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </EmbeddedResource>
      <Compile Condition="'%(Compile.CopyToOutputDirectory)'=='Always' and '%(Compile.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </Compile>
      <Compile Condition="'%(Compile.CopyToOutputDirectory)'=='PreserveNewest' and '%(Compile.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </Compile>
      <_NoneWithTargetPath Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' and '%(_NoneWithTargetPath.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>Always</CopyToPublishDirectory>
      </_NoneWithTargetPath>
      <_NoneWithTargetPath Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' and '%(_NoneWithTargetPath.CopyToPublishDirectory)' == ''">
        <CopyToPublishDirectory>PreserveNewest</CopyToPublishDirectory>
      </_NoneWithTargetPath>
    </ItemGroup>
  </Target>
  <PropertyGroup Condition="'$(SelfContained)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_ComputeManagedRuntimePackAssembliesIfSelfContained>_ComputeManagedRuntimePackAssemblies</_ComputeManagedRuntimePackAssembliesIfSelfContained>
  </PropertyGroup>
  <!-- Determine the managed assembly subset of ResolvedFileToPublish that should be post-processed by linker, and ready to run compilation -->
  <Target Name="_ComputeAssembliesToPostprocessOnPublish" DependsOnTargets="_ComputeUserRuntimeAssemblies;$(_ComputeManagedRuntimePackAssembliesIfSelfContained)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!--
      Default set of files to post-process correspond to the items that would be designated
      as managed runtime assemblies in .deps.json, and published to root of the application.
      RuntimeTargets and satellite assemblies are excluded. Currently, both linker and ready
      to run require a RID, so there will not be RuntimeTargets. Linker could conceptually
      operate without a RID, but would not know how to handle multiple assemblies with same
      identity.
    -->
    <ItemGroup>
      <!-- Assemblies from packages -->
      <_ManagedRuntimeAssembly Include="@(RuntimeCopyLocalItems)" />
      <!-- Assemblies from other references -->
      <_ManagedRuntimeAssembly Include="@(UserRuntimeAssembly)" />
      <!-- Assembly produced by this project -->
      <_ManagedRuntimeAssembly Include="@(IntermediateAssembly)" />
    </ItemGroup>
    <!-- Assemblies from runtime packs for self-contained apps -->
    <ItemGroup Condition="'$(SelfContained)' == 'true'">
      <_ManagedRuntimeAssembly Include="@(_ManagedRuntimePackAssembly)" />
    </ItemGroup>
    <!--
      Match above with ResolvedFileToPublish. Some of above would have been excluded from publish in
      various ways and should be excluded from the list of files to postprocess as well. Furthermore,
      the metadata must match ResolvedFileToPublish as the tools modify or remove these items in that
      list to implement their post-processing.
    -->
    <JoinItems Left="@(_ManagedRuntimeAssembly)" Right="@(ResolvedFileToPublish)" RightMetadata="*">
      <Output TaskParameter="JoinResult" ItemName="_AssemblyToPostprocessOnPublish" />
    </JoinItems>
    <!--
      Set PostprocessAssembly=true metadata on ResolvedFileToPublish, which will be honored by linker
      and crossgen.

      Assemblies injected into ResolvedFileToPublish outside the set above (such as razor views) are
      responsible for setting this metadata to opt in to post-processing.
    -->
    <ItemGroup>
      <ResolvedFileToPublish Remove="@(_AssemblyToPostprocessOnPublish)" />
      <ResolvedFileToPublish Include="@(_AssemblyToPostprocessOnPublish)" PostprocessAssembly="true" />
    </ItemGroup>
  </Target>
  <Target Name="_ComputeManagedRuntimePackAssemblies" Returns="@(_ManagedRuntimePackAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!-- Special case for System.Private.Corelib due to https://github.com/dotnet/core-setup/issues/7728 -->
      <_ManagedRuntimePackAssembly Include="@(RuntimePackAsset)" Condition="'%(RuntimePackAsset.AssetType)' == 'runtime'&#xA;                                                or '%(RuntimePackAsset.Filename)' == 'System.Private.Corelib'" />
    </ItemGroup>
  </Target>
  <Target Name="_ComputeUseBuildDependencyFile" DependsOnTargets="_ComputePackageReferencePublish;&#xA;                            _ParseTargetManifestFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Check to see whether we can re-use the .deps.json file from the build for publish, or whether we have to
         generate a different one. -->
    <PropertyGroup>
      <_TrimRuntimeAssets Condition="'$(PublishSingleFile)' == 'true' and '$(SelfContained)' == 'true'">true</_TrimRuntimeAssets>
      <_UseBuildDependencyFile Condition="'@(_ExcludeFromPublishPackageReference)' == '' and&#xA;                                          '@(RuntimeStorePackages)' == '' and&#xA;                                          '$(PreserveStoreLayout)' != 'true' and&#xA;                                          '$(PublishTrimmed)' != 'true' and&#xA;                                          '$(_TrimRuntimeAssets)' != 'true'">true</_UseBuildDependencyFile>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
                                        GenerateSingleFileBundle

    Bundle the ResolvedFileToPublish items into one file in PublishDir
    (except those marked ExcludeFromSingleFile)
    ============================================================
    -->
  <Target Name="_ComputeFilesToBundle" DependsOnTargets="_HandleFileConflictsForPublish" Condition="'$(PublishSingleFile)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_FilesToBundle Include="@(ResolvedFileToPublish)" Condition="'%(ResolvedFileToPublish.ExcludeFromSingleFile)' != 'true'" />
      <ResolvedFileToPublish Remove="@(_FilesToBundle)" />
    </ItemGroup>
    <PropertyGroup>
      <PublishedSingleFileName>$(AssemblyName)$(_NativeExecutableExtension)</PublishedSingleFileName>
      <PublishedSingleFilePath>$(PublishDir)$(PublishedSingleFileName)</PublishedSingleFilePath>
    </PropertyGroup>
  </Target>
  <Target Name="PrepareForBundle" DependsOnTargets="_ComputeFilesToBundle" Condition="'$(PublishSingleFile)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <FilesToBundle Include="@(_FilesToBundle)" />
    </ItemGroup>
    <PropertyGroup>
      <AppHostFile>$(PublishedSingleFileName)</AppHostFile>
    </PropertyGroup>
  </Target>
  <Target Name="_GenerateSingleFileBundleInputCache" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(PublishedSingleFilePath)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(TraceSingleFileBundler)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(IncludeSymbolsInSingleFile)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(IncludeAllContentForSelfExtract)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(IncludeNativeLibrariesForSelfExtract)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(EnableCompressionInSingleFile)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(PublishedSingleFileName)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(RuntimeIdentifier)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(PublishDir)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="$(_TargetFrameworkVersionWithoutV)" />
      <_GenerateSingleFileBundlePropertyInputsCacheToHash Include="@(FilesToBundle)" />
    </ItemGroup>
    <Hash ItemsToHash="@(_GenerateSingleFileBundlePropertyInputsCacheToHash)">
      <Output TaskParameter="HashResult" PropertyName="_GenerateSingleFileBundlePropertyInputsCacheHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_GenerateSingleFileBundlePropertyInputsCacheHash)" File="$(_GenerateSingleFileBundlePropertyInputsCache)" Overwrite="true" WriteOnlyWhenDifferent="true" />
  </Target>
  <UsingTask TaskName="GenerateBundle" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="GenerateSingleFileBundle" Condition="'$(PublishSingleFile)' == 'true' and '$(PublishAot)' != 'true'" DependsOnTargets="_ComputeFilesToBundle;PrepareForBundle;_GenerateSingleFileBundleInputCache" Inputs="@(FilesToBundle);$(_GenerateSingleFileBundlePropertyInputsCache)" Outputs="$(PublishedSingleFilePath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <TraceSingleFileBundler Condition="'$(TraceSingleFileBundler)' == ''">false</TraceSingleFileBundler>
      <IncludeSymbolsInSingleFile Condition="'$(IncludeSymbolsInSingleFile)' == ''">false</IncludeSymbolsInSingleFile>
      <IncludeAllContentForSelfExtract Condition="'$(IncludeAllContentForSelfExtract)' == ''">false</IncludeAllContentForSelfExtract>
      <IncludeNativeLibrariesForSelfExtract Condition="'$(IncludeNativeLibrariesForSelfExtract)' == ''">$(IncludeAllContentForSelfExtract)</IncludeNativeLibrariesForSelfExtract>
      <EnableCompressionInSingleFile Condition="'$(EnableCompressionInSingleFile)' == ''">false</EnableCompressionInSingleFile>
    </PropertyGroup>
    <NETSdkError Condition="'$(IncludeAllContentForSelfExtract)' == 'true' And '$(IncludeNativeLibrariesForSelfExtract)' != 'true'" ResourceName="CannotIncludeAllContentButNotNativeLibrariesInSingleFile" />
    <GenerateBundle FilesToBundle="@(FilesToBundle)" AppHostName="$(PublishedSingleFileName)" IncludeSymbols="$(IncludeSymbolsInSingleFile)" EnableCompressionInSingleFile="$(EnableCompressionInSingleFile)" IncludeNativeLibraries="$(IncludeNativeLibrariesForSelfExtract)" IncludeAllContent="$(IncludeAllContentForSelfExtract)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV)" RuntimeIdentifier="$(RuntimeIdentifier)" OutputDir="$(PublishDir)" ShowDiagnosticOutput="$(TraceSingleFileBundler)">
      <Output TaskParameter="ExcludedFiles" ItemName="_FilesExcludedFromBundle" />
    </GenerateBundle>
    <ItemGroup>
      <ResolvedFileToPublish Include="@(_FilesExcludedFromBundle)" />
      <!-- ResolvedFileToPublish shouldn't include PublishedSingleFilePath, since the single-file bundle is written directly to the publish directory -->
    </ItemGroup>
  </Target>
  <Target Name="_ComputeIntermediateDepsFilePath" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <!-- IntermediateDepsFilePath is the location where the deps.json file is originally created -->
      <IntermediateDepsFilePath Condition=" '$(PublishDepsFilePath)' != ''">$(PublishDepsFilePath)</IntermediateDepsFilePath>
      <IntermediateDepsFilePath Condition=" '$(PublishDepsFilePath)' == ''">$(IntermediateOutputPath)$(ProjectDepsFileName)</IntermediateDepsFilePath>
    </PropertyGroup>
  </Target>
  <Target Name="_GeneratePublishDependencyFileInputCache" DependsOnTargets="_ComputeIntermediateDepsFilePath" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(PublishDepsFilePath)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(PublishSingleFile)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(MSBuildProjectFullPath)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(ProjectAssetsFile)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(IntermediateDepsFilePath)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(TargetFramework)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(AssemblyName)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(TargetExt)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(Version)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(IncludeMainProjectInDepsFile)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(RuntimeIdentifier)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(MicrosoftNETPlatformLibrary)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(SelfContained)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(IncludeFileVersionsInDependencyFile)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(RuntimeIdentifierGraphPath)" />
      <_GeneratePublishDependencyFilePropertyInputsCacheToHash Include="$(IncludeProjectsNotInAssetsFileInDepsFile)" />
    </ItemGroup>
    <Hash ItemsToHash="@(_GeneratePublishDependencyFilePropertyInputsCacheToHash)">
      <Output TaskParameter="HashResult" PropertyName="_GeneratePublishDependencyFilePropertyInputsCacheHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_GeneratePublishDependencyFilePropertyInputsCacheHash)" File="$(_GeneratePublishDependencyFilePropertyInputsCache)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(_GeneratePublishDependencyFilePropertyInputsCache)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GeneratePublishDependencyFile
    Generates the $(project).deps.json file for a published app
    ============================================================
    -->
  <Target Name="GeneratePublishDependencyFile" DependsOnTargets="_ComputeUseBuildDependencyFile;&#xA;                            _ComputeIntermediateDepsFilePath;&#xA;                            _DefaultMicrosoftNETPlatformLibrary;&#xA;                            _HandlePackageFileConflicts;&#xA;                            _HandlePackageFileConflictsForPublish;&#xA;                            _ComputeReferenceAssemblies;&#xA;                            _ComputeUserRuntimeAssemblies;&#xA;                            ResolveRuntimePackAssets;&#xA;                            _ComputePackageReferencePublish;&#xA;                            _GeneratePublishDependencyFileInputCache" Condition="'$(GenerateDependencyFile)' == 'true' and '$(_UseBuildDependencyFile)' != 'true' and '$(PublishAot)' != 'true'" Inputs="$(ProjectAssetsFile);$(ProjectAssetsCacheFile);$(MSBuildAllProjects);$(_GeneratePublishDependencyFilePropertyInputsCache)" Outputs="$(IntermediateDepsFilePath)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <!-- PublishDepsFilePath is the location where the deps.json resides when published
           PublishDepsFilePath is empty (by default) for PublishSingleFile, since the deps.json file is embedded within the single-file bundle -->
      <PublishDepsFilePath Condition=" '$(PublishDepsFilePath)' == '' And '$(PublishSingleFile)' != 'true'">$(PublishDir)$(ProjectDepsFileName)</PublishDepsFilePath>
      <_IsSingleFilePublish Condition="'$(PublishSingleFile)' == ''">false</_IsSingleFilePublish>
      <_IsSingleFilePublish Condition="'$(PublishSingleFile)' != ''">$(PublishSingleFile)</_IsSingleFilePublish>
    </PropertyGroup>
    <ItemGroup>
      <ResolvedCompileFileDefinitions Remove="@(_PublishConflictPackageFiles)" Condition="'%(_PublishConflictPackageFiles.ConflictItemType)' == 'Reference'" />
      <RuntimeTargetsCopyLocalItems Remove="@(_PublishConflictPackageFiles)" Condition="'%(_PublishConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <RuntimePackAsset Remove="@(_PublishConflictPackageFiles)" Condition="'%(_PublishConflictPackageFiles.ConflictItemType)' != 'Reference'" />
      <_ResolvedNuGetFilesForPublish Include="@(NativeCopyLocalItems)" Condition="'%(NativeCopyLocalItems.CopyToPublishDirectory)' != 'false'" />
      <_ResolvedNuGetFilesForPublish Include="@(ResourceCopyLocalItems)" Condition="'%(ResourceCopyLocalItems.CopyToPublishDirectory)' != 'false'" />
      <_ResolvedNuGetFilesForPublish Include="@(RuntimeCopyLocalItems)" Condition="'%(RuntimeCopyLocalItems.CopyToPublishDirectory)' != 'false'" />
      <_ResolvedNuGetFilesForPublish Remove="@(_PublishConflictPackageFiles)" Condition="'%(_PublishConflictPackageFiles.ConflictItemType)' != 'Reference'" />
    </ItemGroup>
    <GenerateDepsFile ProjectPath="$(MSBuildProjectFullPath)" AssetsFilePath="$(ProjectAssetsFile)" DepsFilePath="$(IntermediateDepsFilePath)" TargetFramework="$(TargetFramework)" AssemblyName="$(AssemblyName)" AssemblyExtension="$(TargetExt)" AssemblyVersion="$(Version)" AssemblySatelliteAssemblies="@(IntermediateSatelliteAssembliesWithTargetPath)" ReferencePaths="@(ReferencePath)" ReferenceDependencyPaths="@(ReferenceDependencyPaths)" ReferenceSatellitePaths="@(ReferenceSatellitePaths)" ReferenceAssemblies="@(_ReferenceAssemblies)" RuntimePackAssets="@(RuntimePackAsset)" IncludeMainProject="$(IncludeMainProjectInDepsFile)" TrimDepsJsonLibrariesWithoutAssets="$(TrimDepsJsonLibrariesWithoutAssets)" RuntimeIdentifier="$(RuntimeIdentifier)" PlatformLibraryName="$(MicrosoftNETPlatformLibrary)" RuntimeFrameworks="@(RuntimeFramework)" CompilerOptions="@(DependencyFileCompilerOptions)" RuntimeStorePackages="@(RuntimeStorePackages)" CompileReferences="@(ResolvedCompileFileDefinitions)" ResolvedNuGetFiles="@(_ResolvedNuGetFilesForPublish)" ResolvedRuntimeTargetsFiles="@(RuntimeTargetsCopyLocalItems)" UserRuntimeAssemblies="@(UserRuntimeAssembly)" IsSelfContained="$(SelfContained)" IsSingleFile="$(_IsSingleFilePublish)" IncludeRuntimeFileVersions="$(IncludeFileVersionsInDependencyFile)" RuntimeGraphPath="$(RuntimeIdentifierGraphPath)" IncludeProjectsNotInAssetsFile="$(IncludeProjectsNotInAssetsFileInDepsFile)" />
    <ItemGroup>
      <ResolvedFileToPublish Include="$(IntermediateDepsFilePath)">
        <RelativePath>$(ProjectDepsFileName)</RelativePath>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        ComputeEmbeddedApphostPaths

    When no build flag is set, EmbeddedApphostPaths is not available. Compute EmbeddedApphostPaths is required to find build asset.
    ============================================================
    -->
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.GetEmbeddedApphostPaths" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ComputeEmbeddedApphostPaths" Condition="'$(PackAsTool)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_PackAsToolShimRuntimeIdentifiers Condition="@(_PackAsToolShimRuntimeIdentifiers) ==''" Include="$(PackAsToolShimRuntimeIdentifiers)" />
    </ItemGroup>
    <GetEmbeddedApphostPaths PackagedShimOutputDirectory="$(PackagedShimOutputRootDirectory)/shims/$(TargetFramework)" ShimRuntimeIdentifiers="@(_PackAsToolShimRuntimeIdentifiers)" ToolCommandName="$(ToolCommandName)">
      <Output TaskParameter="EmbeddedApphostPaths" ItemName="_EmbeddedApphostPaths" />
    </GetEmbeddedApphostPaths>
  </Target>
  <!--
    ============================================================
                                            ComputeFilesCopiedToPublishDir

    Gathers all the files that will be copied to the publish directory.  This is used by wapproj and is required for back compat.
    ============================================================
    -->
  <Target Name="ComputeFilesCopiedToPublishDir" DependsOnTargets="ComputeResolvedFilesToPublishList;&#xA;                            _ComputeFilesToBundle" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <FilesCopiedToPublishDir Include="@(ResolvedFileToPublish)" />
      <FilesCopiedToPublishDir Include="$(PublishedSingleFilePath)" RelativePath="$(PublishedSingleFileName)" IsKeyOutput="true" Condition="'$(PublishSingleFile)' == 'true'" />
      <!-- Wapproj handles adding the correct deps.json file, so remove it here to avoid duplicates. -->
      <FilesCopiedToPublishDir Remove="@(FilesCopiedToPublishDir)" Condition="'%(FilesCopiedToPublishDir.Filename)%(FilesCopiedToPublishDir.Extension)' == '$(ProjectDepsFileName)'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                            PublishItemsOutputGroup

    Emit an output group containing all files that get published.  This will be consumed by VS installer projects.
    ============================================================
    -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PublishItemsOutputGroupDependsOn>
      $(PublishItemsOutputGroupDependsOn);
      ResolveReferences;
      ComputeResolvedFilesToPublishList;
      _ComputeFilesToBundle;
    </PublishItemsOutputGroupDependsOn>
  </PropertyGroup>
  <UsingTask TaskName="Microsoft.NET.Build.Tasks.GetPublishItemsOutputGroupOutputs" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="PublishItemsOutputGroup" DependsOnTargets="$(PublishItemsOutputGroupDependsOn)" Returns="@(PublishItemsOutputGroupOutputs)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GetPublishItemsOutputGroupOutputs ResolvedFileToPublish="@(ResolvedFileToPublish)" PublishDir="$(PublishDir)">
      <Output TaskParameter="PublishItemsOutputGroupOutputs" ItemName="PublishItemsOutputGroupOutputs" />
    </GetPublishItemsOutputGroupOutputs>
    <ItemGroup>
      <PublishItemsOutputGroupOutputs Include="$(PublishedSingleFilePath)" TargetPath="$(PublishedSingleFileName)" IsKeyOutput="true" Condition="'$(PublishSingleFile)' == 'true'" OutputPath="$(PublishedSingleFilePath)" OutputGroup="PublishItemsOutputGroup" />
    </ItemGroup>
  </Target>
  <!--
    This target exists for back-compat with Azure Functions SDK: https://github.com/dotnet/cli/issues/10363
    Because build copy-local now behaves the same as publish with respect to package dependency resolution,
    the Azure Functions SDK doesn't need to resolve publish assets for build.
    TODO: Remove this target when no longer needed as a workaround.
    -->
  <Target Name="RunResolvePublishAssemblies" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    ============================================================
    _CheckForLanguageAndPublishFeatureCombinationSupport

    Block unsupported language and feature combination.
    ============================================================
    -->
  <Target Name="_CheckForLanguageAndPublishFeatureCombinationSupport" Condition="$(IsPublishable) == 'true'" BeforeTargets="Publish;PrepareForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true') and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" ResourceName="NoSupportCppPublishDotnetCore" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackStubs.targets" Condition="('$(Language)' == 'C++' and '$(_EnablePackageReferencesInVCProjects)' != 'true')" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackTool.targets" Condition="'$(PackAsTool)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PackProjectTool.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.PackProjectTool.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.PackProjectTool.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <Target Name="_PackProjectToolValidation" Condition=" '$(PackageType)' == 'DotnetCliTool'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_TargetFrameworkVersionWithoutV)' &gt; '2.2' " ResourceName="ProjectToolOnlySupportTFMLowerThanNetcoreapp22" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.PreserveCompilationContext.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.PreserveCompilationContext.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.PreserveCompilationContext.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RefAssembliesFolderName Condition="'$(RefAssembliesFolderName)' == ''">refs</RefAssembliesFolderName>
    <PreserveCompilationReferences Condition=" '$(PreserveCompilationReferences)' == ''">$(PreserveCompilationContext)</PreserveCompilationReferences>
  </PropertyGroup>
  <Target Name="ComputeDependencyFileCompilerOptions" Condition="'$(PreserveCompilationContext)' == 'true'" BeforeTargets="GenerateBuildDependencyFile;&#xA;                         GeneratePublishDependencyFile" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <DependencyFileCompilerOptions Include="CompilerOptions">
        <DefineConstants>$(DefineConstants)</DefineConstants>
        <LangVersion>$(LangVersion)</LangVersion>
        <PlatformTarget>$(PlatformTarget)</PlatformTarget>
        <AllowUnsafeBlocks>$(AllowUnsafeBlocks)</AllowUnsafeBlocks>
        <TreatWarningsAsErrors>$(TreatWarningsAsErrors)</TreatWarningsAsErrors>
        <Optimize>$(Optimize)</Optimize>
        <AssemblyOriginatorKeyFile>$(AssemblyOriginatorKeyFile)</AssemblyOriginatorKeyFile>
        <DelaySign>$(DelaySign)</DelaySign>
        <PublicSign>$(PublicSign)</PublicSign>
        <DebugType>$(DebugType)</DebugType>
        <OutputType>$(OutputType)</OutputType>
        <GenerateDocumentationFile>$(GenerateDocumentationFile)</GenerateDocumentationFile>
      </DependencyFileCompilerOptions>
    </ItemGroup>
  </Target>
  <UsingTask TaskName="FindItemsFromPackages" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="ComputeRefAssembliesToPublish" Condition="'$(PreserveCompilationReferences)' == 'true'" DependsOnTargets="ResolvePackageAssets;&#xA;                            _ParseTargetManifestFiles" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <FindItemsFromPackages Items="@(RuntimeCopyLocalItems)" Packages="@(RuntimeStorePackages)">
      <Output TaskParameter="ItemsFromPackages" ItemName="_RuntimeItemsInRuntimeStore" />
    </FindItemsFromPackages>
    <ItemGroup>
      <!--
      Don't copy a compilation assembly if it's also a runtime assembly. There is no need to copy the same
      assembly to the 'refs' folder, if it is already in the publish directory.
      -->
      <_RefAssembliesToExclude Include="@(_ResolvedCopyLocalPublishAssets->'%(FullPath)')" />
      <!--
      Similarly, don't copy a compilation assembly if it's also a runtime assembly that is in a runtime store.
      It will be resolved from the runtime store directory at runtime.
      -->
      <_RefAssembliesToExclude Include="@(_RuntimeItemsInRuntimeStore)" />
      <ResolvedFileToPublish Include="@(ReferencePath)" Exclude="@(_RefAssembliesToExclude)">
        <RelativePath>$(RefAssembliesFolderName)\%(Filename)%(Extension)</RelativePath>
      </ResolvedFileToPublish>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                                        _CopyReferenceOnlyAssembliesForBuild

    Copies reference assemblies that normally can't be resolved at runtime to the 'refs' folder in the build output.
    This is necessary in order for the running app to resolve these reference assemblies.
    ============================================================
    -->
  <Target Name="_CopyReferenceOnlyAssembliesForBuild" Condition="'$(PreserveCompilationReferences)' == 'true'" DependsOnTargets="_ComputeReferenceAssemblies" AfterTargets="CopyFilesToOutputDirectory" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Copy SourceFiles="@(_ReferenceOnlyAssemblies)" DestinationFolder="$(OutDir)$(RefAssembliesFolderName)" SkipUnchangedFiles="$(SkipCopyUnchangedFiles)" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.ConflictResolution.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ConflictResolution.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ConflictResolution.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.DefaultPackageConflictOverrides.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.DefaultPackageConflictOverrides.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.DefaultPackageConflictOverrides.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <ItemGroup Condition="'$(DisableDefaultPackageConflictOverrides)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageConflictOverrides Include="Microsoft.NETCore.App" Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And ('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &lt; '3.0')">
      <OverriddenPackages>
        Microsoft.CSharp|4.4.0;
        Microsoft.Win32.Primitives|4.3.0;
        Microsoft.Win32.Registry|4.4.0;
        runtime.debian.8-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.fedora.23-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.fedora.24-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.opensuse.13.2-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.opensuse.42.1-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.osx.10.10-x64.runtime.native.System.Security.Cryptography.Apple|4.3.0;
        runtime.osx.10.10-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.rhel.7-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.14.04-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.16.04-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        runtime.ubuntu.16.10-x64.runtime.native.System.Security.Cryptography.OpenSsl|4.3.0;
        System.AppContext|4.3.0;
        System.Buffers|4.4.0;
        System.Collections|4.3.0;
        System.Collections.Concurrent|4.3.0;
        System.Collections.Immutable|1.4.0;
        System.Collections.NonGeneric|4.3.0;
        System.Collections.Specialized|4.3.0;
        System.ComponentModel|4.3.0;
        System.ComponentModel.EventBasedAsync|4.3.0;
        System.ComponentModel.Primitives|4.3.0;
        System.ComponentModel.TypeConverter|4.3.0;
        System.Console|4.3.0;
        System.Data.Common|4.3.0;
        System.Diagnostics.Contracts|4.3.0;
        System.Diagnostics.Debug|4.3.0;
        System.Diagnostics.DiagnosticSource|4.4.0;
        System.Diagnostics.FileVersionInfo|4.3.0;
        System.Diagnostics.Process|4.3.0;
        System.Diagnostics.StackTrace|4.3.0;
        System.Diagnostics.TextWriterTraceListener|4.3.0;
        System.Diagnostics.Tools|4.3.0;
        System.Diagnostics.TraceSource|4.3.0;
        System.Diagnostics.Tracing|4.3.0;
        System.Dynamic.Runtime|4.3.0;
        System.Globalization|4.3.0;
        System.Globalization.Calendars|4.3.0;
        System.Globalization.Extensions|4.3.0;
        System.IO|4.3.0;
        System.IO.Compression|4.3.0;
        System.IO.Compression.ZipFile|4.3.0;
        System.IO.FileSystem|4.3.0;
        System.IO.FileSystem.AccessControl|4.4.0;
        System.IO.FileSystem.DriveInfo|4.3.0;
        System.IO.FileSystem.Primitives|4.3.0;
        System.IO.FileSystem.Watcher|4.3.0;
        System.IO.IsolatedStorage|4.3.0;
        System.IO.MemoryMappedFiles|4.3.0;
        System.IO.Pipes|4.3.0;
        System.IO.UnmanagedMemoryStream|4.3.0;
        System.Linq|4.3.0;
        System.Linq.Expressions|4.3.0;
        System.Linq.Queryable|4.3.0;
        System.Net.Http|4.3.0;
        System.Net.NameResolution|4.3.0;
        System.Net.Primitives|4.3.0;
        System.Net.Requests|4.3.0;
        System.Net.Security|4.3.0;
        System.Net.Sockets|4.3.0;
        System.Net.WebHeaderCollection|4.3.0;
        System.ObjectModel|4.3.0;
        System.Private.DataContractSerialization|4.3.0;
        System.Reflection|4.3.0;
        System.Reflection.Emit|4.3.0;
        System.Reflection.Emit.ILGeneration|4.3.0;
        System.Reflection.Emit.Lightweight|4.3.0;
        System.Reflection.Extensions|4.3.0;
        System.Reflection.Metadata|1.5.0;
        System.Reflection.Primitives|4.3.0;
        System.Reflection.TypeExtensions|4.3.0;
        System.Resources.ResourceManager|4.3.0;
        System.Runtime|4.3.0;
        System.Runtime.Extensions|4.3.0;
        System.Runtime.Handles|4.3.0;
        System.Runtime.InteropServices|4.3.0;
        System.Runtime.InteropServices.RuntimeInformation|4.3.0;
        System.Runtime.Loader|4.3.0;
        System.Runtime.Numerics|4.3.0;
        System.Runtime.Serialization.Formatters|4.3.0;
        System.Runtime.Serialization.Json|4.3.0;
        System.Runtime.Serialization.Primitives|4.3.0;
        System.Security.AccessControl|4.4.0;
        System.Security.Claims|4.3.0;
        System.Security.Cryptography.Algorithms|4.3.0;
        System.Security.Cryptography.Cng|4.4.0;
        System.Security.Cryptography.Csp|4.3.0;
        System.Security.Cryptography.Encoding|4.3.0;
        System.Security.Cryptography.OpenSsl|4.4.0;
        System.Security.Cryptography.Primitives|4.3.0;
        System.Security.Cryptography.X509Certificates|4.3.0;
        System.Security.Cryptography.Xml|4.4.0;
        System.Security.Principal|4.3.0;
        System.Security.Principal.Windows|4.4.0;
        System.Text.Encoding|4.3.0;
        System.Text.Encoding.Extensions|4.3.0;
        System.Text.RegularExpressions|4.3.0;
        System.Threading|4.3.0;
        System.Threading.Overlapped|4.3.0;
        System.Threading.Tasks|4.3.0;
        System.Threading.Tasks.Extensions|4.3.0;
        System.Threading.Tasks.Parallel|4.3.0;
        System.Threading.Thread|4.3.0;
        System.Threading.ThreadPool|4.3.0;
        System.Threading.Timer|4.3.0;
        System.ValueTuple|4.3.0;
        System.Xml.ReaderWriter|4.3.0;
        System.Xml.XDocument|4.3.0;
        System.Xml.XmlDocument|4.3.0;
        System.Xml.XmlSerializer|4.3.0;
        System.Xml.XPath|4.3.0;
        System.Xml.XPath.XDocument|4.3.0;
      </OverriddenPackages>
    </PackageConflictOverrides>
    <PackageConflictOverrides Include="NETStandard.Library">
      <OverriddenPackages>
        Microsoft.Win32.Primitives|4.3.0;
        System.AppContext|4.3.0;
        System.Collections|4.3.0;
        System.Collections.Concurrent|4.3.0;
        System.Collections.Immutable|1.4.0;
        System.Collections.NonGeneric|4.3.0;
        System.Collections.Specialized|4.3.0;
        System.ComponentModel|4.3.0;
        System.ComponentModel.EventBasedAsync|4.3.0;
        System.ComponentModel.Primitives|4.3.0;
        System.ComponentModel.TypeConverter|4.3.0;
        System.Console|4.3.0;
        System.Data.Common|4.3.0;
        System.Diagnostics.Contracts|4.3.0;
        System.Diagnostics.Debug|4.3.0;
        System.Diagnostics.FileVersionInfo|4.3.0;
        System.Diagnostics.Process|4.3.0;
        System.Diagnostics.StackTrace|4.3.0;
        System.Diagnostics.TextWriterTraceListener|4.3.0;
        System.Diagnostics.Tools|4.3.0;
        System.Diagnostics.TraceSource|4.3.0;
        System.Diagnostics.Tracing|4.3.0;
        System.Dynamic.Runtime|4.3.0;
        System.Globalization|4.3.0;
        System.Globalization.Calendars|4.3.0;
        System.Globalization.Extensions|4.3.0;
        System.IO|4.3.0;
        System.IO.Compression|4.3.0;
        System.IO.Compression.ZipFile|4.3.0;
        System.IO.FileSystem|4.3.0;
        System.IO.FileSystem.DriveInfo|4.3.0;
        System.IO.FileSystem.Primitives|4.3.0;
        System.IO.FileSystem.Watcher|4.3.0;
        System.IO.IsolatedStorage|4.3.0;
        System.IO.MemoryMappedFiles|4.3.0;
        System.IO.Pipes|4.3.0;
        System.IO.UnmanagedMemoryStream|4.3.0;
        System.Linq|4.3.0;
        System.Linq.Expressions|4.3.0;
        System.Linq.Queryable|4.3.0;
        System.Net.Http|4.3.0;
        System.Net.NameResolution|4.3.0;
        System.Net.Primitives|4.3.0;
        System.Net.Requests|4.3.0;
        System.Net.Security|4.3.0;
        System.Net.Sockets|4.3.0;
        System.Net.WebHeaderCollection|4.3.0;
        System.ObjectModel|4.3.0;
        System.Private.DataContractSerialization|4.3.0;
        System.Reflection|4.3.0;
        System.Reflection.Emit|4.3.0;
        System.Reflection.Emit.ILGeneration|4.3.0;
        System.Reflection.Emit.Lightweight|4.3.0;
        System.Reflection.Extensions|4.3.0;
        System.Reflection.Primitives|4.3.0;
        System.Reflection.TypeExtensions|4.3.0;
        System.Resources.ResourceManager|4.3.0;
        System.Runtime|4.3.0;
        System.Runtime.Extensions|4.3.0;
        System.Runtime.Handles|4.3.0;
        System.Runtime.InteropServices|4.3.0;
        System.Runtime.InteropServices.RuntimeInformation|4.3.0;
        System.Runtime.Loader|4.3.0;
        System.Runtime.Numerics|4.3.0;
        System.Runtime.Serialization.Formatters|4.3.0;
        System.Runtime.Serialization.Json|4.3.0;
        System.Runtime.Serialization.Primitives|4.3.0;
        System.Security.AccessControl|4.4.0;
        System.Security.Claims|4.3.0;
        System.Security.Cryptography.Algorithms|4.3.0;
        System.Security.Cryptography.Csp|4.3.0;
        System.Security.Cryptography.Encoding|4.3.0;
        System.Security.Cryptography.Primitives|4.3.0;
        System.Security.Cryptography.X509Certificates|4.3.0;
        System.Security.Cryptography.Xml|4.4.0;
        System.Security.Principal|4.3.0;
        System.Security.Principal.Windows|4.4.0;
        System.Text.Encoding|4.3.0;
        System.Text.Encoding.Extensions|4.3.0;
        System.Text.RegularExpressions|4.3.0;
        System.Threading|4.3.0;
        System.Threading.Overlapped|4.3.0;
        System.Threading.Tasks|4.3.0;
        System.Threading.Tasks.Extensions|4.3.0;
        System.Threading.Tasks.Parallel|4.3.0;
        System.Threading.Thread|4.3.0;
        System.Threading.ThreadPool|4.3.0;
        System.Threading.Timer|4.3.0;
        System.ValueTuple|4.3.0;
        System.Xml.ReaderWriter|4.3.0;
        System.Xml.XDocument|4.3.0;
        System.Xml.XmlDocument|4.3.0;
        System.Xml.XmlSerializer|4.3.0;
        System.Xml.XPath|4.3.0;
        System.Xml.XPath.XDocument|4.3.0;
      </OverriddenPackages>
    </PackageConflictOverrides>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ConflictResolution.targets
============================================================================================================================================
-->
  <UsingTask TaskName="ResolvePackageFileConflicts" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="CheckForDuplicateItemMetadata" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!--
    _HandlePackageFileConflicts
    Handles package file conflict resolution for build.
    This will differ from the conflict resolution at publish time if the publish assets differ from build.
  -->
  <Target Name="_HandlePackageFileConflicts" DependsOnTargets="GetFrameworkPaths;GetReferenceAssemblyPaths;ResolveTargetingPackAssets" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <!--
        All runtime assets for conflict resolution.
        Exclude the copy-local items since those are passed in separately.
      -->
      <_RuntimeAssetsForConflictResolution Include="@(RuntimeCopyLocalItems);&#xA;                 @(NativeCopyLocalItems);&#xA;                 @(ResourceCopyLocalItems);&#xA;                 @(RuntimeTargetsCopyLocalItems)" Exclude="@(ReferenceCopyLocalPaths)" />
    </ItemGroup>
    <ResolvePackageFileConflicts References="@(Reference)" Analyzers="@(Analyzer)" ReferenceCopyLocalPaths="@(ReferenceCopyLocalPaths)" OtherRuntimeItems="@(_RuntimeAssetsForConflictResolution)" PlatformManifests="@(PackageConflictPlatformManifests)" TargetFrameworkDirectories="$(TargetFrameworkDirectory)" PackageOverrides="@(PackageConflictOverrides)" PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="ReferencesWithoutConflicts" ItemName="_ReferencesWithoutConflicts" />
      <Output TaskParameter="AnalyzersWithoutConflicts" ItemName="_AnalyzersWithoutConflicts" />
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ReferenceCopyLocalPathsWithoutConflicts" />
      <Output TaskParameter="Conflicts" ItemName="_ConflictPackageFiles" />
    </ResolvePackageFileConflicts>
    <!-- Replace Reference / ReferenceCopyLocalPaths with the filtered lists.
         We must remove all and include rather than just remove since removal is based
         only on ItemSpec and duplicate ItemSpecs may exist with different metadata
         (eg: HintPath) -->
    <ItemGroup>
      <Reference Remove="@(Reference)" />
      <Reference Include="@(_ReferencesWithoutConflicts)" />
      <Analyzer Remove="@(Analyzer)" />
      <Analyzer Include="@(_AnalyzersWithoutConflicts)" />
      <ReferenceCopyLocalPaths Remove="@(ReferenceCopyLocalPaths)" />
      <ReferenceCopyLocalPaths Include="@(_ReferenceCopyLocalPathsWithoutConflicts)" />
    </ItemGroup>
  </Target>
  <!--
    _HandlePackageFileConflictsForPublish
    Handles package file conflict resolution for publish.
    Currently, publish assets may differ due to the following reasons:
      * A package was marked as excluded from publishing (including PrivateAssets="all").
      * There are runtime store packages to publish against.
      * If we're preserving store layout, which alters the destination paths of files.
    When none of these things are true, then we can rely on the conflict resolution from build.
  -->
  <Target Name="_HandlePackageFileConflictsForPublish" AfterTargets="_ResolveCopyLocalAssetsForPublish;&#xA;                        _FilterSatelliteResourcesForPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ResolvePackageFileConflicts ReferenceCopyLocalPaths="@(_ResolvedCopyLocalPublishAssets)" PlatformManifests="@(PackageConflictPlatformManifests)" TargetFrameworkDirectories="$(TargetFrameworkDirectory)" PreferredPackages="$(PackageConflictPreferredPackages)">
      <Output TaskParameter="ReferenceCopyLocalPathsWithoutConflicts" ItemName="_ResolvedCopyLocalPublishAssetsWithoutConflicts" />
      <Output TaskParameter="Conflicts" ItemName="_PublishConflictPackageFiles" />
    </ResolvePackageFileConflicts>
    <ItemGroup>
      <_ResolvedCopyLocalPublishAssets Remove="@(_ResolvedCopyLocalPublishAssets)" />
      <_ResolvedCopyLocalPublishAssets Include="@(_ResolvedCopyLocalPublishAssetsWithoutConflicts)" />
    </ItemGroup>
  </Target>
  <!--
  _HandleFileConflictsForPublish
  Ensures there are no duplicate files being written to the publish output.
  -->
  <Target Name="_HandleFileConflictsForPublish" AfterTargets="ComputeFilesToPublish" Condition="'$(ErrorOnDuplicatePublishOutputFiles)' != 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <CheckForDuplicateItemMetadata Items="@(ResolvedFileToPublish-&gt;Distinct())" MetadataName="RelativePath">
      <Output TaskParameter="DuplicatesExist" PropertyName="_ResolvedFileToPublishContainsDuplicates" />
      <Output TaskParameter="DuplicateItems" ItemName="_ResolvedFileToPublishDuplicatedItems" />
    </CheckForDuplicateItemMetadata>
    <NETSdkError Condition="'$(_ResolvedFileToPublishContainsDuplicates)' == 'true'" ResourceName="DuplicatePublishOutputFiles" FormatArguments="@(_ResolvedFileToPublishDuplicatedItems, ', ')" />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.CSharp.targets" Condition="'$(Language)' == 'C#'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.CSharp.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.CSharp.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AppDesignerFolder Condition="'$(AppDesignerFolder)' == ''">Properties</AppDesignerFolder>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DisableImplicitConfigurationDefines)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ImplicitConfigurationDefine>$(Configuration.ToUpperInvariant())</ImplicitConfigurationDefine>
    <!-- Replace dashes and periods in the configuration with underscores.  This makes it more likely that
         the resulting compilation constant will be a valid C# conditional compilation symbol.  As the set
         of characters that aren't allowed is essentially open-ended, there's probably not a good way to
         fully sanitize the Configuration in MSBuild evaluation.  If the resulting string still isn't a
         valid conditional compilation symbol, then the compiler will generate the following error and
         the define will be ignored:
            warning MSB3052: The parameter to the compiler is invalid, '/define:0BAD_DEFINE' will be ignored.
         -->
    <ImplicitConfigurationDefine>$(ImplicitConfigurationDefine.Replace('-', '_'))</ImplicitConfigurationDefine>
    <ImplicitConfigurationDefine>$(ImplicitConfigurationDefine.Replace('.', '_'))</ImplicitConfigurationDefine>
    <ImplicitConfigurationDefine>$(ImplicitConfigurationDefine.Replace(' ', '_'))</ImplicitConfigurationDefine>
    <DefineConstants>$(DefineConstants);$(ImplicitConfigurationDefine)</DefineConstants>
  </PropertyGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <DefineConstants>$(DefineConstants);$(VersionlessImplicitFrameworkDefine);$(ImplicitFrameworkDefine);$(BackwardsCompatFrameworkDefine)</DefineConstants>
  </PropertyGroup>
  <!-- Enable hot reload in 6.0 and newer C# projects -->
  <ItemGroup Condition="'$(SupportsHotReload)' != 'false' AND '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '6.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="SupportsHotReload" />
  </ItemGroup>
  <!--
    BinaryFormatter infrastructure is obsolete as error in 7.0+.
    When https://github.com/Microsoft/visualfsharp/issues/3207 is fixed,
    remove the block below and move it into the shared .targets file.
  -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <WarningsAsErrors Condition="'$(_BinaryFormatterObsoleteAsError)' == 'true'">$(WarningsAsErrors);SYSLIB0011</WarningsAsErrors>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.VisualBasic.targets" Condition="'$(Language)' == 'VB'" />-->
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.FSharp.targets" Condition="'$(Language)' == 'F#'" />-->
  <!--<Import Project="$(ILCompilerTargetsPath)" Condition="'$(ILCompilerTargetsPath)' != '' and '$(PublishAot)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="$(ILLinkTargetsPath)" Condition="'$(ILLinkTargetsPath)' != '' and '$(Language)' != 'C++'">

/home/runner/.nuget/packages/microsoft.net.illink.tasks/10.0.0-preview.7.25322.101/build/Microsoft.NET.ILLink.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ILLink.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- These properties should be set even if PublishTrimmed != true, to allow SDK components to
       set PublishTrimmed in targets which are imported after these targets. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IntermediateLinkDir Condition=" '$(IntermediateLinkDir)' == '' ">$(IntermediateOutputPath)linked\</IntermediateLinkDir>
    <IntermediateLinkDir Condition=" !HasTrailingSlash('$(IntermediateLinkDir)') ">$(IntermediateLinkDir)\</IntermediateLinkDir>
    <!-- Used to enable incremental build for the ILLink target. -->
    <_LinkSemaphore>$(IntermediateLinkDir)Link.semaphore</_LinkSemaphore>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AssemblyAttribute Condition="'$(IsTrimmable)' == 'true'" Include="System.Reflection.AssemblyMetadata">
      <_Parameter1>IsTrimmable</_Parameter1>
      <_Parameter2>True</_Parameter2>
    </AssemblyAttribute>
  </ItemGroup>
  <!-- We disable features for trimmed apps here so that the feature
      switches can flow to the runtimeconfig.json. Features are disabled
      by default since they may require assemblies, types or members that
      could be removed by the ILLink, causing a trimmed app to crash. -->
  <PropertyGroup Condition="'$(PublishTrimmed)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <StartupHookSupport Condition="'$(StartupHookSupport)' == ''">false</StartupHookSupport>
    <MetadataUpdaterSupport Condition="'$(MetadataUpdaterSupport)' == ''">false</MetadataUpdaterSupport>
    <CustomResourceTypesSupport Condition="'$(CustomResourceTypesSupport)' == ''">false</CustomResourceTypesSupport>
    <EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization Condition="'$(EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization)' == ''">false</EnableUnsafeBinaryFormatterInDesigntimeLicenseContextSerialization>
    <EnableUnsafeBinaryFormatterSerialization Condition="'$(EnableUnsafeBinaryFormatterSerialization)' == ''">false</EnableUnsafeBinaryFormatterSerialization>
    <EnableUnsafeUTF7Encoding Condition="'$(EnableUnsafeUTF7Encoding)' == ''">false</EnableUnsafeUTF7Encoding>
    <BuiltInComInteropSupport Condition="'$(BuiltInComInteropSupport)' == ''">false</BuiltInComInteropSupport>
    <!-- GeneratedComInterface/ComImport interop requires built-in COM -->
    <EnableGeneratedComInterfaceComImportInterop Condition="'$(BuiltInComInteropSupport)' == 'false'">false</EnableGeneratedComInterfaceComImportInterop>
    <EnableGeneratedComInterfaceComImportInterop Condition="'$(EnableGeneratedComInterfaceComImportInterop)' == ''">false</EnableGeneratedComInterfaceComImportInterop>
    <AutoreleasePoolSupport Condition="'$(AutoreleasePoolSupport)' == ''">false</AutoreleasePoolSupport>
    <EnableCppCLIHostActivation Condition="'$(EnableCppCLIHostActivation)' == ''">false</EnableCppCLIHostActivation>
    <!-- C++/CLI activation requires native hosting -->
    <_EnableConsumingManagedCodeFromNativeHosting Condition="'$(EnableCppCLIHostActivation)' == 'true'">true</_EnableConsumingManagedCodeFromNativeHosting>
    <_EnableConsumingManagedCodeFromNativeHosting Condition="'$(_EnableConsumingManagedCodeFromNativeHosting)' == ''">false</_EnableConsumingManagedCodeFromNativeHosting>
    <VerifyDependencyInjectionOpenGenericServiceTrimmability Condition="'$(VerifyDependencyInjectionOpenGenericServiceTrimmability)' == ''">true</VerifyDependencyInjectionOpenGenericServiceTrimmability>
    <JsonSerializerIsReflectionEnabledByDefault Condition="'$(JsonSerializerIsReflectionEnabledByDefault)' == ''">false</JsonSerializerIsReflectionEnabledByDefault>
    <!-- Linux Bionic doesn't ship GSSAPI, so enable managed implementation -->
    <_UseManagedNtlm Condition="'$(_UseManagedNtlm)' == '' and $(RuntimeIdentifier.StartsWith('linux-bionic'))">true</_UseManagedNtlm>
    <!-- Trim managed NTLM on Linux when it's not explicitly requested -->
    <_UseManagedNtlm Condition="'$(_UseManagedNtlm)' == '' and $(RuntimeIdentifier.StartsWith('linux'))">false</_UseManagedNtlm>
    <_ComObjectDescriptorSupport Condition="'$(_ComObjectDescriptorSupport)' == ''">false</_ComObjectDescriptorSupport>
    <_DesignerHostSupport Condition="'$(_DesignerHostSupport)' == ''">false</_DesignerHostSupport>
    <_DefaultValueAttributeSupport Condition="'$(_DefaultValueAttributeSupport)' == ''">false</_DefaultValueAttributeSupport>
    <DynamicCodeSupport Condition="'$(DynamicCodeSupport)' == ''">true</DynamicCodeSupport>
    <UseSystemResourceKeys Condition="'$(UseSystemResourceKeys)' == ''">false</UseSystemResourceKeys>
    <_DataSetXmlSerializationSupport Condition="'$(_DataSetXmlSerializationSupport)' == ''">false</_DataSetXmlSerializationSupport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(SuppressTrimAnalysisWarnings)' == '' And '$(PublishTrimmed)' == 'true' And '$(EnableTrimAnalyzer)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Suppress for WPF/WinForms -->
    <SuppressTrimAnalysisWarnings Condition="'$(UseWpf)' == 'true' Or '$(UseWindowsForms)' == 'true'">true</SuppressTrimAnalysisWarnings>
    <!-- Otherwise, for .NET 6+, warnings are on by default -->
    <SuppressTrimAnalysisWarnings Condition="'$(SuppressTrimAnalysisWarnings)' == ''">false</SuppressTrimAnalysisWarnings>
  </PropertyGroup>
  <!-- Suppress warnings produced by the trimming or by the ILLink Roslyn analyzer. -->
  <PropertyGroup Condition="'$(SuppressTrimAnalysisWarnings)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) --notrimwarn</_ExtraTrimmerArgs>
    <EnableTrimAnalyzer Condition="'$(EnableTrimAnalyzer)' == ''">false</EnableTrimAnalyzer>
  </PropertyGroup>
  <!-- Disable Redundant Warning Suppressions by default-->
  <PropertyGroup Condition="'$(_TrimmerShowRedundantSuppressions)' != 'true' And '$(PublishTrimmed)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NoWarn>$(NoWarn);IL2121</NoWarn>
  </PropertyGroup>
  <!--
    ============================================================
                     ILLink

    Replace the files to be published with versions that have been
    passed through ILLink. Also prevent removed files from being
    included in the generated deps.json.
    ============================================================
    -->
  <Target Name="ILLink" Condition=" '$(PublishTrimmed)' == 'true' And&#xD;&#xA;                      '$(RunILLink)' != 'false' And&#xD;&#xA;                      '$(TargetFrameworkIdentifier)' == '.NETCoreApp' " DependsOnTargets="_RunILLink" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkError Condition="'$(_ILLinkExitCode)' != '' And '$(_ILLinkExitCode)' != '0'" ResourceName="ILLinkFailed" />
    <ItemGroup>
      <_LinkedResolvedFileToPublish Include="@(_LinkedResolvedFileToPublishCandidate)" Condition="Exists('%(Identity)')" />
      <ResolvedFileToPublish Remove="@(ManagedAssemblyToLink)" />
      <ResolvedFileToPublish Remove="@(_PDBToLink)" />
      <ResolvedFileToPublish Include="@(_LinkedResolvedFileToPublish)" />
    </ItemGroup>
    <!-- Remove assemblies from inputs to GenerateDepsFile. See
         https://github.com/dotnet/sdk/pull/3086 -->
    <ItemGroup>
      <_RemovedManagedAssembly Include="@(ManagedAssemblyToLink)" Condition="!Exists('$(IntermediateLinkDir)%(Filename)%(Extension)')" />
      <ResolvedCompileFileDefinitions Remove="@(_RemovedManagedAssembly)" />
      <RuntimeCopyLocalItems Remove="@(_RemovedManagedAssembly)" />
      <RuntimeTargetsCopyLocalItems Remove="@(_RemovedManagedAssembly)" />
      <UserRuntimeAssembly Remove="@(_RemovedManagedAssembly)" />
      <RuntimePackAsset Remove="@(_RemovedManagedAssembly)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                     _RunILLink

    Execute ILLink. This target runs incrementally, only executing
    if the output semaphore file is out of date with respect to the inputs.
    ============================================================
    -->
  <UsingTask TaskName="ILLink" AssemblyFile="$(ILLinkTasksAssembly)" Condition="'$(ILLinkTasksAssembly)' != ''" TaskFactory="TaskHostFactory" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_RunILLink" DependsOnTargets="_ComputeManagedAssemblyToLink;PrepareForILLink" Inputs="$(MSBuildAllProjects);@(ManagedAssemblyToLink);@(TrimmerRootDescriptor);@(ReferencePath)" Outputs="$(_LinkSemaphore)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NETSdkInformation ResourceName="ILLinkRunning" />
    <!-- When running from Desktop MSBuild, DOTNET_HOST_PATH is not set.
         In this case, explicitly specify the path to the dotnet host. -->
    <PropertyGroup Condition=" '$(DOTNET_HOST_PATH)' == '' ">
      <_DotNetHostDirectory>$(NetCoreRoot)</_DotNetHostDirectory>
      <_DotNetHostFileName>dotnet</_DotNetHostFileName>
      <_DotNetHostFileName Condition="$([MSBuild]::IsOSPlatform(`Windows`))">dotnet.exe</_DotNetHostFileName>
    </PropertyGroup>
    <Delete Files="@(_LinkedResolvedFileToPublishCandidate)" />
    <ILLink AssemblyPaths="@(ManagedAssemblyToLink)" ReferenceAssemblyPaths="@(ReferencePath)" RootAssemblyNames="@(TrimmerRootAssembly)" TrimMode="$(TrimMode)" DefaultAction="$(_TrimmerDefaultAction)" RemoveSymbols="$(TrimmerRemoveSymbols)" PreserveSymbolPaths="$(_TrimmerPreserveSymbolPaths)" FeatureSettings="@(_TrimmerFeatureSettings)" CustomData="@(_TrimmerCustomData)" BeforeFieldInit="$(_TrimmerBeforeFieldInit)" OverrideRemoval="$(_TrimmerOverrideRemoval)" UnreachableBodies="$(_TrimmerUnreachableBodies)" UnusedInterfaces="$(_TrimmerUnusedInterfaces)" IPConstProp="$(_TrimmerIPConstProp)" Sealer="$(_TrimmerSealer)" KeepMetadata="@(_TrimmerKeepMetadata)" Warn="$(ILLinkWarningLevel)" NoWarn="$(NoWarn)" TreatWarningsAsErrors="$(ILLinkTreatWarningsAsErrors)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" SingleWarn="$(TrimmerSingleWarn)" CustomSteps="@(_TrimmerCustomSteps)" RootDescriptorFiles="@(TrimmerRootDescriptor)" OutputDirectory="$(IntermediateLinkDir)" DumpDependencies="$(_TrimmerDumpDependencies)" DependenciesFileFormat="$(_TrimmerDependenciesFileFormat)" ExtraArgs="$(_ExtraTrimmerArgs)" ToolExe="$(_DotNetHostFileName)" ToolPath="$(_DotNetHostDirectory)" ContinueOnError="ErrorAndContinue">
      <Output TaskParameter="ExitCode" PropertyName="_ILLinkExitCode" />
    </ILLink>
    <Touch Files="$(_LinkSemaphore)" AlwaysCreate="true" Condition=" '$(_ILLinkExitCode)' == '0' " />
  </Target>
  <!--
    ============================================================
                     PrepareForILLink

    Set up the default options and inputs to ILLink. Other targets are expected to hook into
    this extension point via BeforeTargets/AfterTargets to opt assemblies into or out of trimming
    using global ILLink options, or per-assembly IsTrimmable and TrimMode metadata.

    Note that adding items to or removing items from ManagedAssemblyToLink is unsupported. To change
    the set of inputs to ILLink, instead use a different extension point to
    set PostprocessAssembly metadata on ResolvedFileToPublish.
   -->
  <Target Name="PrepareForILLink" DependsOnTargets="_ComputeManagedAssemblyToLink" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- We print a message to the user to explain that trimming is
         potentially problematic when warnings are suppressed. -->
    <NETSdkInformation Condition="'$(PublishTrimmed)' == 'true' And '$(SuppressTrimAnalysisWarnings)' == 'true'" ResourceName="ILLinkOptimizedAssemblies" />
    <!-- The defaults currently root non-framework assemblies, which
         is a no-op for portable apps. If we later support more ways
         to customize the behavior we can allow linking portable apps
         in some cases. -->
    <NETSdkError Condition="'$(SelfContained)' != 'true'" ResourceName="ILLinkNotSupportedError" />
    <Warning Condition="'$(SuppressILLinkExplicitPackageReferenceWarning)' != 'true' And&#xD;&#xA;                        '%(PackageReference.Identity)' == 'Microsoft.NET.ILLink.Tasks' And '%(PackageReference.IsImplicitlyDefined)' != 'true'" Text="Delete explicit 'Microsoft.NET.ILLink.Tasks' package reference in your project file to avoid versioning problems." />
    <PropertyGroup Condition=" '$(ILLinkWarningLevel)' == '' ">
      <ILLinkWarningLevel Condition=" '$(EffectiveAnalysisLevel)' != '' And&#xD;&#xA;                                       $([MSBuild]::VersionGreaterThanOrEquals($(EffectiveAnalysisLevel), '5.0')) ">5</ILLinkWarningLevel>
      <ILLinkWarningLevel Condition=" '$(ILLinkWarningLevel)' == '' ">0</ILLinkWarningLevel>
    </PropertyGroup>
    <!-- In .NET 7, TrimmerDefaultAction is deprecated. TrimMode can be used for the supported configurations. -->
    <Warning Condition="'$(TrimmerDefaultAction)' != ''" Text="Property 'TrimmerDefaultAction' is deprecated in .NET 7 and higher and will be ignored. Use TrimMode instead." />
    <PropertyGroup Condition="'@(_ILLinkSuppressions-&gt;Count())' != '0'">
      <_ExtraTrimmerArgs>$(_ExtraTrimmerArgs) --link-attributes "@(_ILLinkSuppressions->'%(Identity)', '" --link-attributes "')"</_ExtraTrimmerArgs>
    </PropertyGroup>
    <!-- Set up TrimMode. -->
    <PropertyGroup>
      <TrimMode Condition="'$(TrimMode)' == ''">full</TrimMode>
    </PropertyGroup>
    <PropertyGroup>
      <ILLinkTreatWarningsAsErrors Condition=" '$(ILLinkTreatWarningsAsErrors)' == '' ">$(TreatWarningsAsErrors)</ILLinkTreatWarningsAsErrors>
      <TrimmerSingleWarn Condition=" '$(TrimmerSingleWarn)' == '' ">true</TrimmerSingleWarn>
    </PropertyGroup>
    <!-- Set a default value for TrimmerRemoveSymbols unless set explicitly. -->
    <PropertyGroup Condition=" '$(TrimmerRemoveSymbols)' == '' ">
      <!-- The default is to remove symbols when debugger support is disabled, and keep them otherwise. -->
      <TrimmerRemoveSymbols Condition=" '$(DebuggerSupport)' == 'false' ">true</TrimmerRemoveSymbols>
      <TrimmerRemoveSymbols Condition=" '$(DebuggerSupport)' != 'false' ">false</TrimmerRemoveSymbols>
    </PropertyGroup>
    <ItemGroup>
      <!-- Keep parameter name and other metadata unless debugger support is disabled. -->
      <_TrimmerKeepMetadata Include="all" Condition=" '$(DebuggerSupport)' != 'false' " />
    </ItemGroup>
    <PropertyGroup>
      <_TrimmerPreserveSymbolPaths Condition=" '$(_TrimmerPreserveSymbolPaths)' == '' and '$(DeterministicSourcePaths)' == 'true' ">true</_TrimmerPreserveSymbolPaths>
      <_TrimmerPreserveSymbolPaths Condition=" '$(_TrimmerPreserveSymbolPaths)' == '' ">false</_TrimmerPreserveSymbolPaths>
    </PropertyGroup>
    <!-- Set IsTrimmable for any assemblies that already have customized TrimMode. -->
    <ItemGroup>
      <ManagedAssemblyToLink Condition=" '%(ManagedAssemblyToLink.TrimMode)' != '' ">
        <IsTrimmable>true</IsTrimmable>
      </ManagedAssemblyToLink>
    </ItemGroup>
    <!-- SetIsTrimmable for any assemblies listed in TrimmableAssembly. -->
    <JoinItems Left="@(ManagedAssemblyToLink)" LeftKey="FileName" LeftMetadata="*" Right="@(TrimmableAssembly)" ItemSpecToUse="Left">
      <Output TaskParameter="JoinResult" ItemName="_TrimmableManagedAssemblyToLink" />
    </JoinItems>
    <ItemGroup>
      <ManagedAssemblyToLink Remove="@(_TrimmableManagedAssemblyToLink)" />
      <ManagedAssemblyToLink Include="@(_TrimmableManagedAssemblyToLink)" IsTrimmable="true" />
    </ItemGroup>
    <!-- Root the main assembly entry point. -->
    <ItemGroup>
      <TrimmerRootAssembly Include="@(IntermediateAssembly)" RootMode="EntryPoint" />
    </ItemGroup>
    <ItemGroup>
      <!-- Don't collapse to a single warning for the intermediate assembly.
           This just sets metadata on the items in ManagedAssemblyToLink that came from IntermediateAssembly. -->
      <!-- Find ManagedAssemblyToLink _except_ IntermediateAssembly -->
      <__SingleWarnIntermediateAssembly Include="@(ManagedAssemblyToLink)" />
      <__SingleWarnIntermediateAssembly Remove="@(IntermediateAssembly)" />
      <!-- Subtract these from ManagedAssemblyToLink, to get the intersection. -->
      <_SingleWarnIntermediateAssembly Include="@(ManagedAssemblyToLink)" />
      <_SingleWarnIntermediateAssembly Remove="@(__SingleWarnIntermediateAssembly)" />
      <!-- Set metadata on the intersection. -->
      <_SingleWarnIntermediateAssembly>
        <TrimmerSingleWarn Condition=" '%(_SingleWarnIntermediateAssembly.TrimmerSingleWarn)' == '' ">false</TrimmerSingleWarn>
      </_SingleWarnIntermediateAssembly>
      <!-- Replace these items in ManagedAssemblyToLink. -->
      <ManagedAssemblyToLink Remove="@(_SingleWarnIntermediateAssembly)" />
      <ManagedAssemblyToLink Include="@(_SingleWarnIntermediateAssembly)" />
      <!-- Don't collapse to a single warning for project references -->
      <ManagedAssemblyToLink Condition=" '%(ManagedAssemblyToLink.ProjectReferenceOriginalItemSpec)' != '' ">
        <TrimmerSingleWarn Condition=" '%(ManagedAssemblyToLink.TrimmerSingleWarn)' == '' ">false</TrimmerSingleWarn>
      </ManagedAssemblyToLink>
    </ItemGroup>
    <ItemGroup>
      <_TrimmerFeatureSettings Include="@(RuntimeHostConfigurationOption)" Condition="'%(RuntimeHostConfigurationOption.Trim)' == 'true'" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
                     _ComputeManagedAssemblyToLink

    Compute the set of inputs to ILLink.
    ============================================================
    -->
  <UsingTask TaskName="ComputeManagedAssemblies" AssemblyFile="$(ILLinkTasksAssembly)" Condition="'$(ILLinkTasksAssembly)' != ''" TaskFactory="TaskHostFactory" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_ComputeManagedAssemblyToLink" DependsOnTargets="_ComputeAssembliesToPostprocessOnPublish" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- NB: There should not be non-managed assemblies in this list, but we still give the ILLink a chance to
         further refine this list. It currently drops C++/CLI assemblies in ComputeManageAssemblies. -->
    <ComputeManagedAssemblies Assemblies="@(ResolvedFileToPublish-&gt;WithMetadataValue('PostprocessAssembly', 'true'))">
      <Output TaskParameter="ManagedAssemblies" ItemName="ManagedAssemblyToLink" />
    </ComputeManagedAssemblies>
    <ItemGroup>
      <!-- ILLink implicitly picks up PDBs next to input assemblies. We will filter these out of the publish set. -->
      <__PDBToLink Include="@(ResolvedFileToPublish)" Exclude="@(ManagedAssemblyToLink->'%(RelativeDir)%(Filename).pdb')" />
      <_PDBToLink Include="@(ResolvedFileToPublish)" Exclude="@(__PDBToLink)" />
    </ItemGroup>
    <ItemGroup>
      <_LinkedResolvedFileToPublishCandidate Include="@(ManagedAssemblyToLink->'$(IntermediateLinkDir)%(Filename)%(Extension)')" />
      <_LinkedResolvedFileToPublishCandidate Include="@(_PDBToLink->'$(IntermediateLinkDir)%(Filename)%(Extension)')" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.Analyzers.targets" Condition="'$(Language)' == 'C#' or '$(Language)' == 'VB'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.Analyzers.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Analyzers.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Analysis level is a single property that can be used to control both the compiler warning waves
         and enable .NET analyzers. Valid values are 'none', 'latest', 'preview', or a version number  -->
    <!-- If not specified and equal to the current most-recent TFM, default the AnalysisLevel to latest.
         Otherwise, default AnalysisLevel to the TFM. We set 'latest' indirectly here because the
         next chunk of logic handles user-defined prefix/suffix, which can also set 'latest', so
         we choose to only do the 'latest' => actual value translation one time. -->
    <_NoneAnalysisLevel>4.0</_NoneAnalysisLevel>
    <!-- When the base TFM of the platform bumps, these must be bumped as well. Preview should always be the 'next' TFM. -->
    <_LatestAnalysisLevel>9.0</_LatestAnalysisLevel>
    <_PreviewAnalysisLevel>10.0</_PreviewAnalysisLevel>
    <AnalysisLevel Condition="'$(AnalysisLevel)' == '' And&#xA;                              '$(TargetFrameworkIdentifier)' == '.NETCoreApp' And&#xA;                              $([MSBuild]::VersionEquals($(_TargetFrameworkVersionWithoutV), '$(_LatestAnalysisLevel)'))">latest</AnalysisLevel>
    <AnalysisLevel Condition="'$(AnalysisLevel)' == '' And&#xA;                              '$(TargetFrameworkIdentifier)' == '.NETCoreApp' And&#xA;                              $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '5.0'))">$(_TargetFrameworkVersionWithoutV)</AnalysisLevel>
    <!-- AnalysisLevel can also contain compound values with a prefix and suffix separated by a '-' character.
         The prefix indicates the core AnalysisLevel and the suffix indicates the bucket of
         rules to enable by default. For example, some valid compound values for AnalysisLevel are:
           1. '5-all' - Indicates core AnalysisLevel = '5' with 'all' the rules enabled by default.
           2. 'latest-none' - Indicates core AnalysisLevel = 'latest' with 'none' of the rules enabled by default.
         AnalysisLevelPrefix is used to set the EffectiveAnalysisLevel below.
         AnalysisLevelSuffix is processed further in Microsoft.CodeAnalysis.NetAnalyzers.targets imported below.
    -->
    <AnalysisLevelPrefix Condition="$(AnalysisLevel.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevel), '-(.)*', ''))</AnalysisLevelPrefix>
    <AnalysisLevelSuffix Condition="'$(AnalysisLevelPrefix)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevel), '$(AnalysisLevelPrefix)-', ''))</AnalysisLevelSuffix>
    <!-- EffectiveAnalysisLevel is used to differentiate from user specified strings (such as 'none')
         and an implied numerical option (such as '4')-->
    <EffectiveAnalysisLevel Condition="'$(AnalysisLevel)' == 'none' or '$(AnalysisLevelPrefix)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevel>
    <EffectiveAnalysisLevel Condition="'$(AnalysisLevel)' == 'latest' or '$(AnalysisLevelPrefix)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevel>
    <EffectiveAnalysisLevel Condition="'$(AnalysisLevel)' == 'preview' or '$(AnalysisLevelPrefix)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevel>
    <!-- Set EffectiveAnalysisLevel to the value of AnalysisLevel if it is a version number -->
    <EffectiveAnalysisLevel Condition="'$(EffectiveAnalysisLevel)' == '' And&#xA;                                       '$(AnalysisLevelPrefix)' != ''">$(AnalysisLevelPrefix)</EffectiveAnalysisLevel>
    <EffectiveAnalysisLevel Condition="'$(EffectiveAnalysisLevel)' == '' And&#xA;                                       '$(AnalysisLevel)' != ''">$(AnalysisLevel)</EffectiveAnalysisLevel>
    <!-- Set WarningLevel based on all we know about the project -->
    <!-- NOTE: at this time only the C# compiler supports warning waves like this. -->
    <!-- If the user specified 'preview' we want to pick a very high warning level to opt into the highest possible warning wave -->
    <WarningLevel Condition="'$(Language)' == 'C#' And '$(WarningLevel)' == '' And '$(AnalysisLevel)' == 'preview'">9999</WarningLevel>
    <!-- The CSharp.props used to hard-code WarningLevel to 4, so to maintain parity with .NET Framework projects we do that here. -->
    <WarningLevel Condition="'$(Language)' == 'C#' And '$(WarningLevel)' == '' And '$(TargetFrameworkIdentifier)' == '.NETFramework' ">4</WarningLevel>
    <!-- .NET projects, however, can float up to their TFM's major version -->
    <WarningLevel Condition="'$(Language)' == 'C#' And '$(WarningLevel)' == '' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp' ">$(_TargetFrameworkVersionWithoutV.Split('.')[0])</WarningLevel>
  </PropertyGroup>
  <!-- Enable Analyzers based on EffectiveAnalysisLevel -->
  <PropertyGroup Condition="'$(EffectiveAnalysisLevel)' != '' And&#xA;                             $([MSBuild]::VersionGreaterThanOrEquals($(EffectiveAnalysisLevel), '5.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- EnableNETAnalyzers Allows analyzers to be disabled in bulk via msbuild if the user wants to -->
    <EnableNETAnalyzers Condition="'$(EnableNETAnalyzers)' == ''">true</EnableNETAnalyzers>
    <!-- Intermediate step to enable ILLink.Analyzers so ILLink, Blazor, Xamarin, AOT, etc. can enable the same flags -->
    <EnableSingleFileAnalyzer Condition="'$(EnableSingleFileAnalyzer)' == '' And&#xA;                                         (&#xA;                                             ('$(PublishSingleFile)' == 'true' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp' And $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '$(_FirstTargetFrameworkVersionToSupportSingleFileAnalyzer)'))) Or&#xA;                                             ('$(PublishAot)' == 'true' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp' And $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '$(_FirstTargetFrameworkVersionToSupportAotAnalyzer)'))) Or&#xA;                                             '$(IsAotCompatible)' == 'true'&#xA;                                         )">true</EnableSingleFileAnalyzer>
    <!-- Enable the trim analyzer when any trimming settings are enabled. Warnings may suppressed based on other settings. -->
    <EnableTrimAnalyzer Condition="'$(EnableTrimAnalyzer)' == '' And&#xA;                                   (&#xA;                                       ('$(PublishTrimmed)' == 'true' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp' And $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '$(_FirstTargetFrameworkVersionToSupportTrimAnalyzer)'))) Or&#xA;                                       ('$(PublishAot)' == 'true' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp' And $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '$(_FirstTargetFrameworkVersionToSupportAotAnalyzer)'))) Or&#xA;                                       '$(IsTrimmable)' == 'true'&#xA;                                   )">true</EnableTrimAnalyzer>
    <!-- Enable the AOT analyzer when AOT is enabled. Warnings may suppressed based on other settings. -->
    <EnableAotAnalyzer Condition="'$(EnableAotAnalyzer)' == '' And&#xA;                                  (&#xA;                                      ('$(PublishAot)' == 'true' And '$(TargetFrameworkIdentifier)' == '.NETCoreApp' And $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '$(_FirstTargetFrameworkVersionToSupportAotAnalyzer)'))) Or&#xA;                                      '$(IsAotCompatible)' == 'true'&#xA;                                  )">true</EnableAotAnalyzer>
    <!-- EnforceCodeStyleInBuild Allows code style analyzers to be disabled in bulk via msbuild if the user wants to -->
    <EnforceCodeStyleInBuild Condition="'$(EnforceCodeStyleInBuild)' == ''">false</EnforceCodeStyleInBuild>
  </PropertyGroup>
  <!-- Establish good defaults for scenarios where no EffectiveAnalysisLevel was set (e.g. .NETFramework) -->
  <PropertyGroup Condition="'$(EffectiveAnalysisLevel)' == '' Or ('$(EffectiveAnalysisLevel)' != '' And $([MSBuild]::VersionLessThanOrEquals($(EffectiveAnalysisLevel), '4.0')))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <EnableNETAnalyzers Condition="'$(EnableNETAnalyzers)' == ''">false</EnableNETAnalyzers>
    <EnforceCodeStyleInBuild Condition="'$(EnforceCodeStyleInBuild)' == ''">false</EnforceCodeStyleInBuild>
    <EnableTrimAnalyzer Condition="'$(EnableTrimAnalyzer)' == ''">false</EnableTrimAnalyzer>
    <EnableAotAnalyzer Condition="'$(EnableAotAnalyzer)' == ''">false</EnableAotAnalyzer>
    <EnableSingleFileAnalyzer Condition="'$(EnableSingleFileAnalyzer)' == ''">false</EnableSingleFileAnalyzer>
  </PropertyGroup>
  <!-- Unconditionally import 'Microsoft.CodeAnalysis.NetAnalyzers.props' for all C# and VB projects for supporting https://github.com/dotnet/roslyn-analyzers/issues/3977 -->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\analyzers\build\Microsoft.CodeAnalysis.NetAnalyzers.props" Condition="'$(Language)' == 'C#' Or '$(Language)' == 'VB'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/analyzers/build/Microsoft.CodeAnalysis.NetAnalyzers.props
============================================================================================================================================
-->
  <!-- 
    This import includes an additional props file that disables built-in analyzers from .NET SDK that have the identical CA rules to those implemented in this package.
    This additional props file should only be present in the analyzer NuGet package, it should **not** be inserted into the .NET SDK.
  -->
  <!--<Import Project="DisableNETAnalyzersForNuGetPackage.props" Condition="Exists('DisableNETAnalyzersForNuGetPackage.props')" />-->
  <!--
    PropertyGroup to set the NetAnalyzers version installed in the SDK.
    We rely on the additional props file 'DisableNETAnalyzersForNuGetPackage.props' not being present in the SDK.
  -->
  <PropertyGroup Condition="!Exists('DisableNETAnalyzersForNuGetPackage.props')">
    <_NETAnalyzersSDKAssemblyVersion>10.0.0</_NETAnalyzersSDKAssemblyVersion>
  </PropertyGroup>
  <!-- 
    This property group handles 'CodeAnalysisTreatWarningsAsErrors = false' for the CA rule ids implemented in this package.
  -->
  <PropertyGroup>
    <CodeAnalysisRuleIds>CA1000;CA1001;CA1002;CA1003;CA1005;CA1008;CA1010;CA1012;CA1014;CA1016;CA1017;CA1018;CA1019;CA1021;CA1024;CA1027;CA1028;CA1030;CA1031;CA1032;CA1033;CA1034;CA1036;CA1040;CA1041;CA1043;CA1044;CA1045;CA1046;CA1047;CA1050;CA1051;CA1052;CA1054;CA1055;CA1056;CA1058;CA1060;CA1061;CA1062;CA1063;CA1064;CA1065;CA1066;CA1067;CA1068;CA1069;CA1070;CA1200;CA1303;CA1304;CA1305;CA1307;CA1308;CA1309;CA1310;CA1311;CA1401;CA1416;CA1417;CA1418;CA1419;CA1420;CA1421;CA1422;CA1501;CA1502;CA1505;CA1506;CA1507;CA1508;CA1509;CA1510;CA1511;CA1512;CA1513;CA1514;CA1515;CA1700;CA1707;CA1708;CA1710;CA1711;CA1712;CA1713;CA1715;CA1716;CA1720;CA1721;CA1724;CA1725;CA1727;CA1802;CA1805;CA1806;CA1810;CA1812;CA1813;CA1814;CA1815;CA1816;CA1819;CA1820;CA1821;CA1822;CA1823;CA1824;CA1825;CA1826;CA1827;CA1828;CA1829;CA1830;CA1831;CA1832;CA1833;CA1834;CA1835;CA1836;CA1837;CA1838;CA1839;CA1840;CA1841;CA1842;CA1843;CA1844;CA1845;CA1846;CA1847;CA1848;CA1849;CA1850;CA1851;CA1852;CA1853;CA1854;CA1855;CA1856;CA1857;CA1858;CA1859;CA1860;CA1861;CA1862;CA1863;CA1864;CA1865;CA1866;CA1867;CA1868;CA1869;CA1870;CA1871;CA1872;CA1873;CA1874;CA1875;CA2000;CA2002;CA2007;CA2008;CA2009;CA2011;CA2012;CA2013;CA2014;CA2015;CA2016;CA2017;CA2018;CA2019;CA2020;CA2021;CA2022;CA2023;CA2024;CA2025;CA2100;CA2101;CA2119;CA2153;CA2200;CA2201;CA2207;CA2208;CA2211;CA2213;CA2214;CA2215;CA2216;CA2217;CA2218;CA2219;CA2224;CA2225;CA2226;CA2227;CA2231;CA2234;CA2235;CA2237;CA2241;CA2242;CA2243;CA2244;CA2245;CA2246;CA2247;CA2248;CA2249;CA2250;CA2251;CA2252;CA2253;CA2254;CA2255;CA2256;CA2257;CA2258;CA2259;CA2260;CA2261;CA2262;CA2263;CA2264;CA2265;CA2300;CA2301;CA2302;CA2305;CA2310;CA2311;CA2312;CA2315;CA2321;CA2322;CA2326;CA2327;CA2328;CA2329;CA2330;CA2350;CA2351;CA2352;CA2353;CA2354;CA2355;CA2356;CA2361;CA2362;CA3001;CA3002;CA3003;CA3004;CA3005;CA3006;CA3007;CA3008;CA3009;CA3010;CA3011;CA3012;CA3061;CA3075;CA3076;CA3077;CA3147;CA5350;CA5351;CA5358;CA5359;CA5360;CA5361;CA5362;CA5363;CA5364;CA5365;CA5366;CA5367;CA5368;CA5369;CA5370;CA5371;CA5372;CA5373;CA5374;CA5375;CA5376;CA5377;CA5378;CA5379;CA5380;CA5381;CA5382;CA5383;CA5384;CA5385;CA5386;CA5387;CA5388;CA5389;CA5390;CA5391;CA5392;CA5393;CA5394;CA5395;CA5396;CA5397;CA5398;CA5399;CA5400;CA5401;CA5402;CA5403;CA5404;CA5405</CodeAnalysisRuleIds>
    <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
    <WarningsNotAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'false' and '$(TreatWarningsAsErrors)' == 'true'">$(WarningsNotAsErrors);$(CodeAnalysisRuleIds)</WarningsNotAsErrors>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.Analyzers.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\analyzers\build\Microsoft.CodeAnalysis.NetAnalyzers.targets" Condition="$(EnableNETAnalyzers)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/analyzers/build/Microsoft.CodeAnalysis.NetAnalyzers.targets
============================================================================================================================================
-->
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" BeforeTargets="CoreCompile" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true'">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersRulesVersion' to 'EffectiveAnalysisLevel' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersRulesVersion)' == '' and '$(EffectiveAnalysisLevel)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevel), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers>$(AnalysisLevelSuffix)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers)' == ''">$(AnalysisMode)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers Condition="'$(MicrosoftCodeAnalysisNetAnalyzersRulesVersion)' != ''">AnalysisLevel_$(MicrosoftCodeAnalysisNetAnalyzersRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzers)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzers Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzers)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzers>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzers Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzers)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzers)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzers>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzers)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzers)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersDesign" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelDesign)' != '' or '$(AnalysisModeDesign)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelDesign' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixDesign', 'AnalysisLevelSuffixDesign' and 'EffectiveAnalysisLevelDesign' -->
      <AnalysisLevelDesign Condition="'$(AnalysisLevelDesign)' == ''">$(AnalysisLevel)</AnalysisLevelDesign>
      <!-- AnalysisLevelDesign can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Design' rules and the suffix indicates the bucket of
           rules to enable for 'Design' rules by default. For example, some valid compound values for AnalysisLevelDesign are:
             1. '5-all' - Indicates core AnalysisLevelDesign = '5' with 'all' the 'Design' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelDesign = 'latest' with 'none' of the 'Design' rules enabled by default.
           AnalysisLevelPrefixDesign is used to set the EffectiveAnalysisLevelDesign below.
           AnalysisLevelSuffixDesign is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixDesign Condition="$(AnalysisLevelDesign.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelDesign), '-(.)*', ''))</AnalysisLevelPrefixDesign>
      <AnalysisLevelSuffixDesign Condition="'$(AnalysisLevelPrefixDesign)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelDesign), '$(AnalysisLevelPrefixDesign)-', ''))</AnalysisLevelSuffixDesign>
      <!-- EffectiveAnalysisLevelDesign is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelDesign Condition="'$(AnalysisLevelDesign)' == 'none' or '$(AnalysisLevelPrefixDesign)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelDesign>
      <EffectiveAnalysisLevelDesign Condition="'$(AnalysisLevelDesign)' == 'latest' or '$(AnalysisLevelPrefixDesign)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelDesign>
      <EffectiveAnalysisLevelDesign Condition="'$(AnalysisLevelDesign)' == 'preview' or '$(AnalysisLevelPrefixDesign)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelDesign>
      <!-- Set EffectiveAnalysisLevelDesign to the value of AnalysisLevelDesign if it is a version number -->
      <EffectiveAnalysisLevelDesign Condition="'$(EffectiveAnalysisLevelDesign)' == '' And&#xA;                                         '$(AnalysisLevelPrefixDesign)' != ''">$(AnalysisLevelPrefixDesign)</EffectiveAnalysisLevelDesign>
      <EffectiveAnalysisLevelDesign Condition="'$(EffectiveAnalysisLevelDesign)' == '' And&#xA;                                         '$(AnalysisLevelDesign)' != ''">$(AnalysisLevelDesign)</EffectiveAnalysisLevelDesign>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersDesignRulesVersion' to 'EffectiveAnalysisLevelDesign' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersDesignRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersDesignRulesVersion)' == '' and '$(EffectiveAnalysisLevelDesign)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelDesign), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersDesignRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign>$(AnalysisLevelSuffixDesign)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign)' == ''">$(AnalysisModeDesign)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersDesignRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign Condition="'$(MicrosoftCodeAnalysisNetAnalyzersDesignRulesVersion)' != ''">AnalysisLevelDesign_$(MicrosoftCodeAnalysisNetAnalyzersDesignRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDesign)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersDesign Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersDesign)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersDesign>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersDesign Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersDesign)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDesign)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersDesign>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersDesign)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersDesign)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersDocumentation" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelDocumentation)' != '' or '$(AnalysisModeDocumentation)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelDocumentation' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixDocumentation', 'AnalysisLevelSuffixDocumentation' and 'EffectiveAnalysisLevelDocumentation' -->
      <AnalysisLevelDocumentation Condition="'$(AnalysisLevelDocumentation)' == ''">$(AnalysisLevel)</AnalysisLevelDocumentation>
      <!-- AnalysisLevelDocumentation can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Documentation' rules and the suffix indicates the bucket of
           rules to enable for 'Documentation' rules by default. For example, some valid compound values for AnalysisLevelDocumentation are:
             1. '5-all' - Indicates core AnalysisLevelDocumentation = '5' with 'all' the 'Documentation' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelDocumentation = 'latest' with 'none' of the 'Documentation' rules enabled by default.
           AnalysisLevelPrefixDocumentation is used to set the EffectiveAnalysisLevelDocumentation below.
           AnalysisLevelSuffixDocumentation is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixDocumentation Condition="$(AnalysisLevelDocumentation.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelDocumentation), '-(.)*', ''))</AnalysisLevelPrefixDocumentation>
      <AnalysisLevelSuffixDocumentation Condition="'$(AnalysisLevelPrefixDocumentation)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelDocumentation), '$(AnalysisLevelPrefixDocumentation)-', ''))</AnalysisLevelSuffixDocumentation>
      <!-- EffectiveAnalysisLevelDocumentation is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelDocumentation Condition="'$(AnalysisLevelDocumentation)' == 'none' or '$(AnalysisLevelPrefixDocumentation)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelDocumentation>
      <EffectiveAnalysisLevelDocumentation Condition="'$(AnalysisLevelDocumentation)' == 'latest' or '$(AnalysisLevelPrefixDocumentation)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelDocumentation>
      <EffectiveAnalysisLevelDocumentation Condition="'$(AnalysisLevelDocumentation)' == 'preview' or '$(AnalysisLevelPrefixDocumentation)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelDocumentation>
      <!-- Set EffectiveAnalysisLevelDocumentation to the value of AnalysisLevelDocumentation if it is a version number -->
      <EffectiveAnalysisLevelDocumentation Condition="'$(EffectiveAnalysisLevelDocumentation)' == '' And&#xA;                                         '$(AnalysisLevelPrefixDocumentation)' != ''">$(AnalysisLevelPrefixDocumentation)</EffectiveAnalysisLevelDocumentation>
      <EffectiveAnalysisLevelDocumentation Condition="'$(EffectiveAnalysisLevelDocumentation)' == '' And&#xA;                                         '$(AnalysisLevelDocumentation)' != ''">$(AnalysisLevelDocumentation)</EffectiveAnalysisLevelDocumentation>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersDocumentationRulesVersion' to 'EffectiveAnalysisLevelDocumentation' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersDocumentationRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersDocumentationRulesVersion)' == '' and '$(EffectiveAnalysisLevelDocumentation)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelDocumentation), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersDocumentationRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation>$(AnalysisLevelSuffixDocumentation)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation)' == ''">$(AnalysisModeDocumentation)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersDocumentationRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation Condition="'$(MicrosoftCodeAnalysisNetAnalyzersDocumentationRulesVersion)' != ''">AnalysisLevelDocumentation_$(MicrosoftCodeAnalysisNetAnalyzersDocumentationRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersDocumentation)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersDocumentation Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersDocumentation)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersDocumentation Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersDocumentation)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersDocumentation)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersDocumentation>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersDocumentation)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersDocumentation)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersGlobalization" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelGlobalization)' != '' or '$(AnalysisModeGlobalization)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelGlobalization' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixGlobalization', 'AnalysisLevelSuffixGlobalization' and 'EffectiveAnalysisLevelGlobalization' -->
      <AnalysisLevelGlobalization Condition="'$(AnalysisLevelGlobalization)' == ''">$(AnalysisLevel)</AnalysisLevelGlobalization>
      <!-- AnalysisLevelGlobalization can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Globalization' rules and the suffix indicates the bucket of
           rules to enable for 'Globalization' rules by default. For example, some valid compound values for AnalysisLevelGlobalization are:
             1. '5-all' - Indicates core AnalysisLevelGlobalization = '5' with 'all' the 'Globalization' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelGlobalization = 'latest' with 'none' of the 'Globalization' rules enabled by default.
           AnalysisLevelPrefixGlobalization is used to set the EffectiveAnalysisLevelGlobalization below.
           AnalysisLevelSuffixGlobalization is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixGlobalization Condition="$(AnalysisLevelGlobalization.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelGlobalization), '-(.)*', ''))</AnalysisLevelPrefixGlobalization>
      <AnalysisLevelSuffixGlobalization Condition="'$(AnalysisLevelPrefixGlobalization)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelGlobalization), '$(AnalysisLevelPrefixGlobalization)-', ''))</AnalysisLevelSuffixGlobalization>
      <!-- EffectiveAnalysisLevelGlobalization is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelGlobalization Condition="'$(AnalysisLevelGlobalization)' == 'none' or '$(AnalysisLevelPrefixGlobalization)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelGlobalization>
      <EffectiveAnalysisLevelGlobalization Condition="'$(AnalysisLevelGlobalization)' == 'latest' or '$(AnalysisLevelPrefixGlobalization)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelGlobalization>
      <EffectiveAnalysisLevelGlobalization Condition="'$(AnalysisLevelGlobalization)' == 'preview' or '$(AnalysisLevelPrefixGlobalization)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelGlobalization>
      <!-- Set EffectiveAnalysisLevelGlobalization to the value of AnalysisLevelGlobalization if it is a version number -->
      <EffectiveAnalysisLevelGlobalization Condition="'$(EffectiveAnalysisLevelGlobalization)' == '' And&#xA;                                         '$(AnalysisLevelPrefixGlobalization)' != ''">$(AnalysisLevelPrefixGlobalization)</EffectiveAnalysisLevelGlobalization>
      <EffectiveAnalysisLevelGlobalization Condition="'$(EffectiveAnalysisLevelGlobalization)' == '' And&#xA;                                         '$(AnalysisLevelGlobalization)' != ''">$(AnalysisLevelGlobalization)</EffectiveAnalysisLevelGlobalization>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersGlobalizationRulesVersion' to 'EffectiveAnalysisLevelGlobalization' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersGlobalizationRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersGlobalizationRulesVersion)' == '' and '$(EffectiveAnalysisLevelGlobalization)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelGlobalization), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersGlobalizationRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization>$(AnalysisLevelSuffixGlobalization)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization)' == ''">$(AnalysisModeGlobalization)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersGlobalizationRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization Condition="'$(MicrosoftCodeAnalysisNetAnalyzersGlobalizationRulesVersion)' != ''">AnalysisLevelGlobalization_$(MicrosoftCodeAnalysisNetAnalyzersGlobalizationRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersGlobalization)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersGlobalization Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersGlobalization)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersGlobalization Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersGlobalization)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersGlobalization)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersGlobalization>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersGlobalization)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersGlobalization)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersInteroperability" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelInteroperability)' != '' or '$(AnalysisModeInteroperability)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelInteroperability' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixInteroperability', 'AnalysisLevelSuffixInteroperability' and 'EffectiveAnalysisLevelInteroperability' -->
      <AnalysisLevelInteroperability Condition="'$(AnalysisLevelInteroperability)' == ''">$(AnalysisLevel)</AnalysisLevelInteroperability>
      <!-- AnalysisLevelInteroperability can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Interoperability' rules and the suffix indicates the bucket of
           rules to enable for 'Interoperability' rules by default. For example, some valid compound values for AnalysisLevelInteroperability are:
             1. '5-all' - Indicates core AnalysisLevelInteroperability = '5' with 'all' the 'Interoperability' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelInteroperability = 'latest' with 'none' of the 'Interoperability' rules enabled by default.
           AnalysisLevelPrefixInteroperability is used to set the EffectiveAnalysisLevelInteroperability below.
           AnalysisLevelSuffixInteroperability is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixInteroperability Condition="$(AnalysisLevelInteroperability.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelInteroperability), '-(.)*', ''))</AnalysisLevelPrefixInteroperability>
      <AnalysisLevelSuffixInteroperability Condition="'$(AnalysisLevelPrefixInteroperability)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelInteroperability), '$(AnalysisLevelPrefixInteroperability)-', ''))</AnalysisLevelSuffixInteroperability>
      <!-- EffectiveAnalysisLevelInteroperability is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelInteroperability Condition="'$(AnalysisLevelInteroperability)' == 'none' or '$(AnalysisLevelPrefixInteroperability)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelInteroperability>
      <EffectiveAnalysisLevelInteroperability Condition="'$(AnalysisLevelInteroperability)' == 'latest' or '$(AnalysisLevelPrefixInteroperability)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelInteroperability>
      <EffectiveAnalysisLevelInteroperability Condition="'$(AnalysisLevelInteroperability)' == 'preview' or '$(AnalysisLevelPrefixInteroperability)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelInteroperability>
      <!-- Set EffectiveAnalysisLevelInteroperability to the value of AnalysisLevelInteroperability if it is a version number -->
      <EffectiveAnalysisLevelInteroperability Condition="'$(EffectiveAnalysisLevelInteroperability)' == '' And&#xA;                                         '$(AnalysisLevelPrefixInteroperability)' != ''">$(AnalysisLevelPrefixInteroperability)</EffectiveAnalysisLevelInteroperability>
      <EffectiveAnalysisLevelInteroperability Condition="'$(EffectiveAnalysisLevelInteroperability)' == '' And&#xA;                                         '$(AnalysisLevelInteroperability)' != ''">$(AnalysisLevelInteroperability)</EffectiveAnalysisLevelInteroperability>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersInteroperabilityRulesVersion' to 'EffectiveAnalysisLevelInteroperability' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersInteroperabilityRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersInteroperabilityRulesVersion)' == '' and '$(EffectiveAnalysisLevelInteroperability)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelInteroperability), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersInteroperabilityRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability>$(AnalysisLevelSuffixInteroperability)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability)' == ''">$(AnalysisModeInteroperability)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersInteroperabilityRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability Condition="'$(MicrosoftCodeAnalysisNetAnalyzersInteroperabilityRulesVersion)' != ''">AnalysisLevelInteroperability_$(MicrosoftCodeAnalysisNetAnalyzersInteroperabilityRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersInteroperability)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersInteroperability Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersInteroperability)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersInteroperability Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersInteroperability)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersInteroperability)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersInteroperability>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersInteroperability)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersInteroperability)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersMaintainability" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelMaintainability)' != '' or '$(AnalysisModeMaintainability)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelMaintainability' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixMaintainability', 'AnalysisLevelSuffixMaintainability' and 'EffectiveAnalysisLevelMaintainability' -->
      <AnalysisLevelMaintainability Condition="'$(AnalysisLevelMaintainability)' == ''">$(AnalysisLevel)</AnalysisLevelMaintainability>
      <!-- AnalysisLevelMaintainability can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Maintainability' rules and the suffix indicates the bucket of
           rules to enable for 'Maintainability' rules by default. For example, some valid compound values for AnalysisLevelMaintainability are:
             1. '5-all' - Indicates core AnalysisLevelMaintainability = '5' with 'all' the 'Maintainability' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelMaintainability = 'latest' with 'none' of the 'Maintainability' rules enabled by default.
           AnalysisLevelPrefixMaintainability is used to set the EffectiveAnalysisLevelMaintainability below.
           AnalysisLevelSuffixMaintainability is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixMaintainability Condition="$(AnalysisLevelMaintainability.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelMaintainability), '-(.)*', ''))</AnalysisLevelPrefixMaintainability>
      <AnalysisLevelSuffixMaintainability Condition="'$(AnalysisLevelPrefixMaintainability)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelMaintainability), '$(AnalysisLevelPrefixMaintainability)-', ''))</AnalysisLevelSuffixMaintainability>
      <!-- EffectiveAnalysisLevelMaintainability is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelMaintainability Condition="'$(AnalysisLevelMaintainability)' == 'none' or '$(AnalysisLevelPrefixMaintainability)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelMaintainability>
      <EffectiveAnalysisLevelMaintainability Condition="'$(AnalysisLevelMaintainability)' == 'latest' or '$(AnalysisLevelPrefixMaintainability)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelMaintainability>
      <EffectiveAnalysisLevelMaintainability Condition="'$(AnalysisLevelMaintainability)' == 'preview' or '$(AnalysisLevelPrefixMaintainability)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelMaintainability>
      <!-- Set EffectiveAnalysisLevelMaintainability to the value of AnalysisLevelMaintainability if it is a version number -->
      <EffectiveAnalysisLevelMaintainability Condition="'$(EffectiveAnalysisLevelMaintainability)' == '' And&#xA;                                         '$(AnalysisLevelPrefixMaintainability)' != ''">$(AnalysisLevelPrefixMaintainability)</EffectiveAnalysisLevelMaintainability>
      <EffectiveAnalysisLevelMaintainability Condition="'$(EffectiveAnalysisLevelMaintainability)' == '' And&#xA;                                         '$(AnalysisLevelMaintainability)' != ''">$(AnalysisLevelMaintainability)</EffectiveAnalysisLevelMaintainability>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersMaintainabilityRulesVersion' to 'EffectiveAnalysisLevelMaintainability' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersMaintainabilityRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersMaintainabilityRulesVersion)' == '' and '$(EffectiveAnalysisLevelMaintainability)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelMaintainability), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersMaintainabilityRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability>$(AnalysisLevelSuffixMaintainability)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability)' == ''">$(AnalysisModeMaintainability)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersMaintainabilityRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability Condition="'$(MicrosoftCodeAnalysisNetAnalyzersMaintainabilityRulesVersion)' != ''">AnalysisLevelMaintainability_$(MicrosoftCodeAnalysisNetAnalyzersMaintainabilityRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersMaintainability)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersMaintainability Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersMaintainability)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersMaintainability Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersMaintainability)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersMaintainability)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersMaintainability>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersMaintainability)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersMaintainability)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersNaming" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelNaming)' != '' or '$(AnalysisModeNaming)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelNaming' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixNaming', 'AnalysisLevelSuffixNaming' and 'EffectiveAnalysisLevelNaming' -->
      <AnalysisLevelNaming Condition="'$(AnalysisLevelNaming)' == ''">$(AnalysisLevel)</AnalysisLevelNaming>
      <!-- AnalysisLevelNaming can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Naming' rules and the suffix indicates the bucket of
           rules to enable for 'Naming' rules by default. For example, some valid compound values for AnalysisLevelNaming are:
             1. '5-all' - Indicates core AnalysisLevelNaming = '5' with 'all' the 'Naming' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelNaming = 'latest' with 'none' of the 'Naming' rules enabled by default.
           AnalysisLevelPrefixNaming is used to set the EffectiveAnalysisLevelNaming below.
           AnalysisLevelSuffixNaming is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixNaming Condition="$(AnalysisLevelNaming.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelNaming), '-(.)*', ''))</AnalysisLevelPrefixNaming>
      <AnalysisLevelSuffixNaming Condition="'$(AnalysisLevelPrefixNaming)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelNaming), '$(AnalysisLevelPrefixNaming)-', ''))</AnalysisLevelSuffixNaming>
      <!-- EffectiveAnalysisLevelNaming is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelNaming Condition="'$(AnalysisLevelNaming)' == 'none' or '$(AnalysisLevelPrefixNaming)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelNaming>
      <EffectiveAnalysisLevelNaming Condition="'$(AnalysisLevelNaming)' == 'latest' or '$(AnalysisLevelPrefixNaming)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelNaming>
      <EffectiveAnalysisLevelNaming Condition="'$(AnalysisLevelNaming)' == 'preview' or '$(AnalysisLevelPrefixNaming)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelNaming>
      <!-- Set EffectiveAnalysisLevelNaming to the value of AnalysisLevelNaming if it is a version number -->
      <EffectiveAnalysisLevelNaming Condition="'$(EffectiveAnalysisLevelNaming)' == '' And&#xA;                                         '$(AnalysisLevelPrefixNaming)' != ''">$(AnalysisLevelPrefixNaming)</EffectiveAnalysisLevelNaming>
      <EffectiveAnalysisLevelNaming Condition="'$(EffectiveAnalysisLevelNaming)' == '' And&#xA;                                         '$(AnalysisLevelNaming)' != ''">$(AnalysisLevelNaming)</EffectiveAnalysisLevelNaming>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersNamingRulesVersion' to 'EffectiveAnalysisLevelNaming' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersNamingRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersNamingRulesVersion)' == '' and '$(EffectiveAnalysisLevelNaming)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelNaming), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersNamingRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming>$(AnalysisLevelSuffixNaming)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming)' == ''">$(AnalysisModeNaming)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersNamingRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming Condition="'$(MicrosoftCodeAnalysisNetAnalyzersNamingRulesVersion)' != ''">AnalysisLevelNaming_$(MicrosoftCodeAnalysisNetAnalyzersNamingRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersNaming)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersNaming Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersNaming)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersNaming>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersNaming Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersNaming)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersNaming)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersNaming>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersNaming)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersNaming)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersPerformance" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelPerformance)' != '' or '$(AnalysisModePerformance)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelPerformance' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixPerformance', 'AnalysisLevelSuffixPerformance' and 'EffectiveAnalysisLevelPerformance' -->
      <AnalysisLevelPerformance Condition="'$(AnalysisLevelPerformance)' == ''">$(AnalysisLevel)</AnalysisLevelPerformance>
      <!-- AnalysisLevelPerformance can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Performance' rules and the suffix indicates the bucket of
           rules to enable for 'Performance' rules by default. For example, some valid compound values for AnalysisLevelPerformance are:
             1. '5-all' - Indicates core AnalysisLevelPerformance = '5' with 'all' the 'Performance' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelPerformance = 'latest' with 'none' of the 'Performance' rules enabled by default.
           AnalysisLevelPrefixPerformance is used to set the EffectiveAnalysisLevelPerformance below.
           AnalysisLevelSuffixPerformance is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixPerformance Condition="$(AnalysisLevelPerformance.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelPerformance), '-(.)*', ''))</AnalysisLevelPrefixPerformance>
      <AnalysisLevelSuffixPerformance Condition="'$(AnalysisLevelPrefixPerformance)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelPerformance), '$(AnalysisLevelPrefixPerformance)-', ''))</AnalysisLevelSuffixPerformance>
      <!-- EffectiveAnalysisLevelPerformance is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelPerformance Condition="'$(AnalysisLevelPerformance)' == 'none' or '$(AnalysisLevelPrefixPerformance)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelPerformance>
      <EffectiveAnalysisLevelPerformance Condition="'$(AnalysisLevelPerformance)' == 'latest' or '$(AnalysisLevelPrefixPerformance)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelPerformance>
      <EffectiveAnalysisLevelPerformance Condition="'$(AnalysisLevelPerformance)' == 'preview' or '$(AnalysisLevelPrefixPerformance)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelPerformance>
      <!-- Set EffectiveAnalysisLevelPerformance to the value of AnalysisLevelPerformance if it is a version number -->
      <EffectiveAnalysisLevelPerformance Condition="'$(EffectiveAnalysisLevelPerformance)' == '' And&#xA;                                         '$(AnalysisLevelPrefixPerformance)' != ''">$(AnalysisLevelPrefixPerformance)</EffectiveAnalysisLevelPerformance>
      <EffectiveAnalysisLevelPerformance Condition="'$(EffectiveAnalysisLevelPerformance)' == '' And&#xA;                                         '$(AnalysisLevelPerformance)' != ''">$(AnalysisLevelPerformance)</EffectiveAnalysisLevelPerformance>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersPerformanceRulesVersion' to 'EffectiveAnalysisLevelPerformance' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersPerformanceRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersPerformanceRulesVersion)' == '' and '$(EffectiveAnalysisLevelPerformance)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelPerformance), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersPerformanceRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance>$(AnalysisLevelSuffixPerformance)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance)' == ''">$(AnalysisModePerformance)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersPerformanceRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance Condition="'$(MicrosoftCodeAnalysisNetAnalyzersPerformanceRulesVersion)' != ''">AnalysisLevelPerformance_$(MicrosoftCodeAnalysisNetAnalyzersPerformanceRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersPerformance)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersPerformance Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersPerformance)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersPerformance>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersPerformance Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersPerformance)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersPerformance)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersPerformance>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersPerformance)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersPerformance)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersReliability" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelReliability)' != '' or '$(AnalysisModeReliability)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelReliability' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixReliability', 'AnalysisLevelSuffixReliability' and 'EffectiveAnalysisLevelReliability' -->
      <AnalysisLevelReliability Condition="'$(AnalysisLevelReliability)' == ''">$(AnalysisLevel)</AnalysisLevelReliability>
      <!-- AnalysisLevelReliability can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Reliability' rules and the suffix indicates the bucket of
           rules to enable for 'Reliability' rules by default. For example, some valid compound values for AnalysisLevelReliability are:
             1. '5-all' - Indicates core AnalysisLevelReliability = '5' with 'all' the 'Reliability' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelReliability = 'latest' with 'none' of the 'Reliability' rules enabled by default.
           AnalysisLevelPrefixReliability is used to set the EffectiveAnalysisLevelReliability below.
           AnalysisLevelSuffixReliability is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixReliability Condition="$(AnalysisLevelReliability.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelReliability), '-(.)*', ''))</AnalysisLevelPrefixReliability>
      <AnalysisLevelSuffixReliability Condition="'$(AnalysisLevelPrefixReliability)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelReliability), '$(AnalysisLevelPrefixReliability)-', ''))</AnalysisLevelSuffixReliability>
      <!-- EffectiveAnalysisLevelReliability is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelReliability Condition="'$(AnalysisLevelReliability)' == 'none' or '$(AnalysisLevelPrefixReliability)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelReliability>
      <EffectiveAnalysisLevelReliability Condition="'$(AnalysisLevelReliability)' == 'latest' or '$(AnalysisLevelPrefixReliability)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelReliability>
      <EffectiveAnalysisLevelReliability Condition="'$(AnalysisLevelReliability)' == 'preview' or '$(AnalysisLevelPrefixReliability)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelReliability>
      <!-- Set EffectiveAnalysisLevelReliability to the value of AnalysisLevelReliability if it is a version number -->
      <EffectiveAnalysisLevelReliability Condition="'$(EffectiveAnalysisLevelReliability)' == '' And&#xA;                                         '$(AnalysisLevelPrefixReliability)' != ''">$(AnalysisLevelPrefixReliability)</EffectiveAnalysisLevelReliability>
      <EffectiveAnalysisLevelReliability Condition="'$(EffectiveAnalysisLevelReliability)' == '' And&#xA;                                         '$(AnalysisLevelReliability)' != ''">$(AnalysisLevelReliability)</EffectiveAnalysisLevelReliability>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersReliabilityRulesVersion' to 'EffectiveAnalysisLevelReliability' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersReliabilityRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersReliabilityRulesVersion)' == '' and '$(EffectiveAnalysisLevelReliability)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelReliability), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersReliabilityRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability>$(AnalysisLevelSuffixReliability)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability)' == ''">$(AnalysisModeReliability)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersReliabilityRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability Condition="'$(MicrosoftCodeAnalysisNetAnalyzersReliabilityRulesVersion)' != ''">AnalysisLevelReliability_$(MicrosoftCodeAnalysisNetAnalyzersReliabilityRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersReliability)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersReliability Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersReliability)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersReliability>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersReliability Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersReliability)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersReliability)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersReliability>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersReliability)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersReliability)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersSecurity" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelSecurity)' != '' or '$(AnalysisModeSecurity)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelSecurity' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixSecurity', 'AnalysisLevelSuffixSecurity' and 'EffectiveAnalysisLevelSecurity' -->
      <AnalysisLevelSecurity Condition="'$(AnalysisLevelSecurity)' == ''">$(AnalysisLevel)</AnalysisLevelSecurity>
      <!-- AnalysisLevelSecurity can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Security' rules and the suffix indicates the bucket of
           rules to enable for 'Security' rules by default. For example, some valid compound values for AnalysisLevelSecurity are:
             1. '5-all' - Indicates core AnalysisLevelSecurity = '5' with 'all' the 'Security' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelSecurity = 'latest' with 'none' of the 'Security' rules enabled by default.
           AnalysisLevelPrefixSecurity is used to set the EffectiveAnalysisLevelSecurity below.
           AnalysisLevelSuffixSecurity is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixSecurity Condition="$(AnalysisLevelSecurity.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelSecurity), '-(.)*', ''))</AnalysisLevelPrefixSecurity>
      <AnalysisLevelSuffixSecurity Condition="'$(AnalysisLevelPrefixSecurity)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelSecurity), '$(AnalysisLevelPrefixSecurity)-', ''))</AnalysisLevelSuffixSecurity>
      <!-- EffectiveAnalysisLevelSecurity is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelSecurity Condition="'$(AnalysisLevelSecurity)' == 'none' or '$(AnalysisLevelPrefixSecurity)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelSecurity>
      <EffectiveAnalysisLevelSecurity Condition="'$(AnalysisLevelSecurity)' == 'latest' or '$(AnalysisLevelPrefixSecurity)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelSecurity>
      <EffectiveAnalysisLevelSecurity Condition="'$(AnalysisLevelSecurity)' == 'preview' or '$(AnalysisLevelPrefixSecurity)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelSecurity>
      <!-- Set EffectiveAnalysisLevelSecurity to the value of AnalysisLevelSecurity if it is a version number -->
      <EffectiveAnalysisLevelSecurity Condition="'$(EffectiveAnalysisLevelSecurity)' == '' And&#xA;                                         '$(AnalysisLevelPrefixSecurity)' != ''">$(AnalysisLevelPrefixSecurity)</EffectiveAnalysisLevelSecurity>
      <EffectiveAnalysisLevelSecurity Condition="'$(EffectiveAnalysisLevelSecurity)' == '' And&#xA;                                         '$(AnalysisLevelSecurity)' != ''">$(AnalysisLevelSecurity)</EffectiveAnalysisLevelSecurity>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersSecurityRulesVersion' to 'EffectiveAnalysisLevelSecurity' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersSecurityRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersSecurityRulesVersion)' == '' and '$(EffectiveAnalysisLevelSecurity)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelSecurity), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersSecurityRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity>$(AnalysisLevelSuffixSecurity)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity)' == ''">$(AnalysisModeSecurity)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersSecurityRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity Condition="'$(MicrosoftCodeAnalysisNetAnalyzersSecurityRulesVersion)' != ''">AnalysisLevelSecurity_$(MicrosoftCodeAnalysisNetAnalyzersSecurityRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersSecurity)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersSecurity Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersSecurity)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersSecurity>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersSecurity Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersSecurity)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersSecurity)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersSecurity>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersSecurity)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersSecurity)" />
    </ItemGroup>
  </Target>
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzersUsage" BeforeTargets="CoreCompile" AfterTargets="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisNetAnalyzers" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true' and ('$(AnalysisLevelUsage)' != '' or '$(AnalysisModeUsage)' != '')">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelUsage' to the core 'AnalysisLevel' and compute 'AnalysisLevelPrefixUsage', 'AnalysisLevelSuffixUsage' and 'EffectiveAnalysisLevelUsage' -->
      <AnalysisLevelUsage Condition="'$(AnalysisLevelUsage)' == ''">$(AnalysisLevel)</AnalysisLevelUsage>
      <!-- AnalysisLevelUsage can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Usage' rules and the suffix indicates the bucket of
           rules to enable for 'Usage' rules by default. For example, some valid compound values for AnalysisLevelUsage are:
             1. '5-all' - Indicates core AnalysisLevelUsage = '5' with 'all' the 'Usage' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelUsage = 'latest' with 'none' of the 'Usage' rules enabled by default.
           AnalysisLevelPrefixUsage is used to set the EffectiveAnalysisLevelUsage below.
           AnalysisLevelSuffixUsage is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixUsage Condition="$(AnalysisLevelUsage.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelUsage), '-(.)*', ''))</AnalysisLevelPrefixUsage>
      <AnalysisLevelSuffixUsage Condition="'$(AnalysisLevelPrefixUsage)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelUsage), '$(AnalysisLevelPrefixUsage)-', ''))</AnalysisLevelSuffixUsage>
      <!-- EffectiveAnalysisLevelUsage is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelUsage Condition="'$(AnalysisLevelUsage)' == 'none' or '$(AnalysisLevelPrefixUsage)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelUsage>
      <EffectiveAnalysisLevelUsage Condition="'$(AnalysisLevelUsage)' == 'latest' or '$(AnalysisLevelPrefixUsage)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelUsage>
      <EffectiveAnalysisLevelUsage Condition="'$(AnalysisLevelUsage)' == 'preview' or '$(AnalysisLevelPrefixUsage)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelUsage>
      <!-- Set EffectiveAnalysisLevelUsage to the value of AnalysisLevelUsage if it is a version number -->
      <EffectiveAnalysisLevelUsage Condition="'$(EffectiveAnalysisLevelUsage)' == '' And&#xA;                                         '$(AnalysisLevelPrefixUsage)' != ''">$(AnalysisLevelPrefixUsage)</EffectiveAnalysisLevelUsage>
      <EffectiveAnalysisLevelUsage Condition="'$(EffectiveAnalysisLevelUsage)' == '' And&#xA;                                         '$(AnalysisLevelUsage)' != ''">$(AnalysisLevelUsage)</EffectiveAnalysisLevelUsage>
      <!-- Default 'MicrosoftCodeAnalysisNetAnalyzersUsageRulesVersion' to 'EffectiveAnalysisLevelUsage' with trimmed trailing '.0' -->
      <MicrosoftCodeAnalysisNetAnalyzersUsageRulesVersion Condition="'$(MicrosoftCodeAnalysisNetAnalyzersUsageRulesVersion)' == '' and '$(EffectiveAnalysisLevelUsage)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(EffectiveAnalysisLevelUsage), '(\.0)*$', ''))</MicrosoftCodeAnalysisNetAnalyzersUsageRulesVersion>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage>$(AnalysisLevelSuffixUsage)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage)' == ''">$(AnalysisModeUsage)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage>
      <!-- Default 'EffectiveCodeAnalysisTreatWarningsAsErrors' to 'CodeAnalysisTreatWarningsAsErrors' for escalating relevant code analysis warnings to errors. -->
      <!-- We use a separate property to allow users to override 'CodeAnalysisTreatWarningsAsErrors' implementation from .NET7 or older SDK, which had a known issue: https://github.com/dotnet/roslyn-analyzers/issues/6281 -->
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <!-- Choose GlobalAnalyzerConfig file with '_warnaserror' suffix if 'EffectiveCodeAnalysisTreatWarningsAsErrors' is 'true'. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage_WarnAsErrorSuffix Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'true'">_warnaserror</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage_WarnAsErrorSuffix>
      <!-- GlobalAnalyzerConfig file name based on user specified package version 'MicrosoftCodeAnalysisNetAnalyzersUsageRulesVersion', if any. We replace '.' with '_' to map the version string to file name suffix. -->
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage Condition="'$(MicrosoftCodeAnalysisNetAnalyzersUsageRulesVersion)' != ''">AnalysisLevelUsage_$(MicrosoftCodeAnalysisNetAnalyzersUsageRulesVersion.Replace(".","_"))_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisNetAnalyzersUsage)$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage_WarnAsErrorSuffix).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersUsage Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersUsage)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersUsage>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersUsage Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisNetAnalyzersUsage)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisNetAnalyzersUsage)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersUsage>
    </PropertyGroup>
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersUsage)')">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisNetAnalyzersUsage)" />
    </ItemGroup>
  </Target>
  <!-- MSBuild properties to thread to the analyzers as options -->
  <ItemGroup>
    <CompilerVisibleProperty Include="TargetFramework" />
    <CompilerVisibleProperty Include="TargetFrameworkIdentifier" />
    <CompilerVisibleProperty Include="TargetFrameworkVersion" />
    <CompilerVisibleProperty Include="TargetPlatformMinVersion" />
    <CompilerVisibleProperty Include="UsingMicrosoftNETSdkWeb" />
    <CompilerVisibleProperty Include="ProjectTypeGuids" />
    <CompilerVisibleProperty Include="InvariantGlobalization" />
    <CompilerVisibleProperty Include="PlatformNeutralAssembly" />
    <CompilerVisibleProperty Include="EnforceExtendedAnalyzerRules" />
  </ItemGroup>
  <!-- MSBuild item metadata to thread to the analyzers as options -->
  <PropertyGroup>
    <_SupportedPlatformList>@(SupportedPlatform, ',')</_SupportedPlatformList>
  </PropertyGroup>
  <!-- MSBuild properties to thread to the analyzers as options -->
  <ItemGroup>
    <CompilerVisibleProperty Include="_SupportedPlatformList" />
  </ItemGroup>
  <!--
    Design-time target to handle 'CodeAnalysisTreatWarningsAsErrors = false' for the CA rule ids implemented in this package.
    Note that a similar 'WarningsNotAsErrors' property group is present in the generated props file to ensure this functionality on command line builds.
  -->
  <Target Name="_CodeAnalysisTreatWarningsAsErrors" BeforeTargets="CoreCompile" Condition="'$(DesignTimeBuild)' == 'true' OR '$(BuildingProject)' != 'true'">
    <PropertyGroup>
      <EffectiveCodeAnalysisTreatWarningsAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == ''">$(CodeAnalysisTreatWarningsAsErrors)</EffectiveCodeAnalysisTreatWarningsAsErrors>
      <WarningsNotAsErrors Condition="'$(EffectiveCodeAnalysisTreatWarningsAsErrors)' == 'false' and '$(TreatWarningsAsErrors)' == 'true'">$(WarningsNotAsErrors);$(CodeAnalysisRuleIds)</WarningsNotAsErrors>
    </PropertyGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.Analyzers.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\codestyle\cs\build\Microsoft.CodeAnalysis.CSharp.CodeStyle.targets" Condition="'$(Language)' == 'C#'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/codestyle/cs/build/Microsoft.CodeAnalysis.CSharp.CodeStyle.targets
============================================================================================================================================
-->
  <Target Name="AddGlobalAnalyzerConfigForPackage_MicrosoftCodeAnalysisCSharpCodeStyle" BeforeTargets="GenerateMSBuildEditorConfigFileCore;CoreCompile" Condition="'$(SkipGlobalAnalyzerConfigForPackage)' != 'true'">
    <!-- PropertyGroup to compute global analyzer config file to be used -->
    <PropertyGroup>
      <!-- Default 'AnalysisLevelStyle' to the core 'AnalysisLevel' -->
      <AnalysisLevelStyle Condition="'$(AnalysisLevelStyle)' == ''">$(AnalysisLevel)</AnalysisLevelStyle>
      <!-- AnalysisLevelStyle can also contain compound values with a prefix and suffix separated by a '-' character.
           The prefix indicates the core AnalysisLevel for 'Style' rules and the suffix indicates the bucket of
           rules to enable for 'Style' rules by default. For example, some valid compound values for AnalysisLevelStyle are:
             1. '5-all' - Indicates core AnalysisLevelStyle = '5' with 'all' the 'Style' rules enabled by default.
             2. 'latest-none' - Indicates core AnalysisLevelStyle = 'latest' with 'none' of the 'Style' rules enabled by default.
           AnalysisLevelPrefixStyle is used to set the EffectiveAnalysisLevelStyle below.
           AnalysisLevelSuffixStyle is used to map to the correct global config.
      -->
      <AnalysisLevelPrefixStyle Condition="$(AnalysisLevelStyle.Contains('-'))">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelStyle), '-(.)*', ''))</AnalysisLevelPrefixStyle>
      <AnalysisLevelSuffixStyle Condition="'$(AnalysisLevelPrefixStyle)' != ''">$([System.Text.RegularExpressions.Regex]::Replace($(AnalysisLevelStyle), '$(AnalysisLevelPrefixStyle)-', ''))</AnalysisLevelSuffixStyle>
      <!-- Default 'AnalysisLevelSuffixStyle' to the core 'AnalysisLevelSuffix' -->
      <AnalysisLevelSuffixStyle Condition="'$(AnalysisLevelSuffixStyle)' == ''">$(AnalysisLevelSuffix)</AnalysisLevelSuffixStyle>
      <!-- Default 'AnalysisModeStyle' to the core 'AnalysisMode' -->
      <AnalysisModeStyle Condition="'$(AnalysisModeStyle)' == ''">$(AnalysisMode)</AnalysisModeStyle>
      <!-- EffectiveAnalysisLevelStyle is used to differentiate from user specified strings (such as 'none')
           and an implied numerical option (such as '4') -->
      <EffectiveAnalysisLevelStyle Condition="'$(AnalysisLevelStyle)' == 'none' or '$(AnalysisLevelPrefixStyle)' == 'none'">$(_NoneAnalysisLevel)</EffectiveAnalysisLevelStyle>
      <EffectiveAnalysisLevelStyle Condition="'$(AnalysisLevelStyle)' == 'latest' or '$(AnalysisLevelPrefixStyle)' == 'latest'">$(_LatestAnalysisLevel)</EffectiveAnalysisLevelStyle>
      <EffectiveAnalysisLevelStyle Condition="'$(AnalysisLevelStyle)' == 'preview' or '$(AnalysisLevelPrefixStyle)' == 'preview'">$(_PreviewAnalysisLevel)</EffectiveAnalysisLevelStyle>
      <!-- Set EffectiveAnalysisLevelStyle to the value of AnalysisLevelStyle if it is a version number -->
      <EffectiveAnalysisLevelStyle Condition="'$(EffectiveAnalysisLevelStyle)' == '' And&#xA;                                          '$(AnalysisLevelPrefixStyle)' != ''">$(AnalysisLevelPrefixStyle)</EffectiveAnalysisLevelStyle>
      <EffectiveAnalysisLevelStyle Condition="'$(EffectiveAnalysisLevelStyle)' == '' And&#xA;                                          '$(AnalysisLevelStyle)' != ''">$(AnalysisLevelStyle)</EffectiveAnalysisLevelStyle>
      <!-- Set the default analysis mode, if not set by the user -->
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle>$(AnalysisModeStyle)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle)' == ''">$(AnalysisLevelSuffixStyle)</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle)' == 'AllEnabledByDefault'">All</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle)' == 'AllDisabledByDefault'">None</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle>
      <_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle Condition="'$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle)' == ''">Default</_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisCSharpCodeStyle>AnalysisLevelStyle_$(_GlobalAnalyzerConfigAnalysisMode_MicrosoftCodeAnalysisCSharpCodeStyle).globalconfig</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisCSharpCodeStyle>
      <_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisCSharpCodeStyle>$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisCSharpCodeStyle.ToLowerInvariant())</_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisCSharpCodeStyle>
      <_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisCSharpCodeStyle Condition="'$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisCSharpCodeStyle)' == ''">$(MSBuildThisFileDirectory)config</_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisCSharpCodeStyle>
      <_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisCSharpCodeStyle Condition="'$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisCSharpCodeStyle)' != ''">$(_GlobalAnalyzerConfigDir_MicrosoftCodeAnalysisCSharpCodeStyle)\$(_GlobalAnalyzerConfigFileName_MicrosoftCodeAnalysisCSharpCodeStyle)</_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisCSharpCodeStyle>
    </PropertyGroup>
    <!-- From .NET 10, the global config is systematically added if the file exists. Please check https://github.com/dotnet/roslyn/pull/71173 for more info. -->
    <ItemGroup Condition="Exists('$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisCSharpCodeStyle)') and&#xA;                           ('$(AnalysisLevelStyle)' != '$(AnalysisLevel)' or '$(AnalysisModeStyle)' != '$(AnalysisMode)' or ('$(EffectiveAnalysisLevelStyle)' != '' and $([MSBuild]::VersionGreaterThanOrEquals('$(EffectiveAnalysisLevelStyle)', '10.0'))))">
      <EditorConfigFiles Include="$(_GlobalAnalyzerConfigFile_MicrosoftCodeAnalysisCSharpCodeStyle)" />
    </ItemGroup>
    <!-- Pass the MSBuild property values for 'EffectiveAnalysisLevelStyle' and 'EnableCodeStyleSeverity' to the analyzers via analyzer config options. -->
    <ItemGroup>
      <CompilerVisibleProperty Include="EffectiveAnalysisLevelStyle" />
      <CompilerVisibleProperty Include="EnableCodeStyleSeverity" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.Analyzers.targets
============================================================================================================================================
-->
  <!--<Import Project="$(MSBuildThisFileDirectory)..\codestyle\vb\build\Microsoft.CodeAnalysis.VisualBasic.CodeStyle.targets" Condition="'$(Language)' == 'VB'" />-->
  <!-- .NET Analyzers -->
  <ItemGroup Condition="$(EnableNETAnalyzers)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Analyzer Condition="'$(Language)' == 'VB'" Include="$(MSBuildThisFileDirectory)..\analyzers\Microsoft.CodeAnalysis.VisualBasic.NetAnalyzers.dll" IsImplicitlyDefined="true" />
    <Analyzer Condition="'$(Language)' == 'C#'" Include="$(MSBuildThisFileDirectory)..\analyzers\Microsoft.CodeAnalysis.CSharp.NetAnalyzers.dll" IsImplicitlyDefined="true" />
    <Analyzer Include="$(MSBuildThisFileDirectory)..\analyzers\Microsoft.CodeAnalysis.NetAnalyzers.dll" IsImplicitlyDefined="true" />
  </ItemGroup>
  <!-- CompilerVisibleProperties for .NET -->
  <ItemGroup Condition="'$(Language)' == 'C#' Or '$(Language)' == 'VB'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Used for analyzer to match namespace to folder structure -->
    <CompilerVisibleProperty Include="RootNamespace" />
    <CompilerVisibleProperty Include="ProjectDir" />
    <!--
      Used by the analyzers in the Microsoft.Interop.ComInterfaceGenerator to detect combinations
      of built-in and source generated COM interop
    -->
    <CompilerVisibleProperty Include="EnableComHosting" />
    <CompilerVisibleProperty Include="EnableGeneratedComInterfaceComImportInterop" />
  </ItemGroup>
  <!-- C# Code Style Analyzers -->
  <ItemGroup Condition="$(EnforceCodeStyleInBuild) And '$(Language)' == 'C#'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Analyzer Include="$(MSBuildThisFileDirectory)..\codestyle\cs\Microsoft.CodeAnalysis.CodeStyle.dll" IsImplicitlyDefined="true" />
    <Analyzer Include="$(MSBuildThisFileDirectory)..\codestyle\cs\Microsoft.CodeAnalysis.CodeStyle.Fixes.dll" IsImplicitlyDefined="true" />
    <Analyzer Include="$(MSBuildThisFileDirectory)..\codestyle\cs\Microsoft.CodeAnalysis.CSharp.CodeStyle.dll" IsImplicitlyDefined="true" />
    <Analyzer Include="$(MSBuildThisFileDirectory)..\codestyle\cs\Microsoft.CodeAnalysis.CSharp.CodeStyle.Fixes.dll" IsImplicitlyDefined="true" />
  </ItemGroup>
  <!-- Visual Basic Code Style Analyzers -->
  <ItemGroup Condition="$(EnforceCodeStyleInBuild) And '$(Language)' == 'VB'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Analyzer Include="$(MSBuildThisFileDirectory)..\codestyle\vb\Microsoft.CodeAnalysis.CodeStyle.dll" IsImplicitlyDefined="true" />
    <Analyzer Include="$(MSBuildThisFileDirectory)..\codestyle\vb\Microsoft.CodeAnalysis.CodeStyle.Fixes.dll" IsImplicitlyDefined="true" />
    <Analyzer Include="$(MSBuildThisFileDirectory)..\codestyle\vb\Microsoft.CodeAnalysis.VisualBasic.CodeStyle.dll" IsImplicitlyDefined="true" />
    <Analyzer Include="$(MSBuildThisFileDirectory)..\codestyle\vb\Microsoft.CodeAnalysis.VisualBasic.CodeStyle.Fixes.dll" IsImplicitlyDefined="true" />
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets
============================================================================================================================================
-->
  <!--
    ============================================================
                                        Run Information
    The ProcessStart information that can be used to run this project.
    ============================================================
    -->
  <!-- TODO: can we now move all of this into the ComputeRunArguments target, or must this be kept for compat? -->
  <!-- NOTE: the targets above may change UseAppHost and other relevant properties, and so all of this pre-computation needs to come after it.
             I checked this when I moved it and none of those targets _used_ the Run* properties.
             This is yet another case where precomputing data during evaluation _is bad_ and should be moved to a Target. -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RunWorkingDirectory Condition="'$(RunWorkingDirectory)' == ''">$(StartWorkingDirectory)</RunWorkingDirectory>
  </PropertyGroup>
  <Choose xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <When Condition="'$(StartAction)' == 'Program'">
      <PropertyGroup>
        <RunCommand Condition="'$(RunCommand)' == ''">$(StartProgram)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' and '$(_IsExecutable)' == 'true'">
      <PropertyGroup Condition="'$(UseAppHost)' != 'true'">
        <!-- TODO: https://github.com/dotnet/sdk/issues/20 Need to get the DotNetHost path from MSBuild -->
        <RunCommand Condition="'$(RunCommand)' == ''">dotnet</RunCommand>
        <_NetCoreRunArguments>exec "$(TargetPath)"</_NetCoreRunArguments>
        <RunArguments Condition="'$(RunArguments)' == '' and '$(StartArguments)' != ''">$(_NetCoreRunArguments) $(StartArguments)</RunArguments>
        <RunArguments Condition="'$(RunArguments)' == ''">$(_NetCoreRunArguments)</RunArguments>
      </PropertyGroup>
      <PropertyGroup Condition="'$(UseAppHost)' == 'true'">
        <RunCommand Condition="'$(RunCommand)' == ''">$(TargetDir)$(AssemblyName)$(_NativeExecutableExtension)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(_IsExecutable)' == 'true'">
      <PropertyGroup Condition="$([MSBuild]::IsOSPlatform(`Windows`))">
        <RunCommand Condition="'$(RunCommand)' == ''">$(TargetPath)</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">$(StartArguments)</RunArguments>
      </PropertyGroup>
      <PropertyGroup Condition="$([MSBuild]::IsOSUnixLike())">
        <RunCommand Condition="'$(RunCommand)' == ''">mono</RunCommand>
        <RunArguments Condition="'$(RunArguments)' == ''">"$(TargetPath)" $(StartArguments)</RunArguments>
      </PropertyGroup>
    </When>
  </Choose>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Ensure $(RunWorkingDirectory) is a full path -->
    <RunWorkingDirectory Condition="'$(RunWorkingDirectory)' != '' and '$([System.IO.Path]::IsPathRooted($(RunWorkingDirectory)))' != 'true'">$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(RunWorkingDirectory)'))))</RunWorkingDirectory>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Signals that this project supports the target-based run invocation protocol powered by the ComputeRunArguments target. -->
    <ProjectCapability Include="SupportsComputeRunCommand" />
  </ItemGroup>
  <!-- Placeholder target for tools to override RunCommand/RunArguments/RunWorkingDirectory.
       This allows tools to run validation or logic required to compute any required data,
       which cannot be done during evaluation.  -->
  <Target Name="ComputeRunArguments" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <!-- Override MSBuild Run Target -->
  <Target Name="Run" DependsOnTargets="ComputeRunArguments" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <Exec Command="$(RunCommand) $(RunArguments)" WorkingDirectory="$(RunWorkingDirectory)" />
  </Target>
  <!-- Import WindowsDesktop targets if necessary -->
  <PropertyGroup Condition=" '$(ImportWindowsDesktopTargets)' == ''&#xA;                            and ('$(UseWpf)' == 'true' Or '$(UseWindowsForms)' == 'true') " xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ImportWindowsDesktopTargets Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp'&#xA;                                           and $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '3.0'))&#xA;                                           and '$(TargetPlatformIdentifier)' == 'Windows' ">true</ImportWindowsDesktopTargets>
    <ImportWindowsDesktopTargets Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">true</ImportWindowsDesktopTargets>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(ImportWindowsDesktopTargets)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <AfterMicrosoftNETSdkTargets>$(AfterMicrosoftNETSdkTargets);$(MSBuildThisFileDirectory)../../Microsoft.NET.Sdk.WindowsDesktop/targets/Microsoft.NET.Sdk.WindowsDesktop.targets</AfterMicrosoftNETSdkTargets>
  </PropertyGroup>
  <!-- Note: Once WindowsDesktop is a workload this will be moved to WorkloadManifest.targets -->
  <ItemGroup Condition="'$(MicrosoftNETWindowsWorkloadInstalled)' == 'true' and&#xA;                        '$(TargetFrameworkIdentifier)' == '.NETCoreApp' and&#xA;                        $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '5.0'))" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SdkSupportedTargetPlatformIdentifier Include="windows" DisplayName="Windows" />
  </ItemGroup>
  <!--<Import Project="$(MSBuildThisFileDirectory)Microsoft.NET.Windows.targets" Condition="'$(TargetPlatformIdentifier)' == 'Windows'" />-->
  <!-- TargetPlatformMoniker and TargetPlatformDisplayName would normally be set in Microsoft.Common.CurrentVersion.targets.  However, the
       TargetPlatformVersion may have been set later than that in evaluation by platform-specific targets or Directory.Build.targets.  So fix up those properties here -->
  <PropertyGroup Condition="'$(TargetPlatformMoniker)' == '' and '$(TargetPlatformIdentifier)' != ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Set TargetPlatformVersion if it isn't set.  This is so that we have a valid TargetPlatformMoniker for Restore.
         This avoids an issue where projects with multitargeted unknown platforms would fail to restore because the platforms
         weren't included in the TargetPlatformMoniker for restore, obscuring the errors about unknown platforms or missing
         workloads. -->
    <TargetPlatformVersion Condition="'$(TargetPlatformVersion)' == ''">0.0</TargetPlatformVersion>
    <TargetPlatformMoniker>$(TargetPlatformIdentifier),Version=$(TargetPlatformVersion)</TargetPlatformMoniker>
    <TargetPlatformDisplayName>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetPlatformSDKDisplayName($(TargetPlatformIdentifier), $(TargetPlatformVersion)))</TargetPlatformDisplayName>
  </PropertyGroup>
  <!-- Default SupportedOSPlatformVersion to TargetPlatformVersion -->
  <PropertyGroup Condition="'$(SupportedOSPlatformVersion)' == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <SupportedOSPlatformVersion>$(TargetPlatformVersion)</SupportedOSPlatformVersion>
  </PropertyGroup>
  <!--<Import Project="$(AfterMicrosoftNETSdkTargets)" Condition="'$(AfterMicrosoftNETSdkTargets)' != ''" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\targets\Microsoft.NET.ApiCompat.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ApiCompat.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup Condition="'$(UseApiCompatPackage)' != 'true'">
    <DotNetApiCompatTaskAssembly Condition="'$(MSBuildRuntimeType)' != 'Core'">$(MSBuildThisFileDirectory)..\tools\net472\Microsoft.DotNet.ApiCompat.Task.dll</DotNetApiCompatTaskAssembly>
    <DotNetApiCompatTaskAssembly Condition="'$(MSBuildRuntimeType)' == 'Core'">$(MSBuildThisFileDirectory)..\tools\net10.0\Microsoft.DotNet.ApiCompat.Task.dll</DotNetApiCompatTaskAssembly>
  </PropertyGroup>
  <ItemGroup Condition="'$(EnablePackageValidation)' == 'true' and&#xA;                        '$(IsPackable)' == 'true' and&#xA;                        '$(DisablePackageBaselineValidation)' != 'true' and&#xA;                        '$(PackageValidationBaselinePath)' == '' and&#xA;                        '$(PackageValidationBaselineVersion)' != ''">
    <PackageDownload Include="$([MSBuild]::ValueOrDefault('$(PackageValidationBaselineName)', '$(PackageId)'))" Version="[$(PackageValidationBaselineVersion)]" />
  </ItemGroup>
  <!--<ImportGroup Condition="'$(UseApiCompatPackage)' != 'true'">-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.ApiCompat.Common.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.Common.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ApiCompat.Common.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Expose the tasks for SDK consumption and for external use cases. -->
  <UsingTask TaskName="Microsoft.DotNet.ApiCompat.Task.ValidateAssembliesTask" AssemblyFile="$(DotNetApiCompatTaskAssembly)" />
  <UsingTask TaskName="Microsoft.DotNet.ApiCompat.Task.ValidatePackageTask" AssemblyFile="$(DotNetApiCompatTaskAssembly)" />
  <Target Name="CollectApiCompatInputs">
    <PropertyGroup Condition="'$(RoslynAssembliesPath)' == ''">
      <!-- If a custom roslyn assemblies path isn't provided, the opt-in switch 'ApiCompatUseRoslynToolsetPackagePath' is set to true and
           the roslyn toolset package is referenced, use the assemblies from that package. -->
      <_UseRoslynToolsetPackage Condition="'$(ApiCompatUseRoslynToolsetPackagePath)' == 'true' and '@(PackageReference-&gt;AnyHaveMetadataValue('Identity', 'Microsoft.Net.Compilers.Toolset'))' == 'true'">true</_UseRoslynToolsetPackage>
      <!-- CSharpCoreTargetsPath and VisualBasicCoreTargetsPath point to the same location, Microsoft.CodeAnalysis.CSharp and Microsoft.CodeAnalysis.VisualBasic
           are on the same directory as Microsoft.CodeAnalysis. So there is no need to distinguish between csproj or vbproj. -->
      <RoslynAssembliesPath Condition="'$(_UseRoslynToolsetPackage)' == 'true'">$([System.IO.Path]::GetDirectoryName('$(CSharpCoreTargetsPath)'))</RoslynAssembliesPath>
      <!-- Otherwise, default to the roslyn compiler provided by the SDK / Visual Studio. -->
      <RoslynAssembliesPath Condition="'$(_UseRoslynToolsetPackage)' != 'true'">$(RoslynTargetsPath)</RoslynAssembliesPath>
      <!-- The SDK stores the roslyn assemblies in the 'bincore' subdirectory. -->
      <RoslynAssembliesPath Condition="'$(MSBuildRuntimeType)' == 'Core'">$([System.IO.Path]::Combine('$(RoslynAssembliesPath)', 'bincore'))</RoslynAssembliesPath>
    </PropertyGroup>
    <!-- Respect legacy property and item names. -->
    <PropertyGroup>
      <ApiCompatGenerateSuppressionFile Condition="'$(ApiCompatGenerateSuppressionFile)' == ''">$(GenerateCompatibilitySuppressionFile)</ApiCompatGenerateSuppressionFile>
    </PropertyGroup>
    <ItemGroup>
      <ApiCompatSuppressionFile Include="$(CompatibilitySuppressionFilePath)" Condition="'@(ApiCompatSuppressionFile)' == '' and '$(CompatibilitySuppressionFilePath)' != ''" />
    </ItemGroup>
    <!-- END: Respect legacy property and item names. -->
    <PropertyGroup>
      <_apiCompatDefaultProjectSuppressionFile>$([MSBuild]::NormalizePath('$(MSBuildProjectDirectory)', 'CompatibilitySuppressions.xml'))</_apiCompatDefaultProjectSuppressionFile>
      <!-- Pass in a default suppression output file if non is supplied, and ApiCompatGenerateSuppressionFile is true. -->
      <ApiCompatSuppressionOutputFile Condition="'$(ApiCompatSuppressionOutputFile)' == '' and '$(ApiCompatGenerateSuppressionFile)' == 'true'">$(_apiCompatDefaultProjectSuppressionFile)</ApiCompatSuppressionOutputFile>
    </PropertyGroup>
    <!-- Pass in a default suppression file, if it exists. -->
    <ItemGroup Condition="'@(ApiCompatSuppressionFile)' == ''">
      <ApiCompatSuppressionFile Include="$(_apiCompatDefaultProjectSuppressionFile)" Condition="Exists($(_apiCompatDefaultProjectSuppressionFile))" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.ApiCompat.ValidatePackage.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.ValidatePackage.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.ApiCompat.ValidatePackage.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <_ApiCompatValidatePackageSemaphoreFile>$(IntermediateOutputPath)$(MSBuildThisFileName).semaphore</_ApiCompatValidatePackageSemaphoreFile>
    <!-- Add any custom targets that need to run before package validation to the following property. -->
    <RunPackageValidationDependsOn>CollectApiCompatInputs;_GetReferencePathFromInnerProjects;$(RunPackageValidationDependsOn)</RunPackageValidationDependsOn>
  </PropertyGroup>
  <Target Name="RunPackageValidation" DependsOnTargets="$(RunPackageValidationDependsOn)" AfterTargets="Pack" Inputs="@(NuGetPackInput);&#xA;                  @(ApiCompatSuppressionFile);&#xA;                  $(ApiCompatSuppressionOutputFile)" Outputs="$(_ApiCompatValidatePackageSemaphoreFile)" Condition="'$(EnablePackageValidation)' == 'true' and '$(IsPackable)' == 'true'">
    <PropertyGroup>
      <PackageValidationBaselineName Condition="'$(PackageValidationBaselineName)' == ''">$(PackageId)</PackageValidationBaselineName>
      <PackageValidationBaselinePath Condition="'$(PackageValidationBaselinePath)' == '' and '$(PackageValidationBaselineVersion)' != ''">$([MSBuild]::NormalizePath('$(NuGetPackageRoot)', '$(PackageValidationBaselineName.ToLower())', '$(PackageValidationBaselineVersion)', '$(PackageValidationBaselineName.ToLower()).$(PackageValidationBaselineVersion).nupkg'))</PackageValidationBaselinePath>
      <_packageValidationBaselinePath Condition="'$(DisablePackageBaselineValidation)' != 'true'">$(PackageValidationBaselinePath)</_packageValidationBaselinePath>
    </PropertyGroup>
    <ItemGroup>
      <_PackageTargetPath Include="@(NuGetPackOutput-&gt;WithMetadataValue('Extension', '.nupkg'))" Condition="!$([System.String]::new('%(Identity)').EndsWith('.symbols.nupkg'))" />
    </ItemGroup>
    <!-- PackageTargetPath isn't exposed by NuGet: https://github.com/NuGet/Home/issues/6671. -->
    <Microsoft.DotNet.ApiCompat.Task.ValidatePackageTask PackageTargetPath="@(_PackageTargetPath)" RuntimeGraph="$(RuntimeIdentifierGraphPath)" NoWarn="$(NoWarn)" RespectInternals="$(ApiCompatRespectInternals)" EnableRuleAttributesMustMatch="$(ApiCompatEnableRuleAttributesMustMatch)" ExcludeAttributesFiles="@(ApiCompatExcludeAttributesFile)" EnableRuleCannotChangeParameterName="$(ApiCompatEnableRuleCannotChangeParameterName)" RunApiCompat="$(RunApiCompat)" EnableStrictModeForCompatibleTfms="$(EnableStrictModeForCompatibleTfms)" EnableStrictModeForCompatibleFrameworksInPackage="$(EnableStrictModeForCompatibleFrameworksInPackage)" EnableStrictModeForBaselineValidation="$(EnableStrictModeForBaselineValidation)" GenerateSuppressionFile="$(ApiCompatGenerateSuppressionFile)" PreserveUnnecessarySuppressions="$(ApiCompatPreserveUnnecessarySuppressions)" PermitUnnecessarySuppressions="$(ApiCompatPermitUnnecessarySuppressions)" SuppressionFiles="@(ApiCompatSuppressionFile)" SuppressionOutputFile="$(ApiCompatSuppressionOutputFile)" BaselinePackageTargetPath="$(_packageValidationBaselinePath)" RoslynAssembliesPath="$(RoslynAssembliesPath)" PackageAssemblyReferences="@(PackageValidationReferencePath)" BaselinePackageFrameworksToIgnore="@(PackageValidationBaselineFrameworkToIgnore)" />
    <MakeDir Directories="$([System.IO.Path]::GetDirectoryName('$(_ApiCompatValidatePackageSemaphoreFile)'))" />
    <Touch Files="$(_ApiCompatValidatePackageSemaphoreFile)" AlwaysCreate="true" />
  </Target>
  <Target Name="GetReferencesForApiCompatValidatePackage" DependsOnTargets="FindReferenceAssembliesForReferences" Returns="@(ApiCompatAssemblyReferencesWithTargetFramework)">
    <ItemGroup>
      <ApiCompatAssemblyReferencesWithTargetFramework Include="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" ReferencePath="@(ReferencePathWithRefAssemblies, ',')">
        <TargetPlatformMoniker Condition="'$(ApiCompatIgnoreTargetPlatformMoniker)' != 'true'">$(TargetPlatformMoniker)</TargetPlatformMoniker>
      </ApiCompatAssemblyReferencesWithTargetFramework>
    </ItemGroup>
  </Target>
  <!-- Depends on NuGet's _GetTargetFrameworksOutput target to calculate inner target frameworks. -->
  <Target Name="_GetReferencePathFromInnerProjects" DependsOnTargets="_GetTargetFrameworksOutput" Condition="'$(RunPackageValidationWithoutReferences)' != 'true'">
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="GetReferencesForApiCompatValidatePackage" Properties="TargetFramework=%(_TargetFrameworks.Identity);&#xA;                         BuildProjectReferences=false">
      <Output ItemName="PackageValidationReferencePath" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.ApiCompat.targets
============================================================================================================================================
-->
  <!--</ImportGroup>-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!-- Import targets from NuGet.Build.Tasks.Pack package/Sdk -->
  <PropertyGroup Condition="'$(NuGetBuildTasksPackTargets)' == '' AND '$(ImportNuGetBuildTasksPackTargetsFromSdk)' != 'false'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NuGetBuildTasksPackTargets Condition="'$(IsCrossTargetingBuild)' == 'true'">$(MSBuildThisFileDirectory)..\..\NuGet.Build.Tasks.Pack\buildCrossTargeting\NuGet.Build.Tasks.Pack.targets</NuGetBuildTasksPackTargets>
    <NuGetBuildTasksPackTargets Condition="'$(IsCrossTargetingBuild)' != 'true'">$(MSBuildThisFileDirectory)..\..\NuGet.Build.Tasks.Pack\build\NuGet.Build.Tasks.Pack.targets</NuGetBuildTasksPackTargets>
    <ImportNuGetBuildTasksPackTargetsFromSdk>true</ImportNuGetBuildTasksPackTargetsFromSdk>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(NuGetBuildTasksPackTargets)" Condition="Exists('$(NuGetBuildTasksPackTargets)') AND '$(ImportNuGetBuildTasksPackTargetsFromSdk)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/NuGet.Build.Tasks.Pack/build/NuGet.Build.Tasks.Pack.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
NuGet.Build.Tasks.Pack.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- Load NuGet.Build.Tasks.Pack.dll, this can be overridden to use a different version with $(NuGetPackTaskAssemblyFile) -->
  <PropertyGroup Condition="$(NuGetPackTaskAssemblyFile) == ''" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <NuGetPackTaskAssemblyFile Condition="'$(MSBuildRuntimeType)' == 'Core'">..\CoreCLR\NuGet.Build.Tasks.Pack.dll</NuGetPackTaskAssemblyFile>
    <NuGetPackTaskAssemblyFile Condition="'$(MSBuildRuntimeType)' != 'Core'">..\Desktop\NuGet.Build.Tasks.Pack.dll</NuGetPackTaskAssemblyFile>
  </PropertyGroup>
  <!-- Tasks -->
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.PackTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.GetPackOutputItemsTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.GetProjectTargetFrameworksTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.GetProjectReferencesFromAssetsFileTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.IsPackableFalseWarningTask" AssemblyFile="$(NuGetPackTaskAssemblyFile)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PackageId Condition=" '$(PackageId)' == '' ">$(AssemblyName)</PackageId>
    <PackageVersion Condition=" '$(PackageVersion)' == '' ">$(Version)</PackageVersion>
    <IncludeContentInPack Condition="'$(IncludeContentInPack)'==''">true</IncludeContentInPack>
    <GenerateNuspecDependsOn>_LoadPackInputItems; _GetTargetFrameworksOutput; _WalkEachTargetPerFramework; _GetPackageFiles; $(GenerateNuspecDependsOn)</GenerateNuspecDependsOn>
    <PackageDescription Condition="'$(PackageDescription)'==''">$(Description)</PackageDescription>
    <PackageDescription Condition="'$(PackageDescription)'==''">Package Description</PackageDescription>
    <IsPackable Condition="'$(IsPackable)'=='' AND ('$(IsTestProject)'=='true' OR '$(IsTestingPlatformApplication)'=='true')">false</IsPackable>
    <IsPackable Condition="'$(IsPackable)'==''">true</IsPackable>
    <IncludeBuildOutput Condition="'$(IncludeBuildOutput)'==''">true</IncludeBuildOutput>
    <BuildOutputTargetFolder Condition="'$(BuildOutputTargetFolder)' == '' AND '$(IsTool)' == 'true'">tools</BuildOutputTargetFolder>
    <BuildOutputTargetFolder Condition="'$(BuildOutputTargetFolder)' == ''">lib</BuildOutputTargetFolder>
    <ContentTargetFolders Condition="'$(ContentTargetFolders)' == ''">content;contentFiles</ContentTargetFolders>
    <PackDependsOn>$(BeforePack); _IntermediatePack; GenerateNuspec; $(PackDependsOn)</PackDependsOn>
    <IsInnerBuild Condition="'$(TargetFramework)' != '' AND '$(TargetFrameworks)' != ''">true</IsInnerBuild>
    <SymbolPackageFormat Condition="'$(SymbolPackageFormat)' == ''">symbols.nupkg</SymbolPackageFormat>
    <AddPriFileDependsOn Condition="'$(MicrosoftPortableCurrentVersionPropsHasBeenImported)' == 'true'">DeterminePortableBuildCapabilities</AddPriFileDependsOn>
    <WarnOnPackingNonPackableProject Condition="'$(WarnOnPackingNonPackableProject)' == ''">false</WarnOnPackingNonPackableProject>
    <ImportNuGetBuildTasksPackTargetsFromSdk Condition="'$(ImportNuGetBuildTasksPackTargetsFromSdk)' == ''">false</ImportNuGetBuildTasksPackTargetsFromSdk>
    <DefaultAllowedOutputExtensionsInPackageBuildOutputFolder Condition="'$(DefaultAllowedOutputExtensionsInPackageBuildOutputFolder)' == ''">.dll; .exe; .winmd; .json; .pri; .xml</DefaultAllowedOutputExtensionsInPackageBuildOutputFolder>
    <AllowedOutputExtensionsInPackageBuildOutputFolder>$(DefaultAllowedOutputExtensionsInPackageBuildOutputFolder) ;$(AllowedOutputExtensionsInPackageBuildOutputFolder)</AllowedOutputExtensionsInPackageBuildOutputFolder>
    <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder Condition="'$(SymbolPackageFormat)' != 'snupkg'">.pdb; .mdb; $(AllowedOutputExtensionsInPackageBuildOutputFolder); $(AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder)</AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>
    <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder Condition="'$(SymbolPackageFormat)' == 'snupkg'">.pdb</AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>
    <SuppressDependenciesWhenPacking Condition="'$(SuppressDependenciesWhenPacking)' == ''">false</SuppressDependenciesWhenPacking>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NoBuild)' == 'true' or '$(GeneratePackageOnBuild)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateNuspecDependsOn>$(GenerateNuspecDependsOn)</GenerateNuspecDependsOn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NoBuild)' != 'true' and '$(GeneratePackageOnBuild)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <GenerateNuspecDependsOn>Build;$(GenerateNuspecDependsOn)</GenerateNuspecDependsOn>
  </PropertyGroup>
  <ItemGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ProjectCapability Include="Pack" />
  </ItemGroup>
  <ItemDefinitionGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <BuildOutputInPackage>
      <TargetFramework>$(TargetFramework)</TargetFramework>
    </BuildOutputInPackage>
  </ItemDefinitionGroup>
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <RestoreOutputPath Condition="'$(RestoreOutputPath)' == ''">$(MSBuildProjectExtensionsPath)</RestoreOutputPath>
    <PackageOutputPath Condition="'$(PackageOutputPath)' == ''">$(BaseOutputPath)$(Configuration)\</PackageOutputPath>
    <NuspecOutputPath Condition="'$(NuspecOutputPath)' == ''">$(BaseIntermediateOutputPath)$(Configuration)\</NuspecOutputPath>
  </PropertyGroup>
  <!--
    ============================================================
    _GetAbsoluteOutputPathsForPack
    Gets the absolute output paths for Pack.
    ============================================================
  -->
  <Target Name="_GetAbsoluteOutputPathsForPack" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ConvertToAbsolutePath Paths="$(RestoreOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="RestoreOutputAbsolutePath" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(PackageOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="PackageOutputAbsolutePath" />
    </ConvertToAbsolutePath>
    <ConvertToAbsolutePath Paths="$(NuspecOutputPath)">
      <Output TaskParameter="AbsolutePaths" PropertyName="NuspecOutputAbsolutePath" />
    </ConvertToAbsolutePath>
  </Target>
  <!--
    ============================================================
    _GetOutputItemsFromPack
    Gets the output '.nupkg' and '.nuspec' absolute file paths.
    ============================================================
  -->
  <Target Name="_GetOutputItemsFromPack" DependsOnTargets="_GetAbsoluteOutputPathsForPack" Returns="@(_OutputPackItems)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- 'PackageOutputAbsolutePath' and 'NuspecOutputAbsolutePath' will be provided by '_GetAbsoluteOutputPathsForPack' target -->
    <GetPackOutputItemsTask PackageOutputPath="$(PackageOutputAbsolutePath)" NuspecOutputPath="$(NuspecOutputAbsolutePath)" PackageId="$(PackageId)" PackageVersion="$(PackageVersion)" IncludeSymbols="$(IncludeSymbols)" IncludeSource="$(IncludeSource)" SymbolPackageFormat="$(SymbolPackageFormat)">
      <Output TaskParameter="OutputPackItems" ItemName="_OutputPackItems" />
    </GetPackOutputItemsTask>
  </Target>
  <!--
    ============================================================
    _GetTargetFrameworksOutput
    Read target frameworks from the project.
    ============================================================
  -->
  <Target Name="_GetTargetFrameworksOutput" Returns="@(_TargetFrameworks)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <_ProjectFrameworks />
    </PropertyGroup>
    <GetProjectTargetFrameworksTask ProjectPath="$(MSBuildProjectFullPath)" TargetFrameworks="$(TargetFrameworks)" TargetFramework="$(TargetFramework)" TargetFrameworkMoniker="$(TargetFrameworkMoniker)" TargetPlatformIdentifier="$(TargetPlatformIdentifier)" TargetPlatformVersion="$(TargetPlatformVersion)" TargetPlatformMinVersion="$(TargetPlatformMinVersion)">
      <Output TaskParameter="ProjectTargetFrameworks" PropertyName="_ProjectFrameworks" />
    </GetProjectTargetFrameworksTask>
    <ItemGroup Condition=" '$(_ProjectFrameworks)' != '' ">
      <_TargetFrameworks Include="$(_ProjectFrameworks.Split(';'))" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Pack
    Post Build Target
    ============================================================
  -->
  <Target Name="_PackAsBuildAfterTarget" AfterTargets="Build" Condition="'$(GeneratePackageOnBuild)' == 'true' AND '$(IsInnerBuild)' != 'true'" DependsOnTargets="Pack" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
  <Target Name="_CleanPackageFiles" DependsOnTargets="_GetOutputItemsFromPack" AfterTargets="Clean" Condition="'$(GeneratePackageOnBuild)' == 'true' AND '$(IsInnerBuild)' != 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_PackageFilesToDelete Include="@(_OutputPackItems)" />
    </ItemGroup>
    <Delete Files="@(_PackageFilesToDelete)" />
  </Target>
  <Target Name="_CalculateInputsOutputsForPack" DependsOnTargets="_GetOutputItemsFromPack" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup Condition="$(ContinuePackingAfterGeneratingNuspec) == '' ">
      <ContinuePackingAfterGeneratingNuspec>false</ContinuePackingAfterGeneratingNuspec>
    </PropertyGroup>
    <ItemGroup>
      <!--This catches changes to properties-->
      <NuGetPackInput Include="$(MSBuildAllProjects)" />
      <NuGetPackInput Include="@(_PackageFiles)" />
      <NuGetPackInput Include="@(_PackageFilesToExclude)" />
      <NuGetPackInput Include="@(_BuildOutputInPackage->'%(FinalOutputPath)')" />
      <NuGetPackInput Include="@(_TargetPathsToSymbols->'%(FinalOutputPath)')" />
      <NuGetPackInput Include="@(_SourceFiles)" />
      <NuGetPackInput Include="@(_References)" />
      <NuGetPackOutput Include="@(_OutputPackItems)" />
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    Pack
    Main entry point for packing packages
    ============================================================
  -->
  <Target Name="Pack" DependsOnTargets="$(PackDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <IsPackableFalseWarningTask Condition="'$(IsPackable)' == 'false' AND '$(WarnOnPackingNonPackableProject)' == 'true'" />
  </Target>
  <Target Name="_IntermediatePack" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <ContinuePackingAfterGeneratingNuspec>true</ContinuePackingAfterGeneratingNuspec>
    </PropertyGroup>
  </Target>
  <Target Name="GenerateNuspec" Condition="'$(IsPackable)' == 'true'" Inputs="@(NuGetPackInput)" Outputs="@(NuGetPackOutput)" DependsOnTargets="$(GenerateNuspecDependsOn);_CalculateInputsOutputsForPack;_GetProjectReferenceVersions;_InitializeNuspecRepositoryInformationProperties" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ConvertToAbsolutePath Condition="$(NuspecFile) != ''" Paths="$(NuspecFile)">
      <Output TaskParameter="AbsolutePaths" PropertyName="NuspecFileAbsolutePath" />
    </ConvertToAbsolutePath>
    <!-- Call Pack -->
    <PackTask PackItem="$(PackProjectInputFile)" PackageFiles="@(_PackageFiles)" PackageFilesToExclude="@(_PackageFilesToExclude)" PackageVersion="$(PackageVersion)" PackageId="$(PackageId)" Title="$(Title)" Authors="$(Authors)" Description="$(PackageDescription)" Copyright="$(Copyright)" RequireLicenseAcceptance="$(PackageRequireLicenseAcceptance)" LicenseUrl="$(PackageLicenseUrl)" ProjectUrl="$(PackageProjectUrl)" IconUrl="$(PackageIconUrl)" ReleaseNotes="$(PackageReleaseNotes)" Tags="$(PackageTags)" DevelopmentDependency="$(DevelopmentDependency)" BuildOutputInPackage="@(_BuildOutputInPackage)" ProjectReferencesWithVersions="@(_ProjectReferencesWithVersions)" TargetPathsToSymbols="@(_TargetPathsToSymbols)" TargetFrameworks="@(_TargetFrameworks)" FrameworksWithSuppressedDependencies="@(_FrameworksWithSuppressedDependencies)" AssemblyName="$(AssemblyName)" PackageOutputPath="$(PackageOutputAbsolutePath)" IncludeSymbols="$(IncludeSymbols)" IncludeSource="$(IncludeSource)" PackageTypes="$(PackageType)" IsTool="$(IsTool)" RepositoryUrl="$(RepositoryUrl)" RepositoryType="$(RepositoryType)" RepositoryBranch="$(RepositoryBranch)" RepositoryCommit="$(RepositoryCommit)" SourceFiles="@(_SourceFiles-&gt;Distinct())" NoPackageAnalysis="$(NoPackageAnalysis)" NoDefaultExcludes="$(NoDefaultExcludes)" MinClientVersion="$(MinClientVersion)" Serviceable="$(Serviceable)" FrameworkAssemblyReferences="@(_FrameworkAssemblyReferences)" ContinuePackingAfterGeneratingNuspec="$(ContinuePackingAfterGeneratingNuspec)" NuspecOutputPath="$(NuspecOutputAbsolutePath)" IncludeBuildOutput="$(IncludeBuildOutput)" BuildOutputFolders="$(BuildOutputTargetFolder)" ContentTargetFolders="$(ContentTargetFolders)" RestoreOutputPath="$(RestoreOutputAbsolutePath)" NuspecFile="$(NuspecFileAbsolutePath)" NuspecBasePath="$(NuspecBasePath)" NuspecProperties="$(NuspecProperties)" AllowedOutputExtensionsInPackageBuildOutputFolder="$(AllowedOutputExtensionsInPackageBuildOutputFolder)" AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder="$(AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder)" NoWarn="$(NoWarn)" WarningsAsErrors="$(WarningsAsErrors)" WarningsNotAsErrors="$(WarningsNotAsErrors)" TreatWarningsAsErrors="$(TreatWarningsAsErrors)" OutputFileNamesWithoutVersion="$(OutputFileNamesWithoutVersion)" InstallPackageToOutputPath="$(InstallPackageToOutputPath)" SymbolPackageFormat="$(SymbolPackageFormat)" PackageLicenseFile="$(PackageLicenseFile)" PackageLicenseExpression="$(PackageLicenseExpression)" PackageLicenseExpressionVersion="$(PackageLicenseExpressionVersion)" Readme="$(PackageReadmeFile)" Deterministic="$(Deterministic)" PackageIcon="$(PackageIcon)" />
  </Target>
  <!--
    Initialize Repository* properties from properties set by a source control package, if available in the project.
  -->
  <Target Name="_InitializeNuspecRepositoryInformationProperties" DependsOnTargets="InitializeSourceControlInformation" Condition="'$(SourceControlInformationFeatureSupported)' == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <PropertyGroup>
      <!-- The project must specify PublishRepositoryUrl=true in order to publish the URL or branch, in order to prevent inadvertent leak of internal data. -->
      <RepositoryUrl Condition="'$(RepositoryUrl)' == '' and '$(PublishRepositoryUrl)' == 'true'">$(PrivateRepositoryUrl)</RepositoryUrl>
      <RepositoryCommit Condition="'$(RepositoryCommit)' == ''">$(SourceRevisionId)</RepositoryCommit>
      <RepositoryBranch Condition="'$(RepositoryBranch)' == '' and '$(PublishRepositoryUrl)' == 'true' and '$(SourceBranchName)' != ''">$(SourceBranchName)</RepositoryBranch>
    </PropertyGroup>
  </Target>
  <!--
    ============================================================
    _LoadPackGraphEntryPoints
    Find project entry point and load them into items.
    ============================================================
  -->
  <Target Name="_LoadPackInputItems" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- Allow overriding items with PackProjectInputFile -->
    <PropertyGroup Condition="'$(PackProjectInputFile)' == ''">
      <PackProjectInputFile>$(MSBuildProjectFullPath)</PackProjectInputFile>
    </PropertyGroup>
  </Target>
  <Target Name="_GetProjectReferenceVersions" Condition="'$(NuspecFile)' == ''" DependsOnTargets="_GetAbsoluteOutputPathsForPack;$(GetPackageVersionDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- 'RestoreOutputAbsolutePath' will be provided by '_GetAbsoluteOutputPathsForPack' target -->
    <ConvertToAbsolutePath Condition="'$(ProjectAssetsFile)' != ''" Paths="$(ProjectAssetsFile)">
      <Output TaskParameter="AbsolutePaths" PropertyName="ProjectAssetsFileAbsolutePath" />
    </ConvertToAbsolutePath>
    <GetProjectReferencesFromAssetsFileTask RestoreOutputAbsolutePath="$(RestoreOutputAbsolutePath)" ProjectAssetsFileAbsolutePath="$(ProjectAssetsFileAbsolutePath)">
      <Output TaskParameter="ProjectReferences" ItemName="_ProjectReferencesFromAssetsFile" />
    </GetProjectReferencesFromAssetsFileTask>
    <MSBuild Projects="@(_ProjectReferencesFromAssetsFile)" Targets="_GetProjectVersion" SkipNonexistentTargets="true" SkipNonexistentProjects="true" Properties="BuildProjectReferences=false;">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferencesWithVersions" />
    </MSBuild>
  </Target>
  <Target Name="_GetProjectVersion" DependsOnTargets="$(GetPackageVersionDependsOn)" Returns="@(_ProjectPathWithVersion)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ProjectPathWithVersion Include="$(MSBuildProjectFullPath)">
        <ProjectVersion Condition="'$(PackageVersion)' != ''">$(PackageVersion)</ProjectVersion>
        <ProjectVersion Condition="'$(PackageVersion)' == ''">1.0.0</ProjectVersion>
      </_ProjectPathWithVersion>
    </ItemGroup>
  </Target>
  <Target Name="_WalkEachTargetPerFramework" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_ProjectsWithTFM Include="$(MSBuildProjectFullPath)" AdditionalProperties="TargetFramework=%(_TargetFrameworks.Identity)" />
      <_ProjectsWithTFMNoBuild Include="$(MSBuildProjectFullPath)" AdditionalProperties="TargetFramework=%(_TargetFrameworks.Identity);BuildProjectReferences=false" />
    </ItemGroup>
    <MSBuild Condition="'$(IncludeBuildOutput)' == 'true'" Projects="@(_ProjectsWithTFM)" Targets="_GetBuildOutputFilesWithTfm" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_BuildOutputInPackage" />
    </MSBuild>
    <MSBuild Condition="'$(TargetsForTfmSpecificContentInPackage)' != ''" Projects="@(_ProjectsWithTFM)" Targets="_GetTfmSpecificContentForPackage" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_PackageFiles" />
    </MSBuild>
    <MSBuild Condition="'$(IncludeBuildOutput)' == 'true'" Projects="@(_ProjectsWithTFM)" Targets="_GetDebugSymbolsWithTfm" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_TargetPathsToSymbols" />
    </MSBuild>
    <MSBuild Condition="'$(IncludeSource)' == 'true'" Projects="@(_ProjectsWithTFMNoBuild)" Targets="SourceFilesProjectOutputGroup" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_SourceFiles" />
    </MSBuild>
    <MSBuild Projects="@(_ProjectsWithTFMNoBuild)" Targets="_GetFrameworkAssemblyReferences" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_FrameworkAssemblyReferences" />
    </MSBuild>
    <MSBuild Projects="@(_ProjectsWithTFMNoBuild)" Targets="_GetFrameworksWithSuppressedDependencies" BuildInParallel="$(BuildInParallel)">
      <Output TaskParameter="TargetOutputs" ItemName="_FrameworksWithSuppressedDependencies" />
    </MSBuild>
  </Target>
  <Target Name="_GetFrameworksWithSuppressedDependencies" Returns="@(_TfmWithDependenciesSuppressed)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_TfmWithDependenciesSuppressed Include="$(TargetFramework)" Condition="'$(SuppressDependenciesWhenPacking)' == 'true'" />
    </ItemGroup>
  </Target>
  <Target Name="_GetFrameworkAssemblyReferences" DependsOnTargets="ResolveReferences" Returns="@(TfmSpecificFrameworkAssemblyReferences)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <TfmSpecificFrameworkAssemblyReferences Include="@(ReferencePath->'%(OriginalItemSpec)')" Condition="'%(ReferencePath.Pack)' != 'false' AND '%(ReferencePath.ResolvedFrom)' == '{TargetFrameworkDirectory}'">
        <TargetFramework>$(TargetFramework)</TargetFramework>
      </TfmSpecificFrameworkAssemblyReferences>
    </ItemGroup>
  </Target>
  <Target Name="_GetBuildOutputFilesWithTfm" DependsOnTargets="BuiltProjectOutputGroup;DocumentationProjectOutputGroup;SatelliteDllsProjectOutputGroup;_AddPriFileToPackBuildOutput;$(TargetsForTfmSpecificBuildOutput)" Returns="@(BuildOutputInPackage)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(IncludeBuildOutput)' == 'true'">
      <BuildOutputInPackage Include="@(SatelliteDllsProjectOutputGroupOutput);&#xD;&#xA;                            @(BuiltProjectOutputGroupOutput);&#xD;&#xA;                            @(DocumentationProjectOutputGroupOutput);&#xD;&#xA;                            @(_PathToPriFile)" />
    </ItemGroup>
  </Target>
  <Target Name="_GetTfmSpecificContentForPackage" DependsOnTargets="$(TargetsForTfmSpecificContentInPackage)" Returns="@(TfmSpecificPackageFileWithRecursiveDir)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <!-- The below workaround needs to be done due to msbuild bug https://github.com/Microsoft/msbuild/issues/3121 -->
    <ItemGroup>
      <TfmSpecificPackageFileWithRecursiveDir Include="@(TfmSpecificPackageFile)">
        <NuGetRecursiveDir>%(TfmSpecificPackageFile.RecursiveDir)</NuGetRecursiveDir>
        <BuildAction>%(TfmSpecificPackageFile.BuildAction)</BuildAction>
      </TfmSpecificPackageFileWithRecursiveDir>
    </ItemGroup>
  </Target>
  <Target Name="_GetDebugSymbolsWithTfm" DependsOnTargets="DebugSymbolsProjectOutputGroup;$(TargetsForTfmSpecificDebugSymbolsInPackage)" Returns="@(_TargetPathsToSymbolsWithTfm)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(IncludeBuildOutput)' == 'true'">
      <_TargetPathsToSymbolsWithTfm Include="@(DebugSymbolsProjectOutputGroupOutput)">
        <TargetFramework>$(TargetFramework)</TargetFramework>
      </_TargetPathsToSymbolsWithTfm>
    </ItemGroup>
    <ItemGroup>
      <_TargetPathsToSymbolsWithTfm Include="@(TfmSpecificDebugSymbolsFile)" />
    </ItemGroup>
  </Target>
  <!--Projects with target framework like UWP, Win8, wpa81 produce a Pri file
    in their bin dir. This Pri file is not included in the BuiltProjectGroupOutput, and
    has to be added manually here.-->
  <Target Name="_AddPriFileToPackBuildOutput" Returns="@(_PathToPriFile)" DependsOnTargets="$(AddPriFileDependsOn)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup Condition="'$(IncludeProjectPriFile)' == 'true'">
      <_PathToPriFile Include="$(ProjectPriFullPath)">
        <FinalOutputPath>$(ProjectPriFullPath)</FinalOutputPath>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </_PathToPriFile>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _GetPackageFiles
    Entry point for generating the project to project references.
    ============================================================
  -->
  <Target Name="_GetPackageFiles" Condition="$(IncludeContentInPack) == 'true'" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <ItemGroup>
      <_PackageFilesToExclude Include="@(Content)" Condition="'%(Content.Pack)' == 'false'" />
    </ItemGroup>
    <!-- Include PackageFiles and Content of the project being packed -->
    <ItemGroup>
      <_PackageFiles Include="@(Content)" Condition=" %(Content.Pack) != 'false' ">
        <BuildAction Condition="'%(Content.BuildAction)' == ''">Content</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(Compile)" Condition=" %(Compile.Pack) == 'true' ">
        <BuildAction Condition="'%(Compile.BuildAction)' == ''">Compile</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(None)" Condition=" %(None.Pack) == 'true' ">
        <BuildAction Condition="'%(None.BuildAction)' == ''">None</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(EmbeddedResource)" Condition=" %(EmbeddedResource.Pack) == 'true' ">
        <BuildAction Condition="'%(EmbeddedResource.BuildAction)' == ''">EmbeddedResource</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(ApplicationDefinition)" Condition=" %(ApplicationDefinition.Pack) == 'true' ">
        <BuildAction Condition="'%(ApplicationDefinition.BuildAction)' == ''">ApplicationDefinition</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(Page)" Condition=" %(Page.Pack) == 'true' ">
        <BuildAction Condition="'%(Page.BuildAction)' == ''">Page</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(Resource)" Condition=" %(Resource.Pack) == 'true' ">
        <BuildAction Condition="'%(Resource.BuildAction)' == ''">Resource</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(SplashScreen)" Condition=" %(SplashScreen.Pack) == 'true' ">
        <BuildAction Condition="'%(SplashScreen.BuildAction)' == ''">SplashScreen</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(DesignData)" Condition=" %(DesignData.Pack) == 'true' ">
        <BuildAction Condition="'%(DesignData.BuildAction)' == ''">DesignData</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(DesignDataWithDesignTimeCreatableTypes)" Condition=" %(DesignDataWithDesignTimeCreatableTypes.Pack) == 'true' ">
        <BuildAction Condition="'%(DesignDataWithDesignTimeCreatableTypes.BuildAction)' == ''">DesignDataWithDesignTimeCreatableTypes</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(CodeAnalysisDictionary)" Condition=" %(CodeAnalysisDictionary.Pack) == 'true' ">
        <BuildAction Condition="'%(CodeAnalysisDictionary.BuildAction)' == ''">CodeAnalysisDictionary</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(AndroidAsset)" Condition=" %(AndroidAsset.Pack) == 'true' ">
        <BuildAction Condition="'%(AndroidAsset.BuildAction)' == ''">AndroidAsset</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(AndroidResource)" Condition=" %(AndroidResource.Pack) == 'true' ">
        <BuildAction Condition="'%(AndroidResource.BuildAction)' == ''">AndroidResource</BuildAction>
      </_PackageFiles>
      <_PackageFiles Include="@(BundleResource)" Condition=" %(BundleResource.Pack) == 'true' ">
        <BuildAction Condition="'%(BundleResource.BuildAction)' == ''">BundleResource</BuildAction>
      </_PackageFiles>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!-- Import targets from Microsoft.NET.Build.Container.targets -->
  <PropertyGroup xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    <_IsNotSetContainersTargetsDir>false</_IsNotSetContainersTargetsDir>
    <_IsNotSetContainersTargetsDir Condition=" '$(_ContainersTargetsDir)'=='' ">true</_IsNotSetContainersTargetsDir>
    <_ContainersTargetsDir Condition="$(_IsNotSetContainersTargetsDir)">$(MSBuildThisFileDirectory)..\..\..\Containers\build\</_ContainersTargetsDir>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(MSBuildThisFileDirectory)..\..\..\Containers\build\Microsoft.NET.Build.Containers.props" Condition="Exists('$(MSBuildThisFileDirectory)..\..\..\Containers\build\Microsoft.NET.Build.Containers.props')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Containers/build/Microsoft.NET.Build.Containers.props
============================================================================================================================================
-->
  <PropertyGroup>
    <!-- A flag representing this package existing in a project.  -->
    <SDKContainerSupportEnabled>true</SDKContainerSupportEnabled>
    <ContainerTaskFolderName>tasks</ContainerTaskFolderName>
    <ContainerTaskFramework Condition="'$(MSBuildRuntimeType)' == 'Core'">net10.0</ContainerTaskFramework>
    <ContainerTaskFramework Condition="'$(MSBuildRuntimeType)' == 'Full'">net472</ContainerTaskFramework>
    <ContainerizeFolderName>containerize</ContainerizeFolderName>
    <!--The folder where the custom task will be present. It points to inside the nuget package. -->
    <ContainerCustomTasksFolder>$(MSBuildThisFileDirectory)..\$(ContainerTaskFolderName)\$(ContainerTaskFramework)\</ContainerCustomTasksFolder>
    <ContainerizeFolder>$(MSBuildThisFileDirectory)..\$(ContainerizeFolderName)\</ContainerizeFolder>
    <!--Reference to the assembly which contains the MSBuild Task-->
    <ContainerCustomTasksAssembly Condition="'$(ContainerCustomTasksAssembly)' == ''">$(ContainerCustomTasksFolder)$(MSBuildThisFileName).dll</ContainerCustomTasksAssembly>
  </PropertyGroup>
  <!--Register our custom task-->
  <UsingTask TaskName="$(MSBuildThisFileName).Tasks.CreateNewImage" AssemblyFile="$(ContainerCustomTasksAssembly)" />
  <UsingTask TaskName="$(MSBuildThisFileName).Tasks.CreateImageIndex" AssemblyFile="$(ContainerCustomTasksAssembly)" />
  <UsingTask TaskName="$(MSBuildThisFileName).Tasks.ParseContainerProperties" AssemblyFile="$(ContainerCustomTasksAssembly)" />
  <UsingTask TaskName="$(MSBuildThisFileName).Tasks.ComputeDotnetBaseImageAndTag" AssemblyFile="$(ContainerCustomTasksAssembly)" />
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="$(_ContainersTargetsDir)Microsoft.NET.Build.Containers.targets" Condition="$(_IsNotSetContainersTargetsDir) AND Exists('$(_ContainersTargetsDir)Microsoft.NET.Build.Containers.targets')">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Containers/build/Microsoft.NET.Build.Containers.targets
============================================================================================================================================
-->
  <PropertyGroup>
    <_IsSDKContainerAllowedVersion>false</_IsSDKContainerAllowedVersion>
    <!-- Anything newer than 7.0.100-preview.7 is supported -->
    <_IsSDKContainerAllowedVersion Condition="$([MSBuild]::VersionGreaterThan($(NetCoreSdkVersion), 7.0.100))&#xA;                       OR ( $([MSBuild]::VersionEquals($(NetCoreSdkVersion), 7.0.100))&#xA;                            AND (&#xA;                                 $(NETCoreSdkVersion.Contains('-preview.7'))&#xA;                                 OR $(NETCoreSdkVersion.Contains('-rc'))&#xA;                                 OR $(NETCoreSdkVersion.Contains('-')) == false&#xA;                                )&#xA;                          )">true</_IsSDKContainerAllowedVersion>
    <_ContainerIsTargetingNet8TFM>false</_ContainerIsTargetingNet8TFM>
    <_ContainerIsTargetingNet8TFM Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp' And $([MSBuild]::VersionGreaterThanOrEquals($(_TargetFrameworkVersionWithoutV), '8.0'))">true</_ContainerIsTargetingNet8TFM>
    <_ContainerIsSelfContained>false</_ContainerIsSelfContained>
    <_ContainerIsSelfContained Condition="'$(SelfContained)' == 'true' or '$(PublishSelfContained)' == 'true'">true</_ContainerIsSelfContained>
    <EnableSdkContainerSupport Condition="'$(EnableSdkContainerSupport)' == '' and '$(OutputType)' != 'Library'">true</EnableSdkContainerSupport>
  </PropertyGroup>
  <ItemGroup>
    <ProjectCapability Include="NetSdkOCIImageBuild" />
  </ItemGroup>
  <Target Name="_ContainerVerifySDKVersion" Condition="'$(WebPublishMethod)' == 'Container' or '$(PublishProfile)' == 'DefaultContainer'" BeforeTargets="AfterPublish">
    <!-- If the user has opted into container publishing via their own profile (WebPublishMethod = Container) or
            via the default Profile (PublishProfile = DefaultContainer), make sure they're on a supported SDK version.
            We do the explicit profile name check here because for preview6 for example the profile didn't exist, so we
            can't rely only on the WebPublishMethod. -->
    <Error Condition="'$(_IsSDKContainerAllowedVersion)' != 'true'" Code="CONTAINER002" Text="The current .NET SDK ($(NETCoreSdkVersion)) doesn't support containerization. Please use version 7.0.100 or higher to enable containerization." />
  </Target>
  <Target Name="ComputeContainerBaseImage" Returns="$(ContainerBaseImage)">
    <PropertyGroup>
      <!-- The Container RID should default to the RID used for the entire build (to ensure things run on the platform they are built for), but the user knows best and so should be able to set it explicitly.
           For builds that have a RID, we default to that RID. Otherwise, we default to the Linux RID matching the architecture of the currently-executing SDK. -->
      <ContainerRuntimeIdentifier Condition="'$(ContainerRuntimeIdentifier)' == '' and '$(RuntimeIdentifier)' != ''">$(RuntimeIdentifier)</ContainerRuntimeIdentifier>
      <ContainerRuntimeIdentifiers Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(ContainerRuntimeIdentifiers)' == '' and '$(IsRidAgnostic)' != 'true'">$(RuntimeIdentifiers)</ContainerRuntimeIdentifiers>
      <ContainerRuntimeIdentifier Condition="'$(ContainerRuntimeIdentifier)' == '' and '$(ContainerRuntimeIdentifiers)' == ''">linux-$(NETCoreSdkPortableRuntimeIdentifier.Split('-')[1])</ContainerRuntimeIdentifier>
      <!-- We want to save customer provided ContainerBaseImage to later set ContainerUser. -->
      <_InitialContainerBaseImage>$(ContainerBaseImage)</_InitialContainerBaseImage>
    </PropertyGroup>
    <ItemGroup>
      <_TargetRuntimeIdentifiers Include="$(ContainerRuntimeIdentifier)" Condition="'$(ContainerRuntimeIdentifier)' != ''" />
      <_TargetRuntimeIdentifiers Include="$(ContainerRuntimeIdentifiers)" Condition="@(_TargetRuntimeIdentifiers-&gt;Count()) == 0" />
    </ItemGroup>
    <ComputeDotnetBaseImageAndTag UserBaseImage="$(ContainerBaseImage)" SdkVersion="$(NetCoreSdkVersion)" TargetFrameworkVersion="$(_TargetFrameworkVersionWithoutV).0" FrameworkReferences="@(FrameworkReference)" IsSelfContained="$(_ContainerIsSelfContained)" IsAotPublished="$(PublishAot)" IsTrimmed="$(PublishTrimmed)" UsesInvariantGlobalization="$(InvariantGlobalization)" TargetRuntimeIdentifiers="@(_TargetRuntimeIdentifiers)" ContainerFamily="$(ContainerFamily)">
      <Output TaskParameter="ComputedContainerBaseImage" PropertyName="ContainerBaseImage" />
    </ComputeDotnetBaseImageAndTag>
    <ItemGroup>
      <_TargetRuntimeIdentifiers Remove="$(_TargetRuntimeIdentifiers)" />
    </ItemGroup>
  </Target>
  <!-- This Target is called early on in the chain for both single-RID and multi-RID containers - but for single-RID it's important
       that we ensure all of the data necessary to create a single-RID container is computed after we exit this target. -->
  <Target Name="ComputeContainerConfig" DependsOnTargets="ComputeContainerBaseImage;_ComputeContainerExecutionArgs">
    <PropertyGroup Label="VS defaults">
      <!-- RegistryUrl is used by existing VS targets for Docker builds - this lets us fill that void -->
      <ContainerRegistry Condition="'$(RegistryUrl)' != ''">$(RegistryUrl)</ContainerRegistry>
      <!-- PublishImageTag is used by existing VS targets for Docker builds - this lets us fill that void -->
      <ContainerImageTag Condition="'$(PublishImageTag)' != ''">$(PublishImageTag)</ContainerImageTag>
      <!-- This line is a compatibility shim for VS support - the VS container targets define a container tag using this property and format. This lets us be a drop-in replacement for them. -->
      <ContainerImageTag Condition="'$(AutoGenerateImageTag)' == 'true'">$([System.DateTime]::UtcNow.ToString('yyyyMMddhhmmss'))</ContainerImageTag>
    </PropertyGroup>
    <!-- Compatibility: previous versions used ImageName, but the proper term is Repository. Keep using that if explicitly set. -->
    <Warning Condition="'$(ContainerImageName)' != ''" Code="CONTAINER003" Text="The property 'ContainerImageName' was set but is obsolete - please use 'ContainerRepository' instead." />
    <!-- Container Defaults -->
    <PropertyGroup>
      <!-- An empty ContainerRegistry implies pushing to the local registry, putting this here for documentation purposes -->
      <!-- <ContainerRegistry></ContainerRegistry> -->
      <!-- An empty LocalRegistry implies detecting the local registry. LocalRegistry can be set explicity to Docker/Podman. -->
      <!-- <LocalRegistry></LocalRegistry> -->
      <!-- Compatibility: previous versions used ImageName, but the proper term is Repository. Keep using that if explicitly set. -->
      <ContainerRepository Condition="'$(ContainerImageName)' != ''">$(ContainerImageName)</ContainerRepository>
      <!-- Note: spaces will be replaced with '-' in ContainerRepository and ContainerImageTag -->
      <ContainerRepository Condition="'$(ContainerRepository)' == ''">$(AssemblyName)</ContainerRepository>
      <!-- Only default a tag name if no tag names at all are provided -->
      <ContainerImageTag Condition="'$(ContainerImageTag)' == '' and '$(ContainerImageTags)' == ''">latest</ContainerImageTag>
      <ContainerImageTag Condition="'$(AutoGenerateImageTag)' == 'true' and '$(ContainerImageTags)' == ''">$([System.DateTime]::UtcNow.ToString('yyyyMMddhhmmss'))</ContainerImageTag>
    </PropertyGroup>
    <ParseContainerProperties FullyQualifiedBaseImageName="$(ContainerBaseImage)" ContainerRegistry="$(ContainerRegistry)" ContainerRepository="$(ContainerRepository)" ContainerImageTag="$(ContainerImageTag)" ContainerImageTags="$(ContainerImageTags)" ContainerEnvironmentVariables="@(ContainerEnvironmentVariable)">
      <Output TaskParameter="ParsedContainerRegistry" PropertyName="ContainerBaseRegistry" />
      <Output TaskParameter="ParsedContainerImage" PropertyName="ContainerBaseName" />
      <Output TaskParameter="ParsedContainerTag" PropertyName="ContainerBaseTag" />
      <Output TaskParameter="ParsedContainerDigest" PropertyName="ContainerBaseDigest" />
      <Output TaskParameter="NewContainerRegistry" PropertyName="ContainerRegistry" />
      <Output TaskParameter="NewContainerRepository" PropertyName="ContainerRepository" />
      <Output TaskParameter="NewContainerTags" ItemName="ContainerImageTags" />
      <Output TaskParameter="NewContainerEnvironmentVariables" ItemName="ContainerEnvironmentVariables" />
    </ParseContainerProperties>
    <PropertyGroup>
      <ContainerGenerateLabels Condition="'$(ContainerGenerateLabels)' == ''">true</ContainerGenerateLabels>
      <ContainerGenerateLabelsImageCreated Condition="'$(ContainerGenerateLabelsImageCreated)' == ''">true</ContainerGenerateLabelsImageCreated>
      <ContainerGenerateLabelsImageDescription Condition="'$(ContainerGenerateLabelsImageDescription)' == ''">true</ContainerGenerateLabelsImageDescription>
      <ContainerGenerateLabelsImageAuthors Condition="'$(ContainerGenerateLabelsImageAuthors)' == ''">true</ContainerGenerateLabelsImageAuthors>
      <ContainerGenerateLabelsImageUrl Condition="'$(ContainerGenerateLabelsImageUrl)' == ''">true</ContainerGenerateLabelsImageUrl>
      <ContainerGenerateLabelsImageDocumentation Condition="'$(ContainerGenerateLabelsImageDocumentation)' == ''">true</ContainerGenerateLabelsImageDocumentation>
      <ContainerGenerateLabelsImageSource Condition="'$(ContainerGenerateLabelsImageSource)' == ''">true</ContainerGenerateLabelsImageSource>
      <ContainerGenerateLabelsImageVersion Condition="'$(ContainerGenerateLabelsImageVersion)' == ''">true</ContainerGenerateLabelsImageVersion>
      <ContainerGenerateLabelsImageRevision Condition="'$(ContainerGenerateLabelsImageRevision)' == ''">true</ContainerGenerateLabelsImageRevision>
      <ContainerGenerateLabelsImageVendor Condition="'$(ContainerGenerateLabelsImageVendor)' == ''">true</ContainerGenerateLabelsImageVendor>
      <ContainerGenerateLabelsImageLicenses Condition="'$(ContainerGenerateLabelsImageLicenses)' == ''">true</ContainerGenerateLabelsImageLicenses>
      <ContainerGenerateLabelsImageTitle Condition="'$(ContainerGenerateLabelsImageTitle)' == ''">true</ContainerGenerateLabelsImageTitle>
      <ContainerGenerateLabelsImageBaseDigest Condition="'$(ContainerGenerateLabelsImageBaseDigest)' == ''">true</ContainerGenerateLabelsImageBaseDigest>
      <ContainerGenerateLabelsImageBaseName Condition="'$(ContainerGenerateLabelsImageBaseName)' == ''">true</ContainerGenerateLabelsImageBaseName>
      <ContainerGenerateLabelsDotnetToolset Condition="'$(ContainerGenerateLabelsDotnetToolset)' == ''">true</ContainerGenerateLabelsDotnetToolset>
    </PropertyGroup>
    <PropertyGroup Label="Defaults for Container Labels">
      <ContainerDescription Condition="'$(ContainerDescription)' == '' and '$(Description)' != ''">$(Description)</ContainerDescription>
      <ContainerAuthors Condition="'$(ContainerAuthors)' == '' and '$(Authors)' != ''">$(Authors)</ContainerAuthors>
      <ContainerInformationUrl Condition="'$(ContainerInformationUrl)' == '' and '$(PackageProjectUrl)' != ''">$(PackageProjectUrl)</ContainerInformationUrl>
      <ContainerDocumentationUrl Condition="'$(ContainerDocumentationUrl)' == '' and '$(PackageProjectUrl)' != ''">$(PackageProjectUrl)</ContainerDocumentationUrl>
      <ContainerVersion Condition="'$(ContainerVersion)' == '' and '$(PackageVersion)' != ''">$(PackageVersion)</ContainerVersion>
      <ContainerLicenseExpression Condition="'$(ContainerLicenseExpression)' == '' and '$(PackageLicenseExpression)' != ''">$(PackageLicenseExpression)</ContainerLicenseExpression>
      <ContainerTitle Condition="'$(ContainerTitle)' == '' and '$(Title)' != ''">$(Title)</ContainerTitle>
    </PropertyGroup>
    <!-- Labels generated from descriptions from the spec at https://github.com/opencontainers/image-spec/blob/main/annotations.md#pre-defined-annotation-keys -->
    <ItemGroup Label="Conventional Label assignment" Condition="'$(ContainerGenerateLabels)' == 'true'">
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageCreated)' == 'true'" Include="org.opencontainers.image.created;org.opencontainers.artifact.created" Value="$([System.DateTime]::UtcNow.ToString('o'))" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageDescription)' == 'true' and '$(ContainerDescription)' != ''" Include="org.opencontainers.artifact.description;org.opencontainers.image.description" Value="$(ContainerDescription)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageAuthors)' == 'true' and '$(ContainerAuthors)' != ''" Include="org.opencontainers.image.authors" Value="$(ContainerAuthors)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageUrl)' == 'true' and '$(ContainerInformationUrl)' != ''" Include="org.opencontainers.image.url" Value="$(ContainerInformationUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageDocumentation)' == 'true' and '$(ContainerDocumentationUrl)' != ''" Include="org.opencontainers.image.documentation" Value="$(ContainerDocumentationUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageVersion)' == 'true' and '$(ContainerVersion)' != ''" Include="org.opencontainers.image.version" Value="$(ContainerVersion)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageVendor)' == 'true' and '$(ContainerVendor)' != ''" Include="org.opencontainers.image.vendor" Value="$(ContainerVendor)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageLicenses)' == 'true' and '$(ContainerLicenseExpression)' != ''" Include="org.opencontainers.image.licenses" Value="$(ContainerLicenseExpression)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageTitle)' == 'true' and '$(ContainerTitle)' != ''" Include="org.opencontainers.image.title" Value="$(ContainerTitle)" />
      <!-- Need to compute digests, not just names, before we can light this up. This suggests we need a task where all of the 'read' steps are done. -->
      <!-- <ContainerLabel Condition="'$(ContainerGenerateLabelsImageBaseDigest)' == 'true' and '$(ContainerBaseImageDigest)' != ''" Include="org.opencontainers.image.base.digest" Value="$(ContainerBaseImageDigest)" /> -->
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageBaseName)' == 'true' and '$(ContainerBaseImage)' != ''" Include="org.opencontainers.image.base.name" Value="$(ContainerBaseImage)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsDotnetToolset)' == 'true' and '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" Include="net.dot.runtime.majorminor" Value="$(_TargetFrameworkVersionWithoutV)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsDotnetToolset)' == 'true'" Include="net.dot.sdk.version" Value="$(NETCoreSdkVersion)" />
    </ItemGroup>
    <!-- These sourcelink-derived properties are only allowed to flow to generated artifacts if `PublishRepositoryUrl` is set as a user signal for opt-in.
             In addition, the 'nice' property names are currently set by NuGet Pack targets and so we have to use the private/generic names here. -->
    <PropertyGroup Label="Source control label assignment" Condition="'$(ContainerGenerateLabels)' == 'true' and '$(PublishRepositoryUrl)' == 'true'">
      <!-- Sourcelink gives us the .git suffix, but scanning tools aren't looking for that so we trim it off here. -->
      <_TrimmedRepositoryUrl Condition="'$(RepositoryType)' == 'git' and '$(PrivateRepositoryUrl)' != '' and $(PrivateRepositoryUrl.EndsWith('.git'))">$(PrivateRepositoryUrl.Substring(0, $(PrivateRepositoryUrl.LastIndexOf('.git'))))</_TrimmedRepositoryUrl>
      <_TrimmedRepositoryUrl Condition="'$(_TrimmedRepositoryUrl)' == '' and '$(PrivateRepositoryUrl)' != ''">$(PrivateRepositoryUrl)</_TrimmedRepositoryUrl>
    </PropertyGroup>
    <ItemGroup Label="Source control label assignment" Condition="'$(ContainerGenerateLabels)' == 'true' and '$(PublishRepositoryUrl)' == 'true'">
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageSource)' == 'true' and '$(_TrimmedRepositoryUrl)' != ''" Include="org.opencontainers.image.source" Value="$(_TrimmedRepositoryUrl)" />
      <ContainerLabel Condition="'$(ContainerGenerateLabelsImageRevision)' == 'true' and '$(SourceRevisionId)' != ''" Include="org.opencontainers.image.revision" Value="$(SourceRevisionId)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <PublishContainerDependsOn>
      _ContainerVerifySDKVersion;
      _ContainerEstablishRIDNess;
      ComputeContainerConfig;
      _CheckContainersPackage
    </PublishContainerDependsOn>
  </PropertyGroup>
  <!-- These args are relevant to container execution and are per-RID by nature. Therefore they're a direct dependency of the _PublishSingleContainer
       target and not computed at the outer, multi-RID build layer. -->
  <Target Name="_ComputeContainerExecutionArgs" Condition="'$(_IsSingleRIDBuild)' == 'true'">
    <PropertyGroup>
      <!-- The Container RID should default to the RID used for the entire build (to ensure things run on the platform they are built for), but the user knows best and so should be able to set it explicitly.
           For builds that have a RID, we default to that RID. Otherwise, we default to the Linux RID matching the architecture of the currently-executing SDK. -->
      <_ContainerIsTargetingWindows>false</_ContainerIsTargetingWindows>
      <_ContainerIsTargetingWindows Condition="$(ContainerRuntimeIdentifier.StartsWith('win'))">true</_ContainerIsTargetingWindows>
      <!-- Set the WorkingDirectory depending on the RID -->
      <ContainerWorkingDirectory Condition="'$(ContainerWorkingDirectory)' == '' and !$(_ContainerIsTargetingWindows)">/app/</ContainerWorkingDirectory>
      <ContainerWorkingDirectory Condition="'$(ContainerWorkingDirectory)' == '' and $(_ContainerIsTargetingWindows)">C:\app\</ContainerWorkingDirectory>
      <_ContainerIsUsingMicrosoftDefaultImages Condition="'$(_InitialContainerBaseImage)' == ''">true</_ContainerIsUsingMicrosoftDefaultImages>
      <_ContainerIsUsingMicrosoftDefaultImages Condition="'$(_InitialContainerBaseImage)' != ''">false</_ContainerIsUsingMicrosoftDefaultImages>
    </PropertyGroup>
    <!-- We only set a default user when the base image is Microsoft-authored, and we're targeting a version of those images that supports a nonroot user -->
    <PropertyGroup Label="ContainerUser Assignment" Condition="$(_ContainerIsUsingMicrosoftDefaultImages) and $(_ContainerIsTargetingNet8TFM) and '$(ContainerUser)' == ''">
      <ContainerUser Condition="$(_ContainerIsTargetingWindows)">ContainerUser</ContainerUser>
    </PropertyGroup>
    <ItemGroup Label="AppCommand Assignment" Condition="'$(ContainerAppCommandInstruction)' != 'None'">
      <!-- For self-contained, invoke the native executable as a single arg -->
      <ContainerAppCommand Condition="@(ContainerAppCommand-&gt;Count()) == 0 and $(_ContainerIsSelfContained)" Include="$(ContainerWorkingDirectory)$(AssemblyName)$(_NativeExecutableExtension)" />
      <!-- For non self-contained, invoke `dotnet` `app.dll` as separate args -->
      <ContainerAppCommand Condition="@(ContainerAppCommand-&gt;Count()) == 0 and !$(_ContainerIsSelfContained)" Include="dotnet;$(ContainerWorkingDirectory)$(TargetFileName)" />
    </ItemGroup>
  </Target>
  <Target Name="_CheckContainersPackage" AfterTargets="Build">
    <PropertyGroup>
      <!-- facts to base on comparisons on -->
      <_ContainersPackageIdentity>Microsoft.NET.Build.Containers</_ContainersPackageIdentity>
      <_WebDefaultSdkVersion>7.0.300</_WebDefaultSdkVersion>
      <_WorkerDefaultSdkVersion>8.0.100</_WorkerDefaultSdkVersion>
      <_ConsoleDefaultSdkVersion>8.0.200</_ConsoleDefaultSdkVersion>
      <!-- capability detection for the executing SDK -->
      <_SdkCanPublishWeb>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_WebDefaultSdkVersion)'))</_SdkCanPublishWeb>
      <_SdkCanPublishWorker>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_WorkerDefaultSdkVersion)'))</_SdkCanPublishWorker>
      <_SdkCanPublishConsole>$([MSBuild]::VersionGreaterThanOrEquals('$(NETCoreSdkVersion)', '$(_ConsoleDefaultSdkVersion)'))</_SdkCanPublishConsole>
      <!-- capability detection for the executing project -->
      <_ContainerPackageIsPresent>false</_ContainerPackageIsPresent>
      <_ContainerPackageIsPresent Condition="@(PackageReference-&gt;AnyHaveMetadataValue('Identity', '$(_ContainersPackageIdentity)'))">true</_ContainerPackageIsPresent>
      <_IsWebProject>false</_IsWebProject>
      <_IsWebProject Condition="@(ProjectCapability-&gt;AnyHaveMetadataValue('Identity', 'DotNetCoreWeb'))">true</_IsWebProject>
      <_IsWorkerProject>false</_IsWorkerProject>
      <_IsWorkerProject Condition="@(ProjectCapability-&gt;AnyHaveMetadataValue('Identity', 'DotNetCoreWorker'))">true</_IsWorkerProject>
    </PropertyGroup>
    <Warning Condition="$(_ContainerPackageIsPresent)&#xA;        and (&#xA;          ($(_SdkCanPublishWeb) and $(_IsWebProject)) or&#xA;          ($(_SdkCanPublishWorker) and $(_IsWorkerProject)) or&#xA;          ($(_SdkCanPublishConsole) and '$(EnableSdkContainerSupport)' == 'true')&#xA;        )" Code="CONTAINER005" Text="The $(_ContainersPackageIdentity) NuGet package is explicitly referenced but the current SDK can natively publish the project as a container. Consider removing the package reference to $(_ContainersPackageIdentity) because it is no longer needed." />
  </Target>
  <!-- There is an implicit dependency here in that both of ComputeContainerConfig and _ComputeContainerExecutionArgs must have been run, but because we call this Target
       in a few different ways we can't express that dependency directly here. -->
  <Target Name="_PublishSingleContainer" Returns="@(GeneratedContainer)">
    <PropertyGroup Condition="'$(DOTNET_HOST_PATH)' == ''">
      <DotNetHostDirectory>$(NetCoreRoot)</DotNetHostDirectory>
      <DotNetHostFileName>dotnet</DotNetHostFileName>
      <DotNetHostFileName Condition="'$(OS)' == 'Windows_NT'">dotnet.exe</DotNetHostFileName>
    </PropertyGroup>
    <CreateNewImage ContainerizeDirectory="$(ContainerizeFolder)" ToolPath="$(DotNetHostDirectory)" ToolExe="$(DotNetHostFileName)" BaseRegistry="$(ContainerBaseRegistry)" BaseImageName="$(ContainerBaseName)" BaseImageTag="$(ContainerBaseTag)" BaseImageDigest="$(ContainerBaseDigest)" ImageFormat="$(ContainerImageFormat)" LocalRegistry="$(LocalRegistry)" OutputRegistry="$(ContainerRegistry)" ArchiveOutputPath="$(ContainerArchiveOutputPath)" Repository="$(ContainerRepository)" ImageTags="@(ContainerImageTags)" PublishDirectory="$(PublishDir)" WorkingDirectory="$(ContainerWorkingDirectory)" Entrypoint="@(ContainerEntrypoint)" EntrypointArgs="@(ContainerEntrypointArgs)" AppCommand="@(ContainerAppCommand)" AppCommandArgs="@(ContainerAppCommandArgs)" AppCommandInstruction="$(ContainerAppCommandInstruction)" DefaultArgs="@(ContainerDefaultArgs)" Labels="@(ContainerLabel)" ExposedPorts="@(ContainerPort)" ContainerEnvironmentVariables="@(ContainerEnvironmentVariables)" ContainerRuntimeIdentifier="$(ContainerRuntimeIdentifier)" ContainerUser="$(ContainerUser)" RuntimeIdentifierGraphPath="$(RuntimeIdentifierGraphPath)" SkipPublishing="$(_SkipContainerPublishing)" GenerateLabels="$(ContainerGenerateLabels)" GenerateDigestLabel="$(ContainerGenerateLabelsImageBaseDigest)">
      <!-- The RID graph path is provided as a property by the SDK. -->
      <Output TaskParameter="GeneratedContainerManifest" PropertyName="GeneratedContainerManifest" />
      <Output TaskParameter="GeneratedContainerConfiguration" PropertyName="GeneratedContainerConfiguration" />
      <Output TaskParameter="GeneratedContainerDigest" PropertyName="GeneratedContainerDigest" />
      <Output TaskParameter="GeneratedArchiveOutputPath" PropertyName="GeneratedArchiveOutputPath" />
      <Output TaskParameter="GeneratedContainerMediaType" PropertyName="GeneratedContainerMediaType" />
      <Output TaskParameter="GeneratedContainerNames" ItemName="GeneratedContainerName" />
      <Output TaskParameter="GeneratedDigestLabel" ItemName="ContainerLabel" />
    </CreateNewImage>
    <ItemGroup>
      <GeneratedContainer Include="GeneratedContainer">
        <Manifest>$(GeneratedContainerManifest)</Manifest>
        <Configuration>$(GeneratedContainerConfiguration)</Configuration>
        <ManifestDigest>$(GeneratedContainerDigest)</ManifestDigest>
        <ManifestMediaType>$(GeneratedContainerMediaType)</ManifestMediaType>
      </GeneratedContainer>
    </ItemGroup>
  </Target>
  <Target Name="_PublishMultiArchContainers" DependsOnTargets="$(PublishContainerDependsOn)" Returns="@(GeneratedContainer)">
    <PropertyGroup>
      <!--We want to skip publishing individual images in case of multi-arch tarball publishing or local daemon (only docker) publishing because all images are published in one tarball.-->
      <!--We don't want to skip publishing individual images in case of remote registry because the individual images should be available in the registry before image index is pushed.-->
      <!--We don't want to skip publishing individual images in case of local daemon podman because podman loads multi-arch tarball differently - only individual image for the current platform.-->
      <_SkipContainerPublishing>false</_SkipContainerPublishing>
      <_SkipContainerPublishing Condition="$(ContainerArchiveOutputPath) != '' or ( $(ContainerRegistry) == '' and ( $(LocalRegistry) == '' or $(LocalRegistry) == 'Docker' ) )">true</_SkipContainerPublishing>
      <!--We want to skip CreateImageIndex task in case of local daemon podman because it is not supported.-->
      <_SkipCreateImageIndex>false</_SkipCreateImageIndex>
      <_SkipCreateImageIndex Condition="$(ContainerArchiveOutputPath) == '' and $(ContainerRegistry) == '' and $(LocalRegistry) == 'Podman'">true</_SkipCreateImageIndex>
      <!-- Figure out what format the inner images should be coerced to -->
      <!-- If a user had an opinion, use that -->
      <_SingleImageContainerFormat Condition="'$(ContainerImageFormat)' != ''">$(ContainerImageFormat)</_SingleImageContainerFormat>
      <!-- If we are publishing to local tarball or to local Docker, force OCI to prevent mismatches between inner images and the outer manifest -->
      <_SingleImageContainerFormat Condition="$(_SkipContainerPublishing) == 'true' ">OCI</_SingleImageContainerFormat>
    </PropertyGroup>
    <ItemGroup>
      <_rids Include="$(ContainerRuntimeIdentifiers)" Condition="'$(ContainerRuntimeIdentifiers)' != ''" />
      <_rids Include="$(RuntimeIdentifiers)" Condition="'$(ContainerRuntimeIdentifiers)' == '' and '$(RuntimeIdentifiers)' != ''" />
      <_InnerBuild Include="$(MSBuildProjectFullPath)" AdditionalProperties="&#xA;          ContainerRuntimeIdentifier=%(_rids.Identity);&#xA;          RuntimeIdentifier=%(_rids.Identity);&#xA;          ContainerBaseRegistry=$(ContainerBaseRegistry);&#xA;          ContainerBaseName=$(ContainerBaseName);&#xA;          ContainerBaseTag=$(ContainerBaseTag);&#xA;          ContainerBaseDigest=$(ContainerBaseDigest);&#xA;          ContainerRegistry=$(ContainerRegistry);&#xA;          _ContainerImageTags=@(ContainerImageTags, ';');&#xA;          ContainerRepository=$(ContainerRepository);&#xA;          _ContainerLabel=@(ContainerLabel->'%(Identity):%(Value)');&#xA;          _ContainerPort=@(ContainerPort->'%(Identity):%(Type)');&#xA;          _ContainerEnvironmentVariables=@(ContainerEnvironmentVariable->'%(Identity):%(Value)');&#xA;          ContainerGenerateLabels=$(ContainerGenerateLabels);&#xA;          ContainerGenerateLabelsImageBaseDigest=$(ContainerGenerateLabelsImageBaseDigest);&#xA;          _SkipContainerPublishing=$(_SkipContainerPublishing);&#xA;          ContainerImageFormat=$(_SingleImageContainerFormat);&#xA;          _IsMultiRIDBuild=false;&#xA;          _IsSingleRIDBuild=true;&#xA;          _InitialContainerBaseImage=$(_InitialContainerBaseImage)&#xA;        " />
      <_rids Remove="$(_rids)" />
    </ItemGroup>
    <MSBuild Projects="@(_InnerBuild)" Targets="Publish;_ParseItemsForPublishingSingleContainer;_ComputeContainerExecutionArgs;_PublishSingleContainer" BuildInParallel="$([MSBuild]::ValueOrDefault('$(ContainerPublishInParallel)', 'true'))">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </MSBuild>
    <CreateImageIndex Condition="'$(_SkipCreateImageIndex)' == 'false' " GeneratedContainers="@(GeneratedContainer)" LocalRegistry="$(LocalRegistry)" OutputRegistry="$(ContainerRegistry)" ArchiveOutputPath="$(ContainerArchiveOutputPath)" Repository="$(ContainerRepository)" ImageTags="@(ContainerImageTags)" BaseRegistry="$(ContainerBaseRegistry)" BaseImageName="$(ContainerBaseName)" BaseImageTag="$(ContainerBaseTag)" BaseImageDigest="$(ContainerBaseDigest)">
      <Output TaskParameter="GeneratedImageIndex" PropertyName="GeneratedImageIndex" />
      <Output TaskParameter="GeneratedArchiveOutputPath" PropertyName="GeneratedArchiveOutputPath" />
    </CreateImageIndex>
  </Target>
  <Target Name="_ParseItemsForPublishingSingleContainer">
    <ItemGroup>
      <OriginalImageTags Include="$(_ContainerImageTags)" />
      <ContainerImageTags Include="@(OriginalImageTags->'%(Identity)-$(ContainerRuntimeIdentifier)')" />
      <_ParsedContainerLabel Condition="'$(_ContainerLabel)' != ':'" Include="$(_ContainerLabel)" />
      <ContainerLabel Condition="@(_ParsedContainerLabel-&gt;Count()) &gt; 0 " Include="$([System.String]::Copy('%(_ParsedContainerLabel.Identity)').Split(':')[0])" Value="$([System.String]::Copy('%(_ParsedContainerLabel.Identity)').Split(':')[1])" />
      <_ParsedContainerPort Condition="'$(_ContainerPort)' != ':'" Include="$(_ContainerPort)" />
      <ContainerPort Condition="@(_ParsedContainerPort-&gt;Count()) &gt; 0 " Include="$([System.String]::Copy('%(_ParsedContainerPort.Identity)').Split(':')[0])" Type="$([System.String]::Copy('%(_ParsedContainerPort.Identity)').Split(':')[1])" />
      <_ParsedContainerEnvironmentVariables Condition="'$(_ContainerEnvironmentVariables)' != ':'" Include="$(_ContainerEnvironmentVariables)" />
      <ContainerEnvironmentVariables Condition="@(_ParsedContainerEnvironmentVariables-&gt;Count()) &gt; 0 " Include="$([System.String]::Copy('%(_ParsedContainerEnvironmentVariables.Identity)').Split(':')[0])" Value="$([System.String]::Copy('%(_ParsedContainerEnvironmentVariables.Identity)').Split(':')[1])" />
    </ItemGroup>
  </Target>
  <Target Name="_ContainerEstablishRIDNess">
    <PropertyGroup>
      <_IsMultiTFMBuild Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">true</_IsMultiTFMBuild>
      <!-- we are multi-RID if:
          * we have CRIDs and no CRID
          * we have RIDs and no (CRIDs or CRID or RID)
      -->
      <_HasCRIDsAndNoCRID Condition="'$(ContainerRuntimeIdentifiers)' != '' and '$(ContainerRuntimeIdentifier)' == ''">true</_HasCRIDsAndNoCRID>
      <_HasRIDs Condition="'$(RuntimeIdentifiers)' != ''">true</_HasRIDs>
      <_NoCRIDsOrCRIDorRID Condition="'$(ContainerRuntimeIdentifiers)' == '' and '$(ContainerRuntimeIdentifier)' == '' and '$(RuntimeIdentifier)' == ''">true</_NoCRIDsOrCRIDorRID>
      <!-- these two are load-bearing for other comparisons - see _ComputeContainerExecutionArgs -->
      <_IsMultiRIDBuild Condition="'$(BuildingInsideVisualStudio)' != 'true' and ('$(_HasCRIDsAndNoCRID)' == true or ('$(_HasRIDs)' == 'true' and '$(_NoCRIDsOrCRIDorRID)' == 'true'))">true</_IsMultiRIDBuild>
      <_IsSingleRIDBuild Condition="'$(_IsMultiRIDBuild)' == ''">true</_IsSingleRIDBuild>
    </PropertyGroup>
  </Target>
  <Target Name="PublishContainer" DependsOnTargets="$(PublishContainerDependsOn)" Condition="'$(IsPublishable)' == 'true' AND '$(EnableSdkContainerSupport)' == 'true'" Returns="@(GeneratedContainer)">
    <!-- Call _PublishMultiArchContainers if we are in a multi-rid build, and call _PublishSingleContainer if we are in a single-RID build -->
    <CallTarget Condition="'$(_IsMultiRIDBuild)' == 'true' " Targets="_PublishMultiArchContainers">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </CallTarget>
    <CallTarget Condition="'$(_IsSingleRIDBuild)' == 'true' " Targets="_PublishSingleContainer">
      <Output TaskParameter="TargetOutputs" ItemName="GeneratedContainer" />
    </CallTarget>
    <Error Condition="'$(_IsMultiTFMBuild)' == 'true'" Code="CONTAINERS0666" Text="Containers cannot be published for multiple TargetFrameworks at this time. Please specify a TargetFramework." />
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Sdk.targets" Sdk="Microsoft.NET.Sdk.StaticWebAssets" Condition="'$(_RazorSdkImportsMicrosoftNetSdkStaticWebAssets)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="Sdk.targets" Sdk="Microsoft.NET.Sdk" Condition="'$(_StaticWebAssetsSdkImportsMicrosoftNetSdk)' == 'true'" />-->
  <PropertyGroup Condition="'$(StaticWebAssetsSdkCurrentVersionTargets)' == ''">
    <StaticWebAssetsSdkCurrentVersionTargets>$(MSBuildThisFileDirectory)..\targets\Sdk.StaticWebAssets.CurrentVersion.targets</StaticWebAssetsSdkCurrentVersionTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(StaticWebAssetsSdkCurrentVersionTargets)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Sdk.StaticWebAssets.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.StaticWebAssets.CurrentVersion.targets
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.
Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <EnableDefaultContentItems Condition=" '$(EnableDefaultContentItems)' == '' ">true</EnableDefaultContentItems>
  </PropertyGroup>
  <!--
    Targets supporting Razor MSBuild integration. Contain support for generating C# code using Razor
    and including the generated code in the project lifecycle, including compiling, publishing and producing
    nuget packages.
  -->
  <!--
    This is a hook to import a set of targets before the Razor targets. By default this is unused.
  -->
  <!--<Import Project="$(CustomBeforeStaticWebAssetsSdkTargets)" Condition="'$(CustomBeforeStaticWebAssetsSdkTargets)' != '' and Exists('$(CustomBeforeStaticWebAssetsSdkTargets)')" />-->
  <PropertyGroup>
    <!-- Paths to tools, tasks, and extensions are calculated relative to the StaticWebAssetsSdkDirectoryRoot. This can be modified to test a local build. -->
    <StaticWebAssetsSdkDirectoryRoot Condition="'$(StaticWebAssetsSdkDirectoryRoot)'==''">$(MSBuildThisFileDirectory)..\</StaticWebAssetsSdkDirectoryRoot>
    <StaticWebAssetsSdkBuildTasksDirectoryRoot Condition="'$(StaticWebAssetsSdkBuildTasksDirectoryRoot)'==''">$(StaticWebAssetsSdkDirectoryRoot)tasks\</StaticWebAssetsSdkBuildTasksDirectoryRoot>
    <_StaticWebAssetsSdkTasksTFM Condition=" '$(MSBuildRuntimeType)' == 'Core'">net10.0</_StaticWebAssetsSdkTasksTFM>
    <_StaticWebAssetsSdkTasksTFM Condition=" '$(_StaticWebAssetsSdkTasksTFM)' == ''">net472</_StaticWebAssetsSdkTasksTFM>
    <StaticWebAssetsSdkBuildTasksAssembly>$(StaticWebAssetsSdkBuildTasksDirectoryRoot)$(_StaticWebAssetsSdkTasksTFM)\Microsoft.NET.Sdk.StaticWebAssets.Tasks.dll</StaticWebAssetsSdkBuildTasksAssembly>
    <_StaticWebAssetsSdkToolAssembly>$(StaticWebAssetsSdkDirectoryRoot)tools\net10.0\Microsoft.NET.Sdk.StaticWebAssets.Tool.dll</_StaticWebAssetsSdkToolAssembly>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DOTNET_HOST_PATH)' == ''">
    <_StaticWebAssetsSdkDotNetHostDirectory>$(NetCoreRoot)</_StaticWebAssetsSdkDotNetHostDirectory>
    <_StaticWebAssetsSdkDotNetHostFileName>dotnet</_StaticWebAssetsSdkDotNetHostFileName>
    <_StaticWebAssetsSdkDotNetHostFileName Condition="'$(OS)' == 'Windows_NT'">dotnet.exe</_StaticWebAssetsSdkDotNetHostFileName>
  </PropertyGroup>
  <!-- Resolve the TFM-specific attributes conditionally. -->
  <Choose>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '9.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <_TargetingNET70OrLater>true</_TargetingNET70OrLater>
        <_TargetingNET80OrLater>true</_TargetingNET80OrLater>
        <_TargetingNET90OrLater>true</_TargetingNET90OrLater>
        <_RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">9.0</_RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <_TargetingNET70OrLater>true</_TargetingNET70OrLater>
        <_TargetingNET80OrLater>true</_TargetingNET80OrLater>
        <_RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">8.0</_RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '7.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <_TargetingNET70OrLater>true</_TargetingNET70OrLater>
        <_RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">7.0</_RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '6.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <_RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">6.0</_RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '5.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">5.0</_RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '3.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">3.0</_RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '2.1')) ">
      <PropertyGroup>
        <_TargetingNETStandard21OrLater>true</_TargetingNETStandard21OrLater>
      </PropertyGroup>
    </When>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '2.0')) ">
      <PropertyGroup>
        <_TargetingNETStandard20OrLater>true</_TargetingNETStandard20OrLater>
      </PropertyGroup>
    </When>
  </Choose>
  <PropertyGroup>
    <!-- If the razor language version was explicitly specified, use that. -->
    <_RazorLangVersion Condition="'$(RazorLangVersion)' != ''">$(RazorLangVersion)</_RazorLangVersion>
    <!--
      In 3.0, we expect RazorLangVersion to either be specified in the template or inferred via TFM. In 2.x, RazorLangVersion is
      specified via the Razor.Design package. We'll default to a version of 2.1, the earliest version that the SDK supports.
      A 2.1 version should result in a build warning if the project contains Components.
    -->
    <_RazorLangVersion Condition="'$(_RazorLangVersion)' == ''">2.1</_RazorLangVersion>
    <!-- Keep this in sync with RazorLangVersion.cs if we introduce new text based values. -->
    <_Targeting30OrNewerRazorLangVersion Condition="&#xA;        '$(_RazorLangVersion)' == 'Latest' OR&#xA;        '$(_RazorLangVersion)' == 'Experimental' OR&#xA;        ('$(_RazorLangVersion)' != '' AND '$(_RazorLangVersion)' &gt;= '3.0')">true</_Targeting30OrNewerRazorLangVersion>
    <!-- Controls whether or not the static web assets feature is enabled. By default is enabled for netcoreapp3.0
        applications and RazorLangVersion 3 or above. -->
    <StaticWebAssetsEnabled Condition="'$(StaticWebAssetsEnabled)' == ''">$(_Targeting30OrNewerRazorLangVersion)</StaticWebAssetsEnabled>
    <UseStaticWebAssetsV2>$(_TargetingNET60OrLater)</UseStaticWebAssetsV2>
    <!-- Controls whether or not the scoped css feature is enabled. By default is enabled for net5.0 applications and RazorLangVersion 5 or above -->
    <ScopedCssEnabled Condition="'$(ScopedCssEnabled)' == '' and '$(StaticWebAssetsEnabled)' == 'true'">$(_TargetingNET50OrLater)</ScopedCssEnabled>
    <JSModulesEnabled Condition="'$(JSModulesEnabled)' == '' and '$(StaticWebAssetsEnabled)' == 'true'">$(_TargetingNET60OrLater)</JSModulesEnabled>
    <CompressionEnabled Condition="'$(CompressionEnabled)' == '' and '$(StaticWebAssetsEnabled)' == 'true'">$(_TargetingNET60OrLater)</CompressionEnabled>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.SingleTargeting.targets" Condition="'$(StaticWebAssetsEnabled)' == 'true' And '$(IsCrossTargetingBuild)' != 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.SingleTargeting.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--<Import Project="Microsoft.NET.Sdk.StaticWebAssets.5_0.targets" Condition="'$(UseStaticWebAssetsV2)' != 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.targets" Condition="'$(UseStaticWebAssetsV2)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ComputeStaticWebAssetsTargetPaths" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.GenerateStaticWebAssetsManifest" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.GenerateStaticWebAssetEndpointsManifest" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ComputeEndpointsForReferenceStaticWebAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.DefineStaticWebAssetEndpoints" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.GenerateStaticWebAssetsDevelopmentManifest" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.GenerateV1StaticWebAssetsManifest" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ReadStaticWebAssetsManifestFile" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.UpdatePackageStaticWebAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.DefineStaticWebAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.CollectStaticWebAssetsToCopy" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.MergeConfigurationProperties" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ComputePublishStaticWebAssetsList" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ComputeReferenceStaticWebAssetItems" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ComputeStaticWebAssetsForCurrentProject" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ResolveStaticWebAssetsEmbeddedProjectConfiguration" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.MergeStaticWebAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.FilterStaticWebAssetEndpoints" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.UpdateStaticWebAssetEndpoints" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ResolveStaticWebAssetEndpointRoutes" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ResolveFingerprintedStaticWebAssetEndpointsForAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.UpdateExternallyDefinedStaticWebAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <!-- Static web assets define how web content needs to be served from web applications, class libraries and packages during
       development and what and where web contents need to be served on the published application.

       Static web assets deal with two concerns:
       * How to map URLs for resources to files during development to serve files from disk as if they were part of the
         wwwroot folder of the app.
       * What files to copy to the publish output folder during the publish folder.

       Static web assets will take over content items within the wwwroot folder of the application and handle all aspects of them.
       During development they will define a JSON manifest that includes the following information:
       * A version number.
       * A hash for the contents of the manifest.
       * The library package id.
       * The asset base path for the library.
       * Manifest mode.
       * The list of related projects manifests with their hashes.
       * The list of "discovery patterns"
       * The list of generated static web assets during build/publish.

       Each section identifies:
       * The version number identifies the manifest format.
       * The hash of the manifest is used for determining whether the contents of the manifest have changed.
       * The library package id is used to differentiate assets served from other projects from assets served from the current project.
       * The asset base path for the library is used to determine what base path to add when applying a discovery pattern to a path coming from another library.
       * The manifest mode defines how assets coming from a given project must be treated during build and publish.
       * The list of related projects manifests is used for determining whether the list of projects have changed since the manifest was generated or if a manifest was updated.
       * The list of "discovery patterns" is useful to enable selective assets to be served at runtime after the manifest has been built. For example
         you can use { Path: "<<Project>/Pages", "BasePath": "{_content/Something}" Pattern: "**.js" } pattern to indicate that only files with a js extension should be served from that folder, so if someone adds
         an image or something like that, it won't be served. (This is important since it is not an asset by any rule and won't be part of the publish output folder).

      We generate two sets of manifests, one build manifest and one publish manifest:
      * The build manifest is generated during the build process and is used during development to serve assets as if they were part of the application.
      * The publish manifest is generated during publish and captures all the transformations that happen during the publish process.

      Assets can be defined during the build and publish phase, and can be "marked" as such at any stage. For example, you can have two files, one that is used during
      development and one that is used on the published app that must be served from the same path. One example of this is `service-worker.js`

      The build time manifest is constructed from the combination of the discovered assets in the project and the assets that come from referenced projects and packages.
      The publish manifest uses the build manifest as a starting point, filtering out the files marked as build only and includes any transformation that happens to those files
      during the build publish process.
      * This enables transformations at publish time like `Linking`, `Bundling`, `Compresion` and other optimizations to take place during the publish step.
      * Referenced projects also produce a publish manifest and their contents are merged with the current project manifest as part of the publish process.
      * We still keep track of the original build manifest for referenced projects during the publish process to enable applications to discard the publish assets for referenced projects
        if they choose to do so and to perform optimizations over the entire transitive closure of assets.
        * For example, a library can produce a minified JS bundle to use during publish. The app can choose to instead of using multiple bundles, collect all the assets from the original build process and generate a single bundle.

      We normally expect the build and publish asset manifest to be the same except when there are publish specific transformations.

      On each manifiest we define the list of assets we generated/computed during the build/publish process and their properties. Those properties are:
        * "Identity": The identity for the asset (Full path to the file).
        * "SourceType": The type of asset ('Discovered', 'Computed', 'Project', 'Package')
        * "ContentRoot": The original path where the asset is exposed in during development.
        * "BasePath": The base path where the asset is exposed.
        * "RelativePath": The relative path for the asset.
        * "AssetKind": The asset kind ('Build', 'Publish' or 'All') This is inferred from CopyToOutputDirectory/CopyToPublishDirectory
        * "AssetMode": The asset mode ('CurrentProject', 'Reference', 'All')
        * "AssetRole": The asset role ('Primary', 'Related', 'Alternative')
        * "AssetMergeSource": The source of the asset when it is being embedded in another TFM.
        * "AssetMergeBehavior": The merge behavior when an asset conflicts with another asset in the same TFM.
        * "RelatedAsset": The Identity of the asset this asset depends on.
        * "AssetTraitName": The name of the trait or characteristic that differentiates this related or dependent asset from a primary asset.
        * "AssetTraitValue": The value of the trait or characteristic that differentiates this related or dependent asset from a primary asset.
        * "CopyToBuildDirectory": Same from Content (PreserveNewest, Always)
        * "CopyToPublishDirectory": Same from Content (PreserveNewest, Always)
        * "OriginalItemSpec": The original spec from where the item was defined

      With regards to how assets are consumed in different scenarios (when they are part of the main project being built or are consumed as a reference) there are three posible options:
      * All: Which means the asset must be used in all situations.
      * Root: Which means the asset must only be considered when the main project is being built.
      * Reference: Which means the asset must only be considered when the project is being consumed as a reference.

      An example of this are the bundles that we produce for CSS isolation:
      * One bundle `<<Project>>.styles.css` is a Root asset and must only be used when the asset is part of the root of the project.
      * The other bundle `<<Project>>.lib.bundle.css` is a Reference asset and must only be used when the asset is being referenced by another project.

      Along with these three modes of operations, projects also define how they operate during build and publish with regards to the files on the manifest. In this regards there are three options:
      * Default: The project copies all the contents to the publish output folder during publish and does not do anything when being referenced from another project. When the project
        is being referenced by another project, it will expect that project to take care of publishing the static web assets.
      * Root: The asset must be considered "a root" for defining static web assets and while a referencing project will still manage the assets,
        they need to be copied to the output folder as if they were being published as the root.
      * Isolated: Its the same as Root with the difference that any referencing project doesn't know anything about static web assets and the project will wire-up handlers for copying the assets to
        the right locations during publish.

      Default is used by class libraries, since they don't copy their assets themselves but rely on a referencing project to copy them to the final publish output folder.
      Root is used by projects like Blazor webassembly hosted where while the project is "referenced" by the hosting ASP.NET Core project, the assets should be considered as if they were
      the root project, so for example, transitive assets are not copied and instead the Root assets were copied instead.
      Isolated is used by projects like Blazor desktop to fold the static web assets into `GetCopyToPublishDirectoryItems` so that any project that references it, doesn't require any knowledge
      of static web assets to work.

      With regards to types of assets, there are four categories that describe static web assets:
      * Discovered assets: These represents assets that were discovered from existing items in the project (Content, None, etc.)
      * Computed assets: Represents assets that were generated as part of the build process and that need to be copied to their final locations during the build.
      * Project: Represents assets that come from a referenced projects.
        * Discovered and Computed assets are transformed into Project assets when manifests from referenced projects get merged.
      * Package: These assets come from a referenced package.

      With regards to asset roles, there are three roles that an asset can play:
      * Primary asset: This value indicates that the asset represents a resource that will be addressable at the appropriate relative path.
        The majority of assets will be part of this role.
      * Related asset: This value indicates that the asset is related to another asset, while maintaining that both assets should be addressable at their own relative paths.
      * Alternative asset: This value indicates that the asset is an alternative representation for the related asset. This can be for example, an asset that is pre-compressed
        or an alternative format for the asset. The expectation is that an alternative asset is served from the same relative path as their related asset. Although its up to
        the runtimes to decide if/how to implement that. At the static web asset level we just make sure we capture the information about the relationship.

      For Related and Alternative assets the RelatedAsset property points to another asset that they depend on. This chain can be extended multiple levels to represent scenarios
      where multiple representations of an asset are produced. Again, static web assets only captures this information, its up to MSBuild targets to decide what to do with it.

      The AssetTraitName and AssetTraitValue define the discriminator between a related or alternative asset and their associated primary asset. In the case of globalization assemblies
      this can capture the assembly culture, in the case of compressed asset it can capture the encoding and the specific encoding format.

      General build/publish flow:
      During a build for the project the following happens:
        PrepareForRun ->
          GenerateStaticWebAssetsManifest ->
            ResolveBuildRelatedStaticWebAssets ->
              ResolveProjectStaticWebAssets;
              ResolveEmbeddedProjectStaticWebAssets;
              ResolveReferencedProjectStaticWebAssetsConfiguration;
              ResolveEmbeddedConfigurationsReferencedProjects;
              ResolveReferencedProjectsStaticWebAssets;
                Invokes the targets returned in ResolveReferencedProjectStaticWebAssetsConfiguration to get the static web assets build
                items from the referenced project.
              (* ResolvePackageStaticWebAssets doesn't need a target, they get defined in the package props file)
              ResolveEmbeddedConfigurationsPackageReferences (* We need to get the package assets that we might need to include in this build
              that come from a TFM we are embedding)
          GetCopyToOutputDirectoryItems ->
            AddStaticWebAssetsManifest
          CopyStaticWebAssetsToOutputDirectory
            MaterializeComputedStaticWebAssets

      During the publish flow for the project the following happens:
        ComputeFilesToPublish ->
          StaticWebAssetsPrepareForPublish ->
            GenerateStaticWebAssetsPublishManifest ->
              ResolveRelatedPublishStaticWebAssets ->
                ResolvePublishStaticWebAssets;
                  LoadStaticWebAssetsBuildManifest;
                  ComputeReferencedProjectsPublishAssets;
                    Invokes ComputeReferencedStaticWebAssetsPublishManifest on referenced projects and gets the list of publish assets.

        // This target is only called by referencing projects, which helps us
        ComputeReferencedStaticWebAssetsPublishManifest ->
          GenerateStaticWebAssetsPublishManifest

          CopyStaticWebAssetsToPublishDirectory ->
            LoadStaticWebAssetsPublishManifest;

        GetCopyToPublishDirectoryItems (only on self-contained mode) ->
          AddStaticWebAssetsToTheListOfResolvedAssetsToPublish ->
            GenerateStaticWebAssetsPublishManifest ->
              ResolveRelatedPublishStaticWebAssets ->
                LoadStaticWebAssetsBuildManifest;
                ComputeReferencedProjectsPublishAssets;
                  Invokes ComputeReferencedStaticWebAssetsPublishManifest on referenced projects and gets the list of publish assets.
  -->
  <!-- Dependency definitions -->
  <PropertyGroup>
    <!-- For preview only, to ease in the new implementation -->
    <PrepareForRunDependsOn>StaticWebAssetsPrepareForRun;$(PrepareForRunDependsOn)</PrepareForRunDependsOn>
    <StaticWebAssetsPrepareForRunDependsOn>$(StaticWebAssetsPrepareForRunDependsOn);ResolveBuildStaticWebAssets;GenerateStaticWebAssetsManifest;CopyStaticWebAssetsToOutputDirectory;</StaticWebAssetsPrepareForRunDependsOn>
    <StaticWebAssetsPrepareForRunDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true'">$(StaticWebAssetsPrepareForRunDependsOn);WriteStaticWebAssetsUpToDateCheck;</StaticWebAssetsPrepareForRunDependsOn>
    <!-- This is a hook for features like scoped CSS and Blazor can ensure all the assets have been generated -->
    <GenerateComputedBuildStaticWebAssetsDependsOn>ResolveCoreStaticWebAssets;$(GenerateComputedBuildStaticWebAssetsDependsOn)</GenerateComputedBuildStaticWebAssetsDependsOn>
    <GenerateStaticWebAssetsManifestDependsOn>$(GenerateStaticWebAssetsManifestDependsOn);ResolveBuildStaticWebAssets</GenerateStaticWebAssetsManifestDependsOn>
    <!-- There are now three stages:
      ResolveCoreStaticWebAssets: This is the stage where we resolve the static web assets for the current project, packages and project references. These assets exist on disk
      and are part of the project or one of its dependencies.
      ResolveStaticWebAssetsInputs: This is the stage where we resolve assets that are generating by the build process, like scoped CSS bundles and that need to look at the
      entire set of assets that are provided to the project.
      ResolveBuildRelatedStaticWebAssets: This is the stage where we resolve assets that are derived from the assets that were resolved in ResolveStaticWebAssetsInputs.
    -->
    <ResolveCoreStaticWebAssetsDependsOn>
      UpdateExistingPackageStaticWebAssets;
      ResolveProjectStaticWebAssets;
      ResolveEmbeddedProjectsStaticWebAssets;
      ResolveReferencedProjectsStaticWebAssets;
      $(ResolveCoreStaticWebAssetsDependsOn);
    </ResolveCoreStaticWebAssetsDependsOn>
    <ResolveStaticWebAssetsInputsDependsOn>
      ResolveCoreStaticWebAssets;
      GenerateComputedBuildStaticWebAssets;
      $(ResolveStaticWebAssetsInputsDependsOn)
    </ResolveStaticWebAssetsInputsDependsOn>
    <ResolveBuildRelatedStaticWebAssetsDependsOn>
      ResolveStaticWebAssetsInputs;
      $(ResolveBuildRelatedStaticWebAssetsDependsOn)
    </ResolveBuildRelatedStaticWebAssetsDependsOn>
    <GetCopyToOutputDirectoryItemsDependsOn>$(GetCopyToOutputDirectoryItemsDependsOn);AddStaticWebAssetsManifest;AddStaticWebAssetEndpointsBuildManifest</GetCopyToOutputDirectoryItemsDependsOn>
    <CopyStaticWebAssetsToOutputDirectoryDependsOn>LoadStaticWebAssetsBuildManifest;$(CopyStaticWebAssetsToOutputDirectoryDependsOn)</CopyStaticWebAssetsToOutputDirectoryDependsOn>
    <!-- StaticWebAssetsPrepareForPublish -> ComputeFilesToPublish -->
    <StaticWebAssetsPrepareForPublishDependsOn>
      $(StaticWebAssetsPrepareForPublishDependsOn);
      ResolveStaticWebAssetsConfiguration;
      GenerateStaticWebAssetsPublishManifest;
    </StaticWebAssetsPrepareForPublishDependsOn>
    <GenerateStaticWebAssetsPublishManifestDependsOn>
      ResolveStaticWebAssetsConfiguration;
      ResolveAllPublishStaticWebAssets;
      $(GenerateStaticWebAssetsPublishManifestDependsOn);
    </GenerateStaticWebAssetsPublishManifestDependsOn>
    <ResolveCorePublishStaticWebAssetsDependsOn>
      LoadStaticWebAssetsBuildManifest;
      ComputeReferencedProjectsEmbeddedPublishAssets;
      ComputeReferencedProjectsPublishAssets;
      $(ResolveCorePublishStaticWebAssetsDependsOn);
    </ResolveCorePublishStaticWebAssetsDependsOn>
    <ResolvePublishStaticWebAssetsDependsOn>
      ResolveCorePublishStaticWebAssets;
      GenerateComputedPublishStaticWebAssets;
      $(ResolvePublishStaticWebAssetsDependsOn);
    </ResolvePublishStaticWebAssetsDependsOn>
    <ResolvePublishRelatedStaticWebAssetsDependsOn />
    <!-- This is a hook for features like scoped CSS and Blazor can ensure all the assets have been generated -->
    <GenerateComputedPublishStaticWebAssetsDependsOn />
    <ComputeReferencedStaticWebAssetsPublishManifestDependsOn>
      $(ComputeReferencedStaticWebAssetsPublishManifestDependsOn);
      StaticWebAssetsPrepareForPublish;
    </ComputeReferencedStaticWebAssetsPublishManifestDependsOn>
    <CopyStaticWebAssetsToPublishDirectoryDependsOn>StaticWebAssetsPrepareForPublish;LoadStaticWebAssetsPublishManifest;$(CopyStaticWebAssetsToPublishDirectoryDependsOn)</CopyStaticWebAssetsToPublishDirectoryDependsOn>
  </PropertyGroup>
  <!-- Static web assets canonical metadata -->
  <ItemGroup>
    <!-- Static web assets metadata -->
    <_StaticWebAssetCanonicalMetadata Include="SourceType" />
    <_StaticWebAssetCanonicalMetadata Include="SourceId" />
    <_StaticWebAssetCanonicalMetadata Include="BasePath" />
    <_StaticWebAssetCanonicalMetadata Include="RelativePath" />
    <_StaticWebAssetCanonicalMetadata Include="ContentRoot" />
    <_StaticWebAssetCanonicalMetadata Include="AssetKind" />
    <_StaticWebAssetCanonicalMetadata Include="AssetMode" />
    <_StaticWebAssetCanonicalMetadata Include="AssetRole" />
    <_StaticWebAssetCanonicalMetadata Include="AssetMergeSource" />
    <_StaticWebAssetCanonicalMetadata Include="AssetMergeBehavior" />
    <_StaticWebAssetCanonicalMetadata Include="RelatedAsset" />
    <_StaticWebAssetCanonicalMetadata Include="AssetTraitName" />
    <_StaticWebAssetCanonicalMetadata Include="AssetTraitValue" />
    <_StaticWebAssetCanonicalMetadata Include="Fingerprint" />
    <_StaticWebAssetCanonicalMetadata Include="Integrity" />
    <_StaticWebAssetCanonicalMetadata Include="CopyToOutputDirectory" />
    <_StaticWebAssetCanonicalMetadata Include="CopyToPublishDirectory" />
    <_StaticWebAssetCanonicalMetadata Include="OriginalItemSpec" />
    <!-- Static web assets discovery pattern metadata -->
    <_StaticWebAssetDiscoveryPatternCanonicalMetadata Include="Source" />
    <_StaticWebAssetDiscoveryPatternCanonicalMetadata Include="BasePath" />
    <_StaticWebAssetDiscoveryPatternCanonicalMetadata Include="ContentRoot" />
    <_StaticWebAssetDiscoveryPatternCanonicalMetadata Include="Pattern" />
    <!-- Static web assets endpoint metadata -->
    <_StaticWebAssetEndpointCanonicalMetadata Include="AssetFile" />
    <_StaticWebAssetEndpointCanonicalMetadata Include="Selectors" />
    <_StaticWebAssetEndpointCanonicalMetadata Include="EndpointProperties" />
    <_StaticWebAssetEndpointCanonicalMetadata Include="ResponseHeaders" />
    <!-- Static web assets project configuration metadata -->
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="Version" />
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="Source" />
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="TargetFramework" />
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="GetBuildAssetsTargets" />
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="GetPublishAssetsTargets" />
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="AdditionalBuildProperties" />
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="AdditionalBuildPropertiesToRemove" />
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="AdditionalPublishProperties" />
    <_StaticWebAssetProjectConfigurationCanonicalMetadata Include="AdditionalPublishPropertiesToRemove" />
    <!-- Embedded project configuration -->
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="Version" />
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="Source" />
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="TargetFramework" />
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="GetEmbeddedBuildAssetsTargets" />
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="GetEmbeddedPublishAssetsTargets" />
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="AdditionalEmbeddedBuildProperties" />
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="AdditionalEmbeddedBuildPropertiesToRemove" />
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="AdditionalEmbeddedPublishProperties" />
    <_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata Include="AdditionalEmbeddedPublishPropertiesToRemove" />
  </ItemGroup>
  <Target Name="ResolveStaticWebAssetsConfiguration">
    <PropertyGroup>
      <StaticWebAssetBasePath Condition="'$(StaticWebAssetBasePath)' == ''">_content/$(PackageId)</StaticWebAssetBasePath>
      <StaticWebAssetProjectMode Condition="'$(StaticWebAssetProjectMode)' == ''">Default</StaticWebAssetProjectMode>
      <StaticWebAssetEndpointMode Condition="'$(StaticWebAssetEndpointMode)' == ''">Hosted</StaticWebAssetEndpointMode>
      <StaticWebAssetsFingerprintContent Condition="'$(StaticWebAssetsFingerprintContent)' == ''">true</StaticWebAssetsFingerprintContent>
      <StaticWebAssetFingerprintingEnabled Condition="'$(StaticWebAssetFingerprintingEnabled)' == ''">true</StaticWebAssetFingerprintingEnabled>
      <StaticWebAssetMergeTarget Condition="'$(TargetFrameworks)' != '' and '$(TargetPlatformIdentifier)' == 'browser'">Browser</StaticWebAssetMergeTarget>
      <StaticWebAssetMergeTarget Condition="'$(TargetFrameworks)' != '' and '$(TargetPlatformIdentifier)' == ''">Server</StaticWebAssetMergeTarget>
      <StaticWebAssetsCacheDefineStaticWebAssetsEnabled Condition="'$(StaticWebAssetsCacheDefineStaticWebAssetsEnabled)' == ''">true</StaticWebAssetsCacheDefineStaticWebAssetsEnabled>
      <!-- Manifest paths -->
      <_StaticWebAssetsManifestBase Condition="'$(_StaticWebAssetsManifestBase)' == ''">$(IntermediateOutputPath)</_StaticWebAssetsManifestBase>
      <StaticWebAssetBuildManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.build.json</StaticWebAssetBuildManifestPath>
      <StaticWebAssetsBuildManifestCacheFilePath>$(StaticWebAssetBuildManifestPath).cache</StaticWebAssetsBuildManifestCacheFilePath>
      <StaticWebAssetPackManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.pack.json</StaticWebAssetPackManifestPath>
      <StaticWebAssetDevelopmentManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.development.json</StaticWebAssetDevelopmentManifestPath>
      <StaticWebAssetEndpointsBuildManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.build.endpoints.json</StaticWebAssetEndpointsBuildManifestPath>
      <StaticWebAssetEndpointsPublishManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.publish.endpoints.json</StaticWebAssetEndpointsPublishManifestPath>
      <StaticWebAssetPublishManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.publish.json</StaticWebAssetPublishManifestPath>
      <_StaticWebAssetsIntermediateOutputPath>$(IntermediateOutputPath)staticwebassets\</_StaticWebAssetsIntermediateOutputPath>
      <!-- Temporary files -->
      <_GeneratedStaticWebAssetsPropsFile>$(_StaticWebAssetsIntermediateOutputPath)msbuild.$(PackageId).Microsoft.AspNetCore.StaticWebAssets.props</_GeneratedStaticWebAssetsPropsFile>
      <_GeneratedStaticWebAssetEndpointsPropsFile>$(_StaticWebAssetsIntermediateOutputPath)msbuild.$(PackageId).Microsoft.AspNetCore.StaticWebAssetEndpoints.props</_GeneratedStaticWebAssetEndpointsPropsFile>
      <_GeneratedBuildPropsFile>$(_StaticWebAssetsIntermediateOutputPath)msbuild.build.$(PackageId).props</_GeneratedBuildPropsFile>
      <_GeneratedBuildMultitargetingPropsFile>$(_StaticWebAssetsIntermediateOutputPath)msbuild.buildMultiTargeting.$(PackageId).props</_GeneratedBuildMultitargetingPropsFile>
      <_GeneratedBuildTransitivePropsFile>$(_StaticWebAssetsIntermediateOutputPath)msbuild.buildTransitive.$(PackageId).props</_GeneratedBuildTransitivePropsFile>
      <!-- Package relative import paths -->
      <_StaticWebAssetsPropsFileImportPath>Microsoft.AspNetCore.StaticWebAssets.props</_StaticWebAssetsPropsFileImportPath>
      <_StaticWebAssetEndpointsPropsFileImportPath>Microsoft.AspNetCore.StaticWebAssetEndpoints.props</_StaticWebAssetEndpointsPropsFileImportPath>
      <_StaticWebAssetsGeneratedBuildPropsFileImportPath>..\build\$(PackageId).props</_StaticWebAssetsGeneratedBuildPropsFileImportPath>
      <_StaticWebAssetsGeneratedBuildMultiTargetingPropsFileImportPath>..\buildMultiTargeting\$(PackageId).props</_StaticWebAssetsGeneratedBuildMultiTargetingPropsFileImportPath>
      <!-- Design -->
      <StaticWebAssetUpToDateCheckManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.upToDateCheck.txt</StaticWebAssetUpToDateCheckManifestPath>
      <StaticWebAssetReferencesUpToDateCheckManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.references.upToDateCheck.txt</StaticWebAssetReferencesUpToDateCheckManifestPath>
      <StaticWebAssetUpToDateCheckRemovedManifestPath>$(_StaticWebAssetsManifestBase)staticwebassets.removed.txt</StaticWebAssetUpToDateCheckRemovedManifestPath>
    </PropertyGroup>
    <MakeDir Directories="$(_StaticWebAssetsManifestBase)" Condition="!Exists('$(_StaticWebAssetsManifestBase)')" />
    <MakeDir Directories="$(_StaticWebAssetsIntermediateOutputPath)" Condition="!Exists('$(_StaticWebAssetsIntermediateOutputPath)')" />
  </Target>
  <!-- Build -->
  <Target Name="_EnsureContentRootFolders" AfterTargets="LoadStaticWebAssetsBuildManifest">
    <ItemGroup>
      <_StaticWebAssetContentRootFolder Include="@(StaticWebAsset->'%(ContentRoot)')" Condition="'%(SourceType)' == 'Computed'" />
    </ItemGroup>
    <MakeDir Directories="@(_StaticWebAssetContentRootFolder)" />
  </Target>
  <Target Name="CopyStaticWebAssetsToOutputDirectory" DependsOnTargets="$(CopyStaticWebAssetsToOutputDirectoryDependsOn)" />
  <Target Name="_SplitStaticWebAssetsByCopyOptions" AfterTargets="CopyStaticWebAssetsToOutputDirectory">
    <CollectStaticWebAssetsToCopy Assets="@(StaticWebAsset)" OutputPath="$(OutputPath)\wwwroot\">
      <Output TaskParameter="AssetsToCopy" ItemName="_BuildStaticWebAssetsTargetPath" />
    </CollectStaticWebAssetsToCopy>
    <ItemGroup>
      <_BuildStaticWebAssetsCopyAlways Include="@(_BuildStaticWebAssetsTargetPath)" Condition="'%(CopyToOutputDirectory)' == 'Always'" />
      <_BuildStaticWebAssetsPreserveNewest Include="@(_BuildStaticWebAssetsTargetPath)" Condition="'%(CopyToOutputDirectory)' == 'PreserveNewest'" />
    </ItemGroup>
  </Target>
  <Target Name="_BuildCopyStaticWebAssetsPreserveNewest" Inputs="@(_BuildStaticWebAssetsPreserveNewest)" Outputs="@(_BuildStaticWebAssetsPreserveNewest->'%(TargetPath)')" AfterTargets="_SplitStaticWebAssetsByCopyOptions">
    <Copy SourceFiles="@(_BuildStaticWebAssetsPreserveNewest)" DestinationFiles="@(_BuildStaticWebAssetsPreserveNewest->'%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <Target Name="_BuildCopyStaticWebAssetsAlways" AfterTargets="_SplitStaticWebAssetsByCopyOptions">
    <Copy SourceFiles="@(_BuildStaticWebAssetsCopyAlways)" DestinationFiles="@(_BuildStaticWebAssetsCopyAlways->'%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <Target Name="WriteStaticWebAssetsUpToDateCheck" DependsOnTargets="_BuildCopyStaticWebAssetsPreserveNewest;_BuildCopyStaticWebAssetsAlways">
    <ItemGroup>
      <_UpToDateCheckStaticWebAssetCandidate Include="@(StaticWebAsset)" Condition="'%(SourceType)' == 'Discovered'" />
    </ItemGroup>
    <ComputeReferenceStaticWebAssetItems Assets="@(_UpToDateCheckStaticWebAssetCandidate)" Patterns="@(DiscoveryPattern)" ProjectMode="$(StaticWebAssetProjectMode)" AssetKind="Build" Source="$(PackageId)">
      <Output TaskParameter="StaticWebAssets" ItemName="_UpToDateCheckStaticWebAssetResolved" />
    </ComputeReferenceStaticWebAssetItems>
    <ItemGroup>
      <_UpToDateCheckStaticWebAssetResolvedCandidate Include="@(_UpToDateCheckStaticWebAssetResolved->'%(OriginalItemSpec)')" />
      <_UpToDateCheckStaticWebAsset Include="@(_UpToDateCheckStaticWebAssetResolvedCandidate-&gt;Distinct())" />
    </ItemGroup>
    <WriteLinesToFile File="$(StaticWebAssetUpToDateCheckManifestPath)" Lines="@(_UpToDateCheckStaticWebAsset)" Overwrite="true" WriteOnlyWhenDifferent="true" Condition="'@(_UpToDateCheckStaticWebAsset)' != ''" />
    <ItemGroup>
      <FileWrites Include="$(StaticWebAssetUpToDateCheckManifestPath)" />
    </ItemGroup>
  </Target>
  <Target Name="AddStaticWebAssetsManifest" DependsOnTargets="ResolveStaticWebAssetsConfiguration">
    <ItemGroup>
      <ContentWithTargetPath Condition="Exists('$(StaticWebAssetDevelopmentManifestPath)')" Include="$(StaticWebAssetDevelopmentManifestPath)" TargetPath="$(TargetName).staticwebassets.runtime.json" CopyToOutputDirectory="PreserveNewest" CopyToPublishDirectory="Never" />
    </ItemGroup>
  </Target>
  <Target Name="AddStaticWebAssetEndpointsBuildManifest" DependsOnTargets="ResolveStaticWebAssetsConfiguration">
    <ItemGroup>
      <ContentWithTargetPath Condition="Exists('$(StaticWebAssetEndpointsBuildManifestPath)')" Include="$(StaticWebAssetEndpointsBuildManifestPath)" TargetPath="$(TargetName).staticwebassets.endpoints.json" CopyToOutputDirectory="PreserveNewest" CopyToPublishDirectory="Never" />
    </ItemGroup>
  </Target>
  <Target Name="StaticWebAssetsPrepareForRun" DependsOnTargets="$(StaticWebAssetsPrepareForRunDependsOn)" />
  <!-- Invoked by VS to re-generate scoped css bundle during hot reload -->
  <Target Name="UpdateStaticWebAssetsDesignTime" DependsOnTargets="ResolveReferencedProjectsStaticWebAssets;GenerateComputedBuildStaticWebAssets" />
  <Target Name="GenerateComputedBuildStaticWebAssets" DependsOnTargets="$(GenerateComputedBuildStaticWebAssetsDependsOn)" />
  <Target Name="GenerateStaticWebAssetsManifest" DependsOnTargets="$(GenerateStaticWebAssetsManifestDependsOn)">
    <MergeStaticWebAssets Condition="'@(StaticWebAssetsEmbeddedConfiguration)' != ''" CandidateAssets="@(StaticWebAsset)" CandidateDiscoveryPatterns="@(StaticWebAssetDiscoveryPattern)" MergeTarget="@(StaticWebAssetMergeTarget)">
      <Output TaskParameter="MergedAssets" ItemName="_MergedStaticWebAsset" />
      <Output TaskParameter="MergedDiscoveryPatterns" ItemName="_MergedStaticWebAssetDiscoveryPattern" />
    </MergeStaticWebAssets>
    <ItemGroup Condition="'@(StaticWebAssetsEmbeddedConfiguration)' != ''">
      <StaticWebAsset Remove="@(StaticWebAsset)" />
      <StaticWebAsset Include="@(_MergedStaticWebAsset)" />
      <StaticWebAssetDiscoveryPattern Remove="@(StaticWebAssetDiscoveryPattern)" />
      <StaticWebAssetDiscoveryPattern Include="@(_MergedStaticWebAssetDiscoveryPattern)" />
    </ItemGroup>
    <GenerateStaticWebAssetsManifest Source="$(PackageId)" BasePath="$(StaticWebAssetBasePath)" Mode="$(StaticWebAssetProjectMode)" ManifestType="Build" ReferencedProjectsConfigurations="@(StaticWebAssetProjectConfiguration)" DiscoveryPatterns="@(StaticWebAssetDiscoveryPattern)" Assets="@(StaticWebAsset)" Endpoints="@(StaticWebAssetEndpoint)" ManifestPath="$(StaticWebAssetBuildManifestPath)" ManifestCacheFilePath="$(StaticWebAssetsBuildManifestCacheFilePath)" />
    <GenerateStaticWebAssetEndpointsManifest Source="$(PackageId)" ManifestType="Build" Assets="@(StaticWebAsset)" Endpoints="@(StaticWebAssetEndpoint)" ManifestPath="$(StaticWebAssetEndpointsBuildManifestPath)" CacheFilePath="$(StaticWebAssetBuildManifestPath)" />
    <GenerateStaticWebAssetsDevelopmentManifest DiscoveryPatterns="@(StaticWebAssetDiscoveryPattern)" Assets="@(StaticWebAsset)" Source="$(PackageId)" ManifestPath="$(StaticWebAssetDevelopmentManifestPath)" CacheFilePath="$(StaticWebAssetBuildManifestPath)" />
    <ItemGroup>
      <_CachedBuildStaticWebAssets Condition="'@(_CachedBuildStaticWebAssets)' == ''" Include="@(StaticWebAsset)" />
      <_CachedBuildStaticWebAssetEndpoints Condition="'@(_CachedBuildStaticWebAssetEndpoints)' == ''" Include="@(StaticWebAssetEndpoint)" />
      <_CachedBuildStaticWebAssetReferencedProjectsConfiguration Condition="'@(_CachedBuildStaticWebAssetReferencedProjectsConfiguration)' == ''" Include="@(StaticWebAssetProjectConfiguration)" />
      <_CachedBuildStaticWebAssetDiscoveryPatterns Condition="'@(_CachedBuildStaticWebAssetDiscoveryPatterns)' == ''" Include="@(StaticWebAssetDiscoveryPattern)" />
    </ItemGroup>
    <ItemGroup>
      <FileWrites Include="$(StaticWebAssetBuildManifestPath)" />
      <FileWrites Include="$(StaticWebAssetsBuildManifestCacheFilePath)" />
      <FileWrites Include="$(StaticWebAssetDevelopmentManifestPath)" />
      <FileWrites Include="$(StaticWebAssetEndpointsBuildManifestPath)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveCoreStaticWebAssets" DependsOnTargets="$(ResolveCoreStaticWebAssetsDependsOn)" />
  <Target Name="ResolveStaticWebAssetsInputs" DependsOnTargets="$(ResolveStaticWebAssetsInputsDependsOn)" />
  <Target Name="ResolveBuildRelatedStaticWebAssets" DependsOnTargets="$(ResolveBuildRelatedStaticWebAssetsDependsOn)" />
  <Target Name="ResolveBuildStaticWebAssets" DependsOnTargets="ResolveCoreStaticWebAssets;ResolveStaticWebAssetsInputs;ResolveBuildRelatedStaticWebAssets" />
  <Target Name="ResolveProjectStaticWebAssets" Condition="'$(NoBuild)' != 'true'" BeforeTargets="AssignTargetPaths" DependsOnTargets="ResolveStaticWebAssetsConfiguration;UpdateExistingPackageStaticWebAssets">
    <PropertyGroup>
      <_ResolveProjectStaticWebAssetsCachePath Condition="'$(StaticWebAssetsCacheDefineStaticWebAssetsEnabled)' == 'true'">$(_StaticWebAssetsManifestBase)rpswa.dswa.cache.json</_ResolveProjectStaticWebAssetsCachePath>
    </PropertyGroup>
    <DefineStaticWebAssets CandidateAssets="@(Content-&gt;Distinct())" FingerprintCandidates="$(StaticWebAssetsFingerprintContent)" FingerprintPatterns="@(StaticWebAssetFingerprintPattern)" RelativePathPattern="wwwroot/**" SourceType="Discovered" SourceId="$(PackageId)" ContentRoot="$(MSBuildProjectDirectory)\wwwroot\" BasePath="$(StaticWebAssetBasePath)" AssetMergeSource="$(StaticWebAssetMergeTarget)" CacheManifestPath="$(_ResolveProjectStaticWebAssetsCachePath)">
      <Output TaskParameter="Assets" ItemName="StaticWebAsset" />
      <Output TaskParameter="Assets" ItemName="_CurrentProjectStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_CurrentProjectStaticWebAsset)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="StaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAssetDiscoveryPattern Include="$(PackageId)\wwwroot" Condition="Exists('$(MSBuildProjectDirectory)\wwwroot')">
        <Source>$(PackageId)</Source>
        <BasePath>$(StaticWebAssetBasePath)</BasePath>
        <ContentRoot>$(MSBuildProjectDirectory)\wwwroot\</ContentRoot>
        <Pattern>**</Pattern>
      </StaticWebAssetDiscoveryPattern>
      <Content Remove="@(StaticWebAsset)" />
      <FileWrites Include="$(_ResolveProjectStaticWebAssetsCachePath)" />
    </ItemGroup>
  </Target>
  <Target Name="UpdateExistingPackageStaticWebAssets">
    <UpdatePackageStaticWebAssets Assets="@(StaticWebAsset)">
      <Output TaskParameter="UpdatedAssets" ItemName="_UpdatedPackageAssets" />
      <Output TaskParameter="OriginalAssets" ItemName="_OriginalPackageAssets" />
    </UpdatePackageStaticWebAssets>
    <ItemGroup>
      <_AssetsWithoutEndpoints Include="@(_UpdatedPackageAssets)" Exclude="@(StaticWebAssetEndpoint->'%(AssetFile)')" />
    </ItemGroup>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_AssetsWithoutEndpoints)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_UpdatedPackageAssetsEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Remove="@(_OriginalPackageAssets)" />
      <StaticWebAsset Include="@(_UpdatedPackageAssets)" />
      <StaticWebAssetEndpoint Include="@(_UpdatedPackageAssetsEndpoint)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.Publish.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.Publish.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <Target Name="StaticWebAssetsPrepareForPublish" BeforeTargets="ComputeFilesToPublish" DependsOnTargets="$(StaticWebAssetsPrepareForPublishDependsOn)" />
  <Target Name="GenerateComputedPublishStaticWebAssets" DependsOnTargets="$(GenerateComputedPublishStaticWebAssetsDependsOn)" />
  <Target Name="GenerateStaticWebAssetsPublishManifest" DependsOnTargets="$(GenerateStaticWebAssetsPublishManifestDependsOn)">
    <ItemGroup>
      <_FinalPublishStaticWebAsset Include="@(StaticWebAsset)" Condition="'%(StaticWebAsset.AssetKind)' != 'Build'" />
    </ItemGroup>
    <GenerateStaticWebAssetsManifest Source="$(PackageId)" BasePath="$(StaticWebAssetBasePath)" Mode="$(StaticWebAssetProjectMode)" ManifestType="Publish" ReferencedProjectsConfigurations="@(StaticWebAssetProjectConfiguration)" DiscoveryPatterns="@(StaticWebAssetDiscoveryPattern)" Assets="@(_FinalPublishStaticWebAsset)" Endpoints="@(StaticWebAssetEndpoint)" ManifestPath="$(StaticWebAssetPublishManifestPath)" />
    <GenerateStaticWebAssetEndpointsManifest Source="$(PackageId)" ManifestType="Publish" Assets="@(_FinalPublishStaticWebAsset)" Endpoints="@(StaticWebAssetEndpoint)" ManifestPath="$(StaticWebAssetEndpointsPublishManifestPath)" />
    <ItemGroup>
      <FileWrites Include="$(StaticWebAssetPublishManifestPath)" />
      <FileWrites Include="$(StaticWebAssetEndpointsPublishManifestPath)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveCorePublishStaticWebAssets" DependsOnTargets="$(ResolveCorePublishStaticWebAssetsDependsOn)" />
  <Target Name="ResolvePublishStaticWebAssets" DependsOnTargets="$(ResolvePublishStaticWebAssetsDependsOn)" />
  <Target Name="ResolvePublishRelatedStaticWebAssets" DependsOnTargets="$(ResolvePublishRelatedStaticWebAssetsDependsOn)" />
  <Target Name="ResolveAllPublishStaticWebAssets" DependsOnTargets="ResolveCorePublishStaticWebAssets;ResolvePublishStaticWebAssets;ResolvePublishRelatedStaticWebAssets" />
  <Target Name="LoadStaticWebAssetsBuildManifest" BeforeTargets="ComputeResolvedFilesToPublishList">
    <!-- Before we load assets from the manifest we cleanup any potential existing asset that might be present by default
         for example, assets from packages as a result of a publish (no-build) invocation. Those assets were already taken
         into account when we built the build manifest that we are about to load for resuming the publish process. -->
    <PropertyGroup>
      <_HasStaticWebAssetsProjectReferences Condition="@(ProjectReference) != ''">true</_HasStaticWebAssetsProjectReferences>
      <_HasCachedBuildStaticWebAssets Condition="@(_CachedBuildStaticWebAssets) == ''">false</_HasCachedBuildStaticWebAssets>
      <_HasCachedBuildStaticWebAssetEndpoints Condition="@(_CachedBuildStaticWebAssetEndpoints) == ''">false</_HasCachedBuildStaticWebAssetEndpoints>
      <_HasCachedBuildStaticWebAssetDiscoveryPatterns Condition="@(_CachedBuildStaticWebAssetDiscoveryPatterns) == ''">false</_HasCachedBuildStaticWebAssetDiscoveryPatterns>
      <_HasCachedBuildStaticWebAssetReferencedProjectsConfiguration Condition="@(_CachedBuildStaticWebAssetReferencedProjectsConfiguration) == ''">false</_HasCachedBuildStaticWebAssetReferencedProjectsConfiguration>
      <_ShouldLoadBuildManifestAndUpdateAssets>false</_ShouldLoadBuildManifestAndUpdateAssets>
      <_ShouldLoadBuildManifestAndUpdateAssets Condition="'$(_HasCachedBuildStaticWebAssets)' == 'false' or&#xA;        '$(_HasCachedBuildStaticWebAssetEndpoints)' == 'false' or&#xA;        '$(_HasCachedBuildStaticWebAssetDiscoveryPatterns)' == 'false' or&#xA;        ('$(_HasStaticWebAssetsProjectReferences)' == 'true' and '$(_HasCachedBuildStaticWebAssetReferencedProjectsConfiguration)' == 'false')">true</_ShouldLoadBuildManifestAndUpdateAssets>
    </PropertyGroup>
    <ItemGroup>
      <StaticWebAsset Remove="@(StaticWebAsset)" />
      <StaticWebAssetEndpoint Remove="@(StaticWebAssetEndpoint)" />
      <StaticWebAssetDiscoveryPattern Remove="@(StaticWebAssetDiscoveryPattern)" />
      <StaticWebAssetProjectConfiguration Remove="@(StaticWebAssetProjectConfiguration)" />
      <_CachedBuildStaticWebAssets Condition="'$(_ShouldLoadBuildManifestAndUpdateAssets)' == 'true'" Remove="@(_CachedBuildStaticWebAssets)" />
      <_CachedBuildStaticWebAssetEndpoints Condition="'$(_ShouldLoadBuildManifestAndUpdateAssets)' == 'true'" Remove="@(_CachedBuildStaticWebAssetEndpoints)" />
      <_CachedBuildStaticWebAssetDiscoveryPatterns Condition="'$(_ShouldLoadBuildManifestAndUpdateAssets)' == 'true'" Remove="@(_CachedBuildStaticWebAssetDiscoveryPatterns)" />
      <_CachedBuildStaticWebAssetReferencedProjectsConfiguration Condition="'$(_ShouldLoadBuildManifestAndUpdateAssets)' == 'true'" Remove="@(_CachedBuildStaticWebAssetReferencedProjectsConfiguration)" />
    </ItemGroup>
    <ReadStaticWebAssetsManifestFile ManifestPath="$(StaticWebAssetBuildManifestPath)" Condition="'$(_ShouldLoadBuildManifestAndUpdateAssets)' == 'true'">
      <Output TaskParameter="Assets" ItemName="_CachedBuildStaticWebAssets" />
      <Output TaskParameter="Endpoints" ItemName="_CachedBuildStaticWebAssetEndpoints" />
      <Output TaskParameter="DiscoveryPatterns" ItemName="_CachedBuildStaticWebAssetDiscoveryPatterns" />
      <Output TaskParameter="ReferencedProjectsConfiguration" ItemName="_CachedBuildStaticWebAssetReferencedProjectsConfiguration" />
    </ReadStaticWebAssetsManifestFile>
    <ItemGroup>
      <Content Remove="@(_CachedBuildStaticWebAssets->'%(OriginalItemSpec)')" />
      <None Remove="@(_CachedBuildStaticWebAssets->'%(OriginalItemSpec)')" />
      <ResolvedFileToPublish Remove="@(_CachedBuildStaticWebAssets->'%(OriginalItemSpec)')" />
      <ResolvedFileToPublish Remove="@(_CachedBuildStaticWebAssets)" />
    </ItemGroup>
    <ItemGroup>
      <StaticWebAsset Include="@(_CachedBuildStaticWebAssets)" />
      <StaticWebAssetEndpoint Include="@(_CachedBuildStaticWebAssetEndpoints)" />
      <StaticWebAssetDiscoveryPattern Include="@(_CachedBuildStaticWebAssetDiscoveryPatterns)" />
      <StaticWebAssetProjectConfiguration Include="@(_CachedBuildStaticWebAssetReferencedProjectsConfiguration)" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeReferencedStaticWebAssetsPublishManifest" DependsOnTargets="$(ComputeReferencedStaticWebAssetsPublishManifestDependsOn)" />
  <Target Name="ComputeReferencedProjectsPublishAssets" DependsOnTargets="LoadStaticWebAssetsBuildManifest">
    <ItemGroup>
      <_ProjectConfigurationsWithPublishTargets Include="@(StaticWebAssetProjectConfiguration)" Condition="'%(StaticWebAssetProjectConfiguration.GetPublishAssetsTargets)' != ''" />
    </ItemGroup>
    <PropertyGroup>
      <_HasProjectsWithStaticWebAssetPublishTargets>false</_HasProjectsWithStaticWebAssetPublishTargets>
      <_HasProjectsWithStaticWebAssetPublishTargets Condition="'@(_ProjectConfigurationsWithPublishTargets)' != ''">true</_HasProjectsWithStaticWebAssetPublishTargets>
    </PropertyGroup>
    <MSBuild Condition="$(_HasProjectsWithStaticWebAssetPublishTargets)" Targets="%(_ProjectConfigurationsWithPublishTargets.GetPublishAssetsTargets)" Properties="%(_ProjectConfigurationsWithPublishTargets.AdditionalPublishProperties)" RemoveProperties="%(_ProjectConfigurationsWithPublishTargets.AdditionalPublishPropertiesToRemove);$(_GlobalPropertiesToRemoveFromProjectReferences)" Projects="@(_ProjectConfigurationsWithPublishTargets)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="false">
      <Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectPublishStaticWebAssetsItems" />
    </MSBuild>
    <ItemGroup>
      <_ReferencedProjectPublishStaticWebAssetsUpdateCandidates Include="@(_ReferencedProjectPublishStaticWebAssetsItems)" Condition="'%(_ReferencedProjectPublishStaticWebAssetsItems.ResultType)' == 'StaticWebAsset'" />
      <_ReferencedProjectPublishStaticWebAssetEndpointsUpdateCandidates Include="@(_ReferencedProjectPublishStaticWebAssetsItems)" Condition="'%(_ReferencedProjectPublishStaticWebAssetsItems.ResultType)' == 'StaticWebAssetEndpoint'" />
    </ItemGroup>
    <UpdateExternallyDefinedStaticWebAssets Condition="$(_HasProjectsWithStaticWebAssetPublishTargets)" Assets="@(_ReferencedProjectPublishStaticWebAssetsUpdateCandidates)" Endpoints="@(_ReferencedProjectPublishStaticWebAssetEndpointsUpdateCandidates)" FingerprintInferenceExpressions="@(StaticWebAssetFingerprintInferenceExpression)">
      <Output TaskParameter="UpdatedAssets" ItemName="_ReferencedProjectPublishStaticWebAssets" />
      <Output TaskParameter="UpdatedEndpoints" ItemName="_ReferencedProjectPublishStaticWebAssetEndpoints" />
      <Output TaskParameter="AssetsWithoutEndpoints" ItemName="_ReferencedProjectPublishStaticWebAssetsWithoutEndpoints" />
    </UpdateExternallyDefinedStaticWebAssets>
    <DefineStaticWebAssetEndpoints Condition="'@(_ReferencedProjectPublishStaticWebAssetsWithoutEndpoints)' != ''" CandidateAssets="@(_ReferencedProjectPublishStaticWebAssetsWithoutEndpoints)" ExistingEndpoints="" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_ReferencedProjectPublishStaticWebAssetEndpoints" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup Condition="$(_HasProjectsWithStaticWebAssetPublishTargets)">
      <StaticWebAsset Remove="@(_ReferencedProjectPublishStaticWebAssets)" />
      <StaticWebAsset Include="@(_ReferencedProjectPublishStaticWebAssets)" />
      <StaticWebAssetEndpoint Remove="@(_ReferencedProjectPublishStaticWebAssetEndpoints)" />
      <StaticWebAssetEndpoint Include="@(_ReferencedProjectPublishStaticWebAssetEndpoints)" />
    </ItemGroup>
  </Target>
  <Target Name="CopyStaticWebAssetsToPublishDirectory" BeforeTargets="ComputeAndCopyFilesToPublishDirectory" DependsOnTargets="$(CopyStaticWebAssetsToPublishDirectoryDependsOn)" />
  <Target Name="_SplitPublishStaticWebAssetsByCopyOptions" AfterTargets="CopyStaticWebAssetsToPublishDirectory">
    <PropertyGroup>
      <_StaticWebAssetsPublishPathPrefix>wwwroot</_StaticWebAssetsPublishPathPrefix>
      <_StaticWebAssetsPublishPathPrefix Condition="'$(StaticWebAssetProjectMode)' == 'Root'">wwwroot/$(StaticWebAssetBasePath)</_StaticWebAssetsPublishPathPrefix>
    </PropertyGroup>
    <ComputeStaticWebAssetsForCurrentProject Assets="@(StaticWebAsset)" ProjectMode="$(StaticWebAssetProjectMode)" AssetKind="Publish" Source="$(PackageId)">
      <Output TaskParameter="StaticWebAssets" ItemName="_StaticWebAssetsToPublish" />
    </ComputeStaticWebAssetsForCurrentProject>
    <ComputeStaticWebAssetsTargetPaths Assets="@(_StaticWebAssetsToPublish)" PathPrefix="$(_StaticWebAssetsPublishPathPrefix)">
      <Output TaskParameter="AssetsWithTargetPath" ItemName="_PublishStaticWebAssetsTargetPath" />
    </ComputeStaticWebAssetsTargetPaths>
    <ItemGroup>
      <_PublishStaticWebAssetsCopyAlways Include="@(_PublishStaticWebAssetsTargetPath)" Condition="'%(CopyToPublishDirectory)' == 'Always'" />
      <_PublishStaticWebAssetsPreserveNewest Include="@(_PublishStaticWebAssetsTargetPath)" Condition="'%(CopyToPublishDirectory)' == 'PreserveNewest'" />
    </ItemGroup>
  </Target>
  <Target Name="_PublishCopyStaticWebAssetsPreserveNewest" Inputs="@(_PublishStaticWebAssetsPreserveNewest)" Outputs="@(_PublishStaticWebAssetsPreserveNewest->'$(PublishDir)%(TargetPath)')" AfterTargets="_SplitPublishStaticWebAssetsByCopyOptions">
    <Copy SourceFiles="@(_PublishStaticWebAssetsPreserveNewest)" DestinationFiles="@(_PublishStaticWebAssetsPreserveNewest->'$(PublishDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <Target Name="_PublishCopyStaticWebAssetsAlways" AfterTargets="_SplitPublishStaticWebAssetsByCopyOptions">
    <Copy SourceFiles="@(_PublishStaticWebAssetsCopyAlways)" DestinationFiles="@(_PublishStaticWebAssetsCopyAlways->'$(PublishDir)%(TargetPath)')" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <Target Name="CopyStaticWebAssetsEndpointsManifest" DependsOnTargets="GenerateStaticWebAssetsPublishManifest" AfterTargets="CopyStaticWebAssetsToPublishDirectory">
    <Copy Condition="Exists('$(StaticWebAssetEndpointsPublishManifestPath)')" SourceFiles="$(StaticWebAssetEndpointsPublishManifestPath)" DestinationFiles="$(PublishDir)$(TargetName).staticwebassets.endpoints.json" OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)" Retries="$(CopyRetryCount)" RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)" UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)" UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>
  </Target>
  <Target Name="LoadStaticWebAssetsPublishManifest">
    <PropertyGroup>
      <_ShouldLoadPublishManifestAndUpdateAssets>false</_ShouldLoadPublishManifestAndUpdateAssets>
      <_ShouldLoadPublishManifestAndUpdateAssets Condition="@(_CachedPublishStaticWebAssets) == '' and @(_CachedPublishStaticWebAssetEndpoints) == '' and @(_CachedPublishStaticWebAssetDiscoveryPatterns) == ''">true</_ShouldLoadPublishManifestAndUpdateAssets>
    </PropertyGroup>
    <ItemGroup>
      <StaticWebAsset Remove="@(StaticWebAsset)" />
      <StaticWebAssetEndpoint Remove="@(StaticWebAssetEndpoint)" />
      <StaticWebAssetDiscoveryPattern Remove="@(StaticWebAssetDiscoveryPattern)" />
    </ItemGroup>
    <ReadStaticWebAssetsManifestFile ManifestPath="$(StaticWebAssetPublishManifestPath)" Condition="'$(_ShouldLoadPublishManifestAndUpdateAssets)' == 'true'">
      <Output TaskParameter="Assets" ItemName="_CachedPublishStaticWebAssets" />
      <Output TaskParameter="Endpoints" ItemName="_CachedPublishStaticWebAssetEndpoints" />
      <Output TaskParameter="DiscoveryPatterns" ItemName="_CachedPublishStaticWebAssetDiscoveryPatterns" />
    </ReadStaticWebAssetsManifestFile>
    <ItemGroup>
      <Content Remove="@(_CachedPublishStaticWebAssets->'%(OriginalItemSpec)')" />
      <None Remove="@(_CachedPublishStaticWebAssets->'%(OriginalItemSpec)')" />
      <ResolvedFileToPublish Remove="@(_CachedPublishStaticWebAssets->'%(OriginalItemSpec)')" />
      <ResolvedFileToPublish Remove="@(_CachedPublishStaticWebAssets)" />
    </ItemGroup>
    <ItemGroup>
      <StaticWebAsset Include="@(_CachedPublishStaticWebAssets)" />
      <StaticWebAssetEndpoint Include="@(_CachedPublishStaticWebAssetEndpoints)" />
      <StaticWebAssetDiscoveryPattern Remove="@(_CachedPublishStaticWebAssetDiscoveryPatterns)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.References.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.References.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <Target Name="_CleanupReferencedProjectItemGroups" BeforeTargets="GetCopyToPublishDirectoryItems" DependsOnTargets="ResolveStaticWebAssetsConfiguration">
    <ReadStaticWebAssetsManifestFile ManifestPath="$(StaticWebAssetBuildManifestPath)">
      <Output TaskParameter="Assets" ItemName="_CleanupStaticWebAsset" />
    </ReadStaticWebAssetsManifestFile>
    <ItemGroup>
      <Content Remove="@(_CleanupStaticWebAsset->'%(OriginalItemSpec)')" />
      <ContentWithTargetPath Remove="@(_CleanupStaticWebAsset->'%(OriginalItemSpec)')" />
      <None Remove="@(_CleanupStaticWebAsset->'%(OriginalItemSpec)')" />
      <_NoneWithTargetPath Remove="@(_CleanupStaticWebAsset->'%(OriginalItemSpec)')" />
      <ResolvedFileToPublish Remove="@(_CleanupStaticWebAsset->'%(OriginalItemSpec)')" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveReferencedProjectsStaticWebAssetsConfiguration" DependsOnTargets="ResolveStaticWebAssetsConfiguration;PrepareProjectReferences">
    <ItemGroup>
      <!-- It is explicitly ok to take a dependency on _MSBuildProjectReferenceExistent as it is
        something many other products already take a dependency on. -->
      <_StaticWebAssetProjectReference Include="@(_MSBuildProjectReferenceExistent)" Condition="'%(BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != ''" />
    </ItemGroup>
    <MSBuild Condition="'@(_StaticWebAssetProjectReference)' != ''" Targets="GetStaticWebAssetsProjectConfiguration" Properties="%(_StaticWebAssetProjectReference.SetConfiguration);%(_StaticWebAssetProjectReference.SetPlatform);%(_StaticWebAssetProjectReference.SetTargetFramework)" RemoveProperties="%(_StaticWebAssetProjectReference.GlobalPropertiesToRemove);$(_GlobalPropertiesToRemoveFromProjectReferences)" Projects="@(_StaticWebAssetProjectReference)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectsConfiguration" />
    </MSBuild>
    <ItemGroup Condition="'$(BuildingInsideVisualStudio)' == 'true'">
      <_ReferenceManifestPath Include="@(_ReferencedProjectsConfiguration->'%(BuildManifestPath)')" Condition="'%(_ReferencedProjectsConfiguration.BuildManifestPath)' != ''" />
    </ItemGroup>
    <WriteLinesToFile Condition="'$(BuildingInsideVisualStudio)' == 'true'" File="$(StaticWebAssetReferencesUpToDateCheckManifestPath)" Lines="@(_ReferenceManifestPath)" Overwrite="false" WriteOnlyWhenDifferent="true" />
    <MergeConfigurationProperties CandidateConfigurations="@(_ReferencedProjectsConfiguration)" ProjectReferences="@(_StaticWebAssetProjectReference)">
      <Output TaskParameter="ProjectConfigurations" ItemName="StaticWebAssetProjectConfiguration" />
    </MergeConfigurationProperties>
  </Target>
  <!--
    The static web asset configuration defines the following metadata:
    Version: Version of the contract supported by this project, it can be 1 or 2.
    Source: The package id of the project.
    GetBuildAssetsTargets: The targets to run to get the build assets.
    GetPublishAssetsTargets: The targets to run to get the publish assets.
    AdditionalBuildProperties: Additional properties to pass to the build assets targets.
    AdditionalBuildPropertiesToRemove: Additional properties to remove from the build assets targets.
    AdditionalPublishProperties: Additional properties to pass to the publish assets targets.
    AdditionalPublishPropertiesToRemove: Additional properties to remove from the publish assets targets.
    TargetFramework: The target framework associated with the current configuration.
  -->
  <Target Name="GetStaticWebAssetsProjectConfiguration" Returns="@(_StaticWebAssetThisProjectConfiguration)" DependsOnTargets="ResolveStaticWebAssetsConfiguration">
    <PropertyGroup>
      <StaticWebAssetsGetPublishAssetsTargets Condition="'$(StaticWebAssetsGetPublishAssetsTargets)' == ''">ComputeReferencedStaticWebAssetsPublishManifest;GetCurrentProjectPublishStaticWebAssetItems</StaticWebAssetsGetPublishAssetsTargets>
      <StaticWebAssetsGetBuildAssetsTargets Condition="'$(StaticWebAssetsGetBuildAssetsTargets)' == ''">GetCurrentProjectBuildStaticWebAssetItems</StaticWebAssetsGetBuildAssetsTargets>
    </PropertyGroup>
    <ItemGroup>
      <_StaticWebAssetThisProjectConfiguration Include="$(MSBuildProjectFullPath)">
        <Version>2</Version>
        <Source>$(PackageId)</Source>
        <TargetFramework>$(TargetFramework)</TargetFramework>
        <!-- Build -->
        <GetBuildAssetsTargets>$(StaticWebAssetsGetBuildAssetsTargets)</GetBuildAssetsTargets>
        <AdditionalBuildProperties>$(StaticWebAssetsAdditionalBuildProperties)</AdditionalBuildProperties>
        <AdditionalBuildPropertiesToRemove>$(StaticWebAssetsAdditionalBuildPropertiesToRemove)</AdditionalBuildPropertiesToRemove>
        <!-- Publish -->
        <GetPublishAssetsTargets>$(StaticWebAssetsGetPublishAssetsTargets)</GetPublishAssetsTargets>
        <AdditionalPublishProperties>$(StaticWebAssetsAdditionalPublishProperties)</AdditionalPublishProperties>
        <AdditionalPublishPropertiesToRemove>$(StaticWebAssetsAdditionalPublishPropertiesToRemove)</AdditionalPublishPropertiesToRemove>
        <!-- Build manifest -->
        <BuildManifestPath>$([System.IO.Path]::GetFullPath('$(StaticWebAssetBuildManifestPath)'))</BuildManifestPath>
      </_StaticWebAssetThisProjectConfiguration>
    </ItemGroup>
  </Target>
  <Target Name="ResolveReferencedProjectsStaticWebAssets" DependsOnTargets="ResolveReferencedProjectsStaticWebAssetsConfiguration">
    <MSBuild Condition="'@(StaticWebAssetProjectConfiguration)' != ''" Targets="%(StaticWebAssetProjectConfiguration.GetBuildAssetsTargets)" Properties="%(StaticWebAssetProjectConfiguration.AdditionalBuildProperties)" RemoveProperties="%(StaticWebAssetProjectConfiguration.AdditionalBuildPropertiesToRemove);$(_GlobalPropertiesToRemoveFromProjectReferences)" Projects="@(StaticWebAssetProjectConfiguration)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="false">
      <Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectBuildStaticWebAssetsItems" />
    </MSBuild>
    <ItemGroup>
      <_ResolvedReferencedProjectBuildStaticWebAssetCandidates Include="@(_ReferencedProjectBuildStaticWebAssetsItems)" Condition="'%(_ReferencedProjectBuildStaticWebAssetsItems.ResultType)' == 'StaticWebAsset'" KeepMetadata="@(_StaticWebAssetCanonicalMetadata)" />
      <_ReferencedProjectBuildStaticWebAssetEndpointsUpdateCandidates Include="@(_ReferencedProjectBuildStaticWebAssetsItems)" Condition="'%(_ReferencedProjectBuildStaticWebAssetsItems.ResultType)' == 'StaticWebAssetEndpoint'" KeepMetadata="@(_StaticWebAssetEndpointCanonicalMetadata)" />
    </ItemGroup>
    <UpdateExternallyDefinedStaticWebAssets Condition="@(_ResolvedReferencedProjectBuildStaticWebAssetCandidates) != ''" Assets="@(_ResolvedReferencedProjectBuildStaticWebAssetCandidates)" Endpoints="@(_ReferencedProjectBuildStaticWebAssetEndpointsUpdateCandidates)" FingerprintInferenceExpressions="@(StaticWebAssetFingerprintInferenceExpression)">
      <Output TaskParameter="UpdatedAssets" ItemName="_ResolvedReferencedProjectBuildStaticWebAssets" />
      <Output TaskParameter="UpdatedEndpoints" ItemName="_ResolvedReferencedProjectBuildStaticWebAssetEndpoints" />
      <Output TaskParameter="AssetsWithoutEndpoints" ItemName="_ReferencedProjectBuildStaticWebAssetsWithoutEndpoints" />
    </UpdateExternallyDefinedStaticWebAssets>
    <DefineStaticWebAssetEndpoints Condition="'@(_ReferencedProjectBuildStaticWebAssetsWithoutEndpoints)' != ''" CandidateAssets="@(_ReferencedProjectBuildStaticWebAssetsWithoutEndpoints)" ExistingEndpoints="" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_ResolvedReferencedProjectBuildStaticWebAssetEndpoints" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Include="@(_ResolvedReferencedProjectBuildStaticWebAssets)" />
      <StaticWebAssetEndpoint Include="@(_ResolvedReferencedProjectBuildStaticWebAssetEndpoints)" />
      <StaticWebAssetDiscoveryPattern Include="@(_ReferencedProjectBuildStaticWebAssetsItems)" Condition="'%(_ReferencedProjectBuildStaticWebAssetsItems.ResultType)' == 'StaticWebAssetDiscoveryPattern'" KeepMetadata="@(_StaticWebAssetDiscoveryPatternCanonicalMetadata)" />
    </ItemGroup>
  </Target>
  <Target Name="GetCurrentProjectBuildStaticWebAssetItems" DependsOnTargets="ResolveStaticWebAssetsConfiguration" Returns="@(_CachedBuildStaticWebAssetItems)">
    <PropertyGroup>
      <_ShouldReadBuildManifestAndUpdateItemGroup>false</_ShouldReadBuildManifestAndUpdateItemGroup>
      <_ShouldReadBuildManifestAndUpdateItemGroup Condition="@(_CachedBuildStaticWebAssets) == '' and @(_CachedBuildStaticWebAssetEndpoints) == '' and @(_CachedBuildStaticWebAssetDiscoveryPatterns) == '' and @(_CachedBuildStaticWebAssetReferencedProjectsConfiguration) == ''">true</_ShouldReadBuildManifestAndUpdateItemGroup>
    </PropertyGroup>
    <ReadStaticWebAssetsManifestFile ManifestPath="$(StaticWebAssetBuildManifestPath)" Condition="'$(_ShouldReadBuildManifestAndUpdateItemGroup)' == 'true'">
      <Output TaskParameter="Assets" ItemName="_CachedBuildStaticWebAssets" />
      <Output TaskParameter="Endpoints" ItemName="_CachedBuildStaticWebAssetEndpoints" />
      <Output TaskParameter="DiscoveryPatterns" ItemName="_CachedBuildStaticWebAssetDiscoveryPatterns" />
      <Output TaskParameter="ReferencedProjectsConfiguration" ItemName="_CachedBuildStaticWebAssetReferencedProjectsConfiguration" />
    </ReadStaticWebAssetsManifestFile>
    <ComputeReferenceStaticWebAssetItems Assets="@(_CachedBuildStaticWebAssets)" Patterns="@(_CachedBuildStaticWebAssetDiscoveryPatterns)" ProjectMode="$(StaticWebAssetProjectMode)" AssetKind="Build" MakeReferencedAssetOriginalItemSpecAbsolute="$(StaticWebAssetMakeReferencedAssetOriginalItemSpecAbsolute)" Source="$(PackageId)">
      <Output TaskParameter="StaticWebAssets" ItemName="_CachedBuildReferencedStaticWebAsset" />
      <Output TaskParameter="DiscoveryPatterns" ItemName="_CachedBuildReferencedStaticWebAssetDiscoveryPatterns" />
    </ComputeReferenceStaticWebAssetItems>
    <ComputeEndpointsForReferenceStaticWebAssets Assets="@(_CachedBuildReferencedStaticWebAsset)" CandidateEndpoints="@(_CachedBuildStaticWebAssetEndpoints)">
      <Output TaskParameter="Endpoints" ItemName="_CachedBuildReferencedStaticWebAssetEndpoints" />
    </ComputeEndpointsForReferenceStaticWebAssets>
    <ItemGroup>
      <_CachedBuildStaticWebassetItems Include="@(_CachedBuildReferencedStaticWebAsset)">
        <ResultType>StaticWebAsset</ResultType>
      </_CachedBuildStaticWebassetItems>
      <_CachedBuildStaticWebassetItems Include="@(_CachedBuildReferencedStaticWebAssetDiscoveryPatterns)">
        <ResultType>StaticWebAssetDiscoveryPattern</ResultType>
      </_CachedBuildStaticWebassetItems>
      <_CachedBuildStaticWebassetItems Include="@(_CachedBuildReferencedStaticWebAssetEndpoints)">
        <ResultType>StaticWebAssetEndpoint</ResultType>
      </_CachedBuildStaticWebassetItems>
    </ItemGroup>
  </Target>
  <Target Name="GetCurrentProjectPublishStaticWebAssetItems" DependsOnTargets="ResolveStaticWebAssetsConfiguration" Returns="@(_CachedPublishStaticWebAssetItems)">
    <PropertyGroup>
      <_ShouldReadPublishManifestAndUpdateItemGroup>false</_ShouldReadPublishManifestAndUpdateItemGroup>
      <_ShouldReadPublishManifestAndUpdateItemGroup Condition="@(_CachedPublishStaticWebAssets) == '' and @(_CachedPublishStaticWebAssetEndpoints) == '' and @(_CachedPublishStaticWebAssetDiscoveryPatterns) == ''">true</_ShouldReadPublishManifestAndUpdateItemGroup>
    </PropertyGroup>
    <ReadStaticWebAssetsManifestFile ManifestPath="$(StaticWebAssetPublishManifestPath)" Condition="'$(_ShouldReadPublishManifestAndUpdateItemGroup)' == 'true'">
      <Output TaskParameter="Assets" ItemName="_CachedPublishStaticWebAssets" />
      <Output TaskParameter="Endpoints" ItemName="_CachedPublishStaticWebAssetEndpoints" />
      <Output TaskParameter="DiscoveryPatterns" ItemName="_CachedPublishStaticWebAssetDiscoveryPatterns" />
    </ReadStaticWebAssetsManifestFile>
    <ComputeReferenceStaticWebAssetItems Assets="@(_CachedPublishStaticWebAssets)" ProjectMode="$(StaticWebAssetProjectMode)" AssetKind="Publish" Source="$(PackageId)" MakeReferencedAssetOriginalItemSpecAbsolute="$(StaticWebAssetMakeReferencedAssetOriginalItemSpecAbsolute)">
      <Output TaskParameter="StaticWebAssets" ItemName="_CachedPublishReferencedStaticWebAsset" />
    </ComputeReferenceStaticWebAssetItems>
    <ComputeEndpointsForReferenceStaticWebAssets Assets="@(_CachedPublishReferencedStaticWebAsset)" CandidateEndpoints="@(_CachedPublishStaticWebAssetEndpoints)">
      <Output TaskParameter="Endpoints" ItemName="_CachedPublishReferencedStaticWebAssetEndpoints" />
    </ComputeEndpointsForReferenceStaticWebAssets>
    <ItemGroup>
      <_CachedPublishStaticWebassetItems Include="@(_CachedPublishReferencedStaticWebAsset)">
        <ResultType>StaticWebAsset</ResultType>
      </_CachedPublishStaticWebassetItems>
      <_CachedPublishStaticWebassetItems Include="@(_CachedPublishReferencedStaticWebAssetEndpoints)">
        <ResultType>StaticWebAssetEndpoint</ResultType>
      </_CachedPublishStaticWebassetItems>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.targets
============================================================================================================================================
-->
  <!--<Import Project="Microsoft.NET.Sdk.StaticWebAssets.Design.targets" Condition="'$(DesignTimeBuild)' == 'true' and '$(BuildingInsideVisualStudio)' == 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.EmbeddedAssets.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.EmbeddedAssets.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <Target Name="GetStaticWebAssetsCrosstargetingProjectConfiguration" Returns="@(_StaticWebAssetThisEmbeddedProjectConfiguration)" DependsOnTargets="ResolveStaticWebAssetsConfiguration">
    <PropertyGroup>
      <StaticWebAssetsGetEmbeddedPublishAssetsTargets Condition="'$(StaticWebAssetsGetEmbeddedPublishAssetsTargets)' == ''">ComputeReferencedStaticWebAssetsPublishManifest;GetCurrentProjectEmbeddedPublishStaticWebAssetItems</StaticWebAssetsGetEmbeddedPublishAssetsTargets>
      <StaticWebAssetsGetEmbeddedBuildAssetsTargets Condition="'$(StaticWebAssetsGetEmbeddedBuildAssetsTargets)' == ''">Build;GetCurrentProjectEmbeddedBuildStaticWebAssetItems</StaticWebAssetsGetEmbeddedBuildAssetsTargets>
      <GetReferencedEmbeddedAssetsProperties>$(GetReferencedEmbeddedAssetsProperties);TargetFramework=$(TargetFramework);ResolveEmbeddedStaticWebAssets=false</GetReferencedEmbeddedAssetsProperties>
      <StaticWebAssetsAdditionalEmbeddedBuildProperties>$(StaticWebAssetsAdditionalEmbeddedBuildProperties);TargetFramework=$(TargetFramework);ResolveEmbeddedStaticWebAssets=false</StaticWebAssetsAdditionalEmbeddedBuildProperties>
      <StaticWebAssetsAdditionalEmbeddedPublishProperties>$(StaticWebAssetsAdditionalEmbeddedPublishProperties);TargetFramework=$(TargetFramework);ResolveEmbeddedStaticWebAssets=false</StaticWebAssetsAdditionalEmbeddedPublishProperties>
    </PropertyGroup>
    <ItemGroup>
      <_StaticWebAssetThisEmbeddedProjectConfiguration Include="$(MSBuildProjectFullPath)">
        <Version>2</Version>
        <Source>$(PackageId)</Source>
        <TargetFramework>$(TargetFramework)</TargetFramework>
        <!-- Get embedded referenced assets properties -->
        <GetReferencedEmbeddedAssetsProperties>$(GetReferencedEmbeddedAssetsProperties)</GetReferencedEmbeddedAssetsProperties>
        <GetReferencedEmbeddedAssetsPropertiesToRemove>$(GetReferencedEmbeddedAssetsPropertiesToRemove)</GetReferencedEmbeddedAssetsPropertiesToRemove>
        <!-- Build -->
        <GetEmbeddedBuildAssetsTargets>$(StaticWebAssetsGetEmbeddedBuildAssetsTargets)</GetEmbeddedBuildAssetsTargets>
        <AdditionalEmbeddedBuildProperties>$(StaticWebAssetsAdditionalEmbeddedBuildProperties)</AdditionalEmbeddedBuildProperties>
        <AdditionalEmbeddedBuildPropertiesToRemove>$(StaticWebAssetsAdditionalEmbeddedBuildPropertiesToRemove)</AdditionalEmbeddedBuildPropertiesToRemove>
        <!-- Publish -->
        <GetEmbeddedPublishAssetsTargets>$(StaticWebAssetsGetEmbeddedPublishAssetsTargets)</GetEmbeddedPublishAssetsTargets>
        <AdditionalEmbeddedPublishProperties>$(StaticWebAssetsAdditionalEmbeddedPublishProperties)</AdditionalEmbeddedPublishProperties>
        <AdditionalEmbeddedPublishPropertiesToRemove>$(StaticWebAssetsAdditionalEmbeddedPublishPropertiesToRemove)</AdditionalEmbeddedPublishPropertiesToRemove>
      </_StaticWebAssetThisEmbeddedProjectConfiguration>
    </ItemGroup>
  </Target>
  <Target Name="ResolveStaticWebAssetsCrossTargetingConfiguration" Condition="'$(TargetFrameworks)' != '' And '@(StaticWebAssetsEmbeddedConfiguration)' != ''" Returns="@(_StaticWebAssetsEmbeddedProjectAssetConfigurations)">
    <!-- Call the outer build to resolve all the project configurations to this project. -->
    <MSBuild Targets="GetStaticWebAssetsCrossTargetingProjectConfiguration" Properties="Configuration=$(Configuration)" RemoveProperties="TargetFramework" Projects="$(MSBuildProjectFullPath)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="true">
      <Output TaskParameter="TargetOutputs" ItemName="_StaticWebAssetsCrossTargetingProjectConfiguration" />
    </MSBuild>
    <!-- Break down the target framework into its components. We do it here because we can't do it inside the task without
         referencing additional dlls, which is painful.
    -->
    <ItemGroup>
      <_ExtendedStaticWebAssetsCrossTargetingProjectConfiguration Include="@(_StaticWebAssetsCrossTargetingProjectConfiguration)">
        <TargetFrameworkIdentifier>$([MSBuild]::GetTargetFrameworkIdentifier('%(_StaticWebAssetsCrossTargetingProjectConfiguration.TargetFramework)'))</TargetFrameworkIdentifier>
        <TargetFrameworkVersion>$([MSBuild]::GetTargetFrameworkVersion('%(_StaticWebAssetsCrossTargetingProjectConfiguration.TargetFramework)'))</TargetFrameworkVersion>
        <Platform>$([MSBuild]::GetTargetPlatformIdentifier('%(_StaticWebAssetsCrossTargetingProjectConfiguration.TargetFramework)'))</Platform>
        <PlatformVersion>$([MSBuild]::GetTargetPlatformVersion('%(_StaticWebAssetsCrossTargetingProjectConfiguration.TargetFramework)'))</PlatformVersion>
      </_ExtendedStaticWebAssetsCrossTargetingProjectConfiguration>
    </ItemGroup>
    <!-- Evaluate the embedding rules for this target framework. -->
    <ResolveStaticWebAssetsEmbeddedProjectConfiguration Condition="'@(_StaticWebAssetsCrossTargetingProjectConfiguration)' != ''" StaticWebAssetProjectConfiguration="@(_ExtendedStaticWebAssetsCrossTargetingProjectConfiguration)" EmbeddingConfiguration="@(StaticWebAssetsEmbeddedConfiguration)" TargetFramework="$(TargetFramework)">
      <Output TaskParameter="EmbeddedProjectAssetConfigurations" ItemName="_StaticWebAssetsEmbeddedProjectAssetConfigurations" />
    </ResolveStaticWebAssetsEmbeddedProjectConfiguration>
    <ItemGroup>
      <_StaticWebAssetsEmbeddedProjectAssetConfigurations Condition="'%(Identity)' != ''" KeepMetadata="@(_StaticWebAssetEmbeddedProjectConfigurationCanonicalMetadata)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveStaticWebAssetsEmbeddingRules" Returns="@(StaticWebAssetsEmbeddedConfiguration)" />
  <Target Name="ResolveEmbeddedProjectsStaticWebAssets" Condition="'$(ResolveEmbeddedStaticWebAssets)' != 'false'" DependsOnTargets="ResolveStaticWebAssetsCrossTargetingConfiguration">
    <MSBuild Condition="'@(_StaticWebAssetsEmbeddedProjectAssetConfigurations)' != '' and %(_StaticWebAssetsEmbeddedProjectAssetConfigurations.TargetFramework) != '$(TargetFramework)'" Targets="%(_StaticWebAssetsEmbeddedProjectAssetConfigurations.GetEmbeddedBuildAssetsTargets)" Properties="%(_StaticWebAssetsEmbeddedProjectAssetConfigurations.AdditionalEmbeddedBuildProperties)" RemoveProperties="%(_StaticWebAssetsEmbeddedProjectAssetConfigurations.AdditionalEmbeddedBuildPropertiesToRemove);$(_GlobalPropertiesToRemoveFromProjectReferences)" Projects="@(_StaticWebAssetsEmbeddedProjectAssetConfigurations)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="false">
      <Output TaskParameter="TargetOutputs" ItemName="_EmbeddedBuildStaticWebAssetsItems" />
    </MSBuild>
    <ItemGroup>
      <StaticWebAsset Include="@(_EmbeddedBuildStaticWebAssetsItems)" Condition="'%(_EmbeddedBuildStaticWebAssetsItems.ResultType)' == 'StaticWebAsset'" KeepMetadata="@(_StaticWebAssetCanonicalMetadata)" />
      <StaticWebAssetDiscoveryPattern Include="@(_EmbeddedBuildStaticWebAssetsItems)" Condition="'%(_EmbeddedBuildStaticWebAssetsItems.ResultType)' == 'StaticWebAssetDiscoveryPattern'" KeepMetadata="@(_StaticWebAssetDiscoveryPatternCanonicalMetadata)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveEmbeddedConfigurationsPackageAssets" Condition="'$(ResolveEmbeddedStaticWebAssets)' != 'false'" DependsOnTargets="ResolveStaticWebAssetsCrossTargetingConfiguration">
    <MSBuild Condition="'@(_StaticWebAssetsEmbeddedProjectAssetConfigurations)' != '' and %(_StaticWebAssetsEmbeddedProjectAssetConfigurations.TargetFramework) != '$(TargetFramework)'" Targets="GetEmbeddedReferencedPackageAssets" Properties="%(_StaticWebAssetsEmbeddedProjectAssetConfigurations.GetReferencedEmbeddedAssetsProperties)" RemoveProperties="%(_StaticWebAssetsEmbeddedProjectAssetConfigurations.GetReferencedEmbeddedAssetsPropertiesToRemove);$(_GlobalPropertiesToRemoveFromProjectReferences)" Projects="@(_StaticWebAssetsEmbeddedProjectAssetConfigurations)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="false">
      <Output TaskParameter="TargetOutputs" ItemName="_EmbeddedBuildStaticWebAssetsItems" />
    </MSBuild>
    <ItemGroup>
      <StaticWebAsset Include="@(_EmbeddedBuildStaticWebAssetsItems)" KeepMetadata="@(_StaticWebAssetCanonicalMetadata)" />
    </ItemGroup>
  </Target>
  <Target Name="GetEmbeddedReferencedPackageAssets" Returns="@(_StaticWebAssetPackageAsset)">
    <ItemGroup>
      <_StaticWebAssetPackageAsset Include="@(StaticWebAsset)" Condition="'%(StaticWebAsset.SourceType)' == 'Package">
        <AssetMergeSource>$(TargetFramework)</AssetMergeSource>
      </_StaticWebAssetPackageAsset>
    </ItemGroup>
  </Target>
  <Target Name="ResolveEmbeddedConfigurationsReferencedProjects" Condition="'$(ResolveEmbeddedStaticWebAssets)' != 'false'" DependsOnTargets="ResolveStaticWebAssetsCrossTargetingConfiguration">
    <MSBuild Condition="'@(_StaticWebAssetsEmbeddedProjectAssetConfigurations)' != '' and %(_StaticWebAssetsEmbeddedProjectAssetConfigurations.TargetFramework) != '$(TargetFramework)'" Targets="GetEmbeddedConfigurationReferencedProjects" Properties="%(_StaticWebAssetsEmbeddedProjectAssetConfigurations.GetReferencedProjectsProperties)" RemoveProperties="%(_StaticWebAssetsEmbeddedProjectAssetConfigurations.GetReferencedProjectsPropertiesToRemove);$(_GlobalPropertiesToRemoveFromProjectReferences)" Projects="@(_StaticWebAssetsEmbeddedProjectAssetConfigurations)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="false">
      <Output TaskParameter="TargetOutputs" ItemName="_EmbeddedBuildStaticWebAssetProjectReference" />
    </MSBuild>
    <ItemGroup>
      <StaticWebAsset Include="@(_EmbeddedBuildStaticWebAssetProjectReference)" KeepMetadata="@(_StaticWebAssetProjectConfigurationCanonicalMetadata)" />
    </ItemGroup>
  </Target>
  <Target Name="GetEmbeddedConfigurationReferencedProjects" DependsOnTargets="ResolveReferencedProjectsStaticWebAssetsConfiguration" Returns="@(StaticWebAssetProjectConfiguration)" />
  <Target Name="ResolveEmbeddedConfigurationReferencedProjectsStaticWebAssets" DependsOnTargets="ResolveEmbeddedConfigurationsReferencedProjects">
    <MSBuild Condition="'@(StaticWebAssetProjectConfiguration)' != ''" Targets="%(StaticWebAssetProjectConfiguration.GetBuildAssetsTargets)" Properties="%(StaticWebAssetProjectConfiguration.AdditionalBuildProperties)" RemoveProperties="%(StaticWebAssetProjectConfiguration.AdditionalBuildPropertiesToRemove);$(_GlobalPropertiesToRemoveFromProjectReferences)" Projects="@(StaticWebAssetProjectConfiguration)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="false">
      <Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectBuildStaticWebAssetsItems" />
    </MSBuild>
    <ItemGroup>
      <StaticWebAsset Include="@(_ReferencedProjectBuildStaticWebAssetsItems)" Condition="'%(_ReferencedProjectBuildStaticWebAssetsItems.ResultType)' == 'StaticWebAsset'" KeepMetadata="@(_StaticWebAssetCanonicalMetadata)" />
      <StaticWebAssetDiscoveryPattern Include="@(_ReferencedProjectBuildStaticWebAssetsItems)" Condition="'%(_ReferencedProjectBuildStaticWebAssetsItems.ResultType)' == 'StaticWebAssetDiscoveryPattern'" KeepMetadata="@(_StaticWebAssetDiscoveryPatternCanonicalMetadata)" />
    </ItemGroup>
  </Target>
  <Target Name="ComputeReferencedProjectsEmbeddedPublishAssets" Condition="'$(ResolveEmbeddedStaticWebAssets)' != 'false'" DependsOnTargets="LoadStaticWebAssetsBuildManifest">
    <ItemGroup>
      <_ProjectConfigurationsWithEmbeddedPublishTargets Include="@(_StaticWebAssetsEmbeddedProjectAssetConfigurations)" Condition="'%(_StaticWebAssetsEmbeddedProjectAssetConfigurations.GetEmbeddedPublishAssetsTargets)' != ''" />
    </ItemGroup>
    <PropertyGroup>
      <_HasProjectsWithStaticWebAssetEmbeddedPublishTargets>false</_HasProjectsWithStaticWebAssetEmbeddedPublishTargets>
      <_HasProjectsWithStaticWebAssetEmbeddedPublishTargets Condition="'@(_ProjectConfigurationsWithEmbeddedPublishTargets)' != ''">true</_HasProjectsWithStaticWebAssetEmbeddedPublishTargets>
    </PropertyGroup>
    <MSBuild Condition="$(_HasProjectsWithStaticWebAssetEmbeddedPublishTargets)" Targets="%(_ProjectConfigurationsWithEmbeddedPublishTargets.GetEmbeddedPublishAssetsTargets)" Properties="%(_ProjectConfigurationsWithEmbeddedPublishTargets.AdditionalEmbeddedPublishProperties)" RemoveProperties="%(_ProjectConfigurationsWithEmbeddedPublishTargets.AdditionalEmbeddedPublishPropertiesToRemove);$(_GlobalPropertiesToRemoveFromProjectReferences)" Projects="@(_ProjectConfigurationsWithEmbeddedPublishTargets)" BuildInParallel="$(BuildInParallel)" ContinueOnError="!$(BuildingProject)" SkipNonexistentTargets="false">
      <Output TaskParameter="TargetOutputs" ItemName="_ReferencedProjectEmbeddedPublishStaticWebAssetsItems" />
    </MSBuild>
    <ItemGroup Condition="$(_HasProjectsWithStaticWebAssetEmbeddedPublishTargets)">
      <StaticWebAsset Remove="@(_ReferencedProjectEmbeddedPublishStaticWebAssetsItems)" />
      <StaticWebAsset Include="@(_ReferencedProjectEmbeddedPublishStaticWebAssetsItems)" Condition="'%(_ReferencedProjectEmbeddedPublishStaticWebAssetsItems.ResultType)' == 'StaticWebAsset'" RemoveMetadata="ResultType" />
    </ItemGroup>
  </Target>
  <Target Name="GetCurrentProjectEmbeddedBuildStaticWebAssetItems" DependsOnTargets="ResolveStaticWebAssetsConfiguration" Returns="@(_CachedEmbeddedBuildStaticWebAssetItems)">
    <PropertyGroup>
      <_ShouldReadEmbeddedBuildManifestAndUpdateItemGroup>false</_ShouldReadEmbeddedBuildManifestAndUpdateItemGroup>
      <_ShouldReadEmbeddedBuildManifestAndUpdateItemGroup Condition="@(_CachedEmbeddedBuildStaticWebAssets) == '' and @(_CachedEmbeddedBuildStaticWebAssetDiscoveryPatterns) == ''">true</_ShouldReadEmbeddedBuildManifestAndUpdateItemGroup>
    </PropertyGroup>
    <ReadStaticWebAssetsManifestFile ManifestPath="$(StaticWebAssetBuildManifestPath)" Condition="'$(_ShouldReadEmbeddedBuildManifestAndUpdateItemGroup)' == 'true'">
      <Output TaskParameter="Assets" ItemName="_CachedEmbeddedBuildStaticWebAssets" />
      <Output TaskParameter="DiscoveryPatterns" ItemName="_CachedEmbeddedBuildStaticWebAssetDiscoveryPatterns" />
    </ReadStaticWebAssetsManifestFile>
    <ComputeStaticWebAssetsForCurrentProject Assets="@(_CachedEmbeddedBuildStaticWebAssets)" ProjectMode="$(StaticWebAssetProjectMode)" AssetKind="Build" Source="$(PackageId)">
      <Output TaskParameter="StaticWebAssets" ItemName="_CachedEmbeddedBuildReferencedStaticWebAsset" />
    </ComputeStaticWebAssetsForCurrentProject>
    <ItemGroup>
      <_CachedEmbeddedBuildStaticWebAssetItems Include="@(_CachedEmbeddedBuildReferencedStaticWebAsset)">
        <ResultType>StaticWebAsset</ResultType>
      </_CachedEmbeddedBuildStaticWebAssetItems>
      <_CachedEmbeddedBuildStaticWebAssetItems Include="@(_CachedEmbeddedBuildStaticWebAssetDiscoveryPatterns)">
        <ResultType>StaticWebAssetDiscoveryPattern</ResultType>
      </_CachedEmbeddedBuildStaticWebAssetItems>
    </ItemGroup>
  </Target>
  <Target Name="GetCurrentProjectEmbeddedPublishStaticWebAssetItems" DependsOnTargets="ResolveStaticWebAssetsConfiguration" Returns="@(_CachedEmbeddedPublishStaticWebAssetItems)">
    <PropertyGroup>
      <_ShouldReadEmbeddedPublishManifestAndUpdateItemGroup>false</_ShouldReadEmbeddedPublishManifestAndUpdateItemGroup>
      <_ShouldReadEmbeddedPublishManifestAndUpdateItemGroup Condition="@(_CachedEmbeddedPublishStaticWebAssets) == '' and @(_CachedEmbeddedPublishStaticWebAssetDiscoveryPatterns) == ''">true</_ShouldReadEmbeddedPublishManifestAndUpdateItemGroup>
    </PropertyGroup>
    <ReadStaticWebAssetsManifestFile ManifestPath="$(StaticWebAssetPublishManifestPath)" Condition="'$(_ShouldReadEmbeddedPublishManifestAndUpdateItemGroup)' == 'true'">
      <Output TaskParameter="Assets" ItemName="_CachedEmbeddedPublishStaticWebAssets" />
      <Output TaskParameter="DiscoveryPatterns" ItemName="_CachedEmbeddedPublishStaticWebAssetDiscoveryPatterns" />
    </ReadStaticWebAssetsManifestFile>
    <ComputeReferenceStaticWebAssetItems Assets="@(_CachedEmbeddedPublishStaticWebAssets)" ProjectMode="$(StaticWebAssetProjectMode)" AssetKind="Publish" Source="$(PackageId)">
      <Output TaskParameter="StaticWebAssets" ItemName="_CachedEmbeddedPublishReferencedStaticWebAsset" />
    </ComputeReferenceStaticWebAssetItems>
    <ItemGroup>
      <_CachedEmbeddedPublishStaticWebassetItems Include="@(_CachedEmbeddedPublishReferencedStaticWebAsset)">
        <ResultType>StaticWebAsset</ResultType>
      </_CachedEmbeddedPublishStaticWebassetItems>
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.Pack.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.Pack.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.GenerateStaticWebAssetsPropsFile" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.GenerateStaticWebAssetEndpointsPropsFile" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.StaticWebAssetsGeneratePackagePropsFile" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.StaticWebAssetsGeneratePackManifest" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.StaticWebAssetsReadPackManifest" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" Condition="'$(StaticWebAssetsSdkBuildTasksAssembly)' != ''" />
  <PropertyGroup>
    <!-- IsInnerBuild is only set up when we are in the context of a cross targeting build and we are building a given
         target framework. There are specific targets to handle packing within cross targeting builds, so we avoid packing
         in this case.
    -->
    <GenerateNuspecDependsOn Condition="$(IsInnerBuild) != 'true'">
      IncludeStaticWebAssetsPackItems;
      $(GenerateNuspecDependsOn);
    </GenerateNuspecDependsOn>
    <IncludeStaticWebAssetsPackItemsDependsOn>
      ResolveStaticWebAssetsConfiguration;LoadStaticWebAssetsBuildManifest
    </IncludeStaticWebAssetsPackItemsDependsOn>
    <IncludeStaticWebAssetsPackItemsDependsOn Condition="'$(NoBuild)' != 'true' and '$(GeneratePackageOnBuild)' != 'true'">
      Build;$(IncludeStaticWebAssetsPackItemsDependsOn);
    </IncludeStaticWebAssetsPackItemsDependsOn>
  </PropertyGroup>
  <!-- This target generates a manifest with all static web assets for the current project that need to
       be included in the package under the folder staticwebassets and generates MSBuild props files to
       ensure that consuming packages can discover and use the static web assets.
       This target generates a Microsoft.AspNetCore.StaticWebAssets.props file that
       goes inside the build directory and describes the static web assets in the package as an
       item group.
       This target also generates a $(PackageId).props file under the build, buildMultiTargeting
       and buildTransitive folders that are setup so that:
       * buildTransitive\$(PackageId).props simply imports buildMultitargeting\$(PackageId).props
       * buildMultitargeting\$(PackageId).props simply imports build\$(PackageId).props
       * build\$(PackageId).props simply imports Microsoft.AspNetCore.StaticWebAssets.props

       We do it this way to preserve the ability of package authors to customize the package in any way
       they see fit and to make sure the package works in all scenarios. Authors including custom MSBuild
       targets into their packages are expected to disable the generation of $(PackageId).props files and
       to manually import build\Microsoft.AspNetCore.StaticWebAssets.props in their custom props files.
   -->
  <Target Name="GenerateStaticWebAssetsPackFiles" Condition="'$(IsPackable)' == 'true'" AfterTargets="GenerateStaticWebAssetsManifest">
    <ItemGroup>
      <StaticWebAssetPackageFile Include="$(_GeneratedStaticWebAssetsPropsFile)" Condition="'$(DisableStaticWebAssetsBuildPropsFileGeneration)' == ''">
        <PackagePath>build\Microsoft.AspNetCore.StaticWebAssets.props</PackagePath>
      </StaticWebAssetPackageFile>
      <StaticWebAssetPackageFile Include="$(_GeneratedStaticWebAssetEndpointsPropsFile)" Condition="'$(DisableStaticWebAssetEndpointsBuildPropsFileGeneration)' == ''">
        <PackagePath>build\Microsoft.AspNetCore.StaticWebAssetEndpoints.props</PackagePath>
      </StaticWebAssetPackageFile>
      <StaticWebAssetPackageFile Include="$(_GeneratedBuildPropsFile)" Condition="'$(StaticWebAssetsDisableProjectBuildPropsFileGeneration)' == ''">
        <PackagePath>build\$(PackageId).props</PackagePath>
      </StaticWebAssetPackageFile>
      <StaticWebAssetPackageFile Include="$(_GeneratedBuildMultitargetingPropsFile)" Condition="'$(StaticWebAssetsDisableProjectBuildMultiTargetingPropsFileGeneration)' == ''">
        <PackagePath>buildMultiTargeting\$(PackageId).props</PackagePath>
      </StaticWebAssetPackageFile>
      <StaticWebAssetPackageFile Include="$(_GeneratedBuildTransitivePropsFile)" Condition="'$(StaticWebAssetsDisableProjectBuildTransitivePropsFileGeneration)' == ''">
        <PackagePath>buildTransitive\$(PackageId).props</PackagePath>
      </StaticWebAssetPackageFile>
      <!-- All files potentially created within this target -->
      <FileWrites Include="$(_GeneratedStaticWebAssetsPropsFile)" />
      <FileWrites Include="$(_GeneratedStaticWebAssetEndpointsPropsFile)" />
      <FileWrites Include="$(_GeneratedBuildPropsFile)" />
      <FileWrites Include="$(_GeneratedBuildMultitargetingPropsFile)" />
      <FileWrites Include="$(_GeneratedBuildTransitivePropsFile)" />
      <FileWrites Include="$(StaticWebAssetPackManifestPath)" />
    </ItemGroup>
    <ItemGroup>
      <_PackStaticWebAssetCandidates Include="@(StaticWebAsset)" Exclude="@(_StaticWebAssetExcludedFromPack)" />
    </ItemGroup>
    <!-- The logic for computing the static web assets to pack, is the same logic that we use to determine what assets we need
      to provide when a referencing project asks for a list of static web assets on our current project. For example, this
      avoids us including things like the transitive bundles for scoped css in the package.

      AssetKind is set to Publish to prefer Publish assets over Build assets when available. Build assets, when present, can be
      considered as development versions of an asset, for example unminified js files, the service worker file that we use during
      development, or the untrimmed Blazor dlls.

      This only affects cases where we have two or more assets targeting the same path and we need to select one of them to pack.
      We can consider in the future packing both assets, which would allow people to include development versions of their assets
      which would help with things like debugging during development.

      For example, this would allow someone to include the unminified version of a JS library + source maps and allow consumers to
      use those during local development using their package without that impacting their ability to use an optimize version transparently
      when they publish their app.

      There is obviously no "Publish" target/step for Razor Class Libraries, so the guidance is that any Publish asset in a Razor Class
      Library needs to be computed as part of the build (This is expected and already accounted for as part of the Static Web Assets
      pipeline).

    -->
    <ComputeReferenceStaticWebAssetItems Assets="@(_PackStaticWebAssetCandidates)" ProjectMode="$(StaticWebAssetProjectMode)" AssetKind="Publish" Source="$(PackageId)" UpdateSourceType="false">
      <Output TaskParameter="StaticWebAssets" ItemName="_PackStaticWebAssets" />
    </ComputeReferenceStaticWebAssetItems>
    <!-- This is similar to what we do when providing assets as reference. We use _PackStaticWebAssets as ComputeEndpointsForReferenceStaticWebAssets
      discards any endpoint that doesn't have a matching asset, which acts as a filter to ensure we only provide the relevant endpoints.
    -->
    <ComputeEndpointsForReferenceStaticWebAssets Assets="@(_PackStaticWebAssets)" CandidateEndpoints="@(StaticWebAssetEndpoint)">
      <Output TaskParameter="Endpoints" ItemName="_PackStaticWebAssetEndpoints" />
    </ComputeEndpointsForReferenceStaticWebAssets>
    <!-- Generates a props file that goes in build\Microsoft.AspNetCore.StaticWebAssets.props
         and that describes the static web assets for the package.
     -->
    <GenerateStaticWebAssetsPropsFile StaticWebAssets="@(_PackStaticWebAssets)" TargetPropsFilePath="$(_GeneratedStaticWebAssetsPropsFile)" />
    <!-- Generates a props file that goes in build\Microsoft.AspNetCore.StaticWebAssetEndpoints.props
        that describes the static web asset endpoints associated with the assets in the package.
    -->
    <GenerateStaticWebAssetEndpointsPropsFile StaticWebAssets="@(_PackStaticWebAssets)" StaticWebAssetEndpoints="@(_PackStaticWebAssetEndpoints)" TargetPropsFilePath="$(_GeneratedStaticWebAssetEndpointsPropsFile)" />
    <!-- Generates a props file the goes in build\$(PackageId).props and that simply imports
         build\Microsoft.AspNetCore.StaticWebAssets.props
     -->
    <StaticWebAssetsGeneratePackagePropsFile PropsFileImport="$(_StaticWebAssetsPropsFileImportPath)" BuildTargetPath="$(_GeneratedBuildPropsFile)" AdditionalImports="$(_StaticWebAssetEndpointsPropsFileImportPath)" />
    <!-- Generates a props file the goes in buildMultiTargeting\$(PackageId).props and that simply imports
         build\$(PackageId).props
     -->
    <StaticWebAssetsGeneratePackagePropsFile PropsFileImport="$(_StaticWebAssetsGeneratedBuildPropsFileImportPath)" BuildTargetPath="$(_GeneratedBuildMultitargetingPropsFile)" />
    <!-- Generates a props file the goes in buildTransitive\$(PackageId).props and that simply imports
         buildMultiTargeting\$(PackageId)
     -->
    <StaticWebAssetsGeneratePackagePropsFile PropsFileImport="$(_StaticWebAssetsGeneratedBuildMultiTargetingPropsFileImportPath)" BuildTargetPath="$(_GeneratedBuildTransitivePropsFile)" />
    <!-- We need to adjust the path for files without extension (LICENSE) for example. Otherwise, when they get packed, nuget creates an
         additional folder for the file. -->
    <ComputeStaticWebAssetsTargetPaths Assets="@(_PackStaticWebAssets)" PathPrefix="staticwebassets" AdjustPathsForPack="true">
      <Output TaskParameter="AssetsWithTargetPath" ItemName="_PackStaticWebAssetWithTargetPath" />
    </ComputeStaticWebAssetsTargetPaths>
    <!-- The pack manifest captures all the information we need to successfully pack all the static web assets
         into the project. We always build this manifest as part of the build process and it is used to drive
         the pack process. This makes dealing with all the pack variants much easier, like 'generate package on
         build' and 'no build' as well as multi targeting scenarios.

         During the actual pack, we read the manifest and add the items as content with the appropriate package
         paths.
     -->
    <StaticWebAssetsGeneratePackManifest Assets="@(_PackStaticWebAssetWithTargetPath)" AdditionalPackageFiles="@(StaticWebAssetPackageFile)" ManifestPath="$(StaticWebAssetPackManifestPath)" />
  </Target>
  <!-- This target is invoked in cross targeting builds to resolve the paths for the pack and build manifests -->
  <Target Name="ResolveStaticWebAssetsManifestPaths" Returns="@(_StaticWebAssetsManifestPaths)" DependsOnTargets="ResolveStaticWebAssetsConfiguration">
    <ItemGroup>
      <_StaticWebAssetsManifestPaths Include="$(MSBuildProjectName)">
        <BuildManifest>$(StaticWebAssetBuildManifestPath)</BuildManifest>
        <PackManifest>$(StaticWebAssetPackManifestPath)</PackManifest>
      </_StaticWebAssetsManifestPaths>
    </ItemGroup>
  </Target>
  <Target Name="IncludeStaticWebAssetsPackItems" DependsOnTargets="$(IncludeStaticWebAssetsPackItemsDependsOn)">
    <!-- LoadStaticWebAssetsBuildManifest takes care of removing all the static web assets from existing item groups
         if they were present already. That ensures no static web asset is mistakenly included as content even if it is
         not an asset that needs to be included on the package. -->
    <StaticWebAssetsReadPackManifest Condition="Exists('$(StaticWebAssetPackManifestPath)')" ManifestPath="$(StaticWebAssetPackManifestPath)">
      <Output TaskParameter="Files" ItemName="_StaticWebAssetsFilesToPack" />
    </StaticWebAssetsReadPackManifest>
    <ItemGroup>
      <Content Include="@(_StaticWebAssetsFilesToPack)" Pack="true" CopyToOutputDirectory="Never" CopyToPublishDirectory="Never" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.ScopedCss.targets" Condition="'$(UsingMicrosoftNETSdkRazor)' == 'true' And '$(ScopedCssEnabled)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.ScopedCss.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.ScopedCss.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- General description of the scoped CSS pipeline and its integration with static web assets:
* Scoped css files get discovered and put into a ScopedCssInput itemgroup.
* Any file with a *.razor.css extension gets processed as a scoped css file. That means two things:
  * A uniquely identifying scope attribute is generated for that file.
  * The file will be transformed to apply the unique scope to all selectors and a new file will be generated.
  * This new file along with the scope will be added to the ScopedCss itemgroup.
  * When resolving Razor inputs we will match RazorComponent items with their associated ScopedCss item by convention.
    * The convention is that the scoped css file will have to have the same full path as the razor file with the addition of the .css extension.
    * Users can define their own convention by adding their own ScopedCssInput item with the RazorComponent metadata on it.
      * This metadata will point to the item spec for a given RazorComponent (typically the path from the root of the project)
  * At this point, if a razor.css file doesn't have an associated RazorComponent it will be discarded and not included in the final bundle.
    * This makes sure that the scoped css pipeline and the components pipeline are as orthogonal as possible.
    * Computing the scopes will happen very early on the pipeline and it will generate all the input that the compiler needs to do its job
      independently.
* For web applications (Blazor webassembly and Blazor server) the main project is responsible for producing the final CSS bundle and making
  it available during development and production behind $(PackageId).styles.css
* For razor class libraries we will add the list of ScopedCss to the list of available static web assets imported by the project, the main project
  will then discover these assets and add them to the ScopedCss files to process in the final bundle.
* For packing in razor class libraries, the ScopedCss files will get processed and added as static web assets to the pack.

Integration with static web assets:
* The generated scoped css files will be added as regular static web assets to participate in the pipeline.
  * Generated scoped css files will have a unique extension '.rz.scp.css' that will be used by the pipeline to identify them as such.
* In razor class libraries these generated files will be packaged normally as part of the static web assets process and if bundling is
  not enabled would be normally accessible at <<StaticWebAssetsBasePath>>/<<RelativePath>>.
* When bundling is enabled (there's no actual way to disable it) all scoped css files from class libraries will be identified by looking
  at the list of static web assets and identifying the ones that have a .rz.scp.css extension.
  * Using the extension is useful as it allows for third party tooling to do alternative processing in an easy way, these files will be
    removed off from the list of static web assets when the default bundling is enabled, so they won't show up in the final output.
-->
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.DiscoverDefaultScopedCssItems" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ResolveAllScopedCssAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ApplyCssScopes" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ComputeCssScope" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.RewriteCss" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ConcatenateCssFiles" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <PropertyGroup>
    <ResolveStaticWebAssetsInputsDependsOn>
    $(ResolveStaticWebAssetsInputsDependsOn);
    ResolveScopedCssAssets;
  </ResolveStaticWebAssetsInputsDependsOn>
    <ResolveScopedCssAssetsDependsOn>
    $(ResolveScopedCssAssetsDependsOn);
    UpdateLegacyPackageScopedCssBundles;
    GenerateScopedCssFiles;
    ResolveBundledCssAssets;
  </ResolveScopedCssAssetsDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateScopedCssFilesDependsOn Condition="'$(DisableScopedCssBundling)' != 'true'">
    $(GenerateScopedCssFilesDependsOn);
    _ResolveBundlingConfiguration;
    _ProcessScopedCssFiles;
    BundleScopedCssFiles;
  </GenerateScopedCssFilesDependsOn>
    <GenerateScopedCssFilesDependsOn Condition="'$(DisableScopedCssBundling)' == 'true'">
    _ProcessScopedCssFiles;
    _ComputeScopedCssStaticWebAssets;
    $(GenerateScopedCssFilesDependsOn);
  </GenerateScopedCssFilesDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateComputedBuildStaticWebAssetsDependsOn Condition="'$(DisableScopedCssBundling)' != 'true'">
    $(GenerateComputedBuildStaticWebAssetsDependsOn);
    BundleScopedCssFiles;
  </GenerateComputedBuildStaticWebAssetsDependsOn>
  </PropertyGroup>
  <Target Name="GenerateScopedCssFiles" DependsOnTargets="$(GenerateScopedCssFilesDependsOn)" />
  <Target Name="ResolveScopedCssAssets" DependsOnTargets="$(ResolveScopedCssAssetsDependsOn)">
    <ItemGroup>
      <StaticWebAsset Include="@(_ScopedCssAppBundleStaticWebAsset)" Condition="'$(DisableScopedCssBundling)' != 'true'" />
      <StaticWebAsset Include="@(_ScopedCssProjectBundleStaticWebAsset)" Condition="'$(DisableScopedCssBundling)' != 'true'" />
      <StaticWebAsset Include="@(_ScopedCssStaticWebAsset)" Condition="'$(DisableScopedCssBundling)' == 'true'" />
      <StaticWebAssetEndpoint Include="@(_ScopedCssAppBundleStaticWebAssetEndpoint)" Condition="'$(DisableScopedCssBundling)' != 'true'" />
      <StaticWebAssetEndpoint Include="@(_ScopedCssProjectBundleStaticWebAssetEndpoint)" Condition="'$(DisableScopedCssBundling)' != 'true'" />
      <StaticWebAssetEndpoint Include="@(_ScopedCssStaticWebAssetEndpoint)" Condition="'$(DisableScopedCssBundling)' == 'true'" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <!-- We are going to use .rz.scp.css as the extension to mark scoped css files that come from packages or that have been pre-procesed by
       referenced class libraries. This way, we can use that information to adjust the build pipeline without having to rely on external
       sources like an additional itemgroup or metadata.
  -->
    <_ScopedCssExtension>.rz.scp.css</_ScopedCssExtension>
  </PropertyGroup>
  <Target Name="ResolveScopedCssInputs">
    <!--
  Gathers input source files for Razor component generation. This is a separate target so that we can avoid
  lots of work when there are no inputs for code generation.

  NOTE: This target is called as part of an incremental build scenario in VS. Do not perform any work
  outside of calculating RazorComponent items in this target.
  -->
    <DiscoverDefaultScopedCssItems Condition="'$(EnableDefaultScopedCssItems)' == 'true'" Content="@(None);@(Content)" SupportsScopedCshtmlCss="true">
      <Output TaskParameter="DiscoveredScopedCssInputs" ItemName="_DiscoveredScopedCssInputs" />
    </DiscoverDefaultScopedCssItems>
    <ItemGroup Condition="'$(EnableDefaultScopedCssItems)' == 'true'">
      <ScopedCssInput Include="@(_DiscoveredScopedCssInputs)" />
    </ItemGroup>
    <ItemGroup>
      <Content Remove="@(ScopedCssInput)" />
      <Content Include="@(ScopedCssInput)" Pack="false" CopyToPublishDirectory="Never" />
    </ItemGroup>
  </Target>
  <!-- This target just generates a Scope identifier for the items that we deemed were scoped css files -->
  <Target Name="ComputeCssScope" DependsOnTargets="ResolveScopedCssInputs">
    <ComputeCssScope ScopedCssInput="@(ScopedCssInput)" Targetname="$(TargetName)">
      <Output TaskParameter="ScopedCss" ItemName="_ScopedCss" />
    </ComputeCssScope>
  </Target>
  <!-- Sets the output path for the processed scoped css files. They will all have a '.rz.scp.css' extension to flag them as processed
     scoped css files. -->
  <Target Name="ResolveScopedCssOutputs" DependsOnTargets="$(ResolveScopedCssOutputsDependsOn)">
    <PropertyGroup>
      <_ScopedCssIntermediatePath>$([System.IO.Path]::GetFullPath($(IntermediateOutputPath)scopedcss\))</_ScopedCssIntermediatePath>
    </PropertyGroup>
    <ItemGroup>
      <_ScopedCss Condition="'%(_ScopedCss.Identity)' != ''">
        <OutputFile>$(_ScopedCssIntermediatePath)%(RelativeDir)%(RecursiveDir)%(FileName)$(_ScopedCssExtension)</OutputFile>
        <RelativePath>%(RelativeDir)%(RecursiveDir)%(FileName)$(_ScopedCssExtension)</RelativePath>
      </_ScopedCss>
      <_ScopedCssOutputs Include="%(_ScopedCss.OutputFile)" />
    </ItemGroup>
    <!-- https://github.com/dotnet/project-system/blob/main/docs/up-to-date-check.md -->
    <ItemGroup>
      <UpToDateCheckInput Include="%(_ScopedCss.Identity)" />
      <UpToDateCheckBuilt Include="%(_ScopedCss.OutputFile)" Original="%(_ScopedCss.Identity)" />
    </ItemGroup>
  </Target>
  <Target Name="_ResolveScopedCssOutputsDesignTime" DependsOnTargets="ResolveScopedCssOutputs" BeforeTargets="CollectUpToDateCheckInputDesignTime;CollectUpToDateCheckBuiltDesignTime" />
  <!-- Transforms the original scoped CSS files into their scoped versions on their designated output paths -->
  <Target Name="_ProcessScopedCssFiles" Inputs="@(_ScopedCss)" Outputs="@(_ScopedCssOutputs)" DependsOnTargets="ResolveScopedCssOutputs">
    <MakeDir Directories="$(_ScopedCssIntermediatePath)" />
    <RewriteCss FilesToTransform="@(_ScopedCss)" />
    <ItemGroup>
      <FileWrites Include="%(_ScopedCss.OutputFile)" />
    </ItemGroup>
  </Target>
  <!--
  This target is added to ResolveStaticWebAssetInputs which only gets called by the main application.
  This makes sure we only include the bundle file when we are processing an application for build/publish
  and avoids including it on razor class libraries.
  In the hosted blazor webassembly case, we want to include the bundle within the assets returned to the host, so we wire up this task
  to `GetCurrentProjectStaticWebAssetsDependsOn` so that contents are replaced and shared with the host application.

  Normally, _CollectAllScopedCssAssets will find all the scoped css files from referenced packages, class libraries and the current project. When ResolveScopedCssAssets
  runs, it will remove all those static web assets and add the bundle asset.
  When _CollectAllScopedCssAssets runs as part of a hosted blazor webassembly app, only the current project and package assets are removed from the list of
  static web assets. If the host also decides to generate a bundle, there will be a bundle for the razor client app and another bundle for the host and they will
  contain some overlapping css.
  * The bundle for the client app will contain the transitive closure of the processed css files for the client app.
  * The bundle for the server app will contain the css for the referenced class libraries (transitively and the packages).
    * Users in this position can choose to remove CssScopedInput entries to avoid including them in the host bundle.

  For Blazor webassembly we want to trigger the bundling at the Blazor client level so that different applications can have self-contained bundles. For the most
  common case, the bundle for a Blazor app and its host should be identical modulo path comments on the bundle.

  If one single bundle is desired, bundling can be disabled in the Blazor application and the host will create a single big bundle file.

-->
  <Target Name="_ResolveBundlingConfiguration" DependsOnTargets="ResolveStaticWebAssetsConfiguration">
    <PropertyGroup>
      <_ScopedCssIntermediatePath>$([System.IO.Path]::GetFullPath($(IntermediateOutputPath)scopedcss\))</_ScopedCssIntermediatePath>
      <!-- This bundle represents the bundle for the entire application dependency graph which includes the application scoped css files and all the scoped css files from
         projects and packages that this app references -->
      <_ScopedCssBundleContentRoot>$(_ScopedCssIntermediatePath)bundle\</_ScopedCssBundleContentRoot>
      <_ScopedCssOutputPath>$(_ScopedCssIntermediatePath)bundle\$(PackageId).styles.css</_ScopedCssOutputPath>
      <_ScopedCssOutputFullPath>$([System.IO.Path]::Combine('$(MSBuildProjectFileDirectory)', '$(_ScopedCssIntermediatePath)bundle\$(PackageId).styles.css'))</_ScopedCssOutputFullPath>
      <!-- This bundle represents the bundle for the scoped css files in this project, without references to other projects or package scoped css files. This bundle is used by projects
         referencing this project that import it through an import rule into their app bundle -->
      <_ScopedCssProjectBundleContentRoot>$(_ScopedCssIntermediatePath)projectbundle\</_ScopedCssProjectBundleContentRoot>
      <_ScopedCssProjectOutputPath>$(_ScopedCssIntermediatePath)projectbundle\$(PackageId).bundle.scp.css</_ScopedCssProjectOutputPath>
      <_ScopedCssProjectOutputFullPath>$([System.IO.Path]::Combine('$(MSBuildProjectFileDirectory)', '$(_ScopedCssIntermediatePath)projectbundle\$(PackageId).bundle.scp.css'))</_ScopedCssProjectOutputFullPath>
      <!-- We want the scoped css bundle path to always point to the root path of the app, overriding the default base path unless it is not explicitly overridden
    by the user. This is so that when you are developing a server-side application or in the future potentially an ASP.NET application using css isolation,
    you don't have to make the urls in your files relative to "_content/$(PackageId).styles.css".
    If the user chooses to override the base path explicitly, we place the bundle at the root of the defined base path, this allows Blazor WebAssembly applications to be hosted
    on different paths other than the root path and for the bundle to behave as expected
    -->
      <_ScopedCssBundleBasePath>/</_ScopedCssBundleBasePath>
      <_ScopedCssBundleBasePath Condition="'$(StaticWebAssetBasePath)' != '_content/$(PackageId)'">$(StaticWebAssetBasePath)</_ScopedCssBundleBasePath>
    </PropertyGroup>
  </Target>
  <Target Name="ResolveBundledCssAssets" Condition="'$(DisableScopedCssBundling)' != 'true'" DependsOnTargets="_ResolveBundlingConfiguration;_CollectAllScopedCssAssets">
    <ItemGroup>
      <_ScopedCssAppBundleStaticWebAssetCandidate Include="$(_ScopedCssOutputPath)">
        <RelativePath Condition="'$(StaticWebAssetFingerprintingEnabled)' == 'true'">$(PackageId)#[.{fingerprint}]?.styles.css</RelativePath>
        <RelativePath Condition="'$(StaticWebAssetFingerprintingEnabled)' != 'true'">$(PackageId).styles.css</RelativePath>
      </_ScopedCssAppBundleStaticWebAssetCandidate>
      <_ScopedCssProjectBundleStaticWebAssetCandidate Include="$(_ScopedCssProjectOutputPath)">
        <RelativePath Condition="'$(StaticWebAssetFingerprintingEnabled)' == 'true'">$(PackageId)#[.{fingerprint}]!.bundle.scp.css</RelativePath>
        <RelativePath Condition="'$(StaticWebAssetFingerprintingEnabled)' != 'true'">$(PackageId).bundle.scp.css</RelativePath>
      </_ScopedCssProjectBundleStaticWebAssetCandidate>
      <!-- Adds a Link: <bundle1>; rel="preload", <bundle2>; rel="preload", <bundle3>; rel="preload" -->
      <_AddLinkHeaderToAppBundle Include="Append" Condition="'@(_ResolvedScopedCssBundleEndpoints)' != ''">
        <UpdateTarget>Header</UpdateTarget>
        <Name>Link</Name>
        <Value>@(_ResolvedScopedCssBundleEndpoints->'&lt;%(Identity)&gt;; rel="preload"; as="style"', ', ')</Value>
      </_AddLinkHeaderToAppBundle>
    </ItemGroup>
    <DefineStaticWebAssets Condition="@(_AllScopedCss) != ''" CandidateAssets="@(_ScopedCssAppBundleStaticWebAssetCandidate)" SourceType="Computed" SourceId="$(PackageId)" ContentRoot="$(_ScopedCssBundleContentRoot)" BasePath="$(StaticWebAssetBasePath)" AssetKind="All" AssetMode="CurrentProject" AssetRole="Primary" AssetMergeSource="$(StaticWebAssetMergeTarget)" RelatedAsset="" AssetTraitName="ScopedCss" AssetTraitValue="ApplicationBundle" CopyToOutputDirectory="Never" CopyToPublishDirectory="PreserveNewest">
      <Output TaskParameter="Assets" ItemName="_ScopedCssAppBundleStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints Condition="@(_AllScopedCss) != ''" CandidateAssets="@(_ScopedCssAppBundleStaticWebAsset)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_ScopedCssAppBundleStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <UpdateStaticWebAssetEndpoints Condition="'@(_AddLinkHeaderToAppBundle)' != ''" EndpointsToUpdate="@(_ScopedCssAppBundleStaticWebAssetEndpoint)" AllEndpoints="@(_ScopedCssAppBundleStaticWebAssetEndpoint)" Operations="@(_AddLinkHeaderToAppBundle)">
      <Output TaskParameter="UpdatedEndpoints" ItemName="_UpdatedScopedCssAppBundleStaticWebAssetEndpoint" />
    </UpdateStaticWebAssetEndpoints>
    <ItemGroup Condition="'@(_AddLinkHeaderToAppBundle)' != ''">
      <_ScopedCssAppBundleStaticWebAssetEndpoint Remove="@(_UpdatedScopedCssAppBundleStaticWebAssetEndpoint)" />
      <_ScopedCssAppBundleStaticWebAssetEndpoint Include="@(_UpdatedScopedCssAppBundleStaticWebAssetEndpoint)" />
    </ItemGroup>
    <DefineStaticWebAssets Condition="@(_ScopedCss) != ''" CandidateAssets="@(_ScopedCssProjectBundleStaticWebAssetCandidate)" SourceType="Computed" SourceId="$(PackageId)" ContentRoot="$(_ScopedCssProjectBundleContentRoot)" BasePath="$(StaticWebAssetBasePath)" AssetKind="All" AssetMode="Reference" AssetRole="Primary" RelatedAsset="" AssetMergeSource="$(StaticWebAssetMergeTarget)" AssetTraitName="ScopedCss" AssetTraitValue="ProjectBundle" CopyToOutputDirectory="Never" CopyToPublishDirectory="PreserveNewest">
      <Output TaskParameter="Assets" ItemName="_ScopedCssProjectBundleStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints Condition="@(_ScopedCss) != ''" CandidateAssets="@(_ScopedCssProjectBundleStaticWebAsset)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_ScopedCssProjectBundleStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
  </Target>
  <!-- This target runs as part of ResolveStaticWebAssetInputs and collects all the generated scoped css files. When bundling is enabled
     these files are removed from the list of static web assets by 'ResolveScopedCssAssets' -->
  <Target Name="_CollectAllScopedCssAssets" DependsOnTargets="_ComputeScopedCssStaticWebAssets">
    <ResolveAllScopedCssAssets StaticWebAssets="@(StaticWebAsset);@(_ScopedCssStaticWebAsset)">
      <Output TaskParameter="ScopedCssAssets" ItemName="_DiscoveredScopedCssFiles" />
      <Output TaskParameter="ScopedCssProjectBundles" ItemName="_ScopedCssProjectBundles" />
    </ResolveAllScopedCssAssets>
    <ItemGroup>
      <_AllScopedCss Include="@(_ScopedCssProjectBundles);@(_DiscoveredScopedCssFiles)" />
    </ItemGroup>
    <!-- https://github.com/dotnet/project-system/blob/main/docs/up-to-date-check.md -->
    <ItemGroup>
      <UpToDateCheckInput Include="@(_AllScopedCss)" />
      <UpToDateCheckBuilt Include="$(_ScopedCssOutputFullPath)" />
      <UpToDateCheckBuilt Include="$(_ScopedCssProjectOutputFullPath)" />
    </ItemGroup>
  </Target>
  <Target Name="_ComputeScopedCssStaticWebAssets" DependsOnTargets="ResolveScopedCssOutputs;ResolveStaticWebAssetsConfiguration">
    <ItemGroup>
      <_ScopedCssCandidateFile Include="%(_ScopedCss.OutputFile)" Condition="@(_ScopedCss) != ''">
        <RelativePath>%(_ScopedCss.RelativePath)</RelativePath>
        <OriginalItemSpec>%(_ScopedCss.Identity)</OriginalItemSpec>
      </_ScopedCssCandidateFile>
    </ItemGroup>
    <DefineStaticWebAssets Condition="@(_ScopedCss) != ''" CandidateAssets="@(_ScopedCssCandidateFile)" SourceType="Computed" SourceId="$(PackageId)" ContentRoot="$(IntermediateOutputPath)scopedcss\" BasePath="$(StaticWebAssetBasePath)" AssetKind="All" AssetMode="All" AssetRole="Primary" AssetMergeSource="$(StaticWebAssetMergeTarget)" AssetTraitName="ScopedCss" AssetTraitValue="ScopedCssFile" CopyToOutputDirectory="Never" CopyToPublishDirectory="PreserveNewest">
      <Output TaskParameter="Assets" ItemName="_ScopedCssStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints Condition="@(_ScopedCss) != ''" CandidateAssets="@(_ScopedCssStaticWebAsset)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_ScopedCssStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
  </Target>
  <Target Name="BundleScopedCssFiles" Condition="'$(DisableScopedCssBundling)' != 'true'" DependsOnTargets="_CollectAllScopedCssAssets;_ProcessScopedCssFiles;_ResolveBundlingConfiguration">
    <!-- Incrementalism is built into the task itself. -->
    <ItemGroup>
      <_CurrentProjectDiscoveredScopedCssFiles Include="@(_DiscoveredScopedCssFiles)" />
      <!-- If we are in standalone hosting, we want to resolve endpoints that match the file name, that's what standalone does -->
      <_ScopedCssProjectBundleFilters Include="Standalone" Condition="$(StaticWebAssetStandaloneHosting) == 'true'" />
      <!-- If we are not in standalone hosting, we want to resolve endpoints with a fingerprint where possible -->
      <_ScopedCssProjectBundleFilters Include="Property" Condition="$(StaticWebAssetStandaloneHosting) != 'true'">
        <Name>fingerprint</Name>
      </_ScopedCssProjectBundleFilters>
      <_ScopedCssProjectBundleFiltersNoFingerprint Include="Property" Condition="$(StaticWebAssetStandaloneHosting) != 'true'">
        <Name>fingerprint</Name>
        <Mode>Exclude</Mode>
      </_ScopedCssProjectBundleFiltersNoFingerprint>
    </ItemGroup>
    <FilterStaticWebAssetEndpoints Condition="'@(_ScopedCssProjectBundles)' != ''" Endpoints="@(StaticWebAssetEndpoint)" Assets="@(_ScopedCssProjectBundles)" Filters="@(_ScopedCssProjectBundleFilters)">
      <Output TaskParameter="FilteredEndpoints" ItemName="_FilteredScopedCssBundleEndpoints" />
      <Output TaskParameter="AssetsWithoutMatchingEndpoints" ItemName="_ScopedCssBundlesWithoutFingerprint" />
    </FilterStaticWebAssetEndpoints>
    <FilterStaticWebAssetEndpoints Condition="'$(StaticWebAssetStandaloneHosting)' != 'true' and '@(_ScopedCssBundlesWithoutFingerprint)' != ''" Endpoints="@(StaticWebAssetEndpoint)" Assets="@(_ScopedCssBundlesWithoutFingerprint)" Filters="@(_ScopedCssProjectBundleFiltersNoFingerprint)">
      <Output TaskParameter="FilteredEndpoints" ItemName="_FilteredScopedCssBundleEndpoints" />
      <Output TaskParameter="AssetsWithoutMatchingEndpoints" ItemName="_ScopedCssBundlesWithoutEndpoints" />
    </FilterStaticWebAssetEndpoints>
    <Error Condition="'@(_ScopedCssProjectBundles)' != '' and '@(_ScopedCssBundlesWithoutEndpoints)' != ''" Text="The following scoped css bundles do not have matching endpoints: @(_ScopedCssBundlesWithoutEndpoints->'%(RelativePath)')" />
    <ResolveStaticWebAssetEndpointRoutes Condition="'@(_ScopedCssProjectBundles)' != ''" Endpoints="@(_FilteredScopedCssBundleEndpoints)" Assets="@(_ScopedCssProjectBundles)">
      <Output TaskParameter="ResolvedEndpoints" ItemName="_ResolvedScopedCssBundleEndpoints" />
    </ResolveStaticWebAssetEndpointRoutes>
    <!-- This is the bundle for the app, we will always generate it when there are scoped css files for the current project or
       we detected existing bundles available. If some other project/package didn't bundle their assets, we will not be including
       them in this bundle. -->
    <ConcatenateCssFiles Condition="'@(_ScopedCssProjectBundles)' != '' or '@(_ScopedCss)' != ''" ScopedCssFiles="@(_CurrentProjectDiscoveredScopedCssFiles)" ProjectBundles="@(_ResolvedScopedCssBundleEndpoints)" ScopedCssBundleBasePath="$(_ScopedCssBundleBasePath)" OutputFile="$(_ScopedCssOutputPath)" />
    <!-- This is the project bundle, we will only generate it when there are scoped files defined in the project. This bundle will be used
       when the project is referenced from another project or packed as a package (Razor Class Library). If some other project/package
       didn't bundle their assets, we will not be including them in this bundle. -->
    <ConcatenateCssFiles Condition="'@(_ScopedCss)' != ''" ScopedCssFiles="@(_CurrentProjectDiscoveredScopedCssFiles)" ProjectBundles="" ScopedCssBundleBasePath="$(_ScopedCssBundleBasePath)" OutputFile="$(_ScopedCssProjectOutputPath)" />
    <ItemGroup>
      <FileWrites Include="$(_ScopedCssOutputPath)" />
      <FileWrites Condition="'@(_ScopedCss)' != ''" Include="$(_ScopedCssProjectOutputPath)" />
    </ItemGroup>
  </Target>
  <!-- Back-compat -->
  <Target Name="UpdateLegacyPackageScopedCssBundles" DependsOnTargets="UpdateExistingPackageStaticWebAssets">
    <ItemGroup>
      <_LegacyOverrides Include="AssetMode" />
      <_PackageProjectBundleCandidates Include="@(StaticWebAsset)" Condition="'%(SourceType)' == 'Package'" />
    </ItemGroup>
    <DefineStaticWebAssets CandidateAssets="@(_PackageProjectBundleCandidates)" RelativePathFilter="**/*.bundle.scp.css" PropertyOverrides="@(_LegacyOverrides)" AssetMode="Reference" AssetRole="Primary" RelatedAsset="" AssetMergeSource="$(StaticWebAssetMergeTarget)" AssetTraitName="ScopedCss" AssetTraitValue="ProjectBundle">
      <Output TaskParameter="Assets" ItemName="_UpdatedLegacyProjectBundles" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssets CandidateAssets="@(_PackageProjectBundleCandidates)" RelativePathFilter="**/*.styles.css" PropertyOverrides="@(_LegacyOverrides)" AssetMode="CurrentProject" AssetRole="Primary" RelatedAsset="" AssetMergeSource="$(StaticWebAssetMergeTarget)" AssetTraitName="ScopedCss" AssetTraitValue="ApplicationBundle">
      <Output TaskParameter="Assets" ItemName="_UpdatedLegacyAppBundles" />
    </DefineStaticWebAssets>
    <ItemGroup>
      <StaticWebAsset Remove="@(_UpdatedLegacyProjectBundles->'%(OriginalItemSpec)')" />
      <StaticWebAsset Include="@(_UpdatedLegacyProjectBundles)" />
      <StaticWebAsset Remove="@(_UpdatedLegacyAppBundles->'%(OriginalItemSpec)')" />
      <StaticWebAsset Include="@(_UpdatedLegacyAppBundles)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.JSModules.targets" Condition="'$(JSModulesEnabled)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.JSModules.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.JsModule.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!-- General description of the JS modules pipeline and its integration with static web assets:
  * JS module files get discovered and put into a JsModule itemgroup.
  * Any file with a module.lib.js extension gets processed as a JS module file. That means:
    * It will be included in a generated list of module files "<project-name>.modules.json"
    * Users can define their own convention by adding their own JsModule file to the item group.
    * For web applications (Blazor webassembly and Blazor server) the main project is responsible for producing a bundle <project-name>.modules.json that will contain the list of modules to load
  * For packing in razor class libraries, the JsModule files will get processed and added as static web assets to the pack.

  Integration with static web assets:
  * The JS modules will be added as regular static web assets to participate in the pipeline.
    * Generated JS module files will have a unique extension '.module.lib.js' that will be used by the pipeline to identify them as such unless otherwise identified.
  * In razor class libraries these generated files will be packaged normally as part of the static web assets process and will be accessible at <<StaticWebAssetsBasePath>>/<<RelativePath>>.
    * Using the extension is useful as it allows for third party tooling to do alternative processing in an easy way, these files will be
      removed off from the list of static web assets when the default bundling is enabled, so they won't show up in the final output.
  -->
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.GenerateJsModuleManifest" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ApplyJsModules" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <PropertyGroup>
    <GenerateJSModuleManifest Condition="$(GenerateJSModuleManifest) == ''">true</GenerateJSModuleManifest>
    <ResolveCoreStaticWebAssetsDependsOn>
      $(ResolveCoreStaticWebAssetsDependsOn);
      ResolveJsInitializerModuleStaticWebAssets;
    </ResolveCoreStaticWebAssetsDependsOn>
    <ResolveCoreStaticWebAssetsDependsOn Condition="'$(UsingMicrosoftNETSdkRazor)' == 'true'">
      $(ResolveCoreStaticWebAssetsDependsOn);
      ResolveJSModuleStaticWebAssets;
    </ResolveCoreStaticWebAssetsDependsOn>
  </PropertyGroup>
  <PropertyGroup>
    <!--
        ResolveStaticWebAssetsInputs
          ResolveJSModuleManifestBuildStaticWebAssets
            GenerateJSModuleManifestBuildStaticWebAssets
              ResolveJSModuleManifestBuildConfiguration
     -->
    <ResolveStaticWebAssetsInputsDependsOn>
      ResolveJSModuleManifestBuildStaticWebAssets;
      $(ResolveStaticWebAssetsInputsDependsOn)
    </ResolveStaticWebAssetsInputsDependsOn>
    <ResolveJSModuleManifestBuildStaticWebAssetsDependsOn>
      GenerateJSModuleManifestBuildStaticWebAssets;
      $(ResolveJSModuleManifestBuildStaticWebAssetsDependsOn)
    </ResolveJSModuleManifestBuildStaticWebAssetsDependsOn>
    <GenerateJSModuleManifestBuildStaticWebAssetsDependsOn>
      ResolveJSModuleManifestBuildConfiguration;
      $(GenerateJSModuleManifestBuildStaticWebAssetsDependsOn)
    </GenerateJSModuleManifestBuildStaticWebAssetsDependsOn>
    <!--
        ResolvePublishStaticWebAssets
          ResolveJSModuleManifestPublishStaticWebAssets
            GenerateJSModuleManifestPublishStaticWebAssets
              ResolveJSModuleManifestPublishConfiguration
     -->
    <ResolvePublishStaticWebAssetsDependsOn Condition="'$(GenerateJSModuleManifest)' == 'true'">
      ResolveJSModuleManifestPublishStaticWebAssets;
      $(ResolvePublishStaticWebAssetsDependsOn)
    </ResolvePublishStaticWebAssetsDependsOn>
    <ResolveJSModuleManifestPublishStaticWebAssetsDependsOn>
      GenerateJSModuleManifestPublishStaticWebAssets;
      $(ResolveJSModuleManifestPublishStaticWebAssetsDependsOn)
    </ResolveJSModuleManifestPublishStaticWebAssetsDependsOn>
    <GenerateJSModuleManifestPublishStaticWebAssetsDependsOn>
      ResolveJSModuleManifestPublishConfiguration;
      $(GenerateJSModuleManifestPublishStaticWebAssetsDependsOn)
    </GenerateJSModuleManifestPublishStaticWebAssetsDependsOn>
  </PropertyGroup>
  <Target Name="ResolveJsInitializerModuleStaticWebAssets">
    <ItemGroup>
      <_JSModuleCandidates Include="@(StaticWebAsset)" Condition="'%(SourceType)' == 'Discovered'" />
    </ItemGroup>
    <!-- This runs after we've discovered the original set of files, we already found the assets in the wwwroot, and here we just need
         to identify them and correctly clasify them. Modules from other projects or packages will already be correctly tagged when we
         retrieve them.
    -->
    <PropertyGroup>
      <_ResolveJsInitializerModuleStaticWebAssetsCachePath Condition="'$(StaticWebAssetsCacheDefineStaticWebAssetsEnabled)' == 'true'">$(_StaticWebAssetsManifestBase)rjimswa.dswa.cache.json</_ResolveJsInitializerModuleStaticWebAssetsCachePath>
    </PropertyGroup>
    <DefineStaticWebAssets Condition="@(_JSModuleCandidates) != ''" CandidateAssets="@(_JSModuleCandidates)" AssetTraitName="JSModule" AssetTraitValue="JSLibraryModule" RelativePathFilter="**/$(PackageId).lib.module.js" PropertyOverrides="AssetTraitName;AssetTraitValue" AssetMergeSource="$(StaticWebAssetMergeTarget)" CacheManifestPath="$(_ResolveJsInitializerModuleStaticWebAssetsCachePath)">
      <Output TaskParameter="Assets" ItemName="_JSModuleStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_JSModuleStaticWebAsset)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_JSModuleStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup Condition="'@(_JSModuleStaticWebAsset)' != ''">
      <!-- Append a property 'script-type' so that we include the file on the import map -->
      <_AddPropertyToInitializers Include="Append">
        <UpdateTarget>Property</UpdateTarget>
        <Name>script-type</Name>
        <Value>module</Value>
      </_AddPropertyToInitializers>
      <!-- Append a property 'dependency-group' so that we can link and preload the file without using the name -->
      <_AddPropertyToInitializers Include="Append">
        <UpdateTarget>Property</UpdateTarget>
        <Name>dependency-group</Name>
        <Value>js-initializer</Value>
      </_AddPropertyToInitializers>
    </ItemGroup>
    <FilterStaticWebAssetEndpoints Condition="'@(_JSModuleStaticWebAsset)' != ''" Endpoints="@(StaticWebAssetEndpoint);@(_JSModuleStaticWebAssetEndpoint)" Assets="@(_JSModuleStaticWebAsset)" Filters="">
      <Output TaskParameter="FilteredEndpoints" ItemName="_FilteredJSModuleStaticWebAssetEndpoint" />
      <Output TaskParameter="AssetsWithoutMatchingEndpoints" ItemName="_MissingJSModuleStaticWebAsset" />
    </FilterStaticWebAssetEndpoints>
    <Error Condition="'@(_MissingJSModuleStaticWebAsset)' != ''" Text="The following JS module files do not have matching endpoints: @(_MissingJSModuleStaticWebAsset->'%(Identity)')" />
    <UpdateStaticWebAssetEndpoints Condition="'@(_AddPropertyToInitializers)' != ''" EndpointsToUpdate="@(_FilteredJSModuleStaticWebAssetEndpoint)" AllEndpoints="@(_FilteredJSModuleStaticWebAssetEndpoint)" Operations="@(_AddPropertyToInitializers)">
      <Output TaskParameter="UpdatedEndpoints" ItemName="_FilteredJSModuleStaticWebAssetEndpointWithProperty" />
    </UpdateStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Remove="@(_JSModuleStaticWebAsset)" />
      <StaticWebAsset Include="@(_JSModuleStaticWebAsset)" />
      <StaticWebAssetEndpoint Remove="@(_FilteredJSModuleStaticWebAssetEndpointWithProperty)" />
      <StaticWebAssetEndpoint Include="@(_FilteredJSModuleStaticWebAssetEndpointWithProperty)" />
      <FileWrites Include="$(_ResolveJsInitializerModuleStaticWebAssetsCachePath)" />
    </ItemGroup>
  </Target>
  <!-- Build -->
  <Target Name="ResolveJSModuleManifestBuildConfiguration" DependsOnTargets="ResolveCoreStaticWebAssets;ResolveJsInitializerModuleStaticWebAssets">
    <PropertyGroup>
      <_JSModuleBuildManifestPath>$(IntermediateOutputPath)jsmodules\jsmodules.build.manifest.json</_JSModuleBuildManifestPath>
      <JSModuleManifestRelativePath Condition="'$(JSModuleManifestRelativePath)' == ''">$(PackageId).modules.json</JSModuleManifestRelativePath>
    </PropertyGroup>
    <ItemGroup>
      <!-- Initializers from referenced projects and packages -->
      <_ExistingBuildJSModules Include="@(StaticWebAsset)" Condition="'%(StaticWebAsset.SourceId)' != '$(PackageId)' and '%(StaticWebAsset.AssetTraitName)' == 'JSModule' and '%(StaticWebAsset.AssetTraitValue)' == 'JSLibraryModule' and '%(StaticWebAsset.AssetKind)' != 'Publish'" />
      <_ExistingBuildJSModules Include="@(_JSModuleStaticWebAsset)" Condition="'%(_JSModuleStaticWebAsset.AssetTraitName)' == 'JSModule' and '%(_JSModuleStaticWebAsset.AssetTraitValue)' == 'JSLibraryModule' and '%(AssetKind)' != 'Publish'" />
      <_JsModuleBuildManifestCandidate Include="$(_JSModuleBuildManifestPath)">
        <RelativePath>$(JSModuleManifestRelativePath)</RelativePath>
      </_JsModuleBuildManifestCandidate>
    </ItemGroup>
  </Target>
  <Target Name="GenerateJSModuleManifestBuildStaticWebAssets" DependsOnTargets="$(GenerateJSModuleManifestBuildStaticWebAssetsDependsOn)">
    <!-- Incrementalism is built into the task itself. -->
    <ItemGroup>
      <!-- If we are in standalone hosting, we want to resolve endpoints that match the file name, that's what standalone does -->
      <_JsModuleBuildManifestFilters Include="Standalone" Condition="$(StaticWebAssetStandaloneHosting) == 'true'" />
      <!-- If we are not in standalone hosting, we want to resolve endpoints with a fingerprint where possible -->
      <_JsModuleBuildManifestFilters Include="Property" Condition="$(StaticWebAssetStandaloneHosting) != 'true'">
        <Name>fingerprint</Name>
      </_JsModuleBuildManifestFilters>
      <_JsModuleBuildManifestFiltersNoFingerprint Include="Property" Condition="$(StaticWebAssetStandaloneHosting) != 'true'">
        <Name>fingerprint</Name>
        <Mode>Exclude</Mode>
      </_JsModuleBuildManifestFiltersNoFingerprint>
    </ItemGroup>
    <FilterStaticWebAssetEndpoints Condition="'@(_ExistingBuildJSModules)' != ''" Endpoints="@(StaticWebAssetEndpoint)" Assets="@(_ExistingBuildJSModules)" Filters="@(_JsModuleBuildManifestFilters)">
      <Output TaskParameter="FilteredEndpoints" ItemName="_FilteredBuildJSModulesEndpoints" />
      <Output TaskParameter="AssetsWithoutMatchingEndpoints" ItemName="_ExistingBuildJSModulesWithoutFingerprint" />
    </FilterStaticWebAssetEndpoints>
    <FilterStaticWebAssetEndpoints Condition="'$(StaticWebAssetStandaloneHosting)' != 'true' and '@(_ExistingBuildJSModulesWithoutFingerprint)' != ''" Endpoints="@(StaticWebAssetEndpoint)" Assets="@(_ExistingBuildJSModulesWithoutFingerprint)" Filters="@(_JsModuleBuildManifestFiltersNoFingerprint)">
      <Output TaskParameter="FilteredEndpoints" ItemName="_FilteredBuildJSModulesEndpoints" />
      <Output TaskParameter="AssetsWithoutMatchingEndpoints" ItemName="_BuildJSModulessWithoutEndpoints" />
    </FilterStaticWebAssetEndpoints>
    <Error Condition="'@(_ExistingBuildJSModules)' != '' and '@(_BuildJSModulessWithoutEndpoints)' != ''" Text="The following scoped css bundles do not have matching endpoints: @(_BuildJSModulessWithoutEndpoints->'%(RelativePath)')" />
    <ResolveStaticWebAssetEndpointRoutes Condition="'@(_ExistingBuildJSModules)' != ''" Endpoints="@(_FilteredBuildJSModulesEndpoints)" Assets="@(_ExistingBuildJSModules)">
      <Output TaskParameter="ResolvedEndpoints" ItemName="_ResolvedJSBuildModuleEndpoints" />
    </ResolveStaticWebAssetEndpointRoutes>
    <GenerateJsModuleManifest Condition="'@(_ExistingBuildJSModules)' != ''" OutputFile="@(_JsModuleBuildManifestCandidate)" JsModules="@(_ResolvedJSBuildModuleEndpoints)" />
    <ItemGroup>
      <FileWrites Condition="'@(_ExistingBuildJSModules)' != ''" Include="@(_JsModuleBuildManifestCandidate)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveJSModuleManifestBuildStaticWebAssets" DependsOnTargets="$(ResolveJSModuleManifestBuildStaticWebAssetsDependsOn)" Condition="'$(GenerateJSModuleManifest)' == 'true'">
    <DefineStaticWebAssets Condition="@(_ExistingBuildJSModules) != ''" CandidateAssets="@(_JsModuleBuildManifestCandidate)" SourceId="$(PackageId)" SourceType="Computed" BasePath="$(StaticWebAssetBasePath)" ContentRoot="$(IntermediateOutputPath)jsmodules\" AssetKind="Build" AssetMode="CurrentProject" AssetRole="Primary" AssetMergeSource="$(StaticWebAssetMergeTarget)" FingerprintCandidates="$(StaticWebAssetsFingerprintContent)" FingerprintPatterns="@(StaticWebAssetFingerprintPattern)" AssetTraitName="JSModule" AssetTraitValue="JSModuleManifest">
      <Output TaskParameter="Assets" ItemName="_BuildJsModuleManifestStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_BuildJsModuleManifestStaticWebAsset)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_BuildJsModuleManifestStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Include="@(_BuildJsModuleManifestStaticWebAsset)" />
      <StaticWebAssetEndpoint Include="@(_BuildJsModuleManifestStaticWebAssetEndpoint)" />
    </ItemGroup>
  </Target>
  <!-- Publish -->
  <Target Name="ResolveJSModuleManifestPublishConfiguration" DependsOnTargets="ResolveCorePublishStaticWebAssets">
    <PropertyGroup>
      <_JSModulePubishManifestPath>$(IntermediateOutputPath)jsmodules\jsmodules.publish.manifest.json</_JSModulePubishManifestPath>
      <JSModuleManifestRelativePath Condition="'$(JSModuleManifestRelativePath)' == ''">$(PackageId).modules.json</JSModuleManifestRelativePath>
    </PropertyGroup>
    <ItemGroup>
      <_ExistingPublishJSModules Include="@(StaticWebAsset)" Condition="'%(StaticWebAsset.AssetTraitName)' == 'JSModule' and '%(StaticWebAsset.AssetTraitValue)' == 'JSLibraryModule' and '%(StaticWebAsset.AssetKind)' != 'Build'" />
    </ItemGroup>
    <ItemGroup>
      <_JsModulePublishManifestCandidate Include="$(_JSModulePubishManifestPath)">
        <RelativePath>$(JSModuleManifestRelativePath)</RelativePath>
      </_JsModulePublishManifestCandidate>
    </ItemGroup>
  </Target>
  <Target Name="GenerateJSModuleManifestPublishStaticWebAssets" DependsOnTargets="$(GenerateJSModuleManifestPublishStaticWebAssetsDependsOn)">
    <!-- Incrementalism is built into the task itself. -->
    <ItemGroup>
      <!-- If we are in standalone hosting, we want to resolve endpoints that match the file name, that's what standalone does -->
      <_JsModulePublishManifestFilters Include="Standalone" Condition="$(StaticWebAssetStandaloneHosting) == 'true'" />
      <!-- If we are not in standalone hosting, we want to resolve endpoints with a fingerprint where possible -->
      <_JsModulePublishManifestFilters Include="Property" Condition="$(StaticWebAssetStandaloneHosting) != 'true'">
        <Name>fingerprint</Name>
      </_JsModulePublishManifestFilters>
      <_JsModulePublishManifestFiltersNoFingerprint Include="Property" Condition="$(StaticWebAssetStandaloneHosting) != 'true'">
        <Name>fingerprint</Name>
        <Mode>Exclude</Mode>
      </_JsModulePublishManifestFiltersNoFingerprint>
    </ItemGroup>
    <FilterStaticWebAssetEndpoints Condition="'@(_ExistingPublishJSModules)' != ''" Endpoints="@(StaticWebAssetEndpoint)" Assets="@(_ExistingPublishJSModules)" Filters="@(_JsModulePublishManifestFilters)">
      <Output TaskParameter="FilteredEndpoints" ItemName="_FilteredPublishJSModulesEndpoints" />
      <Output TaskParameter="AssetsWithoutMatchingEndpoints" ItemName="_ExistingPublishJSModulesWithoutFingerprint" />
    </FilterStaticWebAssetEndpoints>
    <FilterStaticWebAssetEndpoints Condition="'$(StaticWebAssetStandaloneHosting)' != 'true' and '@(_ExistingPublishJSModulesWithoutFingerprint)' != ''" Endpoints="@(StaticWebAssetEndpoint)" Assets="@(_ExistingPublishJSModulesWithoutFingerprint)" Filters="@(_JsModulePublishManifestFiltersNoFingerprint)">
      <Output TaskParameter="FilteredEndpoints" ItemName="_FilteredPublishJSModulesEndpoints" />
      <Output TaskParameter="AssetsWithoutMatchingEndpoints" ItemName="_PublishJSModulessWithoutEndpoints" />
    </FilterStaticWebAssetEndpoints>
    <Error Condition="'@(_ExistingPublishJSModules)' != '' and '@(_PublishJSModulessWithoutEndpoints)' != ''" Text="The following scoped css bundles do not have matching endpoints: @(_PublishJSModulessWithoutEndpoints->'%(RelativePath)')" />
    <ResolveStaticWebAssetEndpointRoutes Condition="'@(_ExistingPublishJSModules)' != ''" Endpoints="@(_FilteredPublishJSModulesEndpoints)" Assets="@(_ExistingPublishJSModules)">
      <Output TaskParameter="ResolvedEndpoints" ItemName="_ResolvedJSPublishModuleEndpoints" />
    </ResolveStaticWebAssetEndpointRoutes>
    <GenerateJsModuleManifest Condition="'@(_ExistingPublishJSModules)' != ''" OutputFile="@(_JsModulePublishManifestCandidate)" JsModules="@(_ResolvedJSPublishModuleEndpoints)" />
    <ItemGroup>
      <FileWrites Condition="@(_ExistingPublishJSModules) != ''" Include="@(_JsModulePublishManifestCandidate)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveJSModuleManifestPublishStaticWebAssets" DependsOnTargets="$(ResolveJSModuleManifestPublishStaticWebAssetsDependsOn)" Condition="'$(GenerateJSModuleManifest)' == 'true'">
    <DefineStaticWebAssets Condition="@(_ExistingPublishJSModules) != ''" CandidateAssets="@(_JsModulePublishManifestCandidate)" SourceId="$(PackageId)" SourceType="Computed" BasePath="$(StaticWebAssetBasePath)" ContentRoot="$(IntermediateOutputPath)jsmodules\" AssetKind="Publish" AssetMode="CurrentProject" AssetRole="Primary" AssetMergeSource="$(StaticWebAssetMergeTarget)" AssetTraitName="JSModule" AssetTraitValue="JSModuleManifest" FingerprintCandidates="$(StaticWebAssetsFingerprintContent)" FingerprintPatterns="@(StaticWebAssetFingerprintPattern)">
      <Output TaskParameter="Assets" ItemName="_PublishJsModuleManifestStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_PublishJsModuleManifestStaticWebAsset)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_PublishJsModuleManifestStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Include="@(_PublishJsModuleManifestStaticWebAsset)" />
      <StaticWebAssetEndpoint Include="@(_PublishJsModuleManifestStaticWebAssetEndpoint)" />
    </ItemGroup>
  </Target>
  <!-- JS file modules -->
  <Target Name="ResolveJSModuleStaticWebAssets" DependsOnTargets="ResolveProjectStaticWebAssets;ResolveRazorComponentInputs;ResolveRazorGenerateInputs">
    <ItemGroup>
      <!-- To avoid situations where the content is defined twice, if the user defines the JS module explicitly as
           a content item, we'll prefer that over the potential item in the None item group
      -->
      <_JSFileModuleCandidates Include="@(Content-&gt;Distinct())" />
      <_JSFileModuleNoneCandidates Include="@(None-&gt;Distinct())" Exclude="@(Content)" />
      <_JSFileModuleCandidates Include="@(_JSFileModuleNoneCandidates)" />
    </ItemGroup>
    <PropertyGroup>
      <_ResolveJSModuleStaticWebAssetsRazorCachePath Condition="'$(StaticWebAssetsCacheDefineStaticWebAssetsEnabled)' == 'true'">$(_StaticWebAssetsManifestBase)rjsmrazor.dswa.cache.json</_ResolveJSModuleStaticWebAssetsRazorCachePath>
    </PropertyGroup>
    <PropertyGroup>
      <_ResolveJSModuleStaticWebAssetsCshtmlCachePath Condition="'$(StaticWebAssetsCacheDefineStaticWebAssetsEnabled)' == 'true'">$(_StaticWebAssetsManifestBase)rjsmcshtml.dswa.cache.json</_ResolveJSModuleStaticWebAssetsCshtmlCachePath>
    </PropertyGroup>
    <!-- Find JS module files -->
    <!-- **/*.razor.js -->
    <DefineStaticWebAssets CandidateAssets="@(_JSFileModuleCandidates)" SourceId="$(PackageId)" RelativePathPattern="**/*.razor.js" ContentRoot="$(MSBuildProjectDirectory)" SourceType="Discovered" BasePath="$(StaticWebAssetBasePath)" AssetMergeSource="$(StaticWebAssetMergeTarget)" FingerprintCandidates="$(StaticWebAssetsFingerprintContent)" FingerprintPatterns="@(StaticWebAssetFingerprintPattern)" CacheManifestPath="$(_ResolveJSModuleStaticWebAssetsRazorCachePath)">
      <Output TaskParameter="Assets" ItemName="_ComponentJSModule" />
    </DefineStaticWebAssets>
    <!-- **/*.cshtml.js -->
    <DefineStaticWebAssets CandidateAssets="@(_JSFileModuleCandidates)" SourceId="$(PackageId)" RelativePathPattern="**/*.cshtml.js" ContentRoot="$(MSBuildProjectDirectory)" SourceType="Discovered" BasePath="$(StaticWebAssetBasePath)" AssetMergeSource="$(StaticWebAssetMergeTarget)" FingerprintCandidates="$(StaticWebAssetsFingerprintContent)" FingerprintPatterns="@(StaticWebAssetFingerprintPattern)" CacheManifestPath="$(_ResolveJSModuleStaticWebAssetsCshtmlCachePath)">
      <Output TaskParameter="Assets" ItemName="_MvcJSModule" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_ComponentJSModule)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_ComponentJSModuleEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_MvcJSModule)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_MvcJSModuleEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ApplyJsModules RazorComponents="@(RazorComponent)" RazorGenerate="@(RazorGenerate)" JSFileModuleCandidates="@(_ComponentJSModule);@(_MvcJSModule)">
      <Output TaskParameter="JsFileModules" ItemName="_JsFileModuleStaticWebAsset" />
    </ApplyJsModules>
    <ItemGroup>
      <_AddPropertyToJsModules Include="Append" Condition="'@(_MvcJSModuleEndpoint)' != '' or '@(_ComponentJSModuleEndpoint)' != ''">
        <UpdateTarget>Property</UpdateTarget>
        <Name>script-type</Name>
        <Value>module</Value>
      </_AddPropertyToJsModules>
    </ItemGroup>
    <UpdateStaticWebAssetEndpoints Condition="'@(_AddPropertyToJsModules)' != ''" EndpointsToUpdate="@(_MvcJSModuleEndpoint);@(_ComponentJSModuleEndpoint)" AllEndpoints="@(_MvcJSModuleEndpoint);@(_ComponentJSModuleEndpoint)" Operations="@(_AddPropertyToJsModules)">
      <Output TaskParameter="UpdatedEndpoints" ItemName="_JSModuleEndpointsWithProperty" />
    </UpdateStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Remove="@(_JsFileModuleStaticWebAsset)" />
      <StaticWebAsset Include="@(_JsFileModuleStaticWebAsset)" />
      <StaticWebAssetEndpoint Include="@(_JSModuleEndpointsWithProperty)" />
      <!-- Remove the items from their original groups since they've now become a StaticWebAsset -->
      <Content Remove="@(_JsFileModuleStaticWebAsset->'%(OriginalItemSpec)')" />
      <None Remove="@(_JsFileModuleStaticWebAsset->'%(OriginalItemSpec)')" />
      <FileWrites Include="$(_ResolveJSModuleStaticWebAssetsRazorCachePath)" />
      <FileWrites Include="$(_ResolveJSModuleStaticWebAssetsCshtmlCachePath)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.StaticWebAssets.Compression.targets" Condition="'$(CompressionEnabled)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.Compression.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.StaticWebAssets.Compression.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.BrotliCompress" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.GZipCompress" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.DiscoverPrecompressedAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ResolveCompressedAssets" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <UsingTask TaskName="Microsoft.AspNetCore.StaticWebAssets.Tasks.ApplyCompressionNegotiation" AssemblyFile="$(StaticWebAssetsSdkBuildTasksAssembly)" />
  <PropertyGroup>
    <EnableDefaultCompressedItems Condition="'$(EnableDefaultCompressedItems)' == '' and '$(_TargetingNET90OrLater)' == 'true'">true</EnableDefaultCompressedItems>
    <!-- File extensions associated with formats that are not already compressed. -->
    <CompressionIncludePatterns Condition="'$(EnableDefaultCompressedItems)' == 'true'">
      $(CompressionIncludePatterns);
      **/*.js;
      **/*.css;
      **/*.html;
      **/*.json;
      **/*.mjs;
      **/*.xml;
      **/*.htm;
      **/*.wasm;
      **/*.txt;
      **/*.dll;
      **/*.pdb;
      **/*.dat;
      **/*.jsx;
      **/*.markdown;
      **/*.md;
      **/*.webmanifest;
      **/*.bmp;
      **/*.svg;
      **/*.otf;
      **/*.art;
      **/*.cmx;
      **/*.cod;
      **/*.dib;
      **/*.ico;
      **/*.ief;
      **/*.pbm;
      **/*.pgm;
      **/*.pnm;
      **/*.ppm;
      **/*.ras;
      **/*.rf;
      **/*.rgb;
      **/*.tif
      **/*.tiff;
      **/*.wbmp;
      **/*.xbm;
      **/*.xpm;
      **/*.xwd;
      **/*.aif;
      **/*.aifc;
      **/*.aif;
      **/*.au;
      **/*.m3u;
      **/*.mid;
      **/*.midi;
      **/*.ra;
      **/*.ram;
      **/*.smd;
      **/*.smx;
      **/*.smz;
      **/*.wav;
      **/*.323;
      **/*.appcache;
      **/*.asm;
      **/*.bas;
      **/*.c;
      **/*.cnf;
      **/*.cpp;
      **/*.csv;
      **/*.disco;
      **/*.dlm;
      **/*.dtd;
      **/*.etx;
      **/*.h;
      **/*.hdml;
      **/*.htc;
      **/*.htt;
      **/*.hxt;
      **/*.ical;
      **/*.icalendar;
      **/*.ics;
      **/*.ifb;
      **/*.map;
      **/*.mno;
      **/*.odc;
      **/*.rtx;
      **/*.sct;
      **/*.sgml;
      **/*.tsv;
      **/*.uls;
      **/*.vbs;
      **/*.vcf;
      **/*.vcs;
      **/*.vml;
      **/*.wml;
      **/*.wmls;
      **/*.wsdl;
      **/*.xdr;
      **/*.xsd;
      **/*.xsf;
      **/*.xsl;
      **/*.xslt;
    </CompressionIncludePatterns>
    <!-- File extensions that should not be compressed because the associated format is already compressed. -->
    <CompressionExcludePatterns Condition="'$(EnableDefaultCompressedItems)' == 'true'">
      $(CompressionExcludePatterns);
      **/*.gz;
      **/*.br;
      **/*.jpeg;
      **/*.jpg;
      **/*.png;
      **/*.gif;
      **/*.webp;
      **/*.woff;
      **/*.woff2;
      **/*.m4v;
      **/*.mov;
      **/*.movie;
      **/*.mp2;
      **/*.mp4;
      **/*.mp4v;
      **/*.mpa;
      **/*.mpe;
      **/*.mpeg;
      **/*.mpg;
      **/*.mpv2;
      **/*.ogg;
      **/*.ogv;
      **/*.webm;
      **/*.jfif;
      **/*.svgz;
      **/*.jpe;
      **/*.pnz;
      **/*.aac;
      **/*.adt;
      **/*.adts;
      **/*.m4a;
      **/*.mp3;
      **/*.oga;
      **/*.wax;
      **/*.wma;
    </CompressionExcludePatterns>
  </PropertyGroup>
  <PropertyGroup>
    <EnableDefaultCompressionFormats Condition="'$(EnableDefaultCompressionFormats)' == ''">true</EnableDefaultCompressionFormats>
    <BuildCompressionFormats Condition="'$(EnableDefaultCompressionFormats)' == 'true'">$(BuildCompressionFormats);gzip</BuildCompressionFormats>
    <PublishCompressionFormats Condition="'$(EnableDefaultCompressionFormats)' == 'true'">$(PublishCompressionFormats);gzip;brotli</PublishCompressionFormats>
    <DisableBuildCompression Condition="'$(DisableBuildCompression)' == ''">false</DisableBuildCompression>
    <CompressDiscoveredAssetsDuringBuild Condition="$(CompressDiscoveredAssetsDuringBuild) == ''">true</CompressDiscoveredAssetsDuringBuild>
    <!-- Support passing in a custom compression level to brotli and respect the old internal flag for blazor -->
    <BrotliCompressionLevel Condition="'$(_BlazorBrotliCompressionLevel)' != ''">$(_BlazorBrotliCompressionLevel)</BrotliCompressionLevel>
  </PropertyGroup>
  <PropertyGroup>
    <!--
      ResolveBuildRelatedStaticWebAssets
        ResolveBuildCompressedStaticWebAssets
          GenerateBuildCompressedStaticWebAssets
            ResolveBuildCompressedStaticWebAssetsConfiguration
     -->
    <ResolveBuildRelatedStaticWebAssetsDependsOn Condition="'$(DisableBuildCompression)' != 'true'">
      ResolveBuildCompressedStaticWebAssets;
      $(ResolveBuildRelatedStaticWebAssetsDependsOn)
    </ResolveBuildRelatedStaticWebAssetsDependsOn>
    <ResolveBuildCompressedStaticWebAssetsDependsOn>
      GenerateBuildCompressedStaticWebAssets;
      $(ResolveBuildCompressedStaticWebAssetsDependsOn)
    </ResolveBuildCompressedStaticWebAssetsDependsOn>
    <GenerateBuildCompressedStaticWebAssetsDependsOn>
      ResolveBuildCompressedStaticWebAssetsConfiguration;
      $(GenerateBuildCompressedStaticWebAssetsDependsOn)
    </GenerateBuildCompressedStaticWebAssetsDependsOn>
    <!--
      ResolvePublishRelatedStaticWebAssets
        ResolvePublishCompressedStaticWebAssets
          GeneratePublishCompressedStaticWebAssets
            ResolvePublishCompressedStaticWebAssetsConfiguration
     -->
    <ResolvePublishRelatedStaticWebAssetsDependsOn>
      ResolvePublishCompressedStaticWebAssets;
      $(ResolvePublishRelatedStaticWebAssetsDependsOn)
    </ResolvePublishRelatedStaticWebAssetsDependsOn>
    <ResolvePublishCompressedStaticWebAssetsDependsOn>
      GeneratePublishCompressedStaticWebAssets;
      $(ResolvePublishCompressedStaticWebAssetsDependsOn)
    </ResolvePublishCompressedStaticWebAssetsDependsOn>
    <GeneratePublishCompressedStaticWebAssetsDependsOn>
      ResolvePublishCompressedStaticWebAssetsConfiguration;
      $(GeneratePublishCompressedStaticWebAssetsDependsOn)
    </GeneratePublishCompressedStaticWebAssetsDependsOn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DOTNET_HOST_PATH)' == ''">
    <_DotNetHostDirectory>$(NetCoreRoot)</_DotNetHostDirectory>
    <_DotNetHostFileName>dotnet</_DotNetHostFileName>
    <_DotNetHostFileName Condition="'$(OS)' == 'Windows_NT'">dotnet.exe</_DotNetHostFileName>
  </PropertyGroup>
  <!-- Build -->
  <Target Name="ResolveBuildCompressedStaticWebAssets" DependsOnTargets="$(ResolveBuildCompressedStaticWebAssetsDependsOn)">
    <PropertyGroup>
      <_ResolveBuildCompressedStaticWebAssetsCachePath Condition="'$(StaticWebAssetsCacheDefineStaticWebAssetsEnabled)' == 'true'">$(_StaticWebAssetsManifestBase)rbcswa.dswa.cache.json</_ResolveBuildCompressedStaticWebAssetsCachePath>
    </PropertyGroup>
    <DefineStaticWebAssets CandidateAssets="@(_CompressedStaticWebAssets)" CacheManifestPath="$(_ResolveBuildCompressedStaticWebAssetsCachePath)">
      <Output TaskParameter="Assets" ItemName="_CompressionBuildStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_CompressionBuildStaticWebAsset);@(_PrecompressedStaticWebAssets)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_CompressionBuildStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Include="@(_CompressionBuildStaticWebAsset)" />
      <StaticWebAssetEndpoint Include="@(_CompressionBuildStaticWebAssetEndpoint)" />
      <_CompressionCurrentProjectBuildAssets Include="@(StaticWebAsset)" />
      <FileWrites Include="@(_ResolveBuildCompressedStaticWebAssetsCachePath)" />
    </ItemGroup>
    <ApplyCompressionNegotiation CandidateEndpoints="@(StaticWebAssetEndpoint)" CandidateAssets="@(_CompressionCurrentProjectBuildAssets)">
      <Output TaskParameter="UpdatedEndpoints" ItemName="_UpdatedCompressionBuildEndpoints" />
    </ApplyCompressionNegotiation>
    <ItemGroup>
      <StaticWebAssetEndpoint Remove="@(_UpdatedCompressionBuildEndpoints)" />
      <StaticWebAssetEndpoint Include="@(_UpdatedCompressionBuildEndpoints)" />
    </ItemGroup>
  </Target>
  <Target Name="GenerateBuildCompressedStaticWebAssets" DependsOnTargets="$(GenerateBuildCompressedStaticWebAssetsDependsOn);$(CompressFilesDependsOn)">
    <ItemGroup>
      <_GZipCompressedStaticWebAssets Include="@(_CompressedStaticWebAssets)" Condition="'%(AssetTraitName)' == 'Content-Encoding' and '%(AssetTraitValue)' == 'gzip'" />
      <_BrotliCompressedStaticWebAssets Include="@(_CompressedStaticWebAssets)" Condition="'%(AssetTraitName)' == 'Content-Encoding' and '%(AssetTraitValue)' == 'br'" />
    </ItemGroup>
    <GZipCompress Condition="'@(_GZipCompressedStaticWebAssets)' != ''" FilesToCompress="@(_GZipCompressedStaticWebAssets)" />
    <BrotliCompress Condition="'@(_BrotliCompressedStaticWebAssets)' != ''" FilesToCompress="@(_BrotliCompressedStaticWebAssets)" CompressionLevel="$(BrotliCompressionLevel)" ToolAssembly="$(_StaticWebAssetsSdkToolAssembly)" ToolExe="$(_DotNetHostFileName)" ToolPath="$(_DotNetHostDirectory)" />
    <ItemGroup>
      <FileWrites Include="@(_GZipCompressedStaticWebAssets)" />
      <FileWrites Include="@(_BrotliCompressedStaticWebAssets)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveBuildCompressedStaticWebAssetsConfiguration" DependsOnTargets="ResolveStaticWebAssetsInputs;$(ResolveCompressedFilesDependsOn)">
    <!-- There might be assets that are precompressed on packages or that are precompressed by other tools.
         In this case, we need to detect those assets, remove them and their endpoints, adjust the asset definition
         and recreate the endpoints for those assets as the original ones will not be correct.
     -->
    <DiscoverPrecompressedAssets CandidateAssets="@(StaticWebAsset)">
      <Output TaskParameter="DiscoveredCompressedAssets" ItemName="_PrecompressedStaticWebAssets" />
    </DiscoverPrecompressedAssets>
    <FilterStaticWebAssetEndpoints Condition="'@(_PrecompressedStaticWebAssets)' != ''" Endpoints="@(StaticWebAssetEndpoint)" Assets="@(_PrecompressedStaticWebAssets)" Filters="">
      <Output TaskParameter="FilteredEndpoints" ItemName="_PrecompressedEndpointsToRemove" />
    </FilterStaticWebAssetEndpoints>
    <ItemGroup Condition="'@(_PrecompressedStaticWebAssets)' != ''">
      <StaticWebAssetEndpoint Remove="@(_PrecompressedEndpointsToRemove)" />
      <StaticWebAsset Remove="@(_PrecompressedStaticWebAssets)" />
      <StaticWebAsset Include="@(_PrecompressedStaticWebAssets)" />
    </ItemGroup>
    <PropertyGroup>
      <StaticWebAssetBuildCompressAllAssets Condition="'$(StaticWebAssetBuildCompressAllAssets)' == '' and '$(StaticWebAssetProjectMode)' == 'Root'">true</StaticWebAssetBuildCompressAllAssets>
      <StaticWebAssetBuildCompressAllAssets Condition="'$(StaticWebAssetBuildCompressAllAssets)' == ''">false</StaticWebAssetBuildCompressAllAssets>
    </PropertyGroup>
    <ItemGroup Condition="'$(StaticWebAssetBuildCompressAllAssets)' == 'true'">
      <_CandidateAssetsForBuild Include="@(StaticWebAsset)" />
    </ItemGroup>
    <ItemGroup Condition="'$(StaticWebAssetBuildCompressAllAssets)' != 'true'">
      <_CandidateAssetsForBuild Include="@(StaticWebAsset)" Condition="'%(SourceType)' == 'Discovered' or '%(SourceType)' == 'Computed'" />
    </ItemGroup>
    <ItemGroup Condition="'$(CompressDiscoveredAssetsDuringBuild)' != 'true'">
      <_CandidateAssetsForBuild Remove="@(_CandidateAssetsForBuild)" Condition="'%(SourceType)' == 'Discovered'" />
    </ItemGroup>
    <ResolveCompressedAssets CandidateAssets="@(_CandidateAssetsForBuild)" Formats="$(BuildCompressionFormats)" IncludePatterns="$(CompressionIncludePatterns)" ExcludePatterns="$(CompressionExcludePatterns)" ExplicitAssets="@(AssetToCompress)" OutputPath="$(IntermediateOutputPath)compressed">
      <Output TaskParameter="AssetsToCompress" ItemName="_CompressedStaticWebAssets" />
    </ResolveCompressedAssets>
    <ItemGroup Condition="'$(IsPackable)' == 'true'">
      <_StaticWebAssetExcludedFromPack Include="@(_CompressedStaticWebAssets)" />
    </ItemGroup>
  </Target>
  <!-- Publish -->
  <Target Name="ResolvePublishCompressedStaticWebAssets" DependsOnTargets="$(ResolvePublishCompressedStaticWebAssetsDependsOn)">
    <DefineStaticWebAssets CandidateAssets="@(_CompressedStaticWebAssetsForPublish)">
      <Output TaskParameter="Assets" ItemName="_CompressionPublishStaticWebAsset" />
    </DefineStaticWebAssets>
    <DefineStaticWebAssetEndpoints CandidateAssets="@(_CompressionPublishStaticWebAsset)" ExistingEndpoints="@(StaticWebAssetEndpoint)" ContentTypeMappings="@(StaticWebAssetContentTypeMapping)">
      <Output TaskParameter="Endpoints" ItemName="_CompressionPublishStaticWebAssetEndpoint" />
    </DefineStaticWebAssetEndpoints>
    <ItemGroup>
      <StaticWebAsset Include="@(_CompressionPublishStaticWebAsset)" />
      <StaticWebAssetEndpoint Include="@(_CompressionPublishStaticWebAssetEndpoint)" />
      <_CompressionCurrentProjectPublishAssets Include="@(StaticWebAsset)" Condition="'%(AssetKind)' != 'Build'" />
    </ItemGroup>
    <ApplyCompressionNegotiation CandidateEndpoints="@(StaticWebAssetEndpoint)" CandidateAssets="@(_CompressionCurrentProjectPublishAssets)">
      <Output TaskParameter="UpdatedEndpoints" ItemName="_UpdatedCompressionPublishEndpoints" />
    </ApplyCompressionNegotiation>
    <ItemGroup>
      <StaticWebAssetEndpoint Remove="@(_UpdatedCompressionPublishEndpoints)" />
      <StaticWebAssetEndpoint Include="@(_UpdatedCompressionPublishEndpoints)" />
    </ItemGroup>
  </Target>
  <Target Name="GeneratePublishCompressedStaticWebAssets" DependsOnTargets="$(CompressFilesForPublishDependsOn);$(GeneratePublishCompressedStaticWebAssetsDependsOn)">
    <ItemGroup>
      <_GZipCompressedStaticWebAssetsForPublish Include="@(_CompressedStaticWebAssetsForPublish)" Condition="'%(AssetTraitName)' == 'Content-Encoding' and '%(AssetTraitValue)' == 'gzip'" />
      <_BrotliCompressedStaticWebAssetsForPublish Include="@(_CompressedStaticWebAssetsForPublish)" Condition="'%(AssetTraitName)' == 'Content-Encoding' and '%(AssetTraitValue)' == 'br'" />
    </ItemGroup>
    <GZipCompress Condition="'@(_GZipCompressedStaticWebAssetsForPublish)' != ''" FilesToCompress="@(_GZipCompressedStaticWebAssetsForPublish)" />
    <BrotliCompress Condition="'@(_BrotliCompressedStaticWebAssetsForPublish)' != ''" FilesToCompress="@(_BrotliCompressedStaticWebAssetsForPublish)" CompressionLevel="$(_BlazorBrotliCompressionLevel)" ToolAssembly="$(_StaticWebAssetsSdkToolAssembly)" ToolExe="$(_DotNetHostFileName)" ToolPath="$(_DotNetHostDirectory)" />
    <ItemGroup>
      <FileWrites Include="@(_GZipCompressedStaticWebAssetsForPublish)" />
      <FileWrites Include="@(_BrotliCompressedStaticWebAssetsForPublish)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolvePublishCompressedStaticWebAssetsConfiguration" DependsOnTargets="ResolvePublishStaticWebAssets;$(ResolveCompressedFilesForPublishDependsOn)">
    <PropertyGroup>
      <StaticWebAssetPublishCompressAllAssets Condition="'$(StaticWebAssetPublishCompressAllAssets)' == '' and '$(StaticWebAssetProjectMode)' == 'Root'">true</StaticWebAssetPublishCompressAllAssets>
      <StaticWebAssetPublishCompressAllAssets Condition="'$(StaticWebAssetPublishCompressAllAssets)' == ''">false</StaticWebAssetPublishCompressAllAssets>
    </PropertyGroup>
    <ItemGroup Condition="'$(StaticWebAssetPublishCompressAllAssets)' == 'true'">
      <_CandidateAssetsForPublish Include="@(StaticWebAsset)" Condition="'%(AssetKind)' != 'Build'" />
    </ItemGroup>
    <ItemGroup Condition="'$(StaticWebAssetPublishCompressAllAssets)' != 'true'">
      <_CandidateAssetsForPublish Include="@(StaticWebAsset)" Condition="'%(AssetKind)' != 'Build' and ('%(SourceType)' == 'Discovered' or '%(SourceType)' == 'Computed')" />
    </ItemGroup>
    <ResolveCompressedAssets CandidateAssets="@(_CandidateAssetsForPublish)" Formats="$(PublishCompressionFormats)" IncludePatterns="$(CompressionIncludePatterns)" ExcludePatterns="$(CompressionExcludePatterns)" ExplicitAssets="@(AssetToCompress)" OutputPath="$(IntermediateOutputPath)compressed\publish">
      <Output TaskParameter="AssetsToCompress" ItemName="_CompressedStaticWebAssetsForPublish" />
    </ResolveCompressedAssets>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.targets
============================================================================================================================================
-->
  <!--<Import Project="Microsoft.NET.Sdk.StaticWebAssets.ServiceWorker.targets" Condition="'$(ServiceWorkerAssetsManifest)' != ''" />-->
  <!--<Import Project="Microsoft.NET.Sdk.StaticWebAssets.HtmlAssetPlaceholders.targets" Condition="'$(OverrideHtmlAssetPlaceholders)' == 'true'" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Microsoft.NET.Sdk.StaticWebAssets.SingleTargeting.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/targets/Sdk.StaticWebAssets.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="Microsoft.NET.Sdk.StaticWebAssets.CrossTargeting.targets" Condition="'$(IsCrossTargetingBuild)' == 'true'" />-->
  <!--
    This is a hook to import a set of targets after the StaticWebAssets targets. By default this is unused.
  -->
  <!--<Import Project="$(CustomAfterStaticWebAssetsSdkTargets)" Condition="'$(CustomAfterStaticWebAssetsSdkTargets)' != '' and Exists('$(CustomAfterStaticWebAssetsSdkTargets)')" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.StaticWebAssets/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/Sdk/Sdk.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(RazorSdkCurrentVersionTargets)' == ''">
    <RazorSdkCurrentVersionTargets>$(MSBuildThisFileDirectory)..\targets\Sdk.Razor.CurrentVersion.targets</RazorSdkCurrentVersionTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(RazorSdkCurrentVersionTargets)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Sdk.Razor.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Sdk.Razor.CurrentVersion.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <EnableDefaultContentItems Condition=" '$(EnableDefaultContentItems)' == '' ">true</EnableDefaultContentItems>
  </PropertyGroup>
  <!--
    Targets supporting Razor MSBuild integration. Contain support for generating C# code using Razor
    and including the generated code in the project lifecycle, including compiling, publishing and producing
    nuget packages.
  -->
  <!--
    This is a hook to import a set of targets before the Razor targets. By default this is unused.
  -->
  <!--<Import Project="$(CustomBeforeRazorSdkTargets)" Condition="'$(CustomBeforeRazorSdkTargets)' != '' and Exists('$(CustomBeforeRazorSdkTargets)')" />-->
  <PropertyGroup>
    <!-- Paths to tools, tasks, and extensions are calculated relative to the RazorSdkDirectoryRoot. This can be modified to test a local build. -->
    <RazorSdkDirectoryRoot Condition="'$(RazorSdkDirectoryRoot)'==''">$(MSBuildThisFileDirectory)..\</RazorSdkDirectoryRoot>
    <RazorSdkBuildTasksDirectoryRoot Condition="'$(RazorSdkBuildTasksDirectoryRoot)'==''">$(RazorSdkDirectoryRoot)tasks\</RazorSdkBuildTasksDirectoryRoot>
    <_RazorSdkTasksTFM Condition=" '$(MSBuildRuntimeType)' == 'Core'">net10.0</_RazorSdkTasksTFM>
    <_RazorSdkTasksTFM Condition=" '$(_RazorSdkTasksTFM)' == ''">net472</_RazorSdkTasksTFM>
    <RazorSdkBuildTasksAssembly>$(RazorSdkBuildTasksDirectoryRoot)$(_RazorSdkTasksTFM)\Microsoft.NET.Sdk.Razor.Tasks.dll</RazorSdkBuildTasksAssembly>
    <_RazorSdkToolAssembly>$(RazorSdkDirectoryRoot)tools\rzc.dll</_RazorSdkToolAssembly>
  </PropertyGroup>
  <PropertyGroup Condition="'$(DOTNET_HOST_PATH)' == ''">
    <_RazorSdkDotNetHostDirectory>$(NetCoreRoot)</_RazorSdkDotNetHostDirectory>
    <_RazorSdkDotNetHostFileName>dotnet</_RazorSdkDotNetHostFileName>
    <_RazorSdkDotNetHostFileName Condition="'$(OS)' == 'Windows_NT'">dotnet.exe</_RazorSdkDotNetHostFileName>
  </PropertyGroup>
  <!-- Resolve the TFM-specific attributes conditionally. -->
  <Choose>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '10.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <_TargetingNET70OrLater>true</_TargetingNET70OrLater>
        <_TargetingNET80OrLater>true</_TargetingNET80OrLater>
        <_TargetingNET90OrLater>true</_TargetingNET90OrLater>
        <_TargetingNET100OrLater>true</_TargetingNET100OrLater>
        <UseRazorSourceGenerator Condition="'$(Language)' == 'C#' AND '$(UseRazorSourceGenerator)' == '' ">true</UseRazorSourceGenerator>
        <RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">9.0</RazorLangVersion>
        <_RazorUseRoslynTokenizer Condition="'$(_RazorUseRoslynTokenizer)'==''">true</_RazorUseRoslynTokenizer>
        <Features Condition="'$(_RazorUseRoslynTokenizer)'=='true'">use-roslyn-tokenizer=true;$(Features)</Features>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '9.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <_TargetingNET70OrLater>true</_TargetingNET70OrLater>
        <_TargetingNET80OrLater>true</_TargetingNET80OrLater>
        <_TargetingNET90OrLater>true</_TargetingNET90OrLater>
        <UseRazorSourceGenerator Condition="'$(Language)' == 'C#' AND '$(UseRazorSourceGenerator)' == '' ">true</UseRazorSourceGenerator>
        <RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">9.0</RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '8.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <_TargetingNET70OrLater>true</_TargetingNET70OrLater>
        <_TargetingNET80OrLater>true</_TargetingNET80OrLater>
        <UseRazorSourceGenerator Condition="'$(Language)' == 'C#' AND '$(UseRazorSourceGenerator)' == '' ">true</UseRazorSourceGenerator>
        <RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">8.0</RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '7.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <_TargetingNET70OrLater>true</_TargetingNET70OrLater>
        <UseRazorSourceGenerator Condition="'$(Language)' == 'C#' AND '$(UseRazorSourceGenerator)' == '' ">true</UseRazorSourceGenerator>
        <RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">7.0</RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '6.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <_TargetingNET60OrLater>true</_TargetingNET60OrLater>
        <UseRazorSourceGenerator Condition="'$(Language)' == 'C#' AND '$(UseRazorSourceGenerator)' == '' ">true</UseRazorSourceGenerator>
        <RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">6.0</RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '5.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <_TargetingNET50OrLater>true</_TargetingNET50OrLater>
        <UseRazorSourceGenerator>false</UseRazorSourceGenerator>
        <RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">5.0</RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '3.0')) ">
      <PropertyGroup>
        <_TargetingNETCoreApp30OrLater>true</_TargetingNETCoreApp30OrLater>
        <UseRazorSourceGenerator>false</UseRazorSourceGenerator>
        <RazorLangVersion Condition="'$(RazorLangVersion)' == '' ">3.0</RazorLangVersion>
      </PropertyGroup>
    </When>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '2.1')) ">
      <PropertyGroup>
        <_TargetingNETStandard21OrLater>true</_TargetingNETStandard21OrLater>
      </PropertyGroup>
    </When>
    <When Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard' AND $([MSBuild]::VersionGreaterThanOrEquals('$(TargetFrameworkVersion)', '2.0')) ">
      <PropertyGroup>
        <_TargetingNETStandard20OrLater>true</_TargetingNETStandard20OrLater>
      </PropertyGroup>
    </When>
  </Choose>
  <PropertyGroup>
    <!--
      In 3.0, we expect RazorLangVersion to either be specified in the template or inferred via TFM. In 2.x, RazorLangVersion is
      specified via the Razor.Design package. We'll default to a version of 2.1, the earliest version that the SDK supports.
      A 2.1 version should result in a build warning if the project contains Components.
    -->
    <RazorLangVersion Condition="'$(RazorLangVersion)' == ''">2.1</RazorLangVersion>
    <!-- Keep this in sync with RazorLangVersion.cs if we introduce new text based values. -->
    <_Targeting30OrNewerRazorLangVersion Condition="&#xA;        '$(RazorLangVersion)' == 'Latest' OR&#xA;        '$(RazorLangVersion)' == 'Experimental' OR&#xA;        ('$(RazorLangVersion)' != '' AND '$(RazorLangVersion)' &gt;= '3.0')">true</_Targeting30OrNewerRazorLangVersion>
  </PropertyGroup>
  <PropertyGroup>
    <!--
      The property IsRazorCompilerReferenced is defined by the 2.x Razor.Design package. We can use this as a best guess to determine if a project is targeting 2.x or earlier.
      This is useful to provide 3.0 or newer specific build warnings. However, since it's not very reliable, we should not use this to make build-altering decisions.
    -->
    <_IsTargetingRazor2X Condition="'$(IsRazorCompilerReferenced)'=='true'">true</_IsTargetingRazor2X>
  </PropertyGroup>
  <!--
    These are the targets that actually do compilation using CSC, separated from the main file for ease of maintenance.

    RazorCoreCompile and any other targets that are needed for two-step compilation should be defined there.
  -->
  <!--<Import Project="Microsoft.NET.Sdk.Razor.Compilation.targets" Condition="'$(UseRazorSourceGenerator)' != 'true'" />-->
  <!--
    Razor defines two primary targets:
      'RazorGenerate' - which updates generated code
      'RazorCompile' - compiles an assembly from generated code

    Use these properties and targets to attach behavior to the corresponding phase.
  -->
  <PropertyGroup>
    <PrepareForRazorGenerateDependsOn>
      ResolveRazorConfiguration;
      ResolveRazorGenerateInputs;
      AssignRazorGenerateTargetPaths;
      _ResolveGeneratedRazorCompileInputs;
      _CheckForIncorrectMvcConfiguration;
    </PrepareForRazorGenerateDependsOn>
    <PrepareForRazorGenerateDependsOn Condition="'$(UseRazorSourceGenerator)' != 'true'">
      $(PrepareForRazorGenerateDependsOn);
      ResolveAssemblyReferenceRazorGenerateInputs;
      _CheckForMissingRazorCompiler;
      ResolveTagHelperRazorGenerateInputs
    </PrepareForRazorGenerateDependsOn>
    <PrepareForRazorComponentGenerateDependsOn>
      ResolveRazorConfiguration;
      ResolveRazorComponentInputs;
      _CheckForIncorrectComponentsConfiguration;
      AssignRazorComponentTargetPaths;
    </PrepareForRazorComponentGenerateDependsOn>
    <RazorGenerateDependsOn>
      PrepareForRazorGenerate;
    </RazorGenerateDependsOn>
    <RazorGenerateDependsOn Condition="'$(UseRazorSourceGenerator)' != 'true'">
      $(RazorGenerateDependsOn);
      _CheckForMissingRazorCompiler;
      RazorCoreGenerate
    </RazorGenerateDependsOn>
    <RazorComponentGenerateDependsOn>
      PrepareForRazorComponentGenerate
    </RazorComponentGenerateDependsOn>
    <PrepareForRazorCompileDependsOn>
      RazorGenerate;
      ResolveRazorCompileInputs;
      GenerateRazorTargetAssemblyInfo
    </PrepareForRazorCompileDependsOn>
    <ResolveRazorCompileInputsDependsOn>
      ResolveRazorEmbeddedResources;
    </ResolveRazorCompileInputsDependsOn>
    <ResolveScopedCssOutputsDependsOn>
      $(ResolveScopedCssOutputsDependsOn);
      ResolveCssScopes;
    </ResolveScopedCssOutputsDependsOn>
    <DebugSymbolsProjectOutputGroupDependsOn>
      $(DebugSymbolsProjectOutputGroupDependsOn);
      _RazorAddDebugSymbolsProjectOutputGroupOutput
    </DebugSymbolsProjectOutputGroupDependsOn>
    <PrepareForBuildDependsOn>
      $(PrepareForBuildDependsOn);
      ResolveRazorGenerateInputs
    </PrepareForBuildDependsOn>
    <GenerateNuspecDependsOn>
      ResolveRazorGenerateInputs;
      $(GenerateNuspecDependsOn)
    </GenerateNuspecDependsOn>
    <PrepareForRunDependsOn>
      _RazorPrepareForRun;
      $(PrepareForRunDependsOn)
    </PrepareForRunDependsOn>
    <_RazorGenerateComponentDesignTimeDependsOn>
      ResolveRazorComponentInputs;
      AssignRazorComponentTargetPaths
    </_RazorGenerateComponentDesignTimeDependsOn>
  </PropertyGroup>
  <!--
    Default values for properties that affect Razor targets to the standard build lifecycle.
  -->
  <PropertyGroup Condition="'$(RazorCompileOnBuild)'=='' AND '$(Language)'=='C#'">
    <RazorCompileOnBuild>true</RazorCompileOnBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(RazorCompileOnPublish)'=='' AND '$(Language)'=='C#'">
    <!-- Always compile on publish by default if we're compiling on build -->
    <RazorCompileOnPublish Condition="'$(RazorCompileOnBuild)'=='true'">true</RazorCompileOnPublish>
    <!-- Compatibility with the old MVC Precompilation setting -->
    <RazorCompileOnPublish Condition="'$(RazorCompileOnPublish)'==''">$(MvcRazorCompileOnPublish)</RazorCompileOnPublish>
    <!-- Default to on if MvcRazorCompileOnPublish isn't set for some reason -->
    <RazorCompileOnPublish Condition="'$(RazorCompileOnPublish)'==''">true</RazorCompileOnPublish>
  </PropertyGroup>
  <!--
    Properties that configure Razor SDK, but need to be defined in targets due to evaluation order.
  -->
  <PropertyGroup>
    <!-- Output directory used for generated files -->
    <RazorGenerateIntermediateOutputPath Condition="'$(RazorGenerateIntermediateOutputPath)'==''">$(IntermediateOutputPath)Razor\</RazorGenerateIntermediateOutputPath>
    <_RazorComponentDeclarationOutputPath Condition="'$(_RazorComponentDeclarationOutputPath)'==''">$(IntermediateOutputPath)RazorDeclaration\</_RazorComponentDeclarationOutputPath>
    <!--
      Use the suffix .Views when producing compiled view assemblies. This matches the requirements for Mvc's ViewsFeatureProvider.
    -->
    <RazorTargetNameSuffix Condition="'$(RazorTargetNameSuffix)'=='' AND '$(_Targeting30OrNewerRazorLangVersion)' == 'true'">.Views</RazorTargetNameSuffix>
    <!-- Suffix appended to $(TargetName) to produce $(RazorTargetName), the name of the assembly produced by Razor -->
    <RazorTargetNameSuffix Condition="'$(RazorTargetNameSuffix)' == ''">.Razor</RazorTargetNameSuffix>
    <!-- File name (without extension) of the assembly produced by Razor -->
    <RazorTargetName Condition="'$(RazorTargetName)'==''">$(TargetName)$(RazorTargetNameSuffix)</RazorTargetName>
    <!--
      The compatibility zone - these properties were provided by the MVC Precompilation tool and they
      map to supported settings in Razor SDK.

      We want to set the defaults for these in the .props file, but we need to process the old settings here
      in case they were set in the project file. The consequence of this is that the old settings will override
      the new ones if they are set to conflicting values.
    -->
    <CopyRazorGenerateFilesToPublishDirectory Condition="'$(MvcRazorExcludeViewFilesFromPublish)'=='true'">false</CopyRazorGenerateFilesToPublishDirectory>
    <CopyRazorGenerateFilesToPublishDirectory Condition="'$(MvcRazorExcludeViewFilesFromPublish)'=='false'">true</CopyRazorGenerateFilesToPublishDirectory>
    <CopyRefAssembliesToPublishDirectory Condition="'$(MvcRazorExcludeRefAssembliesFromPublish)'=='true'">false</CopyRefAssembliesToPublishDirectory>
    <CopyRefAssembliesToPublishDirectory Condition="'$(MvcRazorExcludeRefAssembliesFromPublish)'=='false'">true</CopyRefAssembliesToPublishDirectory>
    <!-- Use PreserveCompilationReferences to determine the behavior of CopyRefAssembliesToPublishDirectory if not explicitly specified by the project. -->
    <CopyRefAssembliesToPublishDirectory Condition="'$(CopyRefAssembliesToPublishDirectory)'==''">$(PreserveCompilationReferences)</CopyRefAssembliesToPublishDirectory>
    <!-- For 2.x projects desktop and .NET Core projects, if they're opting in to runtime compilation (indicated by PreserveCompilationContext=true), set PreserveCompilationReferences = true -->
    <PreserveCompilationReferences Condition=" '$(PreserveCompilationContext)' == 'true' AND&#xA;      ('$(TargetFrameworkIdentifier)' == '.NETFramework' OR&#xA;       ('$(TargetFrameworkIdentifier)' == '.NETCoreApp' AND&#xA;        '$(_TargetingNETCoreApp30OrLater)' != 'true')) ">true</PreserveCompilationReferences>
    <!--
      We can't set the actual default value here due to evaluation order (depends on $(OutDir)).

      This handles a compatibility case with MVC Precompilation.
    -->
    <RazorOutputPath Condition="'$(MvcRazorOutputPath)'!=''">$([MSBuild]::EnsureTrailingSlash('$(MvcRazorOutputPath)'))</RazorOutputPath>
    <!--
      Configures whether all of the @(RazorGenerate) items will be added as embedded files to the produced assembly.

      When true, everything in @(RazorGenerate) will be added to @(RazorEmbeddedFiles) and passed to CSC.
    -->
    <EmbedRazorGenerateSources Condition="'$(MvcRazorEmbedViewSources)'!=''">$(MvcRazorEmbedViewSources)</EmbedRazorGenerateSources>
    <EmbedRazorGenerateSources Condition="'$(EmbedRazorGenerateSources)'==''">false</EmbedRazorGenerateSources>
    <!--
    Set to false to disable Razor code generation from using a persistent build server process.
    -->
    <UseRazorBuildServer Condition="'$(UseRazorBuildServer)'==''">$(UseSharedCompilation)</UseRazorBuildServer>
    <UseRazorBuildServer Condition="'$(UseRazorBuildServer)'==''">true</UseRazorBuildServer>
  </PropertyGroup>
  <PropertyGroup>
    <!-- Similar to https://github.com/Microsoft/msbuild/blob/908cc9ccd4961441628f68e37a148183a87bb067/src/Tasks/Microsoft.Common.CurrentVersion.targets#L146-L153 -->
    <_RazorDebugSymbolsProduced>false</_RazorDebugSymbolsProduced>
    <_RazorDebugSymbolsProduced Condition="'$(DebugSymbols)'=='true'">true</_RazorDebugSymbolsProduced>
    <_RazorDebugSymbolsProduced Condition="'$(DebugType)'=='none'">false</_RazorDebugSymbolsProduced>
    <_RazorDebugSymbolsProduced Condition="'$(DebugType)'=='pdbonly'">true</_RazorDebugSymbolsProduced>
    <_RazorDebugSymbolsProduced Condition="'$(DebugType)'=='full'">true</_RazorDebugSymbolsProduced>
    <_RazorDebugSymbolsProduced Condition="'$(DebugType)'=='portable'">true</_RazorDebugSymbolsProduced>
    <_RazorDebugSymbolsProduced Condition="'$(DebugType)'=='embedded'">false</_RazorDebugSymbolsProduced>
  </PropertyGroup>
  <!--
    Resolve the toolset to use. This specifically applies to compilation with 2.x projects where compilation could be performed either using
    the PrecompilationTool (Microsoft.AspNetCore.Mvc.Razor.ViewCompilation) or the RazorSDK and we have to infer the tool that is to be used.
    In 3.0 or later, there is only the RazorSdk.
   -->
  <PropertyGroup Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true'">
    <ResolvedRazorCompileToolset>RazorSdk</ResolvedRazorCompileToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(ResolvedRazorCompileToolset)' == ''">
    <!-- Default value for the property 'MvcRazorCompileOnPublish' is empty. If it has been explicitly enabled, continue using precompilation. -->
    <ResolvedRazorCompileToolset Condition="'$(MvcRazorCompileOnPublish)' == 'true'">PrecompilationTool</ResolvedRazorCompileToolset>
    <!-- The default value for 'RazorCompileToolset' was not modified. In this case, infer the toolset to use as RazorSdk. -->
    <ResolvedRazorCompileToolset Condition="'$(MvcRazorCompileOnPublish)' == '' AND '$(RazorCompileToolset)' == 'Implicit'">RazorSdk</ResolvedRazorCompileToolset>
    <ResolvedRazorCompileToolset Condition="'$(MvcRazorCompileOnPublish)' == '' AND '$(RazorCompileToolset)' == 'PrecompilationTool'">$(RazorCompileToolset)</ResolvedRazorCompileToolset>
    <ResolvedRazorCompileToolset Condition="'$(MvcRazorCompileOnPublish)' == '' AND '$(RazorCompileToolset)' == 'RazorSdk'">$(RazorCompileToolset)</ResolvedRazorCompileToolset>
    <!-- If RazorSdk is not referenced, fall-back to Precompilation tool when referenced by a 2.2 or earlier targeting project. -->
    <ResolvedRazorCompileToolset Condition="'$(ResolvedRazorCompileToolset)' == 'RazorSdk' And '$(IsRazorCompilerReferenced)' != 'true'">PrecompilationTool</ResolvedRazorCompileToolset>
    <!-- Previous versions of the precompilation tool still depends on the msbuild property 'MvcRazorCompileOnPublish'. Hence, setting it to the old default value -->
    <MvcRazorCompileOnPublish Condition="'$(MvcRazorCompileOnPublish)' == ''">true</MvcRazorCompileOnPublish>
  </PropertyGroup>
  <!-- Back-compat for PrecompilationTool -->
  <PropertyGroup>
    <!--
      For 2.x desktop targeting projects using MvcPrecompilation, ref assemblies are required to compile the PrecompiledViews.dll,
      but are removed by the tool once done. Set PreserveCompilationReferences = true, ignoring any value configured in the project,
      if the project is using the precompilation tool.
    -->
    <PreserveCompilationReferences Condition="'$(ResolvedRazorCompileToolset)'=='PrecompilationTool'">true</PreserveCompilationReferences>
  </PropertyGroup>
  <!--
    Properties that configure Razor SDK, but need to be defined in targets due to evaluation order.
  -->
  <ItemGroup>
    <!-- Used to creating the final compiled Razor dll -->
    <RazorIntermediateAssembly Condition="'$(RazorIntermediateAssembly)'==''" Include="$(IntermediateOutputPath)$(RazorTargetName).dll" />
    <!-- Used in Compilation.targets -->
    <_RazorDebugSymbolsIntermediatePath Condition="'$(_RazorDebugSymbolsProduced)'=='true'" Include="$(IntermediateOutputPath)$(RazorTargetName).pdb" />
  </ItemGroup>
  <ItemGroup>
    <!--
      Add all .razor files to UpToDateCheckInput. Component compilation is not controlled by RazorCompileOnBuild,
      which is why this itemgroup is unconditional.
    -->
    <UpToDateCheckInput Include="@(Content-&gt;WithMetadataValue('Extension', '.razor'))" />
  </ItemGroup>
  <!-- For apps building with the source generator, a separate Views assembly is produced out of the source
  CSHTML files. In that scenario, the source CSHTML files and the output assembly
  are treated in a separate set. -->
  <ItemGroup Condition="'$(UseRazorSourceGenerator)' != 'true'">
    <!--
      Add all cshtml files to UpToDateCheckInput - a collection of files used by FastUpToDateCheck to determine
      if any of the the project inputs have changed.
    -->
    <UpToDateCheckInput Condition="'$(RazorCompileOnBuild)'=='true'" Include="@(Content-&gt;WithMetadataValue('Extension', '.cshtml'))" Set="RazorViews" />
    <!--
      Add Razor output files to UpToDateCheckBuilt - a collection of files used by FastUpToDateCheck to determine
      if any of the project's outputs have changed.
    -->
    <UpToDateCheckBuilt Include="@(RazorIntermediateAssembly)" Condition="'$(RazorCompileOnBuild)'=='true' AND '@(Content-&gt;WithMetadataValue('Extension', '.cshtml'))' != ''" Set="RazorViews" />
  </ItemGroup>
  <!-- For apps building with the source generator, add .cshtml files to the default set since they are compiled into the app binary. -->
  <ItemGroup Condition="'$(UseRazorSourceGenerator)' == 'true'">
    <UpToDateCheckInput Include="@(Content-&gt;WithMetadataValue('Extension', '.cshtml'))" />
  </ItemGroup>
  <!--
    These are the targets that generate code using Razor, separated from the main file for ease of maintenance.
    Most targets related to Razor code generation are defined there.
  -->
  <!-- Determine what compiler and versions of the language to target. For 2.x targeting projects, these are carried by packages referenced by the project. Use this -->
  <!-- When targeting 3.x and later projects, we have to infer configuration by inspecting the project. -->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Razor.Configuration.targets" Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Microsoft.NET.Sdk.Razor.Configuration.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.Net.Sdk.Razor.Versions.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
      Initialize properties and items inferred using the project version. This file is not imported in projects referencing
      MVC \ Razor 2.2 or earlier since values specified here are provided via targets and props imported from NuGet packages
      such as Microsoft.AspNetCore.Razor.Design.

      The properties and items here are designed to be read by CPS so they should be just simple evaluation-time values
      and should not require targets to initialize.

      Also, these values are based on whether the library is targeting netcoreapp3.0 for now. A better heuristic
      would be to detect whether the ASP.NET Core shared framework is referenced.
  -->
  <PropertyGroup>
    <!-- Continue setting this property to maintain compat with legacy Razor.Design -->
    <IsRazorCompilerReferenced Condition="'$(IsRazorCompilerReferenced)'==''">true</IsRazorCompilerReferenced>
  </PropertyGroup>
  <!--
      Resolve MVC specific configuration depending on the presence of MVC specific Razor files.
  -->
  <Target Name="_ResolveMvcAssemblyAttributes" DependsOnTargets="ResolveRazorGenerateInputs" Condition="'$(Language)' == 'C#' AND '$(AddRazorSupportForMvc)' == 'true'">
    <PropertyGroup Condition="'@(RazorGenerate-&gt;Count())' != '0'">
      <!--
        MVC uses a ProvideApplicationPartFactoryAttribute on the generated assembly to load compiled views from assembly. Set this to false, to prevent generating this attribute.
      -->
      <GenerateProvideApplicationPartFactoryAttribute Condition="'$(GenerateProvideApplicationPartFactoryAttribute)'==''">true</GenerateProvideApplicationPartFactoryAttribute>
      <!--
        Determines if the Sdk is allowed to add additional attributes to the project assembly.
        For instance, MVC will generally want to add attributes to support view discovery and runtime compilation.
      -->
      <GenerateRazorAssemblyInfo Condition="'$(GenerateRazorAssemblyInfo)'==''">true</GenerateRazorAssemblyInfo>
      <!--
        The type name of the ApplicationPartFactory applied to the generated Razor file.
      -->
      <ProvideApplicationPartFactoryAttributeTypeName Condition="'$(ProvideApplicationPartFactoryAttributeTypeName)' == ''">Microsoft.AspNetCore.Mvc.ApplicationParts.CompiledRazorAssemblyApplicationPartFactory, Microsoft.AspNetCore.Mvc.Razor</ProvideApplicationPartFactoryAttributeTypeName>
    </PropertyGroup>
    <ItemGroup Condition="'$(GenerateProvideApplicationPartFactoryAttribute)' == 'true' AND '$(ProvideApplicationPartFactoryAttributeTypeName)'!=''">
      <RazorTargetAssemblyAttribute Include="Microsoft.AspNetCore.Mvc.ApplicationParts.ProvideApplicationPartFactoryAttribute">
        <_Parameter1>$(ProvideApplicationPartFactoryAttributeTypeName)</_Parameter1>
      </RazorTargetAssemblyAttribute>
    </ItemGroup>
    <ItemGroup Condition="'$(GenerateRazorAssemblyInfo)'=='true'&#xA;        AND '$(ResolvedRazorCompileToolset)'=='RazorSdk'&#xA;        AND ('$(RazorCompileOnBuild)' == 'true'&#xA;        OR '$(RazorCompileOnPublish)' == 'true')&#xA;        AND '$(UseRazorSourceGenerator)' != 'true'">
      <_RazorAssemblyAttribute Include="Microsoft.AspNetCore.Mvc.ApplicationParts.RelatedAssemblyAttribute">
        <_Parameter1>$(RazorTargetName)</_Parameter1>
      </_RazorAssemblyAttribute>
    </ItemGroup>
  </Target>
  <!--
    Determine the default Razor configuration
  -->
  <PropertyGroup Condition="'$(RazorDefaultConfiguration)'==''">
    <!-- For 5.0, we're not introducing any new language features for MVC. We can continue using the 3.0 configuration \ extension for MVC support. -->
    <RazorDefaultConfiguration Condition="'$(AddRazorSupportForMvc)'=='true'">MVC-3.0</RazorDefaultConfiguration>
    <RazorDefaultConfiguration Condition="'$(RazorDefaultConfiguration)'==''">Default</RazorDefaultConfiguration>
  </PropertyGroup>
  <ItemGroup>
    <!--
      While technically the assembly in this package can provide support for the MVC-2.X, don't declare
      it here. The IDE is hardcoded to inject 2.0 support when needed. The settings flowing through MSBuild should reflect
      the project's runtime.
    -->
    <RazorConfiguration Include="Default" />
    <RazorConfiguration Include="MVC-3.0">
      <Extensions>MVC-3.0;$(CustomRazorExtension)</Extensions>
    </RazorConfiguration>
  </ItemGroup>
  <ItemGroup>
    <RazorExtension Include="MVC-3.0">
      <AssemblyName>Microsoft.CodeAnalysis.Razor.Compiler</AssemblyName>
      <AssemblyFilePath>$(RazorSdkDirectoryRoot)tools\Microsoft.CodeAnalysis.Razor.Compiler.dll</AssemblyFilePath>
    </RazorExtension>
  </ItemGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Sdk.Razor.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Razor.CodeGeneration.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Microsoft.NET.Sdk.Razor.CodeGeneration.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Razor.CodeGeneration

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <!--
    Targets used for Razor SDK code generation. Support for the RazorCoreGenerate target.
    This target is explicitly imported by Razor SDK.
  -->
  <UsingTask TaskName="Microsoft.AspNetCore.Razor.Tasks.SdkRazorGenerate" AssemblyFile="$(RazorSdkBuildTasksAssembly)" Condition="'$(RazorSdkBuildTasksAssembly)' != ''" />
  <UsingTask TaskName="Microsoft.AspNetCore.Razor.Tasks.SdkRazorTagHelper" AssemblyFile="$(RazorSdkBuildTasksAssembly)" Condition="'$(RazorSdkBuildTasksAssembly)' != ''" />
  <!--
    Consider these properties to be private to this targets file. The main Razor SDK should define all of the properties
    that we use to pass data back and forth.
  -->
  <PropertyGroup>
    <!-- Used for tag helper discovery -->
    <_RazorTagHelperInputCache>$(IntermediateOutputPath)$(TargetName).TagHelpers.input.cache</_RazorTagHelperInputCache>
    <_RazorTagHelperOutputCache>$(IntermediateOutputPath)$(TargetName).TagHelpers.output.cache</_RazorTagHelperOutputCache>
    <!-- Used to hash file inputs for RazorGenerate -->
    <_RazorGenerateInputsHash />
    <_RazorGenerateInputsHashFile>$(IntermediateOutputPath)$(MSBuildProjectName).RazorCoreGenerate.cache</_RazorGenerateInputsHashFile>
  </PropertyGroup>
  <!--
    This target will only be called when we have some .cshtml files that are going to participate in code generation.

    This is part of the chain of targets that are called once we've actually committed to generating code.
  -->
  <Target Name="_HashRazorGenerateInputs" Condition="'@(RazorGenerateWithTargetPath)' != ''">
    <Hash ItemsToHash="@(RazorGenerateWithTargetPath)">
      <Output TaskParameter="HashResult" PropertyName="_RazorGenerateInputsHash" />
    </Hash>
    <MakeDir Directories="$(IntermediateOutputPath)" Condition="!Exists('$(IntermediateOutputPath)')" />
    <WriteLinesToFile Lines="$(_RazorGenerateInputsHash)" File="$(_RazorGenerateInputsHashFile)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(_RazorGenerateInputsHashFile)" />
    </ItemGroup>
  </Target>
  <!-- Force a Compile to happen if we are not doing a components build. This keeps parity with 2.x CodeGeneration targets -->
  <Target Name="_RazorEnsureCompiled" Condition="'$(_RazorComponentDeclarationAssemblyFullPath)' == ''" DependsOnTargets="Compile" />
  <Target Name="ResolveTagHelperRazorGenerateInputs" Inputs="$(MSBuildAllProjects);@(RazorReferencePath)" DependsOnTargets="_RazorEnsureCompiled" Outputs="$(_RazorTagHelperInputCache)" Condition="'@(RazorGenerateWithTargetPath)' != ''">
    <!--
      We're manipulating our output directly here because we want to separate the actual up-to-date check
      of RazorCoreGenerate from the output of this target. Many times the set of tag helpers doesn't change
      so we don't need to regenerate the code.
      -->
    <Touch Files="$(_RazorTagHelperInputCache)" AlwaysCreate="true" />
    <ItemGroup>
      <FileWrites Include="$(_RazorTagHelperInputCache)" />
    </ItemGroup>
    <SdkRazorTagHelper Debug="$(_RazorDebugTagHelperTask)" DebugTool="$(_RazorDebugTagHelperTool)" ToolAssembly="$(_RazorSdkToolAssembly)" ToolExe="$(_RazorSdkDotNetHostFileName)" ToolPath="$(_RazorSdkDotNetHostDirectory)" UseServer="$(UseRazorBuildServer)" ForceServer="$(_RazorForceBuildServer)" PipeName="$(_RazorBuildServerPipeName)" Version="$(RazorLangVersion)" Configuration="@(ResolvedRazorConfiguration)" Extensions="@(ResolvedRazorExtension)" Assemblies="@(RazorReferencePath)" ProjectRoot="$(MSBuildProjectDirectory)" TagHelperManifest="$(_RazorTagHelperOutputCache)">
      <Output TaskParameter="TagHelperManifest" ItemName="FileWrites" />
    </SdkRazorTagHelper>
  </Target>
  <Target Name="_ResolveRazorGenerateOutputs" Condition="'@(RazorGenerateWithTargetPath)' != ''">
    <Error Text="RazorGenerateWithTargetPath item '%(RazorGenerateWithTargetPath.Identity)' does not specify required metadata 'GeneratedOutput'." Condition="'%(RazorGenerateWithTargetPath.GeneratedOutput)' == ''" />
    <ItemGroup>
      <_RazorGenerateOutput Include="%(RazorGenerateWithTargetPath.GeneratedOutput)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <RazorCoreGenerateDependsOn>
      _HashRazorGenerateInputs;
      _ResolveRazorGenerateOutputs;
    </RazorCoreGenerateDependsOn>
  </PropertyGroup>
  <Target Name="RazorCoreGenerate" DependsOnTargets="$(RazorCoreGenerateDependsOn)" Inputs="$(MSBuildAllProjects);$(_RazorGenerateInputsHashFile);$(_RazorTagHelperOutputCache);@(RazorGenerateWithTargetPath)" Outputs="@(_RazorGenerateOutput)" Condition="'@(RazorGenerateWithTargetPath)'!= ''">
    <RemoveDir Directories="$(RazorGenerateIntermediateOutputPath)" Condition="Exists('$(RazorGenerateIntermediateOutputPath)')" />
    <MakeDir Directories="%(_RazorGenerateOutput.RelativeDir)" Condition="!Exists('%(_RazorGenerateOutput.RelativeDir)')" />
    <SdkRazorGenerate Debug="$(_RazorDebugGenerateCodeTask)" DebugTool="$(_RazorDebugGenerateCodeTool)" ToolAssembly="$(_RazorSdkToolAssembly)" ToolExe="$(_RazorSdkDotNetHostFileName)" ToolPath="$(_RazorSdkDotNetHostDirectory)" UseServer="$(UseRazorBuildServer)" ForceServer="$(_RazorForceBuildServer)" PipeName="$(_RazorBuildServerPipeName)" Version="$(RazorLangVersion)" RootNamespace="$(RootNamespace)" CSharpLanguageVersion="$(LangVersion)" Configuration="@(ResolvedRazorConfiguration)" Extensions="@(ResolvedRazorExtension)" Sources="@(RazorGenerateWithTargetPath)" ProjectRoot="$(MSBuildProjectDirectory)" TagHelperManifest="$(_RazorTagHelperOutputCache)" SupportLocalizedComponentNames="$(SupportLocalizedComponentNames)" />
    <ItemGroup>
      <FileWrites Include="@(_RazorGenerateOutput)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <ResolveRazorCompileInputsDependsOn>$(ResolveRazorCompileInputsDependsOn)</ResolveRazorCompileInputsDependsOn>
  </PropertyGroup>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Sdk.Razor.CurrentVersion.targets
============================================================================================================================================
-->
  <!--<Import Project="Microsoft.NET.Sdk.Razor.Component.targets" Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true' AND '$(UseRazorSourceGenerator)' != 'true'" />-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Razor.SourceGenerators.targets" Condition="'$(UseRazorSourceGenerator)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Microsoft.NET.Sdk.Razor.SourceGenerators.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Razor.SourceGenerators.targets
WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.
Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="Microsoft.AspNetCore.Razor.Tasks.EncodeRazorInputItem" AssemblyFile="$(RazorSdkBuildTasksAssembly)" />
  <Target Name="_PrepareRazorSourceGenerators" BeforeTargets="GenerateMSBuildEditorConfigFileShouldRun" DependsOnTargets="PrepareForRazorGenerate;PrepareForRazorComponentGenerate">
    <PropertyGroup>
      <_RazorSdkSourceGeneratorDirectoryRoot>$(RazorSdkDirectoryRoot)\source-generators\</_RazorSdkSourceGeneratorDirectoryRoot>
      <ProvideApplicationPartFactoryAttributeTypeName Condition="'$(ProvideApplicationPartFactoryAttributeTypeName)' == ''">Microsoft.AspNetCore.Mvc.ApplicationParts.ConsolidatedAssemblyApplicationPartFactory, Microsoft.AspNetCore.Mvc.Razor</ProvideApplicationPartFactoryAttributeTypeName>
    </PropertyGroup>
    <PropertyGroup>
      <RazorEncConfigFile>$(_RazorSdkSourceGeneratorDirectoryRoot)RazorSourceGenerator.razorencconfig</RazorEncConfigFile>
    </PropertyGroup>
    <ItemGroup>
      <EditorConfigFiles Include="$(RazorEncConfigFile)" Condition="'$(DesignTimeBuild)' == 'true' AND '$(BuildingInsideVisualStudio)' == 'true'" />
    </ItemGroup>
    <ItemGroup>
      <_RazorAnalyzer Include="$(_RazorSdkSourceGeneratorDirectoryRoot)*.dll" />
    </ItemGroup>
    <!-- Configure analyzers -->
    <ItemGroup>
      <Analyzer Include="@(_RazorAnalyzer)" />
      <RazorComponentWithTargetPath GeneratedOutputFullPath="$([System.IO.Path]::GetFullPath(%(GeneratedOutput)))" GeneratedDeclarationFullPath="$([System.IO.Path]::GetFullPath(%(GeneratedDeclaration)))" />
      <RazorGenerateWithTargetPath GeneratedOutputFullPath="$([System.IO.Path]::GetFullPath(%(GeneratedOutput)))" />
    </ItemGroup>
    <ItemGroup>
      <!-- Additional metadata and properties that we want the compiler to pass to   the compiler we want to pass additional MSBuild properties \ metadata -->
      <CompilerVisibleItemMetadata Include="AdditionalFiles" MetadataName="TargetPath" />
      <CompilerVisibleItemMetadata Include="AdditionalFiles" MetadataName="CssScope" />
      <CompilerVisibleProperty Include="RazorLangVersion" />
      <CompilerVisibleProperty Include="RootNamespace" />
      <CompilerVisibleProperty Include="SupportLocalizedComponentNames" />
      <CompilerVisibleProperty Include="GenerateRazorMetadataSourceChecksumAttributes" />
      <CompilerVisibleProperty Include="MSBuildProjectDirectory" />
      <CompilerVisibleProperty Include="_RazorSourceGeneratorDebug" />
    </ItemGroup>
    <ItemGroup>
      <!-- Pass razor files to the compiler. -->
      <_RazorAdditionalFile Include="@(RazorComponentWithTargetPath)" />
      <!-- Ignore .cshtml files if RazorCompileOnBuild=false -->
      <_RazorAdditionalFile Include="@(RazorGenerateWithTargetPath)" Condition="'$(RazorCompileOnBuild)' != 'false'" />
    </ItemGroup>
    <ItemGroup Condition="@(_RazorAdditionalFile-&gt;WithMetadataValue('Extension', '.cshtml')-&gt;Count()) &gt; 0">
      <_RazorAssemblyAttribute Include="Microsoft.AspNetCore.Mvc.ApplicationParts.ProvideApplicationPartFactoryAttribute">
        <_Parameter1>$(ProvideApplicationPartFactoryAttributeTypeName)</_Parameter1>
      </_RazorAssemblyAttribute>
    </ItemGroup>
    <EncodeRazorInputItem RazorInputItems="@(_RazorAdditionalFile)">
      <Output TaskParameter="EncodedRazorInputItems" ItemName="_RazorSpecialCharacterWorkaround" />
    </EncodeRazorInputItem>
    <ItemGroup>
      <_RazorAdditionalFile Remove="@(_RazorAdditionalFile)" />
      <_RazorAdditionalFile Include="@(_RazorSpecialCharacterWorkaround)" />
      <AdditionalFiles Include="@(_RazorAdditionalFile)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Sdk.Razor.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Razor.GenerateAssemblyInfo.targets">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Microsoft.NET.Sdk.Razor.GenerateAssemblyInfo.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Razor.GenerateAssemblyInfo.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!-- Determines if the generated Razor assembly includes an auto-generated assembly info. -->
    <GenerateRazorTargetAssemblyInfo Condition="'$(GenerateRazorTargetAssemblyInfo)'==''">true</GenerateRazorTargetAssemblyInfo>
    <!-- Set to true, to automatically include some AssemblyAttributes inferred from the project metadata in the generated Razor assembly -->
    <EnableDefaultRazorTargetAssemblyInfoAttributes Condition="'$(EnableDefaultRazorTargetAssemblyInfoAttributes)'==''">true</EnableDefaultRazorTargetAssemblyInfoAttributes>
    <!-- AssemblyInfo that gets added to the generated Razor dll -->
    <RazorTargetAssemblyInfo Condition="'$(RazorTargetAssemblyInfo)'==''">$(IntermediateOutputPath)$(MSBuildProjectName).RazorTargetAssemblyInfo.cs</RazorTargetAssemblyInfo>
    <_RazorTargetAssemblyInfoInputsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectName).RazorTargetAssemblyInfo.cache</_RazorTargetAssemblyInfoInputsCacheFile>
    <!-- AssemblyInfo that gets added to the project being compiled -->
    <_RazorAssemblyInfo>$(IntermediateOutputPath)$(MSBuildProjectName).RazorAssemblyInfo.cs</_RazorAssemblyInfo>
    <_RazorAssemblyInfoInputsCacheFile>$(IntermediateOutputPath)$(MSBuildProjectName).RazorAssemblyInfo.cache</_RazorAssemblyInfoInputsCacheFile>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateRazorTargetAssemblyInfoDependsOn>
      GetRazorTargetAssemblyAttributes;
      _CreateRazorTargetAssemblyInfoInputsCacheFile;
      CoreGenerateRazorTargetAssemblyInfo
    </GenerateRazorTargetAssemblyInfoDependsOn>
    <GenerateRazorTargetAssemblyInfoDependsOn Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true'">
      _ResolveMvcAssemblyAttributes;
      $(GenerateRazorTargetAssemblyInfoDependsOn)
    </GenerateRazorTargetAssemblyInfoDependsOn>
  </PropertyGroup>
  <Target Name="GenerateRazorTargetAssemblyInfo" DependsOnTargets="$(GenerateRazorTargetAssemblyInfoDependsOn)" />
  <Target Name="CoreGenerateRazorTargetAssemblyInfo" Inputs="$(_RazorTargetAssemblyInfoInputsCacheFile)" Outputs="$(RazorTargetAssemblyInfo)" Condition="'$(GenerateRazorTargetAssemblyInfo)'=='true' AND '@(RazorCompile)'!=''">
    <ItemGroup Condition="'$(GenerateRazorTargetAssemblyInfo)'=='true'">
      <!-- Ensure the generated assemblyinfo file is not already part of RazorCompile sources -->
      <RazorCompile Remove="$(RazorTargetAssemblyInfo)" />
      <RazorCompile Include="$(RazorTargetAssemblyInfo)" />
    </ItemGroup>
    <WriteCodeFragment AssemblyAttributes="@(RazorTargetAssemblyAttribute)" Language="C#" OutputFile="$(RazorTargetAssemblyInfo)" />
    <ItemGroup>
      <FileWrites Include="$(RazorTargetAssemblyInfo)" />
    </ItemGroup>
  </Target>
  <Target Name="GetRazorTargetAssemblyAttributes" DependsOnTargets="GetAssemblyVersion" Condition="'$(EnableDefaultRazorTargetAssemblyInfoAttributes)'=='true'">
    <PropertyGroup>
      <RazorAssemblyFileVersion Condition="'$(RazorAssemblyFileVersion)' == ''">$(FileVersion)</RazorAssemblyFileVersion>
      <RazorAssemblyInformationalVersion Condition="'$(RazorAssemblyInformationalVersion)' == ''">$(InformationalVersion)</RazorAssemblyInformationalVersion>
      <RazorAssemblyDescription Condition="'$(RazorAssemblyDescription)'==''">$(Description)</RazorAssemblyDescription>
      <RazorAssemblyTitle Condition="'$(RazorAssemblyTitle)'==''">$(RazorTargetName)</RazorAssemblyTitle>
      <RazorAssemblyVersion Condition="'$(RazorAssemblyVersion)' == ''">$(AssemblyVersion)</RazorAssemblyVersion>
    </PropertyGroup>
    <ItemGroup>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyCompanyAttribute" Condition="'$(Company)' != '' and '$(GenerateAssemblyCompanyAttribute)' == 'true'">
        <_Parameter1>$(Company)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyConfigurationAttribute" Condition="'$(Configuration)' != '' and '$(GenerateAssemblyConfigurationAttribute)' == 'true'">
        <_Parameter1>$(Configuration)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyCopyrightAttribute" Condition="'$(Copyright)' != '' and '$(GenerateAssemblyCopyrightAttribute)' == 'true'">
        <_Parameter1>$(Copyright)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyProductAttribute" Condition="'$(Product)' != '' and '$(GenerateAssemblyProductAttribute)' == 'true'">
        <_Parameter1>$(Product)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Resources.NeutralResourcesLanguageAttribute" Condition="'$(NeutralLanguage)' != '' and '$(GenerateNeutralResourcesLanguageAttribute)' == 'true'">
        <_Parameter1>$(NeutralLanguage)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyDescriptionAttribute" Condition="'$(RazorAssemblyDescription)' != '' and '$(GenerateAssemblyDescriptionAttribute)' == 'true'">
        <_Parameter1>$(RazorAssemblyDescription)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyFileVersionAttribute" Condition="'$(RazorAssemblyFileVersion)' != '' and '$(GenerateAssemblyFileVersionAttribute)' == 'true'">
        <_Parameter1>$(RazorAssemblyFileVersion)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyInformationalVersionAttribute" Condition="'$(RazorAssemblyInformationalVersion)' != '' and '$(GenerateAssemblyInformationalVersionAttribute)' == 'true'">
        <_Parameter1>$(RazorAssemblyInformationalVersion)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyTitleAttribute" Condition="'$(RazorAssemblyTitle)' != '' and '$(GenerateAssemblyTitleAttribute)' == 'true'">
        <_Parameter1>$(RazorAssemblyTitle)</_Parameter1>
      </RazorTargetAssemblyAttribute>
      <RazorTargetAssemblyAttribute Include="System.Reflection.AssemblyVersionAttribute" Condition="'$(RazorAssemblyVersion)' != '' and '$(GenerateAssemblyVersionAttribute)' == 'true'">
        <_Parameter1>$(RazorAssemblyVersion)</_Parameter1>
      </RazorTargetAssemblyAttribute>
    </ItemGroup>
  </Target>
  <!--
    To allow version changes to be respected on incremental builds (e.g. through CLI parameters),
    create a hash of all assembly attributes so that the cache file will change with the calculated
    assembly attribute values and msbuild will then execute CoreGenerateAssembly to generate a new file.
  -->
  <Target Name="_CreateRazorTargetAssemblyInfoInputsCacheFile" Condition="'@(RazorTargetAssemblyAttribute)' != ''">
    <!-- We only use up to _Parameter1 for most attributes, but other targets may add additional assembly attributes with multiple parameters. -->
    <Hash ItemsToHash="@(RazorTargetAssemblyAttribute->'%(Identity)%(_Parameter1)%(_Parameter2)%(_Parameter3)%(_Parameter4)%(_Parameter5)%(_Parameter6)%(_Parameter7)%(_Parameter8)')">
      <Output TaskParameter="HashResult" PropertyName="_RazorTargetAssemblyAttributesHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_RazorTargetAssemblyAttributesHash)" File="$(_RazorTargetAssemblyInfoInputsCacheFile)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(_RazorTargetAssemblyInfoInputsCacheFile)" />
    </ItemGroup>
  </Target>
  <Target Name="_CreateRazorAssemblyInfoInputsCacheFile" Condition="'@(_RazorAssemblyAttribute)' != ''">
    <!-- We only use up to _Parameter1 for most attributes, but other targets may add additional assembly attributes with multiple parameters. -->
    <Hash ItemsToHash="@(_RazorAssemblyAttribute->'%(Identity)%(_Parameter1)%(_Parameter2)%(_Parameter3)%(_Parameter4)%(_Parameter5)%(_Parameter6)%(_Parameter7)%(_Parameter8)')">
      <Output TaskParameter="HashResult" PropertyName="_RazorAssemblyAttributesHash" />
    </Hash>
    <WriteLinesToFile Lines="$(_RazorAssemblyAttributesHash)" File="$(_RazorAssemblyInfoInputsCacheFile)" Overwrite="True" WriteOnlyWhenDifferent="True" />
    <ItemGroup>
      <FileWrites Include="$(_RazorAssemblyInfoInputsCacheFile)" />
    </ItemGroup>
  </Target>
  <Target Name="_CoreGenerateRazorAssemblyInfo" DependsOnTargets="_CreateRazorAssemblyInfoInputsCacheFile" Inputs="$(_RazorAssemblyInfoInputsCacheFile)" Outputs="$(_RazorAssemblyInfo)" Condition="'$(GenerateRazorAssemblyInfo)' == 'true' AND '@(_RazorAssemblyAttribute)' != ''">
    <ItemGroup>
      <Compile Remove="$(_RazorAssemblyInfo)" />
      <Compile Include="$(_RazorAssemblyInfo)" />
    </ItemGroup>
    <WriteCodeFragment AssemblyAttributes="@(_RazorAssemblyAttribute)" Language="$(Language)" OutputFile="$(_RazorAssemblyInfo)" />
    <ItemGroup>
      <FileWrites Include="$(_RazorAssemblyInfo)" />
    </ItemGroup>
  </Target>
  <PropertyGroup>
    <!-- Generate attributes in the main assembly if we're targeting a C# project and using the Razor Sdk. -->
    <CoreCompileDependsOn Condition="'$(ResolvedRazorCompileToolset)'=='RazorSdk' and '$(Language)' == 'C#'">
      $(CoreCompileDependsOn);
      _GenerateRazorAssemblyInfo
    </CoreCompileDependsOn>
    <_GenerateRazorAssemblyInfoDependsOn>RazorGetAssemblyAttributes;PrepareForBuild;_CoreGenerateRazorAssemblyInfo</_GenerateRazorAssemblyInfoDependsOn>
    <!-- In 3.0 or later, we need to invoke a target to determine MVC specific configuration. -->
    <_GenerateRazorAssemblyInfoDependsOn Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true'">
      _ResolveMvcAssemblyAttributes;
      $(_GenerateRazorAssemblyInfoDependsOn);
    </_GenerateRazorAssemblyInfoDependsOn>
  </PropertyGroup>
  <Target Name="_GenerateRazorAssemblyInfo" DependsOnTargets="$(_GenerateRazorAssemblyInfoDependsOn)" />
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Sdk.Razor.CurrentVersion.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  <Import Project="Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets" Condition="'$(_TargetingNETCoreApp30OrLater)' == 'true'">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Microsoft.NET.Sdk.Razor.MvcApplicationPartsDiscovery.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Razor.ApplicationPartsDiscovery

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <UsingTask TaskName="Microsoft.AspNetCore.Razor.Tasks.FindAssembliesWithReferencesTo" AssemblyFile="$(RazorSdkBuildTasksAssembly)" Condition="'$(RazorSdkBuildTasksAssembly)' != ''" />
  <PropertyGroup>
    <GenerateMvcApplicationPartsAssemblyAttributes Condition="'$(GenerateMvcApplicationPartsAssemblyAttributes)' == '' AND '$(OutputType)' == 'Exe'">true</GenerateMvcApplicationPartsAssemblyAttributes>
    <CoreCompileDependsOn Condition="'$(GenerateMvcApplicationPartsAssemblyAttributes)' == 'true' AND '$(DesignTimeBuild)' != 'true'">
      _DiscoverMvcApplicationParts;
      $(CoreCompileDependsOn);
    </CoreCompileDependsOn>
    <_MvcApplicationPartAttributeGeneratedFile>$(IntermediateOutputPath)$(TargetName).MvcApplicationPartsAssemblyInfo$(DefaultLanguageSourceExtension)</_MvcApplicationPartAttributeGeneratedFile>
    <_MvcApplicationPartCacheFile>$(IntermediateOutputPath)$(TargetName).MvcApplicationPartsAssemblyInfo.cache</_MvcApplicationPartCacheFile>
  </PropertyGroup>
  <Target Name="_DiscoverMvcApplicationParts" Inputs="$(ProjectAssetsFile);$(MSBuildAllProjects)" Outputs="$(_MvcApplicationPartCacheFile)" DependsOnTargets="ResolveAssemblyReferences">
    <ItemGroup>
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.Abstractions" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.ApiExplorer" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.Core" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.Cors" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.DataAnnotations" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.Formatters.Json" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.Formatters.Xml" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.Localization" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.NewtonsoftJson" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.Razor" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.RazorPages" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.TagHelpers" />
      <_MvcAssemblyName Include="Microsoft.AspNetCore.Mvc.ViewFeatures" />
    </ItemGroup>
    <FindAssembliesWithReferencesTo Assemblies="@(ReferencePath)" TargetAssemblyNames="@(_MvcAssemblyName)">
      <Output TaskParameter="ResolvedAssemblies" ItemName="_ApplicationPartAssemblyNames" />
    </FindAssembliesWithReferencesTo>
    <ItemGroup>
      <_MvcApplicationPartAttribute Include="Microsoft.AspNetCore.Mvc.ApplicationParts.ApplicationPartAttribute">
        <_Parameter1>%(_ApplicationPartAssemblyNames.Identity)</_Parameter1>
      </_MvcApplicationPartAttribute>
    </ItemGroup>
    <!-- If we found application part assemblies, generate attributes for it and add it to compilation list -->
    <WriteCodeFragment AssemblyAttributes="@(_MvcApplicationPartAttribute)" Language="$(Language)" OutputFile="$(_MvcApplicationPartAttributeGeneratedFile)" Condition="'@(_ApplicationPartAssemblyNames-&gt;Count())' != '0'" />
    <!--
      If the generated attribute file exists, but no assembly names were discovered,
      it suggests that the assembly references were changed to no longer point to MVC.
      In this case, delete the file so that future incremental builds can no longer pick it up.
    -->
    <Delete Files="$(_MvcApplicationPartAttributeGeneratedFile)" Condition="'@(_ApplicationPartAssemblyNames-&gt;Count())' == '0' AND Exists('$(_MvcApplicationPartAttributeGeneratedFile)')" />
    <ItemGroup Condition="Exists('$(_MvcApplicationPartAttributeGeneratedFile)')">
      <Compile Remove="$(_MvcApplicationPartAttributeGeneratedFile)" Condition="'$(Language)'!='F#'" />
      <Compile Include="$(_MvcApplicationPartAttributeGeneratedFile)" Condition="'$(Language)'!='F#'" />
      <CompileBefore Remove="$(_MvcApplicationPartAttributeGeneratedFile)" Condition="'$(Language)'=='F#'" />
      <CompileBefore Include="$(_MvcApplicationPartAttributeGeneratedFile)" Condition="'$(Language)'=='F#'" />
      <FileWrites Include="$(_MvcApplicationPartAttributeGeneratedFile)" />
    </ItemGroup>
    <!--
      If we did not find any application parts, produce an empty file which is not added to compilation.
      This is required to play nicely with incremental builds.
    -->
    <Touch Files="$(_MvcApplicationPartCacheFile)" AlwaysCreate="true" />
    <ItemGroup>
      <FileWrites Include="$(_MvcApplicationPartCacheFile)" />
    </ItemGroup>
  </Target>
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Sdk.Razor.CurrentVersion.targets
============================================================================================================================================
-->
  <Target Name="PrepareForRazorGenerate" DependsOnTargets="$(PrepareForRazorGenerateDependsOn)" />
  <Target Name="PrepareForRazorComponentGenerate" DependsOnTargets="$(PrepareForRazorComponentGenerateDependsOn)" />
  <Target Name="RazorGenerate" DependsOnTargets="$(RazorGenerateDependsOn)" />
  <Target Name="RazorComponentGenerate" DependsOnTargets="$(RazorComponentGenerateDependsOn)" />
  <Target Name="PrepareForRazorCompile" DependsOnTargets="$(PrepareForRazorCompileDependsOn)" />
  <Target Name="RazorCompile" DependsOnTargets="$(RazorCompileDependsOn)" Condition="'$(_UseSourceGenerators)' == ''" />
  <!--
    Computes the applicable @(ResolvedRazorConfiguration) and @(ResolvedRazorExtension) items that match the project's
    configuration.
  -->
  <Target Name="ResolveRazorConfiguration">
    <ItemGroup Condition="'$(RazorDefaultConfiguration)'!=''">
      <ResolvedRazorConfiguration Include="@(RazorConfiguration-&gt;WithMetadataValue('Identity', '$(RazorDefaultConfiguration)')-&gt;Distinct())" />
    </ItemGroup>
    <!--
      ResolvedRazorConfiguration should only ever have one item in it. If misconfigured, we may resolve more than one item which
      may result in incorrect results or poorly worded build errors.
    -->
    <Warning Text="Unable to resolve a Razor configuration for the value '$(RazorDefaultConfiguration)'. Available configurations '@(RazorConfiguration->'%(Identity)', ', ')'.'" Code="RAZORSDK1000" Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true' AND '@(ResolvedRazorConfiguration-&gt;Count())' == '0'" />
    <Warning Text="More than one Razor configuration was resolved for the value '$(RazorDefaultConfiguration)'. Available configurations '@(RazorConfiguration->'%(Identity)', ', ')'." Code="RAZORSDK1001" Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true' AND '@(ResolvedRazorConfiguration-&gt;Count())' &gt; '1'" />
    <!-- For a 3.0 project, targeting a RazorLangVersion is nearly always an error condition -->
    <Warning Text="Detected Razor language version downgrade. This is typically caused by a reference to the Microsoft.AspNetCore.Razor.Design package. Consider removing this package reference." Code="RAZORSDK1006" Condition="'$(_Targeting30OrNewerRazorLangVersion)' != 'true' AND '$(_TargetingNETCoreApp30OrLater)' == 'true'" />
    <FindInList List="@(RazorExtension)" ItemSpecToFind="@(ResolvedRazorConfiguration-&gt;Metadata('Extensions'))" Condition="'@(ResolvedRazorConfiguration-&gt;HasMetadata('Extensions')-&gt;Count())' != '0'">
      <Output TaskParameter="ItemFound" ItemName="ResolvedRazorExtension" />
    </FindInList>
  </Target>
  <!--
    Gets assembly attributes in support for Razor runtime code generation. This is a set of standard
    metadata attributes (defined in Microsoft.AspNetCore.Razor.Runtime) that capture the build-time
    Razor configuration of an application to be used at runtime.

    This allows the project file to act as the source of truth for the applicable Razor configuration regardless
    of how Razor is used.

    The SDK expects configurations that use runtime compilation to set $(GenerateRazorHostingAssemblyInfo) to true,
    it will be unset by default.
  -->
  <Target Name="RazorGetAssemblyAttributes" Condition="'$(GenerateRazorHostingAssemblyInfo)'=='true' and '$(RazorDefaultConfiguration)'!=''" DependsOnTargets="ResolveRazorConfiguration">
    <ItemGroup>
      <_RazorAssemblyAttribute Include="Microsoft.AspNetCore.Razor.Hosting.RazorLanguageVersionAttribute">
        <_Parameter1>$(RazorLangVersion)</_Parameter1>
      </_RazorAssemblyAttribute>
      <_RazorAssemblyAttribute Include="Microsoft.AspNetCore.Razor.Hosting.RazorConfigurationNameAttribute">
        <_Parameter1>$(RazorDefaultConfiguration)</_Parameter1>
      </_RazorAssemblyAttribute>
      <_RazorAssemblyAttribute Include="Microsoft.AspNetCore.Razor.Hosting.RazorExtensionAssemblyNameAttribute" Condition="'%(ResolvedRazorExtension.AssemblyName)'!=''">
        <_Parameter1>%(ResolvedRazorExtension.Identity)</_Parameter1>
        <_Parameter2>%(ResolvedRazorExtension.AssemblyName)</_Parameter2>
      </_RazorAssemblyAttribute>
    </ItemGroup>
  </Target>
  <!--
    Gathers input source files for code generation. This is a separate target so that we can avoid
    lots of work when there are no inputs for code generation.
    This target runs as part of PrepareForBuild. This gives us an opportunitity to change things like CopyToPublishDirectory
    for Content items before they are processed by other Build targets.

    NOTE: This target is called as part of an incremental build scenario in VS. Do not perform any work
    outside of calculating RazorGenerate items in this target.
  -->
  <Target Name="ResolveRazorGenerateInputs">
    <!--
      In MVC Precompilation MvcRazorFilesToCompile also had the effect of suppressing the default
      items for Razor code generation. As with all of these MVC Precompilation back-compat settings,
      using the old thing, overrides the new thing.
    -->
    <PropertyGroup Condition="'@(MvcRazorFilesToCompile)'!=''">
      <EnableDefaultRazorGenerateItems>false</EnableDefaultRazorGenerateItems>
    </PropertyGroup>
    <ItemGroup>
      <RazorGenerate Include="@(MvcRazorFilesToCompile)" />
    </ItemGroup>
    <ItemGroup Condition="'$(EnableDefaultRazorGenerateItems)'=='true'">
      <RazorGenerate Include="@(Content)" Exclude="$(_RazorComponentInclude)" Condition="'%(Content.Extension)'=='.cshtml'" />
    </ItemGroup>
    <!--
      Ideally we want to able to update all Content items that also appear in RazorGenerate to have
      CopyToPublishDirectory=Never. However, there isn't a simple way to do this (https://github.com/Microsoft/msbuild/issues/1618).
      Instead, we'll update all cshtml Content items when EnableDefaultRazorGenerateItems=true and Razor Sdk is used for publishing.
    -->
    <ItemGroup Condition="&#xA;      '$(EnableDefaultRazorGenerateItems)'=='true' and&#xA;      '$(CopyRazorGenerateFilesToPublishDirectory)'=='false' and&#xA;      '$(ResolvedRazorCompileToolset)'=='RazorSdk' and&#xA;      '$(RazorCompileOnPublish)'=='true'">
      <Content Condition="'%(Content.Extension)'=='.cshtml'" CopyToPublishDirectory="Never" />
    </ItemGroup>
    <ItemGroup Condition="&#xA;      '$(ResolvedRazorCompileToolset)'=='RazorSdk' and&#xA;      '$(EnableDefaultRazorGenerateItems)'=='true'">
      <Content Condition="'%(Content.Extension)'=='.cshtml'" Pack="$(IncludeRazorContentInPack)" />
      <Content Condition="'%(Content.Extension)'=='.razor'" Pack="$(IncludeRazorContentInPack)" />
    </ItemGroup>
  </Target>
  <Target Name="ResolveRazorComponentInputs">
    <!--
    Gathers input source files for Razor component generation. This is a separate target so that we can avoid
    lots of work when there are no inputs for code generation.

    NOTE: This target is called as part of an incremental build scenario in VS. Do not perform any work
    outside of calculating RazorComponent items in this target.
    -->
    <ItemGroup Condition="'$(EnableDefaultRazorComponentItems)'=='true'">
      <RazorComponent Include="@(Content)" Condition="'%(Content.Extension)'=='.razor'" />
      <RazorComponent Include="$(_RazorComponentInclude)" />
    </ItemGroup>
    <ItemGroup>
      <Content Condition="'%(Content.Extension)'=='.razor'" CopyToPublishDirectory="Never" />
    </ItemGroup>
  </Target>
  <!-- This target validates that there is at most one scoped css file per component, that there are no scoped css files without a
     matching component, and then adds the associated scope to the razor components that have a matching scoped css file.
  -->
  <Target Name="ResolveCssScopes" Condition="'$(ScopedCssEnabled)' == 'true'" BeforeTargets="AssignRazorComponentTargetPaths;AssignRazorGenerateTargetPaths" DependsOnTargets="ComputeCssScope;ResolveRazorComponentInputs;ResolveRazorGenerateInputs">
    <ApplyCssScopes RazorComponents="@(RazorComponent)" RazorGenerate="@(RazorGenerate)" ScopedCss="@(_ScopedCss)">
      <Output TaskParameter="RazorComponentsWithScopes" ItemName="_RazorComponentsWithScopes" />
      <Output TaskParameter="RazorGenerateWithScopes" ItemName="_RazorGenerateWithScopes" />
    </ApplyCssScopes>
    <ItemGroup>
      <RazorComponent Remove="@(_RazorComponentsWithScopes)" />
      <RazorComponent Include="@(_RazorComponentsWithScopes)" />
      <RazorGenerate Remove="@(_RazorGenerateWithScopes)" />
      <RazorGenerate Include="@(_RazorGenerateWithScopes)" />
    </ItemGroup>
  </Target>
  <!--
    Temporarary workaround for https://github.com/dotnet/aspnetcore/issues/6859. This can be removed after a VS insertion with a newer copy of the DesignTime targets.
  -->
  <ItemGroup>
    <Content Update="$(_RazorComponentInclude)">
      <Generator>MSBuild:RazorGenerateComponentDeclarationDesignTime</Generator>
      <CopyToPublishDirectory>Never</CopyToPublishDirectory>
    </Content>
  </ItemGroup>
  <Target Name="AssignRazorComponentTargetPaths" Condition="'@(RazorComponent)' != ''">
    <AssignTargetPath Files="@(RazorComponent)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="RazorComponentWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <RazorComponentWithTargetPath Condition="'%(RazorComponentWithTargetPath.GeneratedOutput)' == ''">
        <GeneratedOutput>$(RazorGenerateIntermediateOutputPath)%(RazorComponentWithTargetPath.TargetPath)$(RazorGenerateOutputFileExtension)</GeneratedOutput>
      </RazorComponentWithTargetPath>
      <RazorComponentWithTargetPath Condition="'%(RazorComponentWithTargetPath.GeneratedDeclaration)' == ''">
        <GeneratedDeclaration>$(_RazorComponentDeclarationOutputPath)%(RazorComponentWithTargetPath.TargetPath)$(RazorGenerateOutputFileExtension)</GeneratedDeclaration>
      </RazorComponentWithTargetPath>
      <RazorComponentWithTargetPath Condition="'%(RazorComponentWithTargetPath.DocumentKind)' == ''">
        <DocumentKind>component</DocumentKind>
      </RazorComponentWithTargetPath>
    </ItemGroup>
  </Target>
  <Target Name="AssignRazorGenerateTargetPaths" Condition="'@(RazorGenerate)' != ''">
    <AssignTargetPath Files="@(RazorGenerate)" RootFolder="$(MSBuildProjectDirectory)">
      <Output TaskParameter="AssignedFiles" ItemName="RazorGenerateWithTargetPath" />
    </AssignTargetPath>
    <ItemGroup>
      <RazorGenerateWithTargetPath Condition="'%(RazorGenerateWithTargetPath.GeneratedOutput)' == ''">
        <GeneratedOutput>$(RazorGenerateIntermediateOutputPath)%(RazorGenerateWithTargetPath.TargetPath)$(RazorGenerateOutputFileExtension)</GeneratedOutput>
      </RazorGenerateWithTargetPath>
      <RazorGenerateWithTargetPath Condition="'%(RazorGenerateWithTargetPath.DocumentKind)' == ''">
        <DocumentKind>mvc</DocumentKind>
      </RazorGenerateWithTargetPath>
    </ItemGroup>
  </Target>
  <!--
    Gathers input assemblies for Tag Helper discovery and compilation. Add items to @(ReferencePath)
  -->
  <Target Name="ResolveAssemblyReferenceRazorGenerateInputs" DependsOnTargets="ResolveReferences">
    <ItemGroup>
      <RazorReferencePath Include="@(ReferencePath)" />
      <!--
      RazorReferencePath must include the closure of assemblies required for tag helper discovery to keep parity with the 2.1 Razor.Design package.
      Use the component declaration assembly, if available or the IntermediateAssembly if no components are involved in the build.
      -->
      <RazorReferencePath Include="$(_RazorComponentDeclarationAssemblyFullPath)" Condition="'$(_RazorComponentDeclarationAssemblyFullPath)' != ''" />
      <RazorReferencePath Include="@(IntermediateAssembly-&gt;Metadata('FullPath'))" Condition="'$(_RazorComponentDeclarationAssemblyFullPath)' == ''" />
    </ItemGroup>
  </Target>
  <!--
    Gathers inputs to the RazorCoreCompile target into the @(RazorCompile) itemgroup.

    This is marker target so that the code generation targets can attach.
  -->
  <Target Name="ResolveRazorCompileInputs" DependsOnTargets="$(ResolveRazorCompileInputsDependsOn)" />
  <Target Name="ResolveRazorEmbeddedResources" Condition="'$(EmbedRazorGenerateSources)'=='true'">
    <ItemGroup>
      <RazorEmbeddedResource Include="@(RazorGenerateWithTargetPath)">
        <LogicalName>/$([System.String]::Copy('%(RazorGenerateWithTargetPath.TargetPath)').Replace('\','/'))</LogicalName>
        <Type>Non-Resx</Type>
        <WithCulture>false</WithCulture>
      </RazorEmbeddedResource>
      <!-- Similar to _GenerateCompileInputs -->
      <_RazorCoreCompileResourceInputs Include="@(RazorEmbeddedResource)" Condition="'%(RazorEmbeddedResource.WithCulture)'=='false' and '%(RazorEmbeddedResource.Type)'=='Non-Resx' " />
    </ItemGroup>
  </Target>
  <!--
    This target is called after PrepareForPublish when RazorCompileOnPublish=true so that we can hook into publish.
    This target just hooks up other targets since Publish and PrepareForPublish don't have a DependsOnTargets
    property we can use.
  -->
  <Target Name="_RazorPrepareForPublish" AfterTargets="PrepareForPublish" DependsOnTargets="RazorCompile" Condition="'$(ResolvedRazorCompileToolset)'=='RazorSdk' and '$(RazorCompileOnPublish)'=='true' and '$(NoBuild)'!='true'" />
  <Target Name="_RazorAddDebugSymbolsProjectOutputGroupOutput" DependsOnTargets="_ResolveRazorTargetPath;ResolveRazorGenerateInputs" Condition="'$(ResolvedRazorCompileToolset)'=='RazorSdk' and '$(RazorCompileOnBuild)'=='true'">
    <ItemGroup Condition="Exists('@(_RazorDebugSymbolsIntermediatePath)')">
      <DebugSymbolsProjectOutputGroupOutput Include="%(_RazorDebugSymbolsIntermediatePath.FullPath)" FinalOutputPath="$(RazorTargetDir)$(RazorTargetName).pdb" />
    </ItemGroup>
  </Target>
  <!--
    Set up RazorCompile to run before PrepareForRun. This should ensure that the Razor dll and pdbs are available to be copied
    as part of GetCopyToOutputDirectoryItems which is invoked during PrepareForRun.
  -->
  <Target Name="_RazorPrepareForRun" DependsOnTargets="RazorCompile" Condition="'$(ResolvedRazorCompileToolset)'=='RazorSdk' and '$(RazorCompileOnBuild)'=='true'" />
  <Target Name="_RazorRemoveRefAssembliesFromPublish" BeforeTargets="PrepareForPublish" Condition="'$(ResolvedRazorCompileToolset)'=='RazorSdk' and '$(RazorCompileOnPublish)'=='true' AND '$(CopyRefAssembliesToPublishDirectory)' != ''">
    <!--
      Setting PreserveCompilationReferences affects both Build and Publish, but we want CopyRefAssembliesToPublishDirectory to only affect publishing.
      Use the value of CopyRefAssembliesToPublishDirectory to determine PreserveCompilationReferences during publish.
    -->
    <PropertyGroup>
      <PreserveCompilationReferences>$(CopyRefAssembliesToPublishDirectory)</PreserveCompilationReferences>
    </PropertyGroup>
  </Target>
  <Target Name="_CheckForMissingRazorCompiler" Condition="'$(IsRazorCompilerReferenced)' != 'true'">
    <Error Code="RAZORSDK1003" Text="A PackageReference for 'Microsoft.AspNetCore.Razor.Design' was not included in your project. This package is required to compile Razor files. Typically, a&#xA; transitive reference to 'Microsoft.AspNetCore.Razor.Design' and references required to compile Razor files are obtained by adding a PackageReference&#xA; for 'Microsoft.AspNetCore.Mvc' in your project. For more information, see https://go.microsoft.com/fwlink/?linkid=868374." />
  </Target>
  <Target Name="_CheckForIncorrectMvcConfiguration" Condition="'@(ResolvedRazorConfiguration)' == 'Default' AND&#xA;      ('$(RazorCompileOnBuild)' == 'true' OR '$(RazorCompileOnPublish)' =='true') AND&#xA;      '@(RazorGenerate-&gt;Count())' != '0' AND&#xA;      '$(_Targeting30OrNewerRazorLangVersion)' == 'true' AND&#xA;      '$(_IsTargetingRazor2X)' != 'true'">
    <Warning Code="RAZORSDK1004" Text="One or more Razor view or page files were found, but the project is not configured to add Razor support for MVC. The MSBuild property 'AddRazorSupportForMvc' must be set to correctly compile Razor files that target MVC. For more information, see https://go.microsoft.com/fwlink/?linkid=868374." />
  </Target>
  <Target Name="_CheckForIncorrectComponentsConfiguration" Condition="('$(RazorCompileOnBuild)' == 'true' OR '$(RazorCompileOnPublish)' =='true') AND&#xA;      '@(RazorComponent-&gt;Count())' != '0' AND&#xA;      '$(_Targeting30OrNewerRazorLangVersion)' != 'true' AND&#xA;      '$(_IsTargetingRazor2X)' != 'true'">
    <Warning Code="RAZORSDK1005" Text="One or more Razor component files (.razor) were found, but the project is not configured to compile Razor Components. Configure the project by targeting RazorLangVersion 3.0 or newer. For more information, see https://go.microsoft.com/fwlink/?linkid=868374." />
  </Target>
  <Target Name="_ResolveRazorTargetPath">
    <PropertyGroup>
      <RazorOutputPath Condition="'$(RazorOutputPath)'==''">$([MSBuild]::EnsureTrailingSlash('$(OutDir)'))</RazorOutputPath>
      <RazorTargetDir>$([MSBuild]::Escape($([MSBuild]::EnsureTrailingSlash($([System.IO.Path]::GetFullPath('$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(RazorOutputPath)'))'))))))</RazorTargetDir>
      <!-- Example, c:\MyProjects\MyProject\bin\debug\MyAssembly.Views.dll -->
      <RazorTargetPath Condition=" '$(RazorTargetPath)' == '' ">$(RazorTargetDir)$(RazorTargetName).dll</RazorTargetPath>
    </PropertyGroup>
  </Target>
  <Target Name="_ResolveGeneratedRazorCompileInputs">
    <ItemGroup>
      <RazorCompile Include="%(RazorGenerateWithTargetPath.GeneratedOutput)" Condition="'%(RazorGenerateWithTargetPath.DocumentKind)'=='mvc'" />
    </ItemGroup>
  </Target>
  <Target Name="_RazorSdkCustomCollectWatchItems">
    <ItemGroup>
      <Watch Include="%(Content.FullPath)" Condition="'%(Content.Extension)' == '.razor' AND '%(Content.Watch)' != 'false'" />
      <Watch Include="%(None.FullPath)" Condition="($([System.String]::Copy('%(None.FullPath)').EndsWith('.razor.css')) OR $([System.String]::Copy('%(None.FullPath)').EndsWith('.cshtml.css'))) AND '%(None.Watch)' != 'false'" />
      <Watch Include="%(Content.FullPath)" Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true' AND '$(AddCshtmlFilesToDotNetWatchList)' != 'false' AND '%(Content.Extension)' == '.cshtml' AND '%(Content.Watch)' != 'false'" />
    </ItemGroup>
  </Target>
  <PropertyGroup Condition="'$(RazorDesignTimeTargets)'==''">
    <RazorDesignTimeTargets>$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Razor\Microsoft.NET.Sdk.Razor.DesignTime.targets</RazorDesignTimeTargets>
    <RazorDesignTimeTargets Condition="!Exists('$(RazorDesignTimeTargets)')">$(MSBuildThisFileDirectory)Microsoft.NET.Sdk.Razor.DesignTime.targets</RazorDesignTimeTargets>
  </PropertyGroup>
  <!--
============================================================================================================================================
  <Import Project="$(RazorDesignTimeTargets)">

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Microsoft.NET.Sdk.Razor.DesignTime.targets
============================================================================================================================================
-->
  <!--
***********************************************************************************************
Microsoft.NET.Sdk.Razor.DesignTime.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
  <PropertyGroup>
    <!--
      Defines the list of file extensions that VS will monitor to reload the application.
      We'll only define these for C# projects targeting RazorLangVersion 3.0 or later, and let VS use defaults in other cases.
    -->
    <UpToDateReloadFileTypes Condition="'$(Language)'=='C#' AND '$(_Targeting30OrNewerRazorLangVersion)' == 'true' AND '$(RazorUpToDateReloadFileTypes)' != ''">$(UpToDateReloadFileTypes);$(RazorUpToDateReloadFileTypes)</UpToDateReloadFileTypes>
  </PropertyGroup>
  <ItemGroup>
    <!--
      Defines the generic .NET Core 'Razor' capability.

      Note that we don't define any capabilities here that depend on the version of the runtime/toolset
      in use by the project. Those capabilities are defined by the relevant runtime packages so that
      we use the lack of the capability to detect downlevel scenarios.
    -->
    <ProjectCapability Include="DotNetCoreRazor" />
    <!--
      Defines the ability to understand the configuration for the Razor language service provided by
      the runtime/toolset packages. Introduced in 2.1
    -->
    <ProjectCapability Include="DotNetCoreRazorConfiguration" Condition="'$(_Targeting30OrNewerRazorLangVersion)' == 'true'" />
    <!--
      Activates the set of nesting behaviors we want from solution explorer.
    -->
    <ProjectCapability Include="WebNestingDefaults" />
    <!--
      Tooling support for TypeScript files.
    -->
    <ProjectCapability Include="SupportsTypeScriptNuGet" />
  </ItemGroup>
  <!--
    In order to properly support Blazor partial classes we need to ensure that older SDKs don't
    add declaration files to the compile list. We do all the compilation work in-memory in latest
    VS.
  -->
  <Target Name="_RemoveRazorDeclartionsFromCompile" AfterTargets="RazorGenerateComponentDeclaration">
    <ItemGroup Condition="'$(DesignTimeBuild)'=='true'">
      <Compile Remove="@(_RazorComponentDeclaration)" />
    </ItemGroup>
  </Target>
  <!--
    WebSdk imports these capabilities for nesting in DotNetCoreWeb projects.
    Conditinally import these capabilities if the project isn't targeting the WebSdk.
   -->
  <ItemGroup Condition="'$(UsingMicrosoftNETSdkWeb)'==''">
    <ProjectCapability Include="SupportHierarchyContextSvc" />
    <ProjectCapability Include="DynamicDependentFile" />
    <ProjectCapability Include="DynamicFileNesting" />
  </ItemGroup>
  <ItemGroup>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)Rules\RazorConfiguration.xaml">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)Rules\RazorExtension.xaml">
      <Context>File</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)Rules\RazorGeneral.xaml">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)Rules\RazorGenerateWithTargetPath.xaml">
      <Context>Project</Context>
    </PropertyPageSchema>
    <PropertyPageSchema Include="$(MSBuildThisFileDirectory)Rules\RazorComponentWithTargetPath.xaml">
      <Context>Project</Context>
    </PropertyPageSchema>
  </ItemGroup>
  <Target Name="RazorGenerateDesignTime" DependsOnTargets="ResolveRazorGenerateInputs;AssignRazorGenerateTargetPaths" Returns="@(RazorGenerateWithTargetPath)" />
  <!--
    Using DependsOnTargets here because real dependencies of this target aren't defined in
    a downlevel (pre-3.0) SDK.
  -->
  <Target Name="RazorGenerateComponentDesignTime" DependsOnTargets="$(_RazorGenerateComponentDesignTimeDependsOn)" Returns="@(RazorComponentWithTargetPath)" />
  <!--
    Using DependsOnTargets here because real dependencies of this target aren't defined in
    a downlevel (pre-3.0) SDK.

    Called by the project system to update generated declaration files
  -->
  <Target Name="RazorGenerateComponentDeclarationDesignTime" DependsOnTargets="$(_RazorGenerateComponentDeclarationDesignTimeDependsOn)" />
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/targets/Sdk.Razor.CurrentVersion.targets
============================================================================================================================================
-->
  <PropertyGroup Condition="'$(_RazorUpToDateReloadFileTypesAllowWorkaround)' != 'false'">
    <!--
      Defines the list of file extensions that VS will monitor to reload the application.
      We'll only define these for C# projects targeting RazorLangVersion 3.0 or later, and let VS use defaults in other cases.

      This property can be removed after the next insertion in to VS.
    -->
    <UpToDateReloadFileTypes Condition="'$(Language)'=='C#' AND '$(_Targeting30OrNewerRazorLangVersion)' == 'true' AND '$(UpToDateReloadFileTypes)' == ''">$(RazorUpToDateReloadFileTypes)</UpToDateReloadFileTypes>
  </PropertyGroup>
  <!--
    This is a hook to import a set of targets after the Razor targets. By default this is unused.
  -->
  <!--<Import Project="$(CustomAfterRazorSdkTargets)" Condition="'$(CustomAfterRazorSdkTargets)' != '' and Exists('$(CustomAfterRazorSdkTargets)')" />-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/.dotnet/sdk/10.0.100-preview.7.25322.101/Sdks/Microsoft.NET.Sdk.Razor/Sdk/Sdk.targets
============================================================================================================================================
-->
  <!--
============================================================================================================================================
  </Import>

/home/runner/work/aspnetcore/aspnetcore/src/Components/CustomElements/src/Microsoft.AspNetCore.Components.CustomElements.csproj
============================================================================================================================================
-->
</Project>