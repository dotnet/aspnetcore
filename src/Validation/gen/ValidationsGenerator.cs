// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Linq;
using Microsoft.CodeAnalysis;

namespace Microsoft.Extensions.Validation;

[Generator(LanguageNames.CSharp)]
public sealed partial class ValidationsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Emit the ValidatableTypeAttribute with embedded support
        context.RegisterPostInitializationOutput(EmitValidatableTypeAttribute);

        // Find the builder.Services.AddValidation() call in the application.
        var addValidation = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: FindAddValidation,
            transform: TransformAddValidation
        );
        // Extract types that have been marked with [ValidatableType].
        // This handles both the framework attribute and the auto-generated attribute.
        var validatableTypesWithAttribute = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: ShouldTransformSymbolWithValidatableTypeAttribute,
            transform: TransformValidatableTypeWithValidatableTypeAttribute
        ).Where(types => types.Length > 0);
        // Extract all minimal API endpoints in the application.
        var endpoints = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: FindEndpoints,
                transform: TransformEndpoints)
            .Where(endpoint => endpoint is not null);
        // Extract validatable types from all endpoints.
        var validatableTypesFromEndpoints = endpoints
            .Select(ExtractValidatableEndpoint);
        // Join all validatable types encountered in the type graph.
        var validatableTypes = validatableTypesWithAttribute
            .Concat(validatableTypesFromEndpoints)
            .Distinct(ValidatableTypeComparer.Instance)
            .Collect();

        var emitInputs = addValidation
            .Combine(validatableTypes);

        // Emit the IValidatableInfo resolver injection and
        // ValidatableTypeInfo for all validatable types.
        context.RegisterSourceOutput(emitInputs, Emit);
    }

    private static void EmitValidatableTypeAttribute(IncrementalGeneratorPostInitializationContext context)
    {
        // First, emit the EmbeddedAttribute if it doesn't exist
        var embeddedAttributeSource = """
            // <auto-generated/>
            namespace Microsoft.CodeAnalysis
            {
                [global::System.AttributeUsage(global::System.AttributeTargets.All, AllowMultiple = true, Inherited = false)]
                internal sealed class EmbeddedAttribute : global::System.Attribute
                {
                }
            }
            """;

        context.AddSource("EmbeddedAttribute.g.cs", embeddedAttributeSource);

        // Then emit the ValidatableTypeAttribute in the global namespace
        // We use global namespace since we don't have access to the project's root namespace here
        var validatableTypeAttributeSource = """
            // <auto-generated/>
            [global::Microsoft.CodeAnalysis.EmbeddedAttribute]
            [global::System.AttributeUsage(global::System.AttributeTargets.Class)]
            internal sealed class ValidatableTypeAttribute : global::System.Attribute
            {
            }
            """;

        context.AddSource("ValidatableTypeAttribute.g.cs", validatableTypeAttributeSource);
    }
}
