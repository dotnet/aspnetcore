<#@ template language="C#" #>
<#@ assembly name="System.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#
var props = new[]
{
    new { Key = "Accept", Name = "Accept", ID = "HttpSysRequestHeader.Accept" },
    new { Key = "Accept-Charset", Name = "AcceptCharset", ID = "HttpSysRequestHeader.AcceptCharset" },
    new { Key = "Accept-Encoding", Name = "AcceptEncoding", ID = "HttpSysRequestHeader.AcceptEncoding" },
    new { Key = "Accept-Language", Name = "AcceptLanguage", ID = "HttpSysRequestHeader.AcceptLanguage" },
    new { Key = "Allow", Name = "Allow", ID = "HttpSysRequestHeader.Allow" },
    new { Key = "Authorization", Name = "Authorization", ID = "HttpSysRequestHeader.Authorization" },
    new { Key = "Cache-Control", Name = "CacheControl", ID = "HttpSysRequestHeader.CacheControl" },
    new { Key = "Connection", Name = "Connection", ID = "HttpSysRequestHeader.Connection" },
    new { Key = "Content-Encoding", Name = "ContentEncoding", ID = "HttpSysRequestHeader.ContentEncoding" },
    new { Key = "Content-Language", Name = "ContentLanguage", ID = "HttpSysRequestHeader.ContentLanguage" },
    new { Key = "Content-Length", Name = "ContentLength", ID = "HttpSysRequestHeader.ContentLength" },
    new { Key = "Content-Location", Name = "ContentLocation", ID = "HttpSysRequestHeader.ContentLocation" },
    new { Key = "Content-Md5", Name = "ContentMD5", ID = "HttpSysRequestHeader.ContentMd5" },
    new { Key = "Content-Range", Name = "ContentRange", ID = "HttpSysRequestHeader.ContentRange" },
    new { Key = "Content-Type", Name = "ContentType", ID = "HttpSysRequestHeader.ContentType" },
    new { Key = "Cookie", Name = "Cookie", ID = "HttpSysRequestHeader.Cookie" },
    new { Key = "Date", Name = "Date", ID = "HttpSysRequestHeader.Date" },
    new { Key = "Expect", Name = "Expect", ID = "HttpSysRequestHeader.Expect" },
    new { Key = "Expires", Name = "Expires", ID = "HttpSysRequestHeader.Expires" },
    new { Key = "From", Name = "From", ID = "HttpSysRequestHeader.From" },
    new { Key = "Host", Name = "Host", ID = "HttpSysRequestHeader.Host" },
    new { Key = "If-Match", Name = "IfMatch", ID = "HttpSysRequestHeader.IfMatch" },
    new { Key = "If-Modified-Since", Name = "IfModifiedSince", ID = "HttpSysRequestHeader.IfModifiedSince" },
    new { Key = "If-None-Match", Name = "IfNoneMatch", ID = "HttpSysRequestHeader.IfNoneMatch" },
    new { Key = "If-Range", Name = "IfRange", ID = "HttpSysRequestHeader.IfRange" },
    new { Key = "If-Unmodified-Since", Name = "IfUnmodifiedSince", ID = "HttpSysRequestHeader.IfUnmodifiedSince" },
    new { Key = "Keep-Alive", Name = "KeepAlive", ID = "HttpSysRequestHeader.KeepAlive" },
    new { Key = "Last-Modified", Name = "LastModified", ID = "HttpSysRequestHeader.LastModified" },
    new { Key = "Max-Forwards", Name = "MaxForwards", ID = "HttpSysRequestHeader.MaxForwards" },
    new { Key = "Pragma", Name = "Pragma", ID = "HttpSysRequestHeader.Pragma" },
    new { Key = "Proxy-Authorization", Name = "ProxyAuthorization", ID = "HttpSysRequestHeader.ProxyAuthorization" },
    new { Key = "Range", Name = "Range", ID = "HttpSysRequestHeader.Range" },
    new { Key = "Referer", Name = "Referer", ID = "HttpSysRequestHeader.Referer" },
    new { Key = "Te", Name = "TE", ID = "HttpSysRequestHeader.Te" },
    new { Key = "Trailer", Name = "Trailer", ID = "HttpSysRequestHeader.Trailer" },
    new { Key = "Transfer-Encoding", Name = "TransferEncoding", ID = "HttpSysRequestHeader.TransferEncoding" },
    new { Key = "Translate", Name = "Translate", ID = "HttpSysRequestHeader.Translate" },
    new { Key = "Upgrade", Name = "Upgrade", ID = "HttpSysRequestHeader.Upgrade" },
    new { Key = "User-Agent", Name = "UserAgent", ID = "HttpSysRequestHeader.UserAgent" },
    new { Key = "Via", Name = "Via", ID = "HttpSysRequestHeader.Via" },
    new { Key = "Warning", Name = "Warning", ID = "HttpSysRequestHeader.Warning" },
}.Select((prop, Index)=>new {prop.Key, prop.Name, prop.ID, Index});

var lengths = props.GroupBy(prop=>prop.Key.Length).OrderBy(prop=>prop.Key);


Func<int,string> IsReadMask = Index => "(_flag" + (Index / 32) + " & 0x" + (1<<(Index % 32)).ToString("x") + "u)";
Func<int,string> MarkRead = Index => "_flag" + (Index / 32) + " |= 0x" + (1<<(Index % 32)).ToString("x") + "u";
Func<int,string> Clear = Index => "_flag" + (Index / 32) + " &= ~0x" + (1<<(Index % 32)).ToString("x") + "u";
#>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// <auto-generated />

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using Microsoft.Extensions.Primitives;
using Microsoft.Net.Http.Headers;

namespace Microsoft.AspNetCore.HttpSys.Internal
{
    [GeneratedCode("TextTemplatingFileGenerator", "")]
    internal partial class RequestHeaders
    {
        // Tracks if individual fields have been read from native or set directly.
        // Once read or set, their presence in the collection is marked by if their StringValues is null or not.
        private UInt32 _flag0, _flag1;

<# foreach(var prop in props) { #>
        private StringValues _<#=prop.Name#>;
<# } #>

<# foreach(var prop in props) { #>
        public StringValues <#=prop.Name#>
        {
            get
            {
                if (<#=IsReadMask(prop.Index)#> == 0)
                {
                    string nativeValue = GetKnownHeader(<#=prop.ID#>);
                    if (nativeValue != null)
                    {
                        _<#=prop.Name#> = nativeValue;
                    }
                    <#=MarkRead(prop.Index)#>;
                }

                return _<#=prop.Name#>.Count > 0 ? _<#=prop.Name#> : StringValues.Empty;
            }
            set
            {
                <#=MarkRead(prop.Index)#>;

                _<#=prop.Name#> = value.Count > 0 ? value : default;
            }
        }

<# } #>
        private bool PropertiesContainsKey(string key)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (string.Equals(key, HeaderNames.<#=prop.Name#>, StringComparison.OrdinalIgnoreCase))
                    {
                        return <#=prop.Name#>.Count > 0;
                    }
<# } #>
                    break;
<# } #>
            }
            return false;
        }

        private bool PropertiesTryGetValue(string key, out StringValues value)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (string.Equals(key, HeaderNames.<#=prop.Name#>, StringComparison.OrdinalIgnoreCase))
                    {
                        value = <#=prop.Name#>;
                        return value.Count > 0;
                    }
<# } #>
                    break;
<# } #>
            }
            value = default;
            return false;
        }

        private bool PropertiesTrySetValue(string key, StringValues value)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (string.Equals(key, HeaderNames.<#=prop.Name#>, StringComparison.OrdinalIgnoreCase))
                    {
                        <#=prop.Name#> = value;
                        return true;
                    }
<# } #>
                    break;
<# } #>
            }
            return false;
        }

        private bool PropertiesTryRemove(string key)
        {
            switch (key.Length)
            {
<# foreach(var length in lengths) { #>
                case <#=length.Key#>:
<# foreach(var prop in length) { #>
                    if (string.Equals(key, HeaderNames.<#=prop.Name#>, StringComparison.Ordinal))
                    {
                        if (HasKnownHeader(<#=prop.ID#>))
                        {
                            <#=prop.Name#> = default;
                            return true;
                        }
                        return false;
                    }

<# } #>
                    break;
<# } #>
            }
            return false;
        }

        private IEnumerable<string> PropertiesKeys()
        {
<# foreach(var prop in props) { #>
            if (<#=prop.Name#>.Count > 0)
            {
                yield return HeaderNames.<#=prop.Name#>;
            }
<# } #>
        }

        private IEnumerable<StringValues> PropertiesValues()
        {
<# foreach(var prop in props) { #>
            if (<#=prop.Name#>.Count > 0)
            {
                yield return <#=prop.Name#>;
            }
<# } #>
        }

        private IEnumerable<KeyValuePair<string, StringValues>> PropertiesEnumerable()
        {
<# foreach(var prop in props) { #>
            if (<#=prop.Name#>.Count > 0)
            {
                yield return new KeyValuePair<string, StringValues>(HeaderNames.<#=prop.Name#>, <#=prop.Name#>);
            }
<# } #>
        }

        private static ReadOnlySpan<HttpSysRequestHeader> HeaderKeys =>
        [
<# foreach(var prop in props) { #>
            <#=prop.ID#>,
<# } #>
        ];

        private string GetHeaderKeyName(HttpSysRequestHeader header) => header switch
        {
<# foreach(var prop in props) { #>
            <#=prop.ID#> => HeaderNames.<#=prop.Name#>,
<# } #>
            _ => throw new NotImplementedException()
        };

        private bool HasKnownHeader(HttpSysRequestHeader header) => header switch
        {
<# foreach(var prop in props) { #>
            <#=prop.ID#> => <#=IsReadMask(prop.Index)#> != 0 ? _<#=prop.Name#>.Count > 0 : _requestMemoryBlob.HasKnownHeader(<#=prop.ID#>),
<# } #>
            _ => throw new NotImplementedException()
        };
    }
}
