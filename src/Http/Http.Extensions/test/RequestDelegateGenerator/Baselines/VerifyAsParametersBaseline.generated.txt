//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

namespace System.Runtime.CompilerServices
{
    %GENERATEDCODEATTRIBUTE%
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace Microsoft.AspNetCore.Http.Generated
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Text.Json;
    using System.Text.Json.Serialization.Metadata;
    using System.Threading.Tasks;
    using System.IO;
    using Microsoft.AspNetCore.Antiforgery;
    using Microsoft.AspNetCore.Routing;
    using Microsoft.AspNetCore.Routing.Patterns;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Http.Json;
    using Microsoft.AspNetCore.Http.Metadata;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.FileProviders;
    using Microsoft.Extensions.Logging;
    using Microsoft.Extensions.Primitives;
    using Microsoft.Extensions.Options;

    using MetadataPopulator = System.Func<System.Reflection.MethodInfo, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions?, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult>;
    using RequestDelegateFactoryFunc = System.Func<System.Delegate, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult?, Microsoft.AspNetCore.Http.RequestDelegateResult>;

    %GENERATEDCODEATTRIBUTE%
    file static class GeneratedRouteBuilderExtensionsCore
    {
        private static readonly JsonOptions FallbackJsonOptions = new();
        private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };
        private static readonly string[] PatchVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Patch };
        private static readonly string[] PostVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Post };
        private static readonly string[] PutVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Put };

        %INTERCEPTSLOCATIONATTRIBUTE%
        internal static RouteHandlerBuilder MapGet0(
            this IEndpointRouteBuilder endpoints,
            [StringSyntax("Route")] string pattern,
            Delegate handler)
        {
            MetadataPopulator populateMetadata = (methodInfo, options) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60", "42.42.42.42"));
                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
            };
            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, "ApplicationServices not found.");
                Debug.Assert(options.EndpointBuilder.FilterFactories != null, "FilterFactories not found.");
                var handler = Cast(del, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue arg0) => throw null!);
                EndpointFilterDelegate? filteredInvocation = null;
                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;
                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);
                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;
                var jsonSerializerOptions = jsonOptions.SerializerOptions;
                jsonSerializerOptions.MakeReadOnly();
                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));

                if (options.EndpointBuilder.FilterFactories.Count > 0)
                {
                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                    {
                        if (ic.HttpContext.Response.StatusCode == 400)
                        {
                            return ValueTask.FromResult<object?>(Results.Empty);
                        }
                        handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue>(0)!);
                        return ValueTask.FromResult<object?>(Results.Empty);
                    },
                    options.EndpointBuilder,
                    handler.Method);
                }

                Task RequestHandler(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    // Endpoint Parameter: Value (Type = int, IsOptional = True, IsParsable = True, IsArray = False, Source = Route)
                    if (options?.RouteParameterNames?.Contains("Value", StringComparer.OrdinalIgnoreCase) != true)
                    {
                        throw new InvalidOperationException($"'Value' is not a route parameter.");
                    }
                    var Value_raw = (string?)httpContext.Request.RouteValues["Value"];
                    var Value_temp = (string?)Value_raw;
                    global::System.Int32 Value_parsed_temp = default;
                    if (GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(Value_temp!, CultureInfo.InvariantCulture, out var Value_temp_parsed_non_nullable))
                    {
                        Value_parsed_temp = Value_temp_parsed_non_nullable;
                    }
                    else if (string.IsNullOrEmpty(Value_temp))
                    {
                        Value_parsed_temp = 42;
                    }
                    else
                    {
                        wasParamCheckFailure = true;
                    }
                    int Value_local = Value_parsed_temp!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue(HttpContext_local, Value_local);

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                        return Task.CompletedTask;
                    }
                    handler(args_local);
                    return Task.CompletedTask;
                }

                async Task RequestHandlerFiltered(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    // Endpoint Parameter: Value (Type = int, IsOptional = True, IsParsable = True, IsArray = False, Source = Route)
                    if (options?.RouteParameterNames?.Contains("Value", StringComparer.OrdinalIgnoreCase) != true)
                    {
                        throw new InvalidOperationException($"'Value' is not a route parameter.");
                    }
                    var Value_raw = (string?)httpContext.Request.RouteValues["Value"];
                    var Value_temp = (string?)Value_raw;
                    global::System.Int32 Value_parsed_temp = default;
                    if (GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(Value_temp!, CultureInfo.InvariantCulture, out var Value_temp_parsed_non_nullable))
                    {
                        Value_parsed_temp = Value_temp_parsed_non_nullable;
                    }
                    else if (string.IsNullOrEmpty(Value_temp))
                    {
                        Value_parsed_temp = 42;
                    }
                    else
                    {
                        wasParamCheckFailure = true;
                    }
                    int Value_local = Value_parsed_temp!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue(HttpContext_local, Value_local);

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                    }
                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue>(httpContext, args_local));
                    if (result is not null)
                    {
                        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);
                    }
                }

                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                return new RequestDelegateResult(targetDelegate, metadata);
            };
            var castHandler = Cast(handler, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListWitDefaultValue arg0) => throw null!);
            return MapCore(
                endpoints,
                pattern,
                handler,
                GetVerb,
                populateMetadata,
                createRequestDelegate,
                castHandler.Method);
        }

        %INTERCEPTSLOCATIONATTRIBUTE%
        internal static RouteHandlerBuilder MapPost1(
            this IEndpointRouteBuilder endpoints,
            [StringSyntax("Route")] string pattern,
            Delegate handler)
        {
            MetadataPopulator populateMetadata = (methodInfo, options) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60", "42.42.42.42"));
                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
            };
            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, "ApplicationServices not found.");
                Debug.Assert(options.EndpointBuilder.FilterFactories != null, "FilterFactories not found.");
                var handler = Cast(del, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct arg0) => throw null!);
                EndpointFilterDelegate? filteredInvocation = null;
                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;
                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);
                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;
                var jsonSerializerOptions = jsonOptions.SerializerOptions;
                jsonSerializerOptions.MakeReadOnly();
                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));
                var Value_RouteOrQueryResolver = GeneratedRouteBuilderExtensionsCore.ResolveFromRouteOrQuery("Value", options.RouteParameterNames);

                if (options.EndpointBuilder.FilterFactories.Count > 0)
                {
                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                    {
                        if (ic.HttpContext.Response.StatusCode == 400)
                        {
                            return ValueTask.FromResult<object?>(Results.Empty);
                        }
                        handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct>(0)!);
                        return ValueTask.FromResult<object?>(Results.Empty);
                    },
                    options.EndpointBuilder,
                    handler.Method);
                }

                Task RequestHandler(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    // Endpoint Parameter: Value (Type = int, IsOptional = False, IsParsable = True, IsArray = False, Source = RouteOrQuery)
                    var Value_raw = Value_RouteOrQueryResolver(httpContext);
                    if (Value_raw is StringValues { Count: 0 })
                    {
                        wasParamCheckFailure = true;
                        logOrThrowExceptionHelper.RequiredParameterNotProvided("int", "Value", "route or query string");
                    }
                    var Value_temp = (string?)Value_raw;
                    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(Value_temp!, CultureInfo.InvariantCulture, out var Value_parsed_temp))
                    {
                        if (!string.IsNullOrEmpty(Value_temp))
                        {
                            logOrThrowExceptionHelper.ParameterBindingFailed("int", "Value", Value_temp);
                            wasParamCheckFailure = true;
                        }
                    }
                    int Value_local = Value_parsed_temp!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct { HttpContext = HttpContext_local, Value = Value_local };

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                        return Task.CompletedTask;
                    }
                    handler(args_local);
                    return Task.CompletedTask;
                }

                async Task RequestHandlerFiltered(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    // Endpoint Parameter: Value (Type = int, IsOptional = False, IsParsable = True, IsArray = False, Source = RouteOrQuery)
                    var Value_raw = Value_RouteOrQueryResolver(httpContext);
                    if (Value_raw is StringValues { Count: 0 })
                    {
                        wasParamCheckFailure = true;
                        logOrThrowExceptionHelper.RequiredParameterNotProvided("int", "Value", "route or query string");
                    }
                    var Value_temp = (string?)Value_raw;
                    if (!GeneratedRouteBuilderExtensionsCore.TryParseExplicit<int>(Value_temp!, CultureInfo.InvariantCulture, out var Value_parsed_temp))
                    {
                        if (!string.IsNullOrEmpty(Value_temp))
                        {
                            logOrThrowExceptionHelper.ParameterBindingFailed("int", "Value", Value_temp);
                            wasParamCheckFailure = true;
                        }
                    }
                    int Value_local = Value_parsed_temp!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct { HttpContext = HttpContext_local, Value = Value_local };

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                    }
                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct>(httpContext, args_local));
                    if (result is not null)
                    {
                        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);
                    }
                }

                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                return new RequestDelegateResult(targetDelegate, metadata);
            };
            var castHandler = Cast(handler, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterListRecordStruct arg0) => throw null!);
            return MapCore(
                endpoints,
                pattern,
                handler,
                PostVerb,
                populateMetadata,
                createRequestDelegate,
                castHandler.Method);
        }

        %INTERCEPTSLOCATIONATTRIBUTE%
        internal static RouteHandlerBuilder MapPut2(
            this IEndpointRouteBuilder endpoints,
            [StringSyntax("Route")] string pattern,
            Delegate handler)
        {
            MetadataPopulator populateMetadata = (methodInfo, options) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60", "42.42.42.42"));
                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
            };
            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, "ApplicationServices not found.");
                Debug.Assert(options.EndpointBuilder.FilterFactories != null, "FilterFactories not found.");
                var handler = Cast(del, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext arg0) => throw null!);
                EndpointFilterDelegate? filteredInvocation = null;
                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;
                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);
                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;
                var jsonSerializerOptions = jsonOptions.SerializerOptions;
                jsonSerializerOptions.MakeReadOnly();
                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));

                if (options.EndpointBuilder.FilterFactories.Count > 0)
                {
                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                    {
                        if (ic.HttpContext.Response.StatusCode == 400)
                        {
                            return ValueTask.FromResult<object?>(Results.Empty);
                        }
                        handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext>(0)!);
                        return ValueTask.FromResult<object?>(Results.Empty);
                    },
                    options.EndpointBuilder,
                    handler.Method);
                }

                Task RequestHandler(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    var User_local = httpContext.User;
                    var Request_local = httpContext.Request;
                    var Response_local = httpContext.Response;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext(HttpContext_local, User_local, Request_local, Response_local);

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                        return Task.CompletedTask;
                    }
                    handler(args_local);
                    return Task.CompletedTask;
                }

                async Task RequestHandlerFiltered(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    var User_local = httpContext.User;
                    var Request_local = httpContext.Request;
                    var Response_local = httpContext.Response;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext(HttpContext_local, User_local, Request_local, Response_local);

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                    }
                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext>(httpContext, args_local));
                    if (result is not null)
                    {
                        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);
                    }
                }

                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                return new RequestDelegateResult(targetDelegate, metadata);
            };
            var castHandler = Cast(handler, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithHttpContext arg0) => throw null!);
            return MapCore(
                endpoints,
                pattern,
                handler,
                PutVerb,
                populateMetadata,
                createRequestDelegate,
                castHandler.Method);
        }

        %INTERCEPTSLOCATIONATTRIBUTE%
        internal static RouteHandlerBuilder MapPatch3(
            this IEndpointRouteBuilder endpoints,
            [StringSyntax("Route")] string pattern,
            Delegate handler)
        {
            MetadataPopulator populateMetadata = (methodInfo, options) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60", "42.42.42.42"));
                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(contentTypes: GeneratedMetadataConstants.JsonContentType));
                options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, contentTypes: GeneratedMetadataConstants.PlaintextContentType));
                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
            };
            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, "ApplicationServices not found.");
                Debug.Assert(options.EndpointBuilder.FilterFactories != null, "FilterFactories not found.");
                var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody arg0) => throw null!);
                EndpointFilterDelegate? filteredInvocation = null;
                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;
                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);
                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;
                var jsonSerializerOptions = jsonOptions.SerializerOptions;
                jsonSerializerOptions.MakeReadOnly();
                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));
                var serviceProviderIsService = serviceProvider?.GetService<IServiceProviderIsService>();
                var Todo_JsonBodyOrServiceResolver = ResolveJsonBodyOrService<global::Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct>(logOrThrowExceptionHelper, "TodoStruct", "Todo", jsonSerializerOptions, serviceProviderIsService);

                if (options.EndpointBuilder.FilterFactories.Count > 0)
                {
                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                    {
                        if (ic.HttpContext.Response.StatusCode == 400)
                        {
                            return ValueTask.FromResult<object?>(Results.Empty);
                        }
                        return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody>(0)!));
                    },
                    options.EndpointBuilder,
                    handler.Method);
                }

                async Task RequestHandler(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    // Endpoint Parameter: Todo (Type = Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)
                    var Todo_resolveJsonBodyOrServiceResult = await Todo_JsonBodyOrServiceResolver(httpContext, false);
                    if (!Todo_resolveJsonBodyOrServiceResult.Item1)
                    {
                        return;
                    }
                    var Todo_local = Todo_resolveJsonBodyOrServiceResult.Item2!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody(HttpContext_local, Todo_local);

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                        return;
                    }
                    var result = handler(args_local);
                    if (result is string)
                    {
                        httpContext.Response.ContentType ??= "text/plain; charset=utf-8";
                    }
                    else
                    {
                        httpContext.Response.ContentType ??= "application/json; charset=utf-8";
                    }
                    await httpContext.Response.WriteAsync(result);
                }

                async Task RequestHandlerFiltered(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    // Endpoint Parameter: Todo (Type = Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)
                    var Todo_resolveJsonBodyOrServiceResult = await Todo_JsonBodyOrServiceResolver(httpContext, false);
                    if (!Todo_resolveJsonBodyOrServiceResult.Item1)
                    {
                        return;
                    }
                    var Todo_local = Todo_resolveJsonBodyOrServiceResult.Item2!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody(HttpContext_local, Todo_local);

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                    }
                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody>(httpContext, args_local));
                    if (result is not null)
                    {
                        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);
                    }
                }

                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                return new RequestDelegateResult(targetDelegate, metadata);
            };
            var castHandler = Cast(handler, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithImplicitFromBody arg0) => throw null!);
            return MapCore(
                endpoints,
                pattern,
                handler,
                PatchVerb,
                populateMetadata,
                createRequestDelegate,
                castHandler.Method);
        }

        %INTERCEPTSLOCATIONATTRIBUTE%
        internal static RouteHandlerBuilder MapGet4(
            this IEndpointRouteBuilder endpoints,
            [StringSyntax("Route")] string pattern,
            Delegate handler)
        {
            MetadataPopulator populateMetadata = (methodInfo, options) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60", "42.42.42.42"));
                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(contentTypes: GeneratedMetadataConstants.JsonContentType));
                var parameterInfos = methodInfo.GetParameters();
                var Value_ParameterInfo = new PropertyAsParameterInfo(false, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType)!.GetProperty("Value")!, typeof(Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType).GetConstructor(new[] { typeof(Microsoft.AspNetCore.Http.HttpContext), typeof(Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty) })?.GetParameters()[1]);
                PopulateMetadataForParameter<global::Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty>(Value_ParameterInfo, options.EndpointBuilder);
                PopulateMetadataForEndpoint<global::Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty>(methodInfo, options.EndpointBuilder);
                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
            };
            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, "ApplicationServices not found.");
                Debug.Assert(options.EndpointBuilder.FilterFactories != null, "FilterFactories not found.");
                var handler = Cast(del, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType arg0) => throw null!);
                EndpointFilterDelegate? filteredInvocation = null;
                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;
                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);
                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;
                var jsonSerializerOptions = jsonOptions.SerializerOptions;
                jsonSerializerOptions.MakeReadOnly();
                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));
                var serviceProviderIsService = serviceProvider?.GetService<IServiceProviderIsService>();
                var Value_JsonBodyOrServiceResolver = ResolveJsonBodyOrService<global::Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty>(logOrThrowExceptionHelper, "AddsCustomParameterMetadataAsProperty", "Value", jsonSerializerOptions, serviceProviderIsService);

                if (options.EndpointBuilder.FilterFactories.Count > 0)
                {
                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                    {
                        if (ic.HttpContext.Response.StatusCode == 400)
                        {
                            return ValueTask.FromResult<object?>(Results.Empty);
                        }
                        handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType>(0)!);
                        return ValueTask.FromResult<object?>(Results.Empty);
                    },
                    options.EndpointBuilder,
                    handler.Method);
                }

                async Task RequestHandler(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    // Endpoint Parameter: Value (Type = Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)
                    var Value_resolveJsonBodyOrServiceResult = await Value_JsonBodyOrServiceResolver(httpContext, false);
                    if (!Value_resolveJsonBodyOrServiceResult.Item1)
                    {
                        return;
                    }
                    var Value_local = Value_resolveJsonBodyOrServiceResult.Item2!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType(HttpContext_local, Value_local);

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                        return;
                    }
                    handler(args_local);
                }

                async Task RequestHandlerFiltered(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        var HttpContext_local = httpContext;
                    // Endpoint Parameter: Value (Type = Microsoft.AspNetCore.Http.Generators.Tests.AddsCustomParameterMetadataAsProperty, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)
                    var Value_resolveJsonBodyOrServiceResult = await Value_JsonBodyOrServiceResolver(httpContext, false);
                    if (!Value_resolveJsonBodyOrServiceResult.Item1)
                    {
                        return;
                    }
                    var Value_local = Value_resolveJsonBodyOrServiceResult.Item2!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType(HttpContext_local, Value_local);

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                    }
                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType>(httpContext, args_local));
                    if (result is not null)
                    {
                        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);
                    }
                }

                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                return new RequestDelegateResult(targetDelegate, metadata);
            };
            var castHandler = Cast(handler, void (global::Microsoft.AspNetCore.Http.Generators.Tests.ParametersListWithMetadataType arg0) => throw null!);
            return MapCore(
                endpoints,
                pattern,
                handler,
                GetVerb,
                populateMetadata,
                createRequestDelegate,
                castHandler.Method);
        }

        %INTERCEPTSLOCATIONATTRIBUTE%
        internal static RouteHandlerBuilder MapPost5(
            this IEndpointRouteBuilder endpoints,
            [StringSyntax("Route")] string pattern,
            Delegate handler)
        {
            MetadataPopulator populateMetadata = (methodInfo, options) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                options.EndpointBuilder.Metadata.Add(new System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.AspNetCore.Http.RequestDelegateGenerator, Version=42.42.42.42, Culture=neutral, PublicKeyToken=adb9793829ddae60", "42.42.42.42"));
                options.EndpointBuilder.Metadata.Add(new AcceptsMetadata(contentTypes: GeneratedMetadataConstants.JsonContentType));
                options.EndpointBuilder.Metadata.Add(new ProducesResponseTypeMetadata(statusCode: StatusCodes.Status200OK, contentTypes: GeneratedMetadataConstants.PlaintextContentType));
                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
            };
            RequestDelegateFactoryFunc createRequestDelegate = (del, options, inferredMetadataResult) =>
            {
                Debug.Assert(options != null, "RequestDelegateFactoryOptions not found.");
                Debug.Assert(options.EndpointBuilder != null, "EndpointBuilder not found.");
                Debug.Assert(options.EndpointBuilder.ApplicationServices != null, "ApplicationServices not found.");
                Debug.Assert(options.EndpointBuilder.FilterFactories != null, "FilterFactories not found.");
                var handler = Cast(del, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService arg0) => throw null!);
                EndpointFilterDelegate? filteredInvocation = null;
                var serviceProvider = options.ServiceProvider ?? options.EndpointBuilder.ApplicationServices;
                var logOrThrowExceptionHelper = new LogOrThrowExceptionHelper(serviceProvider, options);
                var jsonOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value ?? FallbackJsonOptions;
                var jsonSerializerOptions = jsonOptions.SerializerOptions;
                jsonSerializerOptions.MakeReadOnly();
                var objectJsonTypeInfo = (JsonTypeInfo<object?>)jsonSerializerOptions.GetTypeInfo(typeof(object));
                var serviceProviderIsService = serviceProvider?.GetService<IServiceProviderIsService>();
                var Todo_JsonBodyOrServiceResolver = ResolveJsonBodyOrService<global::Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct>(logOrThrowExceptionHelper, "TodoStruct", "Todo", jsonSerializerOptions, serviceProviderIsService);
                var Service_JsonBodyOrServiceResolver = ResolveJsonBodyOrService<global::Microsoft.AspNetCore.Http.Generators.Tests.TestService>(logOrThrowExceptionHelper, "TestService", "Service", jsonSerializerOptions, serviceProviderIsService);

                if (options.EndpointBuilder.FilterFactories.Count > 0)
                {
                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                    {
                        if (ic.HttpContext.Response.StatusCode == 400)
                        {
                            return ValueTask.FromResult<object?>(Results.Empty);
                        }
                        return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService>(0)!));
                    },
                    options.EndpointBuilder,
                    handler.Method);
                }

                async Task RequestHandler(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        // Endpoint Parameter: Todo (Type = Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)
                    var Todo_resolveJsonBodyOrServiceResult = await Todo_JsonBodyOrServiceResolver(httpContext, false);
                    if (!Todo_resolveJsonBodyOrServiceResult.Item1)
                    {
                        return;
                    }
                    var Todo_local = Todo_resolveJsonBodyOrServiceResult.Item2!;
                    // Endpoint Parameter: Service (Type = Microsoft.AspNetCore.Http.Generators.Tests.TestService, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)
                    var Service_resolveJsonBodyOrServiceResult = await Service_JsonBodyOrServiceResolver(httpContext, false);
                    if (!Service_resolveJsonBodyOrServiceResult.Item1)
                    {
                        return;
                    }
                    var Service_local = Service_resolveJsonBodyOrServiceResult.Item2!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService { Todo = Todo_local, Service = Service_local };

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                        return;
                    }
                    var result = handler(args_local);
                    if (result is string)
                    {
                        httpContext.Response.ContentType ??= "text/plain; charset=utf-8";
                    }
                    else
                    {
                        httpContext.Response.ContentType ??= "application/json; charset=utf-8";
                    }
                    await httpContext.Response.WriteAsync(result);
                }

                async Task RequestHandlerFiltered(HttpContext httpContext)
                {
                    var wasParamCheckFailure = false;
                    // Endpoint Parameter: args (Type = Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService, IsOptional = False, IsParsable = False, IsArray = False, Source = AsParameters)
                                        // Endpoint Parameter: Todo (Type = Microsoft.AspNetCore.Http.Generators.Tests.TodoStruct, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)
                    var Todo_resolveJsonBodyOrServiceResult = await Todo_JsonBodyOrServiceResolver(httpContext, false);
                    if (!Todo_resolveJsonBodyOrServiceResult.Item1)
                    {
                        return;
                    }
                    var Todo_local = Todo_resolveJsonBodyOrServiceResult.Item2!;
                    // Endpoint Parameter: Service (Type = Microsoft.AspNetCore.Http.Generators.Tests.TestService, IsOptional = False, IsParsable = False, IsArray = False, Source = JsonBodyOrService)
                    var Service_resolveJsonBodyOrServiceResult = await Service_JsonBodyOrServiceResolver(httpContext, false);
                    if (!Service_resolveJsonBodyOrServiceResult.Item1)
                    {
                        return;
                    }
                    var Service_local = Service_resolveJsonBodyOrServiceResult.Item2!;

                    var args_local = new global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService { Todo = Todo_local, Service = Service_local };

                    if (wasParamCheckFailure)
                    {
                        httpContext.Response.StatusCode = 400;
                    }
                    var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService>(httpContext, args_local));
                    if (result is not null)
                    {
                        await GeneratedRouteBuilderExtensionsCore.ExecuteReturnAsync(result, httpContext, objectJsonTypeInfo);
                    }
                }

                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                return new RequestDelegateResult(targetDelegate, metadata);
            };
            var castHandler = Cast(handler, global::System.String (global::Microsoft.AspNetCore.Http.Generators.Tests.ParameterRecordStructWithJsonBodyOrService arg0) => throw null!);
            return MapCore(
                endpoints,
                pattern,
                handler,
                PostVerb,
                populateMetadata,
                createRequestDelegate,
                castHandler.Method);
        }



        internal static RouteHandlerBuilder MapCore(
            this IEndpointRouteBuilder routes,
            string pattern,
            Delegate handler,
            IEnumerable<string>? httpMethods,
            MetadataPopulator populateMetadata,
            RequestDelegateFactoryFunc createRequestDelegate,
            MethodInfo methodInfo)
        {
            return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate, methodInfo);
        }

        private static T Cast<T>(Delegate d, T _) where T : Delegate
        {
            return (T)d;
        }

        private static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)
        {
            var routeHandlerFilters =  builder.FilterFactories;
            var context0 = new EndpointFilterFactoryContext
            {
                MethodInfo = mi,
                ApplicationServices = builder.ApplicationServices,
            };
            var initialFilteredInvocation = filteredInvocation;
            for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)
            {
                var filterFactory = routeHandlerFilters[i];
                filteredInvocation = filterFactory(context0, filteredInvocation);
            }
            return filteredInvocation;
        }

        private static Task ExecuteReturnAsync(object? obj, HttpContext httpContext, JsonTypeInfo<object?> jsonTypeInfo)
        {
            if (obj is IResult r)
            {
                return r.ExecuteAsync(httpContext);
            }
            else if (obj is string s)
            {
                return httpContext.Response.WriteAsync(s);
            }
            else
            {
                return WriteJsonResponseAsync(httpContext.Response, obj, jsonTypeInfo);
            }
        }

        [UnconditionalSuppressMessage("Trimming", "IL2026:RequiresUnreferencedCode",
            Justification = "The 'JsonSerializer.IsReflectionEnabledByDefault' feature switch, which is set to false by default for trimmed ASP.NET apps, ensures the JsonSerializer doesn't use Reflection.")]
        [UnconditionalSuppressMessage("AOT", "IL3050:RequiresDynamicCode", Justification = "See above.")]
        private static Task WriteJsonResponseAsync<T>(HttpResponse response, T? value, JsonTypeInfo<T?> jsonTypeInfo)
        {
            var runtimeType = value?.GetType();

            if (jsonTypeInfo.ShouldUseWith(runtimeType))
            {
                return HttpResponseJsonExtensions.WriteAsJsonAsync(response, value, jsonTypeInfo, default);
            }

            return response.WriteAsJsonAsync<object?>(value, jsonTypeInfo.Options);
        }

        private static bool HasKnownPolymorphism(this JsonTypeInfo jsonTypeInfo)
            => jsonTypeInfo.Type.IsSealed || jsonTypeInfo.Type.IsValueType || jsonTypeInfo.PolymorphismOptions is not null;

        private static bool ShouldUseWith(this JsonTypeInfo jsonTypeInfo, [NotNullWhen(false)] Type? runtimeType)
            => runtimeType is null || jsonTypeInfo.Type == runtimeType || jsonTypeInfo.HasKnownPolymorphism();

        private static Func<HttpContext, StringValues> ResolveFromRouteOrQuery(string parameterName, IEnumerable<string>? routeParameterNames)
        {
            return routeParameterNames?.Contains(parameterName, StringComparer.OrdinalIgnoreCase) == true
                ? (httpContext) => new StringValues((string?)httpContext.Request.RouteValues[parameterName])
                : (httpContext) => httpContext.Request.Query[parameterName];
        }
        private static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, LogOrThrowExceptionHelper logOrThrowExceptionHelper, bool allowEmpty, string parameterTypeName, string parameterName, JsonTypeInfo<T> jsonTypeInfo, bool isInferred = false)
        {
            var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();
            T? bodyValue = default;
            var bodyValueSet = false;

            if (feature?.CanHaveBody == true)
            {
                if (!httpContext.Request.HasJsonContentType())
                {
                    logOrThrowExceptionHelper.UnexpectedJsonContentType(httpContext.Request.ContentType);
                    httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;
                    return (false, default);
                }
                try
                {
                    bodyValue = await httpContext.Request.ReadFromJsonAsync(jsonTypeInfo);
                    bodyValueSet = bodyValue != null;
                }
                catch (BadHttpRequestException badHttpRequestException)
                {
                    logOrThrowExceptionHelper.RequestBodyIOException(badHttpRequestException);
                    httpContext.Response.StatusCode = badHttpRequestException.StatusCode;
                    return (false, default);
                }
                catch (IOException ioException)
                {
                    logOrThrowExceptionHelper.RequestBodyIOException(ioException);
                    httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
                    return (false, default);
                }
                catch (System.Text.Json.JsonException jsonException)
                {
                    logOrThrowExceptionHelper.InvalidJsonRequestBody(parameterTypeName, parameterName, jsonException);
                    httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
                    return (false, default);
                }
            }

            if (!allowEmpty && !bodyValueSet)
            {
                if (!isInferred)
                {
                    logOrThrowExceptionHelper.RequiredParameterNotProvided(parameterTypeName, parameterName, "body");
                }
                else
                {
                    logOrThrowExceptionHelper.ImplicitBodyNotProvided(parameterName);
                }
                httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
                return (false, bodyValue);
            }

            return (true, bodyValue);
        }
        private static Func<HttpContext, bool, ValueTask<(bool, T?)>> ResolveJsonBodyOrService<T>(LogOrThrowExceptionHelper logOrThrowExceptionHelper, string parameterTypeName, string parameterName, JsonSerializerOptions jsonSerializerOptions, IServiceProviderIsService? serviceProviderIsService = null)
        {
            if (serviceProviderIsService is not null)
            {
                if (serviceProviderIsService.IsService(typeof(T)))
                {
                    return static (httpContext, isOptional) => new ValueTask<(bool, T?)>((true, httpContext.RequestServices.GetService<T>()));
                }
            }
            var jsonTypeInfo = (JsonTypeInfo<T>)jsonSerializerOptions.GetTypeInfo(typeof(T));
            return (httpContext, isOptional) => TryResolveBodyAsync<T>(httpContext, logOrThrowExceptionHelper, isOptional, parameterTypeName, parameterName, jsonTypeInfo, isInferred: true);
        }
        private static bool TryParseExplicit<T>(string? s, IFormatProvider? provider, [MaybeNullWhen(returnValue: false)] out T result) where T: IParsable<T>
            => T.TryParse(s, provider, out result);
        private static void PopulateMetadataForEndpoint<T>(MethodInfo method, EndpointBuilder builder)
            where T : IEndpointMetadataProvider
        {
            T.PopulateMetadata(method, builder);
        }
        private static void PopulateMetadataForParameter<T>(ParameterInfo parameter, EndpointBuilder builder)
            where T : IEndpointParameterMetadataProvider
        {
            T.PopulateMetadata(parameter, builder);
        }

    }

    %GENERATEDCODEATTRIBUTE%
    file static class GeneratedMetadataConstants
    {
        public static readonly string[] JsonContentType = new [] { "application/json" };
        public static readonly string[] PlaintextContentType = new [] { "text/plain" };
        public static readonly string[] FormFileContentType = new[] { "multipart/form-data" };
        public static readonly string[] FormContentType = new[] { "multipart/form-data", "application/x-www-form-urlencoded" };
    }

    %GENERATEDCODEATTRIBUTE%
    file sealed class PropertyAsParameterInfo : ParameterInfo
    {
        private readonly PropertyInfo _underlyingProperty;
        private readonly ParameterInfo? _constructionParameterInfo;

        public PropertyAsParameterInfo(bool isOptional, PropertyInfo propertyInfo)
        {
            Debug.Assert(propertyInfo != null, "PropertyInfo must be provided.");

            AttrsImpl = (ParameterAttributes)propertyInfo.Attributes;
            NameImpl = propertyInfo.Name;
            MemberImpl = propertyInfo;
            ClassImpl = propertyInfo.PropertyType;

            // It is not a real parameter in the delegate, so,
            // not defining a real position.
            PositionImpl = -1;

            _underlyingProperty = propertyInfo;
            IsOptional = isOptional;
        }

        public PropertyAsParameterInfo(bool isOptional, PropertyInfo property, ParameterInfo? parameterInfo)
            : this(isOptional, property)
        {
            _constructionParameterInfo = parameterInfo;
        }

        public override bool HasDefaultValue
            => _constructionParameterInfo is not null && _constructionParameterInfo.HasDefaultValue;
        public override object? DefaultValue
            => _constructionParameterInfo?.DefaultValue;
        public override int MetadataToken => _underlyingProperty.MetadataToken;
        public override object? RawDefaultValue
            => _constructionParameterInfo?.RawDefaultValue;

        public override object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            var constructorAttributes = _constructionParameterInfo?.GetCustomAttributes(attributeType, inherit);

            if (constructorAttributes == null || constructorAttributes is { Length: 0 })
            {
                return _underlyingProperty.GetCustomAttributes(attributeType, inherit);
            }

            var propertyAttributes = _underlyingProperty.GetCustomAttributes(attributeType, inherit);

            var mergedAttributes = new Attribute[constructorAttributes.Length + propertyAttributes.Length];
            Array.Copy(constructorAttributes, mergedAttributes, constructorAttributes.Length);
            Array.Copy(propertyAttributes, 0, mergedAttributes, constructorAttributes.Length, propertyAttributes.Length);

            return mergedAttributes;
        }

        public override object[] GetCustomAttributes(bool inherit)
        {
            var constructorAttributes = _constructionParameterInfo?.GetCustomAttributes(inherit);

            if (constructorAttributes == null || constructorAttributes is { Length: 0 })
            {
                return _underlyingProperty.GetCustomAttributes(inherit);
            }

            var propertyAttributes = _underlyingProperty.GetCustomAttributes(inherit);

            // Since the constructors attributes should take priority we will add them first,
            // as we usually call it as First() or FirstOrDefault() in the argument creation
            var mergedAttributes = new object[constructorAttributes.Length + propertyAttributes.Length];
            Array.Copy(constructorAttributes, mergedAttributes, constructorAttributes.Length);
            Array.Copy(propertyAttributes, 0, mergedAttributes, constructorAttributes.Length, propertyAttributes.Length);

            return mergedAttributes;
        }

        public override IList<CustomAttributeData> GetCustomAttributesData()
        {
            var attributes = new List<CustomAttributeData>(
                _constructionParameterInfo?.GetCustomAttributesData() ?? Array.Empty<CustomAttributeData>());
            attributes.AddRange(_underlyingProperty.GetCustomAttributesData());

            return attributes.AsReadOnly();
        }

        public override Type[] GetOptionalCustomModifiers()
            => _underlyingProperty.GetOptionalCustomModifiers();

        public override Type[] GetRequiredCustomModifiers()
            => _underlyingProperty.GetRequiredCustomModifiers();

        public override bool IsDefined(Type attributeType, bool inherit)
        {
            return (_constructionParameterInfo is not null && _constructionParameterInfo.IsDefined(attributeType, inherit)) ||
                _underlyingProperty.IsDefined(attributeType, inherit);
        }

        public new bool IsOptional { get; }
    }

    %GENERATEDCODEATTRIBUTE%
    file sealed class LogOrThrowExceptionHelper
    {
        private readonly ILogger? _rdgLogger;
        private readonly bool _shouldThrow;

        public LogOrThrowExceptionHelper(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)
        {
            var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();
            _rdgLogger = loggerFactory?.CreateLogger("Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator");
            _shouldThrow = options?.ThrowOnBadRequest ?? false;
        }

        public void RequestBodyIOException(IOException exception)
        {
            if (_rdgLogger != null)
            {
                _requestBodyIOException(_rdgLogger, exception);
            }
        }

        private static readonly Action<ILogger, Exception?> _requestBodyIOException =
            LoggerMessage.Define(LogLevel.Debug, new EventId(1, "RequestBodyIOException"), "Reading the request body failed with an IOException.");

        public void InvalidJsonRequestBody(string parameterTypeName, string parameterName, Exception exception)
        {
            if (_shouldThrow)
            {
                var message = string.Format(CultureInfo.InvariantCulture, "Failed to read parameter \"{0} {1}\" from the request body as JSON.", parameterTypeName, parameterName);
                throw new BadHttpRequestException(message, exception);
            }

            if (_rdgLogger != null)
            {
                _invalidJsonRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);
            }
        }

        private static readonly Action<ILogger, string, string, Exception?> _invalidJsonRequestBody =
            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(2, "InvalidJsonRequestBody"), "Failed to read parameter \"{ParameterType} {ParameterName}\" from the request body as JSON.");

        public void ParameterBindingFailed(string parameterTypeName, string parameterName, string sourceValue)
        {
            if (_shouldThrow)
            {
                var message = string.Format(CultureInfo.InvariantCulture, "Failed to bind parameter \"{0} {1}\" from \"{2}\".", parameterTypeName, parameterName, sourceValue);
                throw new BadHttpRequestException(message);
            }

            if (_rdgLogger != null)
            {
                _parameterBindingFailed(_rdgLogger, parameterTypeName, parameterName, sourceValue, null);
            }
        }

        private static readonly Action<ILogger, string, string, string, Exception?> _parameterBindingFailed =
            LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(3, "ParameterBindingFailed"), "Failed to bind parameter \"{ParameterType} {ParameterName}\" from \"{SourceValue}\".");

        public void RequiredParameterNotProvided(string parameterTypeName, string parameterName, string source)
        {
            if (_shouldThrow)
            {
                var message = string.Format(CultureInfo.InvariantCulture, "Required parameter \"{0} {1}\" was not provided from {2}.", parameterTypeName, parameterName, source);
                throw new BadHttpRequestException(message);
            }

            if (_rdgLogger != null)
            {
                _requiredParameterNotProvided(_rdgLogger, parameterTypeName, parameterName, source, null);
            }
        }

        private static readonly Action<ILogger, string, string, string, Exception?> _requiredParameterNotProvided =
            LoggerMessage.Define<string, string, string>(LogLevel.Debug, new EventId(4, "RequiredParameterNotProvided"), "Required parameter \"{ParameterType} {ParameterName}\" was not provided from {Source}.");

        public void ImplicitBodyNotProvided(string parameterName)
        {
            if (_shouldThrow)
            {
                var message = string.Format(CultureInfo.InvariantCulture, "Implicit body inferred for parameter \"{0}\" but no body was provided. Did you mean to use a Service instead?", parameterName);
                throw new BadHttpRequestException(message);
            }

            if (_rdgLogger != null)
            {
                _implicitBodyNotProvided(_rdgLogger, parameterName, null);
            }
        }

        private static readonly Action<ILogger, string, Exception?> _implicitBodyNotProvided =
            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(5, "ImplicitBodyNotProvided"), "Implicit body inferred for parameter \"{ParameterName}\" but no body was provided. Did you mean to use a Service instead?");

        public void UnexpectedJsonContentType(string? contentType)
        {
            if (_shouldThrow)
            {
                var message = string.Format(CultureInfo.InvariantCulture, "Expected a supported JSON media type but got \"{0}\".", contentType);
                throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);
            }

            if (_rdgLogger != null)
            {
                _unexpectedJsonContentType(_rdgLogger, contentType ?? "(none)", null);
            }
        }

        private static readonly Action<ILogger, string, Exception?> _unexpectedJsonContentType =
            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(6, "UnexpectedContentType"), "Expected a supported JSON media type but got \"{ContentType}\".");

        public void UnexpectedNonFormContentType(string? contentType)
        {
            if (_shouldThrow)
            {
                var message = string.Format(CultureInfo.InvariantCulture, "Expected a supported form media type but got \"{0}\".", contentType);
                throw new BadHttpRequestException(message, StatusCodes.Status415UnsupportedMediaType);
            }

            if (_rdgLogger != null)
            {
                _unexpectedNonFormContentType(_rdgLogger, contentType ?? "(none)", null);
            }
        }

        private static readonly Action<ILogger, string, Exception?> _unexpectedNonFormContentType =
            LoggerMessage.Define<string>(LogLevel.Debug, new EventId(7, "UnexpectedNonFormContentType"), "Expected a supported form media type but got \"{ContentType}\".");

        public void InvalidFormRequestBody(string parameterTypeName, string parameterName, Exception exception)
        {
            if (_shouldThrow)
            {
                var message = string.Format(CultureInfo.InvariantCulture, "Failed to read parameter \"{0} {1}\" from the request body as form.", parameterTypeName, parameterName);
                throw new BadHttpRequestException(message, exception);
            }

            if (_rdgLogger != null)
            {
                _invalidFormRequestBody(_rdgLogger, parameterTypeName, parameterName, exception);
            }
        }

        private static readonly Action<ILogger, string, string, Exception?> _invalidFormRequestBody =
            LoggerMessage.Define<string, string>(LogLevel.Debug, new EventId(8, "InvalidFormRequestBody"), "Failed to read parameter \"{ParameterType} {ParameterName}\" from the request body as form.");
    }
}
