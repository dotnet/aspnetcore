//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

namespace Microsoft.AspNetCore.Builder
{
    %GENERATEDCODEATTRIBUTE%
    internal class SourceKey
    {
        public string Path { get; init; }
        public int Line { get; init; }

        public SourceKey(string path, int line)
        {
            Path = path;
            Line = line;
        }
    }

    // This class needs to be internal so that the compiled application
    // has access to the strongly-typed endpoint definitions that are
    // generated by the compiler so that they will be favored by
    // overload resolution and opt the runtime in to the code generated
    // implementation produced here.
    %GENERATEDCODEATTRIBUTE%
    internal static class GenerateRouteBuilderEndpoints
    {
        private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };
        private static readonly string[] PostVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Post };
        private static readonly string[] PutVerb = new[]  { global::Microsoft.AspNetCore.Http.HttpMethods.Put };
        private static readonly string[] DeleteVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Delete };
        private static readonly string[] PatchVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Patch };

        internal static global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder MapGet(
            this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints,
            [global::System.Diagnostics.CodeAnalysis.StringSyntax("Route")] string pattern,
            global::System.Func<global::System.String?, global::System.String> handler,
            [global::System.Runtime.CompilerServices.CallerFilePath] string filePath = "",
            [global::System.Runtime.CompilerServices.CallerLineNumber]int lineNumber = 0)
        {
            return global::Microsoft.AspNetCore.Http.Generated.GeneratedRouteBuilderExtensionsCore.MapCore(
                    endpoints,
                    pattern,
                    handler,
                    GetVerb,
                    filePath,
                    lineNumber);
        }

    }
}

namespace Microsoft.AspNetCore.Http.Generated
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Linq;
    using System.Reflection;
    using System.Threading.Tasks;
    using System.IO;
    using Microsoft.AspNetCore.Routing;
    using Microsoft.AspNetCore.Routing.Patterns;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Http.Metadata;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.FileProviders;
    using Microsoft.Extensions.Primitives;

    using MetadataPopulator = System.Func<System.Reflection.MethodInfo, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions?, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult>;
    using RequestDelegateFactoryFunc = System.Func<System.Delegate, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult?, Microsoft.AspNetCore.Http.RequestDelegateResult>;

    file static class GeneratedRouteBuilderExtensionsCore
    {

        private static readonly Dictionary<(string, int), (MetadataPopulator, RequestDelegateFactoryFunc)> map = new()
        {
            [(@"TestMapActions.cs", 16)] = (
               (methodInfo, options) =>
                {
                    Debug.Assert(options?.EndpointBuilder != null, "EndpointBuilder not found.");
                    options.EndpointBuilder.Metadata.Add(new SourceKey(@"TestMapActions.cs", 16));
                    return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
                },
                (del, options, inferredMetadataResult) =>
                {
                    var handler = (Func<global::System.String?, global::System.String>)del;
                    EndpointFilterDelegate? filteredInvocation = null;

                    if (options?.EndpointBuilder?.FilterFactories.Count > 0)
                    {
                        filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                        {
                            if (ic.HttpContext.Response.StatusCode == 400)
                            {
                                return ValueTask.FromResult<object?>(Results.Empty);
                            }
                            return ValueTask.FromResult<object?>(handler(ic.GetArgument<string?>(0)));
                        },
                        options.EndpointBuilder,
                        handler.Method);
                    }

                    Task RequestHandler(HttpContext httpContext)
                    {
                        var wasParamCheckFailure = false;
                        // Endpoint Parameter: p (Type = string?, IsOptional = True, Source = Query)
                        var p_raw = httpContext.Request.Query["p"];
                        var p_local = p_raw.Count > 0 ? p_raw.ToString() : null;

                        if (wasParamCheckFailure)
                        {
                            httpContext.Response.StatusCode = 400;
                            return Task.CompletedTask;
                        }
                        httpContext.Response.ContentType ??= "text/plain";
                        var result = handler(p_local);
                        return httpContext.Response.WriteAsync(result);
                    }
                    async Task RequestHandlerFiltered(HttpContext httpContext)
                    {
                        var wasParamCheckFailure = false;
                        // Endpoint Parameter: p (Type = string?, IsOptional = True, Source = Query)
                        var p_raw = httpContext.Request.Query["p"];
                        var p_local = p_raw.Count > 0 ? p_raw.ToString() : null;

                        if (wasParamCheckFailure)
                        {
                            httpContext.Response.StatusCode = 400;
                        }
                        var result = await filteredInvocation(new EndpointFilterInvocationContext<string?>(httpContext, p_local));
                        await GeneratedRouteBuilderExtensionsCore.ExecuteObjectResult(result, httpContext);
                    }

                    RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                    var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                    return new RequestDelegateResult(targetDelegate, metadata);
                }),

        };

        internal static RouteHandlerBuilder MapCore(
            this IEndpointRouteBuilder routes,
            string pattern,
            Delegate handler,
            IEnumerable<string> httpMethods,
            string filePath,
            int lineNumber)
        {
            var (populateMetadata, createRequestDelegate) = map[(filePath, lineNumber)];
            return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate);
        }

        private static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)
        {
            var routeHandlerFilters =  builder.FilterFactories;
            var context0 = new EndpointFilterFactoryContext
            {
                MethodInfo = mi,
                ApplicationServices = builder.ApplicationServices,
            };
            var initialFilteredInvocation = filteredInvocation;
            for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)
            {
                var filterFactory = routeHandlerFilters[i];
                filteredInvocation = filterFactory(context0, filteredInvocation);
            }
            return filteredInvocation;
        }

        private static Task ExecuteObjectResult(object? obj, HttpContext httpContext)
        {
            if (obj is IResult r)
            {
                return r.ExecuteAsync(httpContext);
            }
            else if (obj is string s)
            {
                return httpContext.Response.WriteAsync(s);
            }
            else
            {
                return httpContext.Response.WriteAsJsonAsync(obj);
            }
        }

        private static async ValueTask<(bool, T?)> TryResolveBody<T>(HttpContext httpContext, bool allowEmpty)
        {
            var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();

            if (feature?.CanHaveBody == true)
            {
                if (!httpContext.Request.HasJsonContentType())
                {
                    httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;
                    return (false, default);
                }
                try
                {
                    var bodyValue = await httpContext.Request.ReadFromJsonAsync<T>();
                    if (!allowEmpty && bodyValue == null)
                    {
                        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
                        return (false, bodyValue);
                    }
                    return (true, bodyValue);
                }
                catch (IOException)
                {
                    return (false, default);
                }
                catch (System.Text.Json.JsonException)
                {
                    httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
                    return (false, default);
                }
            }
            return (false, default);
        }
    }

    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }

        public int Count => 1;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }

        public int Count => 2;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1, T2> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
            Arg2 = arg2;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                2 => Arg2,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                   case 2:
                        Arg2 = (T2)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }
        public T2 Arg2 { get; set; }

        public int Count => 3;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               2 => (T)(object)Arg2!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1, T2, T3> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
            Arg2 = arg2;
            Arg3 = arg3;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                2 => Arg2,
                3 => Arg3,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                   case 2:
                        Arg2 = (T2)(object?)value!;
                        break;
                   case 3:
                        Arg3 = (T3)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }
        public T2 Arg2 { get; set; }
        public T3 Arg3 { get; set; }

        public int Count => 4;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               2 => (T)(object)Arg2!,
               3 => (T)(object)Arg3!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1, T2, T3, T4> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
            Arg2 = arg2;
            Arg3 = arg3;
            Arg4 = arg4;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                2 => Arg2,
                3 => Arg3,
                4 => Arg4,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                   case 2:
                        Arg2 = (T2)(object?)value!;
                        break;
                   case 3:
                        Arg3 = (T3)(object?)value!;
                        break;
                   case 4:
                        Arg4 = (T4)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }
        public T2 Arg2 { get; set; }
        public T3 Arg3 { get; set; }
        public T4 Arg4 { get; set; }

        public int Count => 5;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               2 => (T)(object)Arg2!,
               3 => (T)(object)Arg3!,
               4 => (T)(object)Arg4!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
            Arg2 = arg2;
            Arg3 = arg3;
            Arg4 = arg4;
            Arg5 = arg5;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                2 => Arg2,
                3 => Arg3,
                4 => Arg4,
                5 => Arg5,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                   case 2:
                        Arg2 = (T2)(object?)value!;
                        break;
                   case 3:
                        Arg3 = (T3)(object?)value!;
                        break;
                   case 4:
                        Arg4 = (T4)(object?)value!;
                        break;
                   case 5:
                        Arg5 = (T5)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }
        public T2 Arg2 { get; set; }
        public T3 Arg3 { get; set; }
        public T4 Arg4 { get; set; }
        public T5 Arg5 { get; set; }

        public int Count => 6;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               2 => (T)(object)Arg2!,
               3 => (T)(object)Arg3!,
               4 => (T)(object)Arg4!,
               5 => (T)(object)Arg5!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5, T6> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
            Arg2 = arg2;
            Arg3 = arg3;
            Arg4 = arg4;
            Arg5 = arg5;
            Arg6 = arg6;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                2 => Arg2,
                3 => Arg3,
                4 => Arg4,
                5 => Arg5,
                6 => Arg6,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                   case 2:
                        Arg2 = (T2)(object?)value!;
                        break;
                   case 3:
                        Arg3 = (T3)(object?)value!;
                        break;
                   case 4:
                        Arg4 = (T4)(object?)value!;
                        break;
                   case 5:
                        Arg5 = (T5)(object?)value!;
                        break;
                   case 6:
                        Arg6 = (T6)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }
        public T2 Arg2 { get; set; }
        public T3 Arg3 { get; set; }
        public T4 Arg4 { get; set; }
        public T5 Arg5 { get; set; }
        public T6 Arg6 { get; set; }

        public int Count => 7;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               2 => (T)(object)Arg2!,
               3 => (T)(object)Arg3!,
               4 => (T)(object)Arg4!,
               5 => (T)(object)Arg5!,
               6 => (T)(object)Arg6!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5, T6, T7> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
            Arg2 = arg2;
            Arg3 = arg3;
            Arg4 = arg4;
            Arg5 = arg5;
            Arg6 = arg6;
            Arg7 = arg7;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                2 => Arg2,
                3 => Arg3,
                4 => Arg4,
                5 => Arg5,
                6 => Arg6,
                7 => Arg7,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                   case 2:
                        Arg2 = (T2)(object?)value!;
                        break;
                   case 3:
                        Arg3 = (T3)(object?)value!;
                        break;
                   case 4:
                        Arg4 = (T4)(object?)value!;
                        break;
                   case 5:
                        Arg5 = (T5)(object?)value!;
                        break;
                   case 6:
                        Arg6 = (T6)(object?)value!;
                        break;
                   case 7:
                        Arg7 = (T7)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }
        public T2 Arg2 { get; set; }
        public T3 Arg3 { get; set; }
        public T4 Arg4 { get; set; }
        public T5 Arg5 { get; set; }
        public T6 Arg6 { get; set; }
        public T7 Arg7 { get; set; }

        public int Count => 8;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               2 => (T)(object)Arg2!,
               3 => (T)(object)Arg3!,
               4 => (T)(object)Arg4!,
               5 => (T)(object)Arg5!,
               6 => (T)(object)Arg6!,
               7 => (T)(object)Arg7!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5, T6, T7, T8> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
            Arg2 = arg2;
            Arg3 = arg3;
            Arg4 = arg4;
            Arg5 = arg5;
            Arg6 = arg6;
            Arg7 = arg7;
            Arg8 = arg8;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                2 => Arg2,
                3 => Arg3,
                4 => Arg4,
                5 => Arg5,
                6 => Arg6,
                7 => Arg7,
                8 => Arg8,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                   case 2:
                        Arg2 = (T2)(object?)value!;
                        break;
                   case 3:
                        Arg3 = (T3)(object?)value!;
                        break;
                   case 4:
                        Arg4 = (T4)(object?)value!;
                        break;
                   case 5:
                        Arg5 = (T5)(object?)value!;
                        break;
                   case 6:
                        Arg6 = (T6)(object?)value!;
                        break;
                   case 7:
                        Arg7 = (T7)(object?)value!;
                        break;
                   case 8:
                        Arg8 = (T8)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }
        public T2 Arg2 { get; set; }
        public T3 Arg3 { get; set; }
        public T4 Arg4 { get; set; }
        public T5 Arg5 { get; set; }
        public T6 Arg6 { get; set; }
        public T7 Arg7 { get; set; }
        public T8 Arg8 { get; set; }

        public int Count => 9;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               2 => (T)(object)Arg2!,
               3 => (T)(object)Arg3!,
               4 => (T)(object)Arg4!,
               5 => (T)(object)Arg5!,
               6 => (T)(object)Arg6!,
               7 => (T)(object)Arg7!,
               8 => (T)(object)Arg8!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    %GENERATEDCODEATTRIBUTE%
    file class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> : EndpointFilterInvocationContext, IList<object?>
    {
        internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
        {
            HttpContext = httpContext;
            Arg0 = arg0;
            Arg1 = arg1;
            Arg2 = arg2;
            Arg3 = arg3;
            Arg4 = arg4;
            Arg5 = arg5;
            Arg6 = arg6;
            Arg7 = arg7;
            Arg8 = arg8;
            Arg9 = arg9;
        }

        public object? this[int index]
        {
            get => index switch
            {
                0 => Arg0,
                1 => Arg1,
                2 => Arg2,
                3 => Arg3,
                4 => Arg4,
                5 => Arg5,
                6 => Arg6,
                7 => Arg7,
                8 => Arg8,
                9 => Arg9,
                _ => new IndexOutOfRangeException()
            };
            set
            {
                switch (index)
                {
                   case 0:
                        Arg0 = (T0)(object?)value!;
                        break;
                   case 1:
                        Arg1 = (T1)(object?)value!;
                        break;
                   case 2:
                        Arg2 = (T2)(object?)value!;
                        break;
                   case 3:
                        Arg3 = (T3)(object?)value!;
                        break;
                   case 4:
                        Arg4 = (T4)(object?)value!;
                        break;
                   case 5:
                        Arg5 = (T5)(object?)value!;
                        break;
                   case 6:
                        Arg6 = (T6)(object?)value!;
                        break;
                   case 7:
                        Arg7 = (T7)(object?)value!;
                        break;
                   case 8:
                        Arg8 = (T8)(object?)value!;
                        break;
                   case 9:
                        Arg9 = (T9)(object?)value!;
                        break;
                    default:
                        break;
                }
            }
        }

        public override HttpContext HttpContext { get; }

        public override IList<object?> Arguments => this;

        public T0 Arg0 { get; set; }
        public T1 Arg1 { get; set; }
        public T2 Arg2 { get; set; }
        public T3 Arg3 { get; set; }
        public T4 Arg4 { get; set; }
        public T5 Arg5 { get; set; }
        public T6 Arg6 { get; set; }
        public T7 Arg7 { get; set; }
        public T8 Arg8 { get; set; }
        public T9 Arg9 { get; set; }

        public int Count => 10;

        public bool IsReadOnly => false;

        public bool IsFixedSize => true;

        public void Add(object? item)
        {
            throw new NotSupportedException();
        }

        public void Clear()
        {
            throw new NotSupportedException();
        }

        public bool Contains(object? item)
        {
            return IndexOf(item) >= 0;
        }

        public void CopyTo(object?[] array, int arrayIndex)
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                array[arrayIndex++] = Arguments[i];
            }
        }

        public IEnumerator<object?> GetEnumerator()
        {
            for (int i = 0; i < Arguments.Count; i++)
            {
                yield return Arguments[i];
            }
        }

        public override T GetArgument<T>(int index)
        {
            return index switch
            {
               0 => (T)(object)Arg0!,
               1 => (T)(object)Arg1!,
               2 => (T)(object)Arg2!,
               3 => (T)(object)Arg3!,
               4 => (T)(object)Arg4!,
               5 => (T)(object)Arg5!,
               6 => (T)(object)Arg6!,
               7 => (T)(object)Arg7!,
               8 => (T)(object)Arg8!,
               9 => (T)(object)Arg9!,
               _ => throw new IndexOutOfRangeException()
            };
        }

        public int IndexOf(object? item)
        {
            return Arguments.IndexOf(item);
        }

        public void Insert(int index, object? item)
        {
            throw new NotSupportedException();
        }

        public bool Remove(object? item)
        {
            throw new NotSupportedException();
        }

        public void RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}