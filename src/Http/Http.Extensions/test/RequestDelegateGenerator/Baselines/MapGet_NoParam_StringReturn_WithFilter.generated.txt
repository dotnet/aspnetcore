//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using global::Microsoft.AspNetCore.Http;

namespace Microsoft.AspNetCore.Builder
{
    %GENERATEDCODEATTRIBUTE%
    internal class SourceKey
    {
        public string Path { get; init; }
        public int Line { get; init; }

        public SourceKey(string path, int line)
        {
            Path = path;
            Line = line;
        }
    }
}

// This class needs to be internal so that the compiled application
// has access to the strongly-typed endpoint definitions that are
// generated by the compiler so that they will be favored by
// overload resolution and opt the runtime in to the code generated
// implementation produced here.
internal static class GenerateRouteBuilderEndpoints
{
    %GENERATEDCODEATTRIBUTE%
    internal static global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder MapGet(
        this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints,
        [global::System.Diagnostics.CodeAnalysis.StringSyntax("Route")] string pattern,
        global::System.Func<string> handler,
        [global::System.Runtime.CompilerServices.CallerFilePath] string filePath = "",
        [global::System.Runtime.CompilerServices.CallerLineNumber]int lineNumber = 0)
    {
        return global::Microsoft.AspNetCore.Http.Generated.GeneratedRouteBuilderExtensionsCore.MapCore(endpoints, pattern, handler, new[] { HttpMethods.Get }, filePath, lineNumber);
    }

}

namespace Microsoft.AspNetCore.Http.Generated
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Linq;
    using System.Reflection;
    using System.Threading.Tasks;
    using System.IO;
    using Microsoft.AspNetCore.Routing;
    using Microsoft.AspNetCore.Routing.Patterns;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Http.Metadata;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.FileProviders;
    using Microsoft.Extensions.Primitives;

    using MetadataPopulator = System.Func<System.Reflection.MethodInfo, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions?, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult>;
    using RequestDelegateFactoryFunc = System.Func<System.Delegate, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult?, Microsoft.AspNetCore.Http.RequestDelegateResult>;

    file static class GeneratedRouteBuilderExtensionsCore
    {

        private static readonly Dictionary<(string, int), (MetadataPopulator, RequestDelegateFactoryFunc)> map = new()
        {
            [(@"TestMapActions.cs", 15)] = (
           (methodInfo, options) =>
            {
                if (options == null)
                {
                    return new RequestDelegateMetadataResult { EndpointMetadata = ReadOnlyCollection<object>.Empty };
                }
                options.EndpointBuilder.Metadata.Add(new SourceKey(@"TestMapActions.cs", 15));
                return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
            },
            (del, options, inferredMetadataResult) =>
            {
                var handler = (System.Func<string>)del;
                EndpointFilterDelegate? filteredInvocation = null;

                if (options.EndpointBuilder.FilterFactories.Count > 0)
                {
                    filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                    {
                        if (ic.HttpContext.Response.StatusCode == 400)
                        {
                            return ValueTask.FromResult<object?>(Results.Empty);
                        }
                        return ValueTask.FromResult<object?>(handler());
                    },
                    options.EndpointBuilder,
                    handler.Method);
                }

                Task RequestHandler(HttpContext httpContext)
                {
                        var result = handler();
                        return httpContext.Response.WriteAsync(result);
                }
                async Task RequestHandlerFiltered(HttpContext httpContext)
                {
                    var result = await filteredInvocation(new DefaultEndpointFilterInvocationContext(httpContext));
                    await GeneratedRouteBuilderExtensionsCore.ExecuteObjectResult(result, httpContext);
                }

                RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                return new RequestDelegateResult(targetDelegate, metadata);
            }),

        };

        internal static RouteHandlerBuilder MapCore(
            this IEndpointRouteBuilder routes,
            string pattern,
            Delegate handler,
            IEnumerable<string> httpMethods,
            string filePath,
            int lineNumber)
        {
            var (populateMetadata, createRequestDelegate) = map[(filePath, lineNumber)];
            return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate);
        }

        private static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)
        {
            var routeHandlerFilters =  builder.FilterFactories;
            var context0 = new EndpointFilterFactoryContext
            {
                MethodInfo = mi,
                ApplicationServices = builder.ApplicationServices,
            };
            var initialFilteredInvocation = filteredInvocation;
            for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)
            {
                var filterFactory = routeHandlerFilters[i];
                filteredInvocation = filterFactory(context0, filteredInvocation);
            }
            return filteredInvocation;
        }

        private static void PopulateMetadata<T>(MethodInfo method, EndpointBuilder builder) where T : IEndpointMetadataProvider
        {
            T.PopulateMetadata(method, builder);
        }

        private static void PopulateMetadata<T>(ParameterInfo parameter, EndpointBuilder builder) where T : IEndpointParameterMetadataProvider
        {
            T.PopulateMetadata(parameter, builder);
        }

        private static Task ExecuteObjectResult(object? obj, HttpContext httpContext)
        {
            if (obj is IResult r)
            {
                return r.ExecuteAsync(httpContext);
            }
            else if (obj is string s)
            {
                return httpContext.Response.WriteAsync(s);
            }
            else
            {
                return httpContext.Response.WriteAsJsonAsync(obj);
            }
        }
    }
}
