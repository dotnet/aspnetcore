// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using System.IO;
using System.Collections.Generic;
using System;
using System.Globalization;

namespace Microsoft.AspNetCore.Http.ValidationsGenerator;

public sealed partial class ValidationsGenerator : IIncrementalGenerator
{
    public static string GeneratedCodeConstructor => $@"global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(ValidationsGenerator).Assembly.FullName}"", ""{typeof(ValidationsGenerator).Assembly.GetName().Version}"")";
    public static string GeneratedCodeAttribute => $"[{GeneratedCodeConstructor}]";

    internal static void Emit(SourceProductionContext context, (InterceptableLocation? AddValidation, ImmutableArray<ValidatableType> ValidatableTypes) emitInputs)
    {
        var source = Emit(emitInputs.AddValidation, emitInputs.ValidatableTypes);
        context.AddSource("ValidatableInfoResolver.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string Emit(InterceptableLocation? addValidation, ImmutableArray<ValidatableType> validatableTypes) => $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

namespace System.Runtime.CompilerServices
{
    {{GeneratedCodeAttribute}}
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : System.Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
        }
    }
}

namespace Microsoft.AspNetCore.Http.Validation.Generated
{
    {{GeneratedCodeAttribute}}
    file sealed class GeneratedValidatablePropertyInfo : global::Microsoft.AspNetCore.Http.Validation.ValidatablePropertyInfo
    {
        private readonly global::System.ComponentModel.DataAnnotations.ValidationAttribute[] _validationAttributes;

        public GeneratedValidatablePropertyInfo(
            global::System.Type containingType,
            global::System.Type propertyType,
            string name,
            string displayName,
            global::System.ComponentModel.DataAnnotations.ValidationAttribute[] validationAttributes) : base(containingType, propertyType, name, displayName)
        {
            _validationAttributes = validationAttributes;
        }

        protected override global::System.ComponentModel.DataAnnotations.ValidationAttribute[] GetValidationAttributes() => _validationAttributes;
    }

    {{GeneratedCodeAttribute}}
    file sealed class GeneratedValidatableTypeInfo : global::Microsoft.AspNetCore.Http.Validation.ValidatableTypeInfo
    {
        public GeneratedValidatableTypeInfo(
            global::System.Type type,
            ValidatablePropertyInfo[] members,
            bool implementsIValidatableObject,
            global::System.Type[]? validatableSubTypes = null) : base(type, members, implementsIValidatableObject, validatableSubTypes) { }
    }

    {{GeneratedCodeAttribute}}
    file class GeneratedValidatableInfoResolver : global::Microsoft.AspNetCore.Http.Validation.IValidatableInfoResolver
    {
        public global::Microsoft.AspNetCore.Http.Validation.ValidatableTypeInfo? GetValidatableTypeInfo(global::System.Type type)
        {
{{EmitTypeChecks(validatableTypes)}}
            return null;
        }

        // No-ops, rely on runtime code for ParameterInfo-based resolution
        public global::Microsoft.AspNetCore.Http.Validation.ValidatableParameterInfo? GetValidatableParameterInfo(global::System.Reflection.ParameterInfo parameterInfo)
        {
            return null;
        }

{{EmitCreateMethods(validatableTypes)}}
    }

    {{GeneratedCodeAttribute}}
    file static class GeneratedServiceCollectionExtensions
    {
        {{addValidation!.GetInterceptsLocationAttributeSyntax()}}
        public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddValidation(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services, global::System.Action<ValidationOptions>? configureOptions = null)
        {
            // Use non-extension method to avoid infinite recursion.
            return global::Microsoft.Extensions.DependencyInjection.ValidationServiceCollectionExtensions.AddValidation(services, options =>
            {
                options.Resolvers.Insert(0, new GeneratedValidatableInfoResolver());
                if (configureOptions is not null)
                {
                    configureOptions(options);
                }
            });
        }
    }

    {{GeneratedCodeAttribute}}
    file static class ValidationAttributeCache
    {
        private sealed record CacheKey(global::System.Type AttributeType, object[] Arguments, global::System.Collections.Generic.Dictionary<string, object> NamedArguments);
        private static readonly global::System.Collections.Concurrent.ConcurrentDictionary<CacheKey, global::System.ComponentModel.DataAnnotations.ValidationAttribute> _cache = new();

        public static global::System.ComponentModel.DataAnnotations.ValidationAttribute? GetOrCreateValidationAttribute(
            global::System.Type attributeType,
            object[] arguments,
            global::System.Collections.Generic.Dictionary<string, object> namedArguments)
        {
            var key = new CacheKey(attributeType, arguments, namedArguments);
            return _cache.GetOrAdd(key, static k =>
            {
                var type = k.AttributeType;
                var args = k.Arguments;

                global::System.ComponentModel.DataAnnotations.ValidationAttribute attribute;

                if (args.Length == 0)
                {
                    attribute = type switch
                    {
                        global::System.Type t when t == typeof(global::System.ComponentModel.DataAnnotations.RequiredAttribute) => new global::System.ComponentModel.DataAnnotations.RequiredAttribute(),
                        global::System.Type t when t == typeof(global::System.ComponentModel.DataAnnotations.EmailAddressAttribute) => new global::System.ComponentModel.DataAnnotations.EmailAddressAttribute(),
                        global::System.Type t when t == typeof(global::System.ComponentModel.DataAnnotations.PhoneAttribute) => new global::System.ComponentModel.DataAnnotations.PhoneAttribute(),
                        global::System.Type t when t == typeof(global::System.ComponentModel.DataAnnotations.UrlAttribute) => new global::System.ComponentModel.DataAnnotations.UrlAttribute(),
                        global::System.Type t when t == typeof(global::System.ComponentModel.DataAnnotations.CreditCardAttribute) => new global::System.ComponentModel.DataAnnotations.CreditCardAttribute(),
                        _ when typeof(global::System.ComponentModel.DataAnnotations.ValidationAttribute).IsAssignableFrom(type) =>
                            (global::System.ComponentModel.DataAnnotations.ValidationAttribute)global::System.Activator.CreateInstance(type)!
                    };
                }
                else if (type == typeof(global::System.ComponentModel.DataAnnotations.CustomValidationAttribute) && args.Length == 2)
                {
                    // CustomValidationAttribute requires special handling
                    // First argument is a type, second is a method name
                    if (args[0] is global::System.Type validatingType && args[1] is string methodName)
                    {
                        attribute = new global::System.ComponentModel.DataAnnotations.CustomValidationAttribute(validatingType, methodName);
                    }
                    else
                    {
                        throw new global::System.ArgumentException($"Invalid arguments for CustomValidationAttribute: Type and method name required");
                    }
                }
                else if (type == typeof(global::System.ComponentModel.DataAnnotations.StringLengthAttribute))
                {
                    if (args[0] is int maxLength)
                    {
                        attribute = new global::System.ComponentModel.DataAnnotations.StringLengthAttribute(maxLength);
                    }
                    else
                    {
                        throw new global::System.ArgumentException($"Invalid maxLength value for StringLengthAttribute: {args[0]}");
                    }
                }
                else if (type == typeof(global::System.ComponentModel.DataAnnotations.MinLengthAttribute))
                {
                    if (args[0] is int length)
                    {
                        attribute = new global::System.ComponentModel.DataAnnotations.MinLengthAttribute(length);
                    }
                    else
                    {
                        throw new global::System.ArgumentException($"Invalid length value for MinLengthAttribute: {args[0]}");
                    }
                }
                else if (type == typeof(global::System.ComponentModel.DataAnnotations.MaxLengthAttribute))
                {
                    if (args[0] is int length)
                    {
                        attribute = new global::System.ComponentModel.DataAnnotations.MaxLengthAttribute(length);
                    }
                    else
                    {
                        throw new global::System.ArgumentException($"Invalid length value for MaxLengthAttribute: {args[0]}");
                    }
                }
                else if (type == typeof(global::System.ComponentModel.DataAnnotations.RangeAttribute) && args.Length == 2)
                {
                    if (args[0] is int min && args[1] is int max)
                    {
                        attribute = new global::System.ComponentModel.DataAnnotations.RangeAttribute(min, max);
                    }
                    else if (args[0] is double dmin && args[1] is double dmax)
                    {
                        attribute = new global::System.ComponentModel.DataAnnotations.RangeAttribute(dmin, dmax);
                    }
                    else
                    {
                        throw new global::System.ArgumentException($"Invalid range values for RangeAttribute: {args[0]}, {args[1]}");
                    }
                }
                else if (type == typeof(global::System.ComponentModel.DataAnnotations.RegularExpressionAttribute))
                {
                    if (args[0] is string pattern)
                    {
                        attribute = new global::System.ComponentModel.DataAnnotations.RegularExpressionAttribute(pattern);
                    }
                    else
                    {
                        throw new global::System.ArgumentException($"Invalid pattern for RegularExpressionAttribute: {args[0]}");
                    }
                }
                else if (type == typeof(global::System.ComponentModel.DataAnnotations.CompareAttribute))
                {
                    if (args[0] is string otherProperty)
                    {
                        attribute = new global::System.ComponentModel.DataAnnotations.CompareAttribute(otherProperty);
                    }
                    else
                    {
                        throw new global::System.ArgumentException($"Invalid otherProperty for CompareAttribute: {args[0]}");
                    }
                }
                else if (typeof(global::System.ComponentModel.DataAnnotations.ValidationAttribute).IsAssignableFrom(type))
                {
                    var constructors = type.GetConstructors();
                    var success = false;
                    attribute = null!;

                    foreach (var constructor in constructors)
                    {
                        var parameters = constructor.GetParameters();
                        if (parameters.Length != args.Length)
                            continue;

                        var convertedArgs = new object[args.Length];
                        var canUseConstructor = true;

                        for (var i = 0; i < parameters.Length; i++)
                        {
                            try
                            {
                                if (args[i] != null && args[i].GetType() == parameters[i].ParameterType)
                                {
                                    // Type already matches, use as-is
                                    convertedArgs[i] = args[i];
                                }
                                else
                                {
                                    // Try to convert
                                    convertedArgs[i] = global::System.Convert.ChangeType(args[i], parameters[i].ParameterType);
                                }
                            }
                            catch
                            {
                                canUseConstructor = false;
                                break;
                            }
                        }

                        if (canUseConstructor)
                        {
                            attribute = (global::System.ComponentModel.DataAnnotations.ValidationAttribute)global::System.Activator.CreateInstance(type, convertedArgs)!;
                            success = true;
                            break;
                        }
                    }

                    if (!success)
                    {
                        throw new global::System.ArgumentException($"Could not find a suitable constructor for validation attribute type: {type.FullName}");
                    }
                }
                else
                {
                    throw new global::System.ArgumentException($"Unsupported validation attribute type: {type.FullName}");
                }

                // Apply named arguments after construction
                foreach (var namedArg in k.NamedArguments)
                {
                    var prop = type.GetProperty(namedArg.Key);
                    if (prop != null && prop.CanWrite)
                    {
                        try
                        {
                            if (namedArg.Value != null && namedArg.Value.GetType() == prop.PropertyType)
                            {
                                // Type already matches, use as-is
                                prop.SetValue(attribute, namedArg.Value);
                            }
                            else
                            {
                                // Try to convert
                                prop.SetValue(attribute, global::System.Convert.ChangeType(namedArg.Value, prop.PropertyType));
                            }
                        }
                        catch (global::System.Exception ex)
                        {
                            throw new global::System.ArgumentException($"Failed to set property {namedArg.Key} on {type.FullName}: {ex.Message}");
                        }
                    }
                }

                return attribute;
            });
        }
    }
}
""";

    private static string EmitValidationAttributeForCreate(ValidationAttribute attr)
    {
        // Process constructor arguments - convert to appropriate typed objects
        var processedArgs = new List<string>(attr.Arguments.Count);

        foreach (var arg in attr.Arguments)
        {
            // Handle different types of arguments
            if (arg.StartsWith("\"", StringComparison.OrdinalIgnoreCase) && arg.EndsWith("\"", StringComparison.OrdinalIgnoreCase))
            {
                // String literal - remove quotes and pass as object
                var stringValue = arg.Substring(1, arg.Length - 2).Replace("\\\"", "\"");
                processedArgs.Add($"\"{stringValue}\"");
            }
            else if (arg.StartsWith("typeof(", StringComparison.OrdinalIgnoreCase) && arg.EndsWith(")", StringComparison.OrdinalIgnoreCase))
            {
                // Type argument - pass directly
                processedArgs.Add(arg);
            }
            else if (int.TryParse(arg, out var intValue))
            {
                // Integer
                processedArgs.Add(intValue.ToString(CultureInfo.InvariantCulture));
            }
            else if (double.TryParse(arg, out var doubleValue))
            {
                // Double
                processedArgs.Add(doubleValue.ToString(CultureInfo.InvariantCulture) + "d");
            }
            else if (bool.TryParse(arg, out var boolValue))
            {
                // Boolean
                processedArgs.Add(boolValue.ToString().ToLowerInvariant());
            }
            else if (arg == "null")
            {
                // Null
                processedArgs.Add("null");
            }
            else
            {
                // Default to string for anything else
                processedArgs.Add($"\"{arg.Replace("\"", "\\\"")}\"");
            }
        }

        var args = attr.Arguments.Count > 0
            ? $"[{string.Join(", ", processedArgs)}]"
            : "[]";

        // Process named arguments - ensure proper formatting for object dictionary
        var namedArgsParts = new List<string>(attr.NamedArguments.Count);
        foreach (var pair in attr.NamedArguments)
        {
            // Convert the value based on its format
            var valueStr = pair.Value;
            string objectValue;

            if (valueStr.StartsWith("\"", StringComparison.OrdinalIgnoreCase) && valueStr.EndsWith("\"", StringComparison.OrdinalIgnoreCase))
            {
                // String literal
                objectValue = valueStr;
            }
            else if (valueStr.StartsWith("typeof(", StringComparison.OrdinalIgnoreCase) && valueStr.EndsWith(")", StringComparison.OrdinalIgnoreCase))
            {
                // Type argument
                objectValue = valueStr;
            }
            else if (int.TryParse(valueStr, out _))
            {
                // Integer
                objectValue = valueStr;
            }
            else if (double.TryParse(valueStr, out _))
            {
                // Double
                objectValue = valueStr + "d";
            }
            else if (bool.TryParse(valueStr, out var boolVal))
            {
                // Boolean
                objectValue = boolVal.ToString().ToLowerInvariant();
            }
            else if (valueStr == "null")
            {
                // Null
                objectValue = "null";
            }
            else
            {
                // Default to string for anything else
                objectValue = $"\"{valueStr.Replace("\"", "\\\"")}\"";
            }

            namedArgsParts.Add($"{{ \"{pair.Key}\", {objectValue} }}");
        }

        var namedArgs = attr.NamedArguments.Count > 0
            ? $"new global::System.Collections.Generic.Dictionary<string, object> {{ {string.Join(", ", namedArgsParts)} }}"
            : "[]";

        // Use string interpolation with @ to prevent escaping issues in the error message
        return $@"ValidationAttributeCache.GetOrCreateValidationAttribute(typeof({attr.ClassName}), {args}, {namedArgs}) ?? throw new global::System.InvalidOperationException(@""Failed to create validation attribute {attr.ClassName}"")";
    }

    private static string EmitTypeChecks(ImmutableArray<ValidatableType> validatableTypes)
    {
        var sw = new StringWriter();
        var cw = new CodeWriter(sw, baseIndent: 2);
        foreach (var validatableType in validatableTypes)
        {
            var typeName = validatableType.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            cw.WriteLine($"if (type == typeof({typeName}))");
            cw.StartBlock();
            cw.WriteLine($"return Create{SanitizeTypeName(validatableType.Type.MetadataName)}();");
            cw.EndBlock();
        }
        return sw.ToString();
    }

    private static string EmitCreateMethods(ImmutableArray<ValidatableType> validatableTypes)
    {
        var sw = new StringWriter();
        var cw = new CodeWriter(sw, baseIndent: 2);
        foreach (var validatableType in validatableTypes)
        {
            var validatableSubTypes = validatableType.ValidatableSubTypeNames.IsDefaultOrEmpty
                ? "null"
                : $"[{string.Join(", ", validatableType.ValidatableSubTypeNames.Select(t => $"typeof({t})"))}]";
            cw.WriteLine($@"private ValidatableTypeInfo Create{SanitizeTypeName(validatableType.Type.MetadataName)}()");
            cw.StartBlock();
            cw.WriteLine("return new GeneratedValidatableTypeInfo(");
            cw.Indent++;
            cw.WriteLine($"type: typeof({validatableType.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}),");
            if (validatableType.Members.IsDefaultOrEmpty)
            {
                cw.WriteLine("members: []");
            }
            else
            {
                cw.WriteLine("members: [");
                cw.Indent++;
                foreach (var member in validatableType.Members)
                {
                    EmitValidatableMemberForCreate(member, cw);
                }
                cw.Indent--;
                cw.WriteLine("],");
            }
            cw.WriteLine($"implementsIValidatableObject: {(validatableType.IsIValidatableObject ? "true" : "false")},");
            cw.WriteLine($"validatableSubTypes: {validatableSubTypes}");
            cw.Indent--;
            cw.WriteLine(");");
            cw.EndBlock();
        }
        return sw.ToString();
    }

    private static void EmitValidatableMemberForCreate(ValidatableProperty member, CodeWriter cw)
    {
        var validationAttributes = member.Attributes.IsDefaultOrEmpty
            ? "[]"
            : $"[{string.Join(", ", member.Attributes.Select(EmitValidationAttributeForCreate))}]";
        cw.WriteLine("new GeneratedValidatablePropertyInfo(");
        cw.Indent++;
        cw.WriteLine($"containingType: typeof({member.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}),");
        cw.WriteLine($"propertyType: typeof({member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}),");
        cw.WriteLine($"name: \"{member.Name}\",");
        cw.WriteLine($"displayName: \"{member.DisplayName}\",");
        cw.WriteLine($"validationAttributes: {validationAttributes}");
        cw.Indent--;
        cw.WriteLine("),");
    }

    private static string SanitizeTypeName(string typeName)
    {
        // Replace invalid characters with underscores and remove generic notation
        return typeName
            .Replace(".", "_")
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace(" ", "_");
    }
}
